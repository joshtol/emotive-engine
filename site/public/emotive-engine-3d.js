/*! Emotive Engine 3D v3.2.3 | MIT License */
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = '181';

/**
 * Represents mouse buttons and interaction types in context of controls.
 *
 * @type {ConstantsMouse}
 * @constant
 */
const MOUSE = { ROTATE: 0, DOLLY: 1, PAN: 2 };

/**
 * Represents touch interaction types in context of controls.
 *
 * @type {ConstantsTouch}
 * @constant
 */
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };

/**
 * Disables face culling.
 *
 * @type {number}
 * @constant
 */
const CullFaceNone = 0;

/**
 * Culls back faces.
 *
 * @type {number}
 * @constant
 */
const CullFaceBack = 1;

/**
 * Culls front faces.
 *
 * @type {number}
 * @constant
 */
const CullFaceFront = 2;

/**
 * Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm.
 *
 * @type {number}
 * @constant
 */
const PCFShadowMap = 1;

/**
 * Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm with
 * better soft shadows especially when using low-resolution shadow maps.
 *
 * @type {number}
 * @constant
 */
const PCFSoftShadowMap = 2;

/**
 * Filters shadow maps using the Variance Shadow Map (VSM) algorithm.
 * When using VSMShadowMap all shadow receivers will also cast shadows.
 *
 * @type {number}
 * @constant
 */
const VSMShadowMap = 3;

/**
 * Only front faces are rendered.
 *
 * @type {number}
 * @constant
 */
const FrontSide = 0;

/**
 * Only back faces are rendered.
 *
 * @type {number}
 * @constant
 */
const BackSide = 1;

/**
 * Both front and back faces are rendered.
 *
 * @type {number}
 * @constant
 */
const DoubleSide = 2;

/**
 * No blending is performed which effectively disables
 * alpha transparency.
 *
 * @type {number}
 * @constant
 */
const NoBlending = 0;

/**
 * The default blending.
 *
 * @type {number}
 * @constant
 */
const NormalBlending = 1;

/**
 * Represents additive blending.
 *
 * @type {number}
 * @constant
 */
const AdditiveBlending = 2;

/**
 * Represents subtractive blending.
 *
 * @type {number}
 * @constant
 */
const SubtractiveBlending = 3;

/**
 * Represents multiply blending.
 *
 * @type {number}
 * @constant
 */
const MultiplyBlending = 4;

/**
 * Represents custom blending.
 *
 * @type {number}
 * @constant
 */
const CustomBlending = 5;

/**
 * A `source + destination` blending equation.
 *
 * @type {number}
 * @constant
 */
const AddEquation = 100;

/**
 * A `source - destination` blending equation.
 *
 * @type {number}
 * @constant
 */
const SubtractEquation = 101;

/**
 * A `destination - source` blending equation.
 *
 * @type {number}
 * @constant
 */
const ReverseSubtractEquation = 102;

/**
 * A blend equation that uses the minimum of source and destination.
 *
 * @type {number}
 * @constant
 */
const MinEquation = 103;

/**
 * A blend equation that uses the maximum of source and destination.
 *
 * @type {number}
 * @constant
 */
const MaxEquation = 104;

/**
 * Multiplies all colors by `0`.
 *
 * @type {number}
 * @constant
 */
const ZeroFactor = 200;

/**
 * Multiplies all colors by `1`.
 *
 * @type {number}
 * @constant
 */
const OneFactor = 201;

/**
 * Multiplies all colors by the source colors.
 *
 * @type {number}
 * @constant
 */
const SrcColorFactor = 202;

/**
 * Multiplies all colors by `1` minus each source color.
 *
 * @type {number}
 * @constant
 */
const OneMinusSrcColorFactor = 203;

/**
 * Multiplies all colors by the source alpha value.
 *
 * @type {number}
 * @constant
 */
const SrcAlphaFactor = 204;

/**
 * Multiplies all colors by 1 minus the source alpha value.
 *
 * @type {number}
 * @constant
 */
const OneMinusSrcAlphaFactor = 205;

/**
 * Multiplies all colors by the destination alpha value.
 *
 * @type {number}
 * @constant
 */
const DstAlphaFactor = 206;

/**
 * Multiplies all colors by `1` minus the destination alpha value.
 *
 * @type {number}
 * @constant
 */
const OneMinusDstAlphaFactor = 207;

/**
 * Multiplies all colors by the destination color.
 *
 * @type {number}
 * @constant
 */
const DstColorFactor = 208;

/**
 * Multiplies all colors by `1` minus each destination color.
 *
 * @type {number}
 * @constant
 */
const OneMinusDstColorFactor = 209;

/**
 * Multiplies the RGB colors by the smaller of either the source alpha
 * value or the value of `1` minus the destination alpha value. The alpha
 * value is multiplied by `1`.
 *
 * @type {number}
 * @constant
 */
const SrcAlphaSaturateFactor = 210;

/**
 * Multiplies all colors by a constant color.
 *
 * @type {number}
 * @constant
 */
const ConstantColorFactor = 211;

/**
 * Multiplies all colors by `1` minus a constant color.
 *
 * @type {number}
 * @constant
 */
const OneMinusConstantColorFactor = 212;

/**
 * Multiplies all colors by a constant alpha value.
 *
 * @type {number}
 * @constant
 */
const ConstantAlphaFactor = 213;

/**
 * Multiplies all colors by 1 minus a constant alpha value.
 *
 * @type {number}
 * @constant
 */
const OneMinusConstantAlphaFactor = 214;

/**
 * Never pass.
 *
 * @type {number}
 * @constant
 */
const NeverDepth = 0;

/**
 * Always pass.
 *
 * @type {number}
 * @constant
 */
const AlwaysDepth = 1;

/**
 * Pass if the incoming value is less than the depth buffer value.
 *
 * @type {number}
 * @constant
 */
const LessDepth = 2;

/**
 * Pass if the incoming value is less than or equal to the depth buffer value.
 *
 * @type {number}
 * @constant
 */
const LessEqualDepth = 3;

/**
 * Pass if the incoming value equals the depth buffer value.
 *
 * @type {number}
 * @constant
 */
const EqualDepth = 4;

/**
 * Pass if the incoming value is greater than or equal to the depth buffer value.
 *
 * @type {number}
 * @constant
 */
const GreaterEqualDepth = 5;

/**
 * Pass if the incoming value is greater than the depth buffer value.
 *
 * @type {number}
 * @constant
 */
const GreaterDepth = 6;

/**
 * Pass if the incoming value is not equal to the depth buffer value.
 *
 * @type {number}
 * @constant
 */
const NotEqualDepth = 7;

/**
 * Multiplies the environment map color with the surface color.
 *
 * @type {number}
 * @constant
 */
const MultiplyOperation = 0;

/**
 * Uses reflectivity to blend between the two colors.
 *
 * @type {number}
 * @constant
 */
const MixOperation = 1;

/**
 * Adds the two colors.
 *
 * @type {number}
 * @constant
 */
const AddOperation = 2;

/**
 * No tone mapping is applied.
 *
 * @type {number}
 * @constant
 */
const NoToneMapping = 0;

/**
 * Linear tone mapping.
 *
 * @type {number}
 * @constant
 */
const LinearToneMapping = 1;

/**
 * Reinhard tone mapping.
 *
 * @type {number}
 * @constant
 */
const ReinhardToneMapping = 2;

/**
 * Cineon tone mapping.
 *
 * @type {number}
 * @constant
 */
const CineonToneMapping = 3;

/**
 * ACES Filmic tone mapping.
 *
 * @type {number}
 * @constant
 */
const ACESFilmicToneMapping = 4;

/**
 * Custom tone mapping.
 *
 * Expects a custom implementation by modifying shader code of the material's fragment shader.
 *
 * @type {number}
 * @constant
 */
const CustomToneMapping = 5;

/**
 * AgX tone mapping.
 *
 * @type {number}
 * @constant
 */
const AgXToneMapping = 6;

/**
 * Neutral tone mapping.
 *
 * Implementation based on the Khronos 3D Commerce Group standard tone mapping.
 *
 * @type {number}
 * @constant
 */
const NeutralToneMapping = 7;

/**
 * Maps textures using the geometry's UV coordinates.
 *
 * @type {number}
 * @constant
 */
const UVMapping = 300;

/**
 * Reflection mapping for cube textures.
 *
 * @type {number}
 * @constant
 */
const CubeReflectionMapping = 301;

/**
 * Refraction mapping for cube textures.
 *
 * @type {number}
 * @constant
 */
const CubeRefractionMapping = 302;

/**
 * Reflection mapping for equirectangular textures.
 *
 * @type {number}
 * @constant
 */
const EquirectangularReflectionMapping = 303;

/**
 * Refraction mapping for equirectangular textures.
 *
 * @type {number}
 * @constant
 */
const EquirectangularRefractionMapping = 304;

/**
 * Reflection mapping for PMREM textures.
 *
 * @type {number}
 * @constant
 */
const CubeUVReflectionMapping = 306;

/**
 * The texture will simply repeat to infinity.
 *
 * @type {number}
 * @constant
 */
const RepeatWrapping = 1000;

/**
 * The last pixel of the texture stretches to the edge of the mesh.
 *
 * @type {number}
 * @constant
 */
const ClampToEdgeWrapping = 1001;

/**
 * The texture will repeats to infinity, mirroring on each repeat.
 *
 * @type {number}
 * @constant
 */
const MirroredRepeatWrapping = 1002;

/**
 * Returns the value of the texture element that is nearest (in Manhattan distance)
 * to the specified texture coordinates.
 *
 * @type {number}
 * @constant
 */
const NearestFilter = 1003;

/**
 * Chooses the mipmap that most closely matches the size of the pixel being textured
 * and uses the `NearestFilter` criterion (the texel nearest to the center of the pixel)
 * to produce a texture value.
 *
 * @type {number}
 * @constant
 */
const NearestMipmapNearestFilter = 1004;

/**
 * Chooses the two mipmaps that most closely match the size of the pixel being textured and
 * uses the `NearestFilter` criterion to produce a texture value from each mipmap.
 * The final texture value is a weighted average of those two values.
 *
 * @type {number}
 * @constant
 */
const NearestMipmapLinearFilter = 1005;

/**
 * Returns the weighted average of the four texture elements that are closest to the specified
 * texture coordinates, and can include items wrapped or repeated from other parts of a texture,
 * depending on the values of `wrapS` and `wrapT`, and on the exact mapping.
 *
 * @type {number}
 * @constant
 */
const LinearFilter = 1006;

/**
 * Chooses the mipmap that most closely matches the size of the pixel being textured and uses
 * the `LinearFilter` criterion (a weighted average of the four texels that are closest to the
 * center of the pixel) to produce a texture value.
 *
 * @type {number}
 * @constant
 */
const LinearMipmapNearestFilter = 1007;

/**
 * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses
 * the `LinearFilter` criterion to produce a texture value from each mipmap. The final texture value
 * is a weighted average of those two values.
 *
 * @type {number}
 * @constant
 */
const LinearMipmapLinearFilter = 1008;

/**
 * An unsigned byte data type for textures.
 *
 * @type {number}
 * @constant
 */
const UnsignedByteType = 1009;

/**
 * A byte data type for textures.
 *
 * @type {number}
 * @constant
 */
const ByteType = 1010;

/**
 * A short data type for textures.
 *
 * @type {number}
 * @constant
 */
const ShortType = 1011;

/**
 * An unsigned short data type for textures.
 *
 * @type {number}
 * @constant
 */
const UnsignedShortType = 1012;

/**
 * An int data type for textures.
 *
 * @type {number}
 * @constant
 */
const IntType = 1013;

/**
 * An unsigned int data type for textures.
 *
 * @type {number}
 * @constant
 */
const UnsignedIntType = 1014;

/**
 * A float data type for textures.
 *
 * @type {number}
 * @constant
 */
const FloatType = 1015;

/**
 * A half float data type for textures.
 *
 * @type {number}
 * @constant
 */
const HalfFloatType = 1016;

/**
 * An unsigned short 4_4_4_4 (packed) data type for textures.
 *
 * @type {number}
 * @constant
 */
const UnsignedShort4444Type = 1017;

/**
 * An unsigned short 5_5_5_1 (packed) data type for textures.
 *
 * @type {number}
 * @constant
 */
const UnsignedShort5551Type = 1018;

/**
 * An unsigned int 24_8 data type for textures.
 *
 * @type {number}
 * @constant
 */
const UnsignedInt248Type = 1020;

/**
 * An unsigned int 5_9_9_9 (packed) data type for textures.
 *
 * @type {number}
 * @constant
 */
const UnsignedInt5999Type = 35902;

/**
 * An unsigned int 10_11_11 (packed) data type for textures.
 *
 * @type {number}
 * @constant
 */
const UnsignedInt101111Type = 35899;

/**
 * Discards the red, green and blue components and reads just the alpha component.
 *
 * @type {number}
 * @constant
 */
const AlphaFormat = 1021;

/**
 * Discards the alpha component and reads the red, green and blue component.
 *
 * @type {number}
 * @constant
 */
const RGBFormat = 1022;

/**
 * Reads the red, green, blue and alpha components.
 *
 * @type {number}
 * @constant
 */
const RGBAFormat = 1023;

/**
 * Reads each element as a single depth value, converts it to floating point, and clamps to the range `[0,1]`.
 *
 * @type {number}
 * @constant
 */
const DepthFormat = 1026;

/**
 * Reads each element is a pair of depth and stencil values. The depth component of the pair is interpreted as
 * in `DepthFormat`. The stencil component is interpreted based on the depth + stencil internal format.
 *
 * @type {number}
 * @constant
 */
const DepthStencilFormat = 1027;

/**
 * Discards the green, blue and alpha components and reads just the red component.
 *
 * @type {number}
 * @constant
 */
const RedFormat = 1028;

/**
 * Discards the green, blue and alpha components and reads just the red component. The texels are read as integers instead of floating point.
 *
 * @type {number}
 * @constant
 */
const RedIntegerFormat = 1029;

/**
 * Discards the alpha, and blue components and reads the red, and green components.
 *
 * @type {number}
 * @constant
 */
const RGFormat = 1030;

/**
 * Discards the alpha, and blue components and reads the red, and green components. The texels are read as integers instead of floating point.
 *
 * @type {number}
 * @constant
 */
const RGIntegerFormat = 1031;

/**
 * Reads the red, green, blue and alpha components. The texels are read as integers instead of floating point.
 *
 * @type {number}
 * @constant
 */
const RGBAIntegerFormat = 1033;

/**
 * A DXT1-compressed image in an RGB image format.
 *
 * @type {number}
 * @constant
 */
const RGB_S3TC_DXT1_Format = 33776;

/**
 * A DXT1-compressed image in an RGB image format with a simple on/off alpha value.
 *
 * @type {number}
 * @constant
 */
const RGBA_S3TC_DXT1_Format = 33777;

/**
 * A DXT3-compressed image in an RGBA image format. Compared to a 32-bit RGBA texture, it offers 4:1 compression.
 *
 * @type {number}
 * @constant
 */
const RGBA_S3TC_DXT3_Format = 33778;

/**
 * A DXT5-compressed image in an RGBA image format. It also provides a 4:1 compression, but differs to the DXT3
 * compression in how the alpha compression is done.
 *
 * @type {number}
 * @constant
 */
const RGBA_S3TC_DXT5_Format = 33779;

/**
 * PVRTC RGB compression in 4-bit mode. One block for each 4×4 pixels.
 *
 * @type {number}
 * @constant
 */
const RGB_PVRTC_4BPPV1_Format = 35840;

/**
 * PVRTC RGB compression in 2-bit mode. One block for each 8×4 pixels.
 *
 * @type {number}
 * @constant
 */
const RGB_PVRTC_2BPPV1_Format = 35841;

/**
 * PVRTC RGBA compression in 4-bit mode. One block for each 4×4 pixels.
 *
 * @type {number}
 * @constant
 */
const RGBA_PVRTC_4BPPV1_Format = 35842;

/**
 * PVRTC RGBA compression in 2-bit mode. One block for each 8×4 pixels.
 *
 * @type {number}
 * @constant
 */
const RGBA_PVRTC_2BPPV1_Format = 35843;

/**
 * ETC1 RGB format.
 *
 * @type {number}
 * @constant
 */
const RGB_ETC1_Format = 36196;

/**
 * ETC2 RGB format.
 *
 * @type {number}
 * @constant
 */
const RGB_ETC2_Format = 37492;

/**
 * ETC2 RGBA format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ETC2_EAC_Format = 37496;

/**
 * ASTC RGBA 4x4 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_4x4_Format = 37808;

/**
 * ASTC RGBA 5x4 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_5x4_Format = 37809;

/**
 * ASTC RGBA 5x5 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_5x5_Format = 37810;

/**
 * ASTC RGBA 6x5 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_6x5_Format = 37811;

/**
 * ASTC RGBA 6x6 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_6x6_Format = 37812;

/**
 * ASTC RGBA 8x5 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_8x5_Format = 37813;

/**
 * ASTC RGBA 8x6 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_8x6_Format = 37814;

/**
 * ASTC RGBA 8x8 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_8x8_Format = 37815;

/**
 * ASTC RGBA 10x5 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_10x5_Format = 37816;

/**
 * ASTC RGBA 10x6 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_10x6_Format = 37817;

/**
 * ASTC RGBA 10x8 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_10x8_Format = 37818;

/**
 * ASTC RGBA 10x10 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_10x10_Format = 37819;

/**
 * ASTC RGBA 12x10 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_12x10_Format = 37820;

/**
 * ASTC RGBA 12x12 format.
 *
 * @type {number}
 * @constant
 */
const RGBA_ASTC_12x12_Format = 37821;

/**
 * BPTC RGBA format.
 *
 * @type {number}
 * @constant
 */
const RGBA_BPTC_Format = 36492;

/**
 * BPTC Signed RGB format.
 *
 * @type {number}
 * @constant
 */
const RGB_BPTC_SIGNED_Format = 36494;

/**
 * BPTC Unsigned RGB format.
 *
 * @type {number}
 * @constant
 */
const RGB_BPTC_UNSIGNED_Format = 36495;

/**
 * RGTC1 Red format.
 *
 * @type {number}
 * @constant
 */
const RED_RGTC1_Format = 36283;

/**
 * RGTC1 Signed Red format.
 *
 * @type {number}
 * @constant
 */
const SIGNED_RED_RGTC1_Format = 36284;

/**
 * RGTC2 Red Green format.
 *
 * @type {number}
 * @constant
 */
const RED_GREEN_RGTC2_Format = 36285;

/**
 * RGTC2 Signed Red Green format.
 *
 * @type {number}
 * @constant
 */
const SIGNED_RED_GREEN_RGTC2_Format = 36286;

/**
 * Basic depth packing.
 *
 * @type {number}
 * @constant
 */
const BasicDepthPacking = 3200;

/**
 * A depth value is packed into 32 bit RGBA.
 *
 * @type {number}
 * @constant
 */
const RGBADepthPacking = 3201;

/**
 * Normal information is relative to the underlying surface.
 *
 * @type {number}
 * @constant
 */
const TangentSpaceNormalMap = 0;

/**
 * Normal information is relative to the object orientation.
 *
 * @type {number}
 * @constant
 */
const ObjectSpaceNormalMap = 1;

// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.

/**
 * No color space.
 *
 * @type {string}
 * @constant
 */
const NoColorSpace = '';

/**
 * sRGB color space.
 *
 * @type {string}
 * @constant
 */
const SRGBColorSpace = 'srgb';

/**
 * sRGB-linear color space.
 *
 * @type {string}
 * @constant
 */
const LinearSRGBColorSpace = 'srgb-linear';

/**
 * Linear transfer function.
 *
 * @type {string}
 * @constant
 */
const LinearTransfer = 'linear';

/**
 * sRGB transfer function.
 *
 * @type {string}
 * @constant
 */
const SRGBTransfer = 'srgb';

/**
 * Keeps the current value.
 *
 * @type {number}
 * @constant
 */
const KeepStencilOp = 7680;

/**
 * Will always return true.
 *
 * @type {number}
 * @constant
 */
const AlwaysStencilFunc = 519;

/**
 * Never pass.
 *
 * @type {number}
 * @constant
 */
const NeverCompare = 512;

/**
 * Pass if the incoming value is less than the texture value.
 *
 * @type {number}
 * @constant
 */
const LessCompare = 513;

/**
 * Pass if the incoming value equals the texture value.
 *
 * @type {number}
 * @constant
 */
const EqualCompare = 514;

/**
 * Pass if the incoming value is less than or equal to the texture value.
 *
 * @type {number}
 * @constant
 */
const LessEqualCompare = 515;

/**
 * Pass if the incoming value is greater than the texture value.
 *
 * @type {number}
 * @constant
 */
const GreaterCompare = 516;

/**
 * Pass if the incoming value is not equal to the texture value.
 *
 * @type {number}
 * @constant
 */
const NotEqualCompare = 517;

/**
 * Pass if the incoming value is greater than or equal to the texture value.
 *
 * @type {number}
 * @constant
 */
const GreaterEqualCompare = 518;

/**
 * Always pass.
 *
 * @type {number}
 * @constant
 */
const AlwaysCompare = 519;

/**
 * The contents are intended to be specified once by the application, and used many
 * times as the source for drawing and image specification commands.
 *
 * @type {number}
 * @constant
 */
const StaticDrawUsage = 35044;

/**
 * The contents are intended to be respecified repeatedly by the application, and
 * used many times as the source for drawing and image specification commands.
 *
 * @type {number}
 * @constant
 */
const DynamicDrawUsage = 35048;

/**
 * GLSL 3 shader code.
 *
 * @type {string}
 * @constant
 */
const GLSL3 = '300 es';

/**
 * WebGL coordinate system.
 *
 * @type {number}
 * @constant
 */
const WebGLCoordinateSystem = 2000;

/**
 * WebGPU coordinate system.
 *
 * @type {number}
 * @constant
 */
const WebGPUCoordinateSystem = 2001;

/**
 * This type represents mouse buttons and interaction types in context of controls.
 *
 * @typedef {Object} ConstantsMouse
 * @property {number} MIDDLE - The left mouse button.
 * @property {number} LEFT - The middle mouse button.
 * @property {number} RIGHT - The right mouse button.
 * @property {number} ROTATE - A rotate interaction.
 * @property {number} DOLLY - A dolly interaction.
 * @property {number} PAN - A pan interaction.
 **/

/**
 * This type represents touch interaction types in context of controls.
 *
 * @typedef {Object} ConstantsTouch
 * @property {number} ROTATE - A rotate interaction.
 * @property {number} PAN - A pan interaction.
 * @property {number} DOLLY_PAN - The dolly-pan interaction.
 * @property {number} DOLLY_ROTATE - A dolly-rotate interaction.
 **/

/**
 * This type represents the different timestamp query types.
 *
 * @typedef {Object} ConstantsTimestampQuery
 * @property {string} COMPUTE - A `compute` timestamp query.
 * @property {string} RENDER - A `render` timestamp query.
 **/

/**
 * Represents the different interpolation sampling types.
 *
 * @typedef {Object} ConstantsInterpolationSamplingType
 * @property {string} PERSPECTIVE - Perspective-correct interpolation.
 * @property {string} LINEAR - Linear interpolation.
 * @property {string} FLAT - Flat interpolation.
 */

/**
 * Represents the different interpolation sampling modes.
 *
 * @typedef {Object} ConstantsInterpolationSamplingMode
 * @property {string} NORMAL - Normal sampling mode.
 * @property {string} CENTROID - Centroid sampling mode.
 * @property {string} SAMPLE - Sample-specific sampling mode.
 * @property {string} FIRST - Flat interpolation using the first vertex.
 * @property {string} EITHER - Flat interpolation using either vertex.
 */

function arrayNeedsUint32( array ) {

	// assumes larger values usually on last

	for ( let i = array.length - 1; i >= 0; -- i ) {

		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

	}

	return false;

}

function createElementNS( name ) {

	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

}

function createCanvasElement() {

	const canvas = createElementNS( 'canvas' );
	canvas.style.display = 'block';
	return canvas;

}

const _cache = {};

function log( ...params ) {

	const message = 'THREE.' + params.shift();

	{

		console.log( message, ...params );

	}

}

function warn( ...params ) {

	const message = 'THREE.' + params.shift();

	{

		console.warn( message, ...params );

	}

}

function error( ...params ) {

	const message = 'THREE.' + params.shift();

	{

		console.error( message, ...params );

	}

}

function warnOnce( ...params ) {

	const message = params.join( ' ' );

	if ( message in _cache ) return;

	_cache[ message ] = true;

	warn( ...params );

}

function probeAsync( gl, sync, interval ) {

	return new Promise( function ( resolve, reject ) {

		function probe() {

			switch ( gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 ) ) {

				case gl.WAIT_FAILED:
					reject();
					break;

				case gl.TIMEOUT_EXPIRED:
					setTimeout( probe, interval );
					break;

				default:
					resolve();

			}

		}

		setTimeout( probe, interval );

	} );

}

/**
 * This modules allows to dispatch event objects on custom JavaScript objects.
 *
 * Main repository: [eventdispatcher.js](https://github.com/mrdoob/eventdispatcher.js/)
 *
 * Code Example:
 * ```js
 * class Car extends EventDispatcher {
 * 	start() {
 *		this.dispatchEvent( { type: 'start', message: 'vroom vroom!' } );
 *	}
 *};
 *
 * // Using events with the custom object
 * const car = new Car();
 * car.addEventListener( 'start', function ( event ) {
 * 	alert( event.message );
 * } );
 *
 * car.start();
 * ```
 */
class EventDispatcher {

	/**
	 * Adds the given event listener to the given event type.
	 *
	 * @param {string} type - The type of event to listen to.
	 * @param {Function} listener - The function that gets called when the event is fired.
	 */
	addEventListener( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		const listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === -1 ) {

			listeners[ type ].push( listener );

		}

	}

	/**
	 * Returns `true` if the given event listener has been added to the given event type.
	 *
	 * @param {string} type - The type of event.
	 * @param {Function} listener - The listener to check.
	 * @return {boolean} Whether the given event listener has been added to the given event type.
	 */
	hasEventListener( type, listener ) {

		const listeners = this._listeners;

		if ( listeners === undefined ) return false;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== -1;

	}

	/**
	 * Removes the given event listener from the given event type.
	 *
	 * @param {string} type - The type of event.
	 * @param {Function} listener - The listener to remove.
	 */
	removeEventListener( type, listener ) {

		const listeners = this._listeners;

		if ( listeners === undefined ) return;

		const listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			const index = listenerArray.indexOf( listener );

			if ( index !== -1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	}

	/**
	 * Dispatches an event object.
	 *
	 * @param {Object} event - The event that gets fired.
	 */
	dispatchEvent( event ) {

		const listeners = this._listeners;

		if ( listeners === undefined ) return;

		const listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice( 0 );

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

			event.target = null;

		}

	}

}

const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];


const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

/**
 * Generate a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)
 * (universally unique identifier).
 *
 * @return {string} The UUID.
 */
function generateUUID() {

	// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();

}

/**
 * Clamps the given value between min and max.
 *
 * @param {number} value - The value to clamp.
 * @param {number} min - The min value.
 * @param {number} max - The max value.
 * @return {number} The clamped value.
 */
function clamp( value, min, max ) {

	return Math.max( min, Math.min( max, value ) );

}

/**
 * Computes the Euclidean modulo of the given parameters that
 * is `( ( n % m ) + m ) % m`.
 *
 * @param {number} n - The first parameter.
 * @param {number} m - The second parameter.
 * @return {number} The Euclidean modulo.
 */
function euclideanModulo( n, m ) {

	// https://en.wikipedia.org/wiki/Modulo_operation

	return ( ( n % m ) + m ) % m;

}

/**
 * Returns a value linearly interpolated from two known points based on the given interval -
 * `t = 0` will return `x` and `t = 1` will return `y`.
 *
 * @param {number} x - The start point
 * @param {number} y - The end point.
 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
 * @return {number} The interpolated value.
 */
function lerp( x, y, t ) {

	return ( 1 - t ) * x + t * y;

}

/**
 * Denormalizes the given value according to the given typed array.
 *
 * @param {number} value - The value to denormalize.
 * @param {TypedArray} array - The typed array that defines the data type of the value.
 * @return {number} The denormalize (float) value in the range `[0,1]`.
 */
function denormalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint32Array:

			return value / 4294967295.0;

		case Uint16Array:

			return value / 65535.0;

		case Uint8Array:

			return value / 255.0;

		case Int32Array:

			return Math.max( value / 2147483647.0, -1 );

		case Int16Array:

			return Math.max( value / 32767.0, -1 );

		case Int8Array:

			return Math.max( value / 127.0, -1 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

/**
 * Normalizes the given value according to the given typed array.
 *
 * @param {number} value - The float value in the range `[0,1]` to normalize.
 * @param {TypedArray} array - The typed array that defines the data type of the value.
 * @return {number} The normalize value.
 */
function normalize$1( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint32Array:

			return Math.round( value * 4294967295.0 );

		case Uint16Array:

			return Math.round( value * 65535.0 );

		case Uint8Array:

			return Math.round( value * 255.0 );

		case Int32Array:

			return Math.round( value * 2147483647.0 );

		case Int16Array:

			return Math.round( value * 32767.0 );

		case Int8Array:

			return Math.round( value * 127.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

/**
 * @class
 * @classdesc A collection of math utility functions.
 * @hideconstructor
 */
const MathUtils = {
	DEG2RAD: DEG2RAD};

/**
 * Class representing a 2D vector. A 2D vector is an ordered pair of numbers
 * (labeled x and y), which can be used to represent a number of things, such as:
 *
 * - A point in 2D space (i.e. a position on a plane).
 * - A direction and length across a plane. In three.js the length will
 * always be the Euclidean distance(straight-line distance) from `(0, 0)` to `(x, y)`
 * and the direction is also measured from `(0, 0)` towards `(x, y)`.
 * - Any arbitrary ordered pair of numbers.
 *
 * There are other things a 2D vector can be used to represent, such as
 * momentum vectors, complex numbers and so on, however these are the most
 * common uses in three.js.
 *
 * Iterating through a vector instance will yield its components `(x, y)` in
 * the corresponding order.
 * ```js
 * const a = new THREE.Vector2( 0, 1 );
 *
 * //no arguments; will be initialised to (0, 0)
 * const b = new THREE.Vector2( );
 *
 * const d = a.distanceTo( b );
 * ```
 */
class Vector2 {

	/**
	 * Constructs a new 2D vector.
	 *
	 * @param {number} [x=0] - The x value of this vector.
	 * @param {number} [y=0] - The y value of this vector.
	 */
	constructor( x = 0, y = 0 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		Vector2.prototype.isVector2 = true;

		/**
		 * The x value of this vector.
		 *
		 * @type {number}
		 */
		this.x = x;

		/**
		 * The y value of this vector.
		 *
		 * @type {number}
		 */
		this.y = y;

	}

	/**
	 * Alias for {@link Vector2#x}.
	 *
	 * @type {number}
	 */
	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	/**
	 * Alias for {@link Vector2#y}.
	 *
	 * @type {number}
	 */
	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	/**
	 * Sets the vector components.
	 *
	 * @param {number} x - The value of the x component.
	 * @param {number} y - The value of the y component.
	 * @return {Vector2} A reference to this vector.
	 */
	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	/**
	 * Sets the vector components to the same value.
	 *
	 * @param {number} scalar - The value to set for all vector components.
	 * @return {Vector2} A reference to this vector.
	 */
	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	/**
	 * Sets the vector's x component to the given value
	 *
	 * @param {number} x - The value to set.
	 * @return {Vector2} A reference to this vector.
	 */
	setX( x ) {

		this.x = x;

		return this;

	}

	/**
	 * Sets the vector's y component to the given value
	 *
	 * @param {number} y - The value to set.
	 * @return {Vector2} A reference to this vector.
	 */
	setY( y ) {

		this.y = y;

		return this;

	}

	/**
	 * Allows to set a vector component with an index.
	 *
	 * @param {number} index - The component index. `0` equals to x, `1` equals to y.
	 * @param {number} value - The value to set.
	 * @return {Vector2} A reference to this vector.
	 */
	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	/**
	 * Returns the value of the vector component which matches the given index.
	 *
	 * @param {number} index - The component index. `0` equals to x, `1` equals to y.
	 * @return {number} A vector component value.
	 */
	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	/**
	 * Returns a new vector with copied values from this instance.
	 *
	 * @return {Vector2} A clone of this instance.
	 */
	clone() {

		return new this.constructor( this.x, this.y );

	}

	/**
	 * Copies the values of the given vector to this instance.
	 *
	 * @param {Vector2} v - The vector to copy.
	 * @return {Vector2} A reference to this vector.
	 */
	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	/**
	 * Adds the given vector to this instance.
	 *
	 * @param {Vector2} v - The vector to add.
	 * @return {Vector2} A reference to this vector.
	 */
	add( v ) {

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	/**
	 * Adds the given scalar value to all components of this instance.
	 *
	 * @param {number} s - The scalar to add.
	 * @return {Vector2} A reference to this vector.
	 */
	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	/**
	 * Adds the given vectors and stores the result in this instance.
	 *
	 * @param {Vector2} a - The first vector.
	 * @param {Vector2} b - The second vector.
	 * @return {Vector2} A reference to this vector.
	 */
	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	/**
	 * Adds the given vector scaled by the given factor to this instance.
	 *
	 * @param {Vector2} v - The vector.
	 * @param {number} s - The factor that scales `v`.
	 * @return {Vector2} A reference to this vector.
	 */
	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	/**
	 * Subtracts the given vector from this instance.
	 *
	 * @param {Vector2} v - The vector to subtract.
	 * @return {Vector2} A reference to this vector.
	 */
	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	/**
	 * Subtracts the given scalar value from all components of this instance.
	 *
	 * @param {number} s - The scalar to subtract.
	 * @return {Vector2} A reference to this vector.
	 */
	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	/**
	 * Subtracts the given vectors and stores the result in this instance.
	 *
	 * @param {Vector2} a - The first vector.
	 * @param {Vector2} b - The second vector.
	 * @return {Vector2} A reference to this vector.
	 */
	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	/**
	 * Multiplies the given vector with this instance.
	 *
	 * @param {Vector2} v - The vector to multiply.
	 * @return {Vector2} A reference to this vector.
	 */
	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	/**
	 * Multiplies the given scalar value with all components of this instance.
	 *
	 * @param {number} scalar - The scalar to multiply.
	 * @return {Vector2} A reference to this vector.
	 */
	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	/**
	 * Divides this instance by the given vector.
	 *
	 * @param {Vector2} v - The vector to divide.
	 * @return {Vector2} A reference to this vector.
	 */
	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	/**
	 * Divides this vector by the given scalar.
	 *
	 * @param {number} scalar - The scalar to divide.
	 * @return {Vector2} A reference to this vector.
	 */
	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	/**
	 * Multiplies this vector (with an implicit 1 as the 3rd component) by
	 * the given 3x3 matrix.
	 *
	 * @param {Matrix3} m - The matrix to apply.
	 * @return {Vector2} A reference to this vector.
	 */
	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	/**
	 * If this vector's x or y value is greater than the given vector's x or y
	 * value, replace that value with the corresponding min value.
	 *
	 * @param {Vector2} v - The vector.
	 * @return {Vector2} A reference to this vector.
	 */
	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	/**
	 * If this vector's x or y value is less than the given vector's x or y
	 * value, replace that value with the corresponding max value.
	 *
	 * @param {Vector2} v - The vector.
	 * @return {Vector2} A reference to this vector.
	 */
	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	/**
	 * If this vector's x or y value is greater than the max vector's x or y
	 * value, it is replaced by the corresponding value.
	 * If this vector's x or y value is less than the min vector's x or y value,
	 * it is replaced by the corresponding value.
	 *
	 * @param {Vector2} min - The minimum x and y values.
	 * @param {Vector2} max - The maximum x and y values in the desired range.
	 * @return {Vector2} A reference to this vector.
	 */
	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = clamp( this.x, min.x, max.x );
		this.y = clamp( this.y, min.y, max.y );

		return this;

	}

	/**
	 * If this vector's x or y values are greater than the max value, they are
	 * replaced by the max value.
	 * If this vector's x or y values are less than the min value, they are
	 * replaced by the min value.
	 *
	 * @param {number} minVal - The minimum value the components will be clamped to.
	 * @param {number} maxVal - The maximum value the components will be clamped to.
	 * @return {Vector2} A reference to this vector.
	 */
	clampScalar( minVal, maxVal ) {

		this.x = clamp( this.x, minVal, maxVal );
		this.y = clamp( this.y, minVal, maxVal );

		return this;

	}

	/**
	 * If this vector's length is greater than the max value, it is replaced by
	 * the max value.
	 * If this vector's length is less than the min value, it is replaced by the
	 * min value.
	 *
	 * @param {number} min - The minimum value the vector length will be clamped to.
	 * @param {number} max - The maximum value the vector length will be clamped to.
	 * @return {Vector2} A reference to this vector.
	 */
	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );

	}

	/**
	 * The components of this vector are rounded down to the nearest integer value.
	 *
	 * @return {Vector2} A reference to this vector.
	 */
	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	/**
	 * The components of this vector are rounded up to the nearest integer value.
	 *
	 * @return {Vector2} A reference to this vector.
	 */
	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	/**
	 * The components of this vector are rounded to the nearest integer value
	 *
	 * @return {Vector2} A reference to this vector.
	 */
	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	/**
	 * The components of this vector are rounded towards zero (up if negative,
	 * down if positive) to an integer value.
	 *
	 * @return {Vector2} A reference to this vector.
	 */
	roundToZero() {

		this.x = Math.trunc( this.x );
		this.y = Math.trunc( this.y );

		return this;

	}

	/**
	 * Inverts this vector - i.e. sets x = -x and y = -y.
	 *
	 * @return {Vector2} A reference to this vector.
	 */
	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	/**
	 * Calculates the dot product of the given vector with this instance.
	 *
	 * @param {Vector2} v - The vector to compute the dot product with.
	 * @return {number} The result of the dot product.
	 */
	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	/**
	 * Calculates the cross product of the given vector with this instance.
	 *
	 * @param {Vector2} v - The vector to compute the cross product with.
	 * @return {number} The result of the cross product.
	 */
	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	/**
	 * Computes the square of the Euclidean length (straight-line length) from
	 * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
	 * compare the length squared instead as it is slightly more efficient to calculate.
	 *
	 * @return {number} The square length of this vector.
	 */
	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	/**
	 * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
	 *
	 * @return {number} The length of this vector.
	 */
	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	/**
	 * Computes the Manhattan length of this vector.
	 *
	 * @return {number} The length of this vector.
	 */
	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	/**
	 * Converts this vector to a unit vector - that is, sets it equal to a vector
	 * with the same direction as this one, but with a vector length of `1`.
	 *
	 * @return {Vector2} A reference to this vector.
	 */
	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	/**
	 * Computes the angle in radians of this vector with respect to the positive x-axis.
	 *
	 * @return {number} The angle in radians.
	 */
	angle() {

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	/**
	 * Returns the angle between the given vector and this instance in radians.
	 *
	 * @param {Vector2} v - The vector to compute the angle with.
	 * @return {number} The angle in radians.
	 */
	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp( theta, -1, 1 ) );

	}

	/**
	 * Computes the distance from the given vector to this instance.
	 *
	 * @param {Vector2} v - The vector to compute the distance to.
	 * @return {number} The distance.
	 */
	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	/**
	 * Computes the squared distance from the given vector to this instance.
	 * If you are just comparing the distance with another distance, you should compare
	 * the distance squared instead as it is slightly more efficient to calculate.
	 *
	 * @param {Vector2} v - The vector to compute the squared distance to.
	 * @return {number} The squared distance.
	 */
	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	/**
	 * Computes the Manhattan distance from the given vector to this instance.
	 *
	 * @param {Vector2} v - The vector to compute the Manhattan distance to.
	 * @return {number} The Manhattan distance.
	 */
	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	/**
	 * Sets this vector to a vector with the same direction as this one, but
	 * with the specified length.
	 *
	 * @param {number} length - The new length of this vector.
	 * @return {Vector2} A reference to this vector.
	 */
	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	/**
	 * Linearly interpolates between the given vector and this instance, where
	 * alpha is the percent distance along the line - alpha = 0 will be this
	 * vector, and alpha = 1 will be the given one.
	 *
	 * @param {Vector2} v - The vector to interpolate towards.
	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	 * @return {Vector2} A reference to this vector.
	 */
	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	/**
	 * Linearly interpolates between the given vectors, where alpha is the percent
	 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
	 * be the second one. The result is stored in this instance.
	 *
	 * @param {Vector2} v1 - The first vector.
	 * @param {Vector2} v2 - The second vector.
	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	 * @return {Vector2} A reference to this vector.
	 */
	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	/**
	 * Returns `true` if this vector is equal with the given one.
	 *
	 * @param {Vector2} v - The vector to test for equality.
	 * @return {boolean} Whether this vector is equal with the given one.
	 */
	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	/**
	 * Sets this vector's x value to be `array[ offset ]` and y
	 * value to be `array[ offset + 1 ]`.
	 *
	 * @param {Array<number>} array - An array holding the vector component values.
	 * @param {number} [offset=0] - The offset into the array.
	 * @return {Vector2} A reference to this vector.
	 */
	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	/**
	 * Writes the components of this vector to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number>} [array=[]] - The target array holding the vector components.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number>} The vector components.
	 */
	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	/**
	 * Sets the components of this vector from the given buffer attribute.
	 *
	 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
	 * @param {number} index - The index into the attribute.
	 * @return {Vector2} A reference to this vector.
	 */
	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	/**
	 * Rotates this vector around the given center by the given angle.
	 *
	 * @param {Vector2} center - The point around which to rotate.
	 * @param {number} angle - The angle to rotate, in radians.
	 * @return {Vector2} A reference to this vector.
	 */
	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	/**
	 * Sets each component of this vector to a pseudo-random value between `0` and
	 * `1`, excluding `1`.
	 *
	 * @return {Vector2} A reference to this vector.
	 */
	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;

	}

}

/**
 * Class for representing a Quaternion. Quaternions are used in three.js to represent rotations.
 *
 * Iterating through a vector instance will yield its components `(x, y, z, w)` in
 * the corresponding order.
 *
 * Note that three.js expects Quaternions to be normalized.
 * ```js
 * const quaternion = new THREE.Quaternion();
 * quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );
 *
 * const vector = new THREE.Vector3( 1, 0, 0 );
 * vector.applyQuaternion( quaternion );
 * ```
 */
class Quaternion {

	/**
	 * Constructs a new quaternion.
	 *
	 * @param {number} [x=0] - The x value of this quaternion.
	 * @param {number} [y=0] - The y value of this quaternion.
	 * @param {number} [z=0] - The z value of this quaternion.
	 * @param {number} [w=1] - The w value of this quaternion.
	 */
	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isQuaternion = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	/**
	 * Interpolates between two quaternions via SLERP. This implementation assumes the
	 * quaternion data are managed in flat arrays.
	 *
	 * @param {Array<number>} dst - The destination array.
	 * @param {number} dstOffset - An offset into the destination array.
	 * @param {Array<number>} src0 - The source array of the first quaternion.
	 * @param {number} srcOffset0 - An offset into the first source array.
	 * @param {Array<number>} src1 -  The source array of the second quaternion.
	 * @param {number} srcOffset1 - An offset into the second source array.
	 * @param {number} t - The interpolation factor in the range `[0,1]`.
	 * @see {@link Quaternion#slerp}
	 */
	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		let x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t <= 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

			return;

		}

		if ( t >= 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;

			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let dot = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1;

			if ( dot < 0 ) {

				x1 = - x1;
				y1 = - y1;
				z1 = - z1;
				w1 = - w1;

				dot = - dot;

			}

			let s = 1 - t;

			if ( dot < 0.9995 ) {

				// slerp

				const theta = Math.acos( dot );
				const sin = Math.sin( theta );

				s = Math.sin( s * theta ) / sin;
				t = Math.sin( t * theta ) / sin;

				x0 = x0 * s + x1 * t;
				y0 = y0 * s + y1 * t;
				z0 = z0 * s + z1 * t;
				w0 = w0 * s + w1 * t;

			} else {

				// for small angles, lerp then normalize

				x0 = x0 * s + x1 * t;
				y0 = y0 * s + y1 * t;
				z0 = z0 * s + z1 * t;
				w0 = w0 * s + w1 * t;

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	/**
	 * Multiplies two quaternions. This implementation assumes the quaternion data are managed
	 * in flat arrays.
	 *
	 * @param {Array<number>} dst - The destination array.
	 * @param {number} dstOffset - An offset into the destination array.
	 * @param {Array<number>} src0 - The source array of the first quaternion.
	 * @param {number} srcOffset0 - An offset into the first source array.
	 * @param {Array<number>} src1 -  The source array of the second quaternion.
	 * @param {number} srcOffset1 - An offset into the second source array.
	 * @return {Array<number>} The destination array.
	 * @see {@link Quaternion#multiplyQuaternions}.
	 */
	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	/**
	 * The x value of this quaternion.
	 *
	 * @type {number}
	 * @default 0
	 */
	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	/**
	 * The y value of this quaternion.
	 *
	 * @type {number}
	 * @default 0
	 */
	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	/**
	 * The z value of this quaternion.
	 *
	 * @type {number}
	 * @default 0
	 */
	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	/**
	 * The w value of this quaternion.
	 *
	 * @type {number}
	 * @default 1
	 */
	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	/**
	 * Sets the quaternion components.
	 *
	 * @param {number} x - The x value of this quaternion.
	 * @param {number} y - The y value of this quaternion.
	 * @param {number} z - The z value of this quaternion.
	 * @param {number} w - The w value of this quaternion.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	/**
	 * Returns a new quaternion with copied values from this instance.
	 *
	 * @return {Quaternion} A clone of this instance.
	 */
	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	/**
	 * Copies the values of the given quaternion to this instance.
	 *
	 * @param {Quaternion} quaternion - The quaternion to copy.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	/**
	 * Sets this quaternion from the rotation specified by the given
	 * Euler angles.
	 *
	 * @param {Euler} euler - The Euler angles.
	 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	setFromEuler( euler, update = true ) {

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				warn( 'Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	/**
	 * Sets this quaternion from the given axis and angle.
	 *
	 * @param {Vector3} axis - The normalized axis.
	 * @param {number} angle - The angle in radians.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	/**
	 * Sets this quaternion from the given rotation matrix.
	 *
	 * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
	 * @return {Quaternion} A reference to this quaternion.
	 */
	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	/**
	 * Sets this quaternion to the rotation required to rotate the direction vector
	 * `vFrom` to the direction vector `vTo`.
	 *
	 * @param {Vector3} vFrom - The first (normalized) direction vector.
	 * @param {Vector3} vTo - The second (normalized) direction vector.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < 1e-8 ) { // the epsilon value has been discussed in #31286

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	/**
	 * Returns the angle between this quaternion and the given one in radians.
	 *
	 * @param {Quaternion} q - The quaternion to compute the angle with.
	 * @return {number} The angle in radians.
	 */
	angleTo( q ) {

		return 2 * Math.acos( Math.abs( clamp( this.dot( q ), -1, 1 ) ) );

	}

	/**
	 * Rotates this quaternion by a given angular step to the given quaternion.
	 * The method ensures that the final quaternion will not overshoot `q`.
	 *
	 * @param {Quaternion} q - The target quaternion.
	 * @param {number} step - The angular step in radians.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	/**
	 * Sets this quaternion to the identity quaternion; that is, to the
	 * quaternion that represents "no rotation".
	 *
	 * @return {Quaternion} A reference to this quaternion.
	 */
	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	/**
	 * Inverts this quaternion via {@link Quaternion#conjugate}. The
	 * quaternion is assumed to have unit length.
	 *
	 * @return {Quaternion} A reference to this quaternion.
	 */
	invert() {

		return this.conjugate();

	}

	/**
	 * Returns the rotational conjugate of this quaternion. The conjugate of a
	 * quaternion represents the same rotation in the opposite direction about
	 * the rotational axis.
	 *
	 * @return {Quaternion} A reference to this quaternion.
	 */
	conjugate() {

		this._x *= -1;
		this._y *= -1;
		this._z *= -1;

		this._onChangeCallback();

		return this;

	}

	/**
	 * Calculates the dot product of this quaternion and the given one.
	 *
	 * @param {Quaternion} v - The quaternion to compute the dot product with.
	 * @return {number} The result of the dot product.
	 */
	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	/**
	 * Computes the squared Euclidean length (straight-line length) of this quaternion,
	 * considered as a 4 dimensional vector. This can be useful if you are comparing the
	 * lengths of two quaternions, as this is a slightly more efficient calculation than
	 * {@link Quaternion#length}.
	 *
	 * @return {number} The squared Euclidean length.
	 */
	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	/**
	 * Computes the Euclidean length (straight-line length) of this quaternion,
	 * considered as a 4 dimensional vector.
	 *
	 * @return {number} The Euclidean length.
	 */
	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	/**
	 * Normalizes this quaternion - that is, calculated the quaternion that performs
	 * the same rotation as this one, but has a length equal to `1`.
	 *
	 * @return {Quaternion} A reference to this quaternion.
	 */
	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	/**
	 * Multiplies this quaternion by the given one.
	 *
	 * @param {Quaternion} q - The quaternion.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	multiply( q ) {

		return this.multiplyQuaternions( this, q );

	}

	/**
	 * Pre-multiplies this quaternion by the given one.
	 *
	 * @param {Quaternion} q - The quaternion.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	/**
	 * Multiplies the given quaternions and stores the result in this instance.
	 *
	 * @param {Quaternion} a - The first quaternion.
	 * @param {Quaternion} b - The second quaternion.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	/**
	 * Performs a spherical linear interpolation between quaternions.
	 *
	 * @param {Quaternion} qb - The target quaternion.
	 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	slerp( qb, t ) {

		if ( t <= 0 ) return this;

		if ( t >= 1 ) return this.copy( qb ); // copy calls _onChangeCallback()

		let x = qb._x, y = qb._y, z = qb._z, w = qb._w;

		let dot = this.dot( qb );

		if ( dot < 0 ) {

			x = - x;
			y = - y;
			z = - z;
			w = - w;

			dot = - dot;

		}

		let s = 1 - t;

		if ( dot < 0.9995 ) {

			// slerp

			const theta = Math.acos( dot );
			const sin = Math.sin( theta );

			s = Math.sin( s * theta ) / sin;
			t = Math.sin( t * theta ) / sin;

			this._x = this._x * s + x * t;
			this._y = this._y * s + y * t;
			this._z = this._z * s + z * t;
			this._w = this._w * s + w * t;

			this._onChangeCallback();

		} else {

			// for small angles, lerp then normalize

			this._x = this._x * s + x * t;
			this._y = this._y * s + y * t;
			this._z = this._z * s + z * t;
			this._w = this._w * s + w * t;

			this.normalize(); // normalize calls _onChangeCallback()

		}

		return this;

	}

	/**
	 * Performs a spherical linear interpolation between the given quaternions
	 * and stores the result in this quaternion.
	 *
	 * @param {Quaternion} qa - The source quaternion.
	 * @param {Quaternion} qb - The target quaternion.
	 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	slerpQuaternions( qa, qb, t ) {

		return this.copy( qa ).slerp( qb, t );

	}

	/**
	 * Sets this quaternion to a uniformly random, normalized quaternion.
	 *
	 * @return {Quaternion} A reference to this quaternion.
	 */
	random() {

		// Ken Shoemake
		// Uniform random rotations
		// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

		const theta1 = 2 * Math.PI * Math.random();
		const theta2 = 2 * Math.PI * Math.random();

		const x0 = Math.random();
		const r1 = Math.sqrt( 1 - x0 );
		const r2 = Math.sqrt( x0 );

		return this.set(
			r1 * Math.sin( theta1 ),
			r1 * Math.cos( theta1 ),
			r2 * Math.sin( theta2 ),
			r2 * Math.cos( theta2 ),
		);

	}

	/**
	 * Returns `true` if this quaternion is equal with the given one.
	 *
	 * @param {Quaternion} quaternion - The quaternion to test for equality.
	 * @return {boolean} Whether this quaternion is equal with the given one.
	 */
	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	/**
	 * Sets this quaternion's components from the given array.
	 *
	 * @param {Array<number>} array - An array holding the quaternion component values.
	 * @param {number} [offset=0] - The offset into the array.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	/**
	 * Writes the components of this quaternion to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number>} The quaternion components.
	 */
	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	/**
	 * Sets the components of this quaternion from the given buffer attribute.
	 *
	 * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
	 * @param {number} index - The index into the attribute.
	 * @return {Quaternion} A reference to this quaternion.
	 */
	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		this._onChangeCallback();

		return this;

	}

	/**
	 * This methods defines the serialization result of this class. Returns the
	 * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
	 *
	 * @return {Array<number>} The serialized quaternion.
	 */
	toJSON() {

		return this.toArray();

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._w;

	}

}

/**
 * Class representing a 3D vector. A 3D vector is an ordered triplet of numbers
 * (labeled x, y and z), which can be used to represent a number of things, such as:
 *
 * - A point in 3D space.
 * - A direction and length in 3D space. In three.js the length will
 * always be the Euclidean distance(straight-line distance) from `(0, 0, 0)` to `(x, y, z)`
 * and the direction is also measured from `(0, 0, 0)` towards `(x, y, z)`.
 * - Any arbitrary ordered triplet of numbers.
 *
 * There are other things a 3D vector can be used to represent, such as
 * momentum vectors and so on, however these are the most
 * common uses in three.js.
 *
 * Iterating through a vector instance will yield its components `(x, y, z)` in
 * the corresponding order.
 * ```js
 * const a = new THREE.Vector3( 0, 1, 0 );
 *
 * //no arguments; will be initialised to (0, 0, 0)
 * const b = new THREE.Vector3( );
 *
 * const d = a.distanceTo( b );
 * ```
 */
class Vector3 {

	/**
	 * Constructs a new 3D vector.
	 *
	 * @param {number} [x=0] - The x value of this vector.
	 * @param {number} [y=0] - The y value of this vector.
	 * @param {number} [z=0] - The z value of this vector.
	 */
	constructor( x = 0, y = 0, z = 0 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		Vector3.prototype.isVector3 = true;

		/**
		 * The x value of this vector.
		 *
		 * @type {number}
		 */
		this.x = x;

		/**
		 * The y value of this vector.
		 *
		 * @type {number}
		 */
		this.y = y;

		/**
		 * The z value of this vector.
		 *
		 * @type {number}
		 */
		this.z = z;

	}

	/**
	 * Sets the vector components.
	 *
	 * @param {number} x - The value of the x component.
	 * @param {number} y - The value of the y component.
	 * @param {number} z - The value of the z component.
	 * @return {Vector3} A reference to this vector.
	 */
	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	/**
	 * Sets the vector components to the same value.
	 *
	 * @param {number} scalar - The value to set for all vector components.
	 * @return {Vector3} A reference to this vector.
	 */
	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	/**
	 * Sets the vector's x component to the given value
	 *
	 * @param {number} x - The value to set.
	 * @return {Vector3} A reference to this vector.
	 */
	setX( x ) {

		this.x = x;

		return this;

	}

	/**
	 * Sets the vector's y component to the given value
	 *
	 * @param {number} y - The value to set.
	 * @return {Vector3} A reference to this vector.
	 */
	setY( y ) {

		this.y = y;

		return this;

	}

	/**
	 * Sets the vector's z component to the given value
	 *
	 * @param {number} z - The value to set.
	 * @return {Vector3} A reference to this vector.
	 */
	setZ( z ) {

		this.z = z;

		return this;

	}

	/**
	 * Allows to set a vector component with an index.
	 *
	 * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
	 * @param {number} value - The value to set.
	 * @return {Vector3} A reference to this vector.
	 */
	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	/**
	 * Returns the value of the vector component which matches the given index.
	 *
	 * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
	 * @return {number} A vector component value.
	 */
	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	/**
	 * Returns a new vector with copied values from this instance.
	 *
	 * @return {Vector3} A clone of this instance.
	 */
	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	/**
	 * Copies the values of the given vector to this instance.
	 *
	 * @param {Vector3} v - The vector to copy.
	 * @return {Vector3} A reference to this vector.
	 */
	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	/**
	 * Adds the given vector to this instance.
	 *
	 * @param {Vector3} v - The vector to add.
	 * @return {Vector3} A reference to this vector.
	 */
	add( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	/**
	 * Adds the given scalar value to all components of this instance.
	 *
	 * @param {number} s - The scalar to add.
	 * @return {Vector3} A reference to this vector.
	 */
	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	/**
	 * Adds the given vectors and stores the result in this instance.
	 *
	 * @param {Vector3} a - The first vector.
	 * @param {Vector3} b - The second vector.
	 * @return {Vector3} A reference to this vector.
	 */
	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	/**
	 * Adds the given vector scaled by the given factor to this instance.
	 *
	 * @param {Vector3|Vector4} v - The vector.
	 * @param {number} s - The factor that scales `v`.
	 * @return {Vector3} A reference to this vector.
	 */
	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	/**
	 * Subtracts the given vector from this instance.
	 *
	 * @param {Vector3} v - The vector to subtract.
	 * @return {Vector3} A reference to this vector.
	 */
	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	/**
	 * Subtracts the given scalar value from all components of this instance.
	 *
	 * @param {number} s - The scalar to subtract.
	 * @return {Vector3} A reference to this vector.
	 */
	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	/**
	 * Subtracts the given vectors and stores the result in this instance.
	 *
	 * @param {Vector3} a - The first vector.
	 * @param {Vector3} b - The second vector.
	 * @return {Vector3} A reference to this vector.
	 */
	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	/**
	 * Multiplies the given vector with this instance.
	 *
	 * @param {Vector3} v - The vector to multiply.
	 * @return {Vector3} A reference to this vector.
	 */
	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	/**
	 * Multiplies the given scalar value with all components of this instance.
	 *
	 * @param {number} scalar - The scalar to multiply.
	 * @return {Vector3} A reference to this vector.
	 */
	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	/**
	 * Multiplies the given vectors and stores the result in this instance.
	 *
	 * @param {Vector3} a - The first vector.
	 * @param {Vector3} b - The second vector.
	 * @return {Vector3} A reference to this vector.
	 */
	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	/**
	 * Applies the given Euler rotation to this vector.
	 *
	 * @param {Euler} euler - The Euler angles.
	 * @return {Vector3} A reference to this vector.
	 */
	applyEuler( euler ) {

		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

	}

	/**
	 * Applies a rotation specified by an axis and an angle to this vector.
	 *
	 * @param {Vector3} axis - A normalized vector representing the rotation axis.
	 * @param {number} angle - The angle in radians.
	 * @return {Vector3} A reference to this vector.
	 */
	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

	}

	/**
	 * Multiplies this vector with the given 3x3 matrix.
	 *
	 * @param {Matrix3} m - The 3x3 matrix.
	 * @return {Vector3} A reference to this vector.
	 */
	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	/**
	 * Multiplies this vector by the given normal matrix and normalizes
	 * the result.
	 *
	 * @param {Matrix3} m - The normal matrix.
	 * @return {Vector3} A reference to this vector.
	 */
	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	/**
	 * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
	 * divides by perspective.
	 *
	 * @param {Matrix4} m - The matrix to apply.
	 * @return {Vector3} A reference to this vector.
	 */
	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	/**
	 * Applies the given Quaternion to this vector.
	 *
	 * @param {Quaternion} q - The Quaternion.
	 * @return {Vector3} A reference to this vector.
	 */
	applyQuaternion( q ) {

		// quaternion q is assumed to have unit length

		const vx = this.x, vy = this.y, vz = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// t = 2 * cross( q.xyz, v );
		const tx = 2 * ( qy * vz - qz * vy );
		const ty = 2 * ( qz * vx - qx * vz );
		const tz = 2 * ( qx * vy - qy * vx );

		// v + q.w * t + cross( q.xyz, t );
		this.x = vx + qw * tx + qy * tz - qz * ty;
		this.y = vy + qw * ty + qz * tx - qx * tz;
		this.z = vz + qw * tz + qx * ty - qy * tx;

		return this;

	}

	/**
	 * Projects this vector from world space into the camera's normalized
	 * device coordinate (NDC) space.
	 *
	 * @param {Camera} camera - The camera.
	 * @return {Vector3} A reference to this vector.
	 */
	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	/**
	 * Unprojects this vector from the camera's normalized device coordinate (NDC)
	 * space into world space.
	 *
	 * @param {Camera} camera - The camera.
	 * @return {Vector3} A reference to this vector.
	 */
	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	/**
	 * Transforms the direction of this vector by a matrix (the upper left 3 x 3
	 * subset of the given 4x4 matrix and then normalizes the result.
	 *
	 * @param {Matrix4} m - The matrix.
	 * @return {Vector3} A reference to this vector.
	 */
	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	/**
	 * Divides this instance by the given vector.
	 *
	 * @param {Vector3} v - The vector to divide.
	 * @return {Vector3} A reference to this vector.
	 */
	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	/**
	 * Divides this vector by the given scalar.
	 *
	 * @param {number} scalar - The scalar to divide.
	 * @return {Vector3} A reference to this vector.
	 */
	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	/**
	 * If this vector's x, y or z value is greater than the given vector's x, y or z
	 * value, replace that value with the corresponding min value.
	 *
	 * @param {Vector3} v - The vector.
	 * @return {Vector3} A reference to this vector.
	 */
	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	/**
	 * If this vector's x, y or z value is less than the given vector's x, y or z
	 * value, replace that value with the corresponding max value.
	 *
	 * @param {Vector3} v - The vector.
	 * @return {Vector3} A reference to this vector.
	 */
	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	/**
	 * If this vector's x, y or z value is greater than the max vector's x, y or z
	 * value, it is replaced by the corresponding value.
	 * If this vector's x, y or z value is less than the min vector's x, y or z value,
	 * it is replaced by the corresponding value.
	 *
	 * @param {Vector3} min - The minimum x, y and z values.
	 * @param {Vector3} max - The maximum x, y and z values in the desired range.
	 * @return {Vector3} A reference to this vector.
	 */
	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = clamp( this.x, min.x, max.x );
		this.y = clamp( this.y, min.y, max.y );
		this.z = clamp( this.z, min.z, max.z );

		return this;

	}

	/**
	 * If this vector's x, y or z values are greater than the max value, they are
	 * replaced by the max value.
	 * If this vector's x, y or z values are less than the min value, they are
	 * replaced by the min value.
	 *
	 * @param {number} minVal - The minimum value the components will be clamped to.
	 * @param {number} maxVal - The maximum value the components will be clamped to.
	 * @return {Vector3} A reference to this vector.
	 */
	clampScalar( minVal, maxVal ) {

		this.x = clamp( this.x, minVal, maxVal );
		this.y = clamp( this.y, minVal, maxVal );
		this.z = clamp( this.z, minVal, maxVal );

		return this;

	}

	/**
	 * If this vector's length is greater than the max value, it is replaced by
	 * the max value.
	 * If this vector's length is less than the min value, it is replaced by the
	 * min value.
	 *
	 * @param {number} min - The minimum value the vector length will be clamped to.
	 * @param {number} max - The maximum value the vector length will be clamped to.
	 * @return {Vector3} A reference to this vector.
	 */
	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );

	}

	/**
	 * The components of this vector are rounded down to the nearest integer value.
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	/**
	 * The components of this vector are rounded up to the nearest integer value.
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	/**
	 * The components of this vector are rounded to the nearest integer value
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	/**
	 * The components of this vector are rounded towards zero (up if negative,
	 * down if positive) to an integer value.
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	roundToZero() {

		this.x = Math.trunc( this.x );
		this.y = Math.trunc( this.y );
		this.z = Math.trunc( this.z );

		return this;

	}

	/**
	 * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	/**
	 * Calculates the dot product of the given vector with this instance.
	 *
	 * @param {Vector3} v - The vector to compute the dot product with.
	 * @return {number} The result of the dot product.
	 */
	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	/**
	 * Computes the square of the Euclidean length (straight-line length) from
	 * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
	 * compare the length squared instead as it is slightly more efficient to calculate.
	 *
	 * @return {number} The square length of this vector.
	 */
	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	/**
	 * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
	 *
	 * @return {number} The length of this vector.
	 */
	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	/**
	 * Computes the Manhattan length of this vector.
	 *
	 * @return {number} The length of this vector.
	 */
	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	/**
	 * Converts this vector to a unit vector - that is, sets it equal to a vector
	 * with the same direction as this one, but with a vector length of `1`.
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	/**
	 * Sets this vector to a vector with the same direction as this one, but
	 * with the specified length.
	 *
	 * @param {number} length - The new length of this vector.
	 * @return {Vector3} A reference to this vector.
	 */
	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	/**
	 * Linearly interpolates between the given vector and this instance, where
	 * alpha is the percent distance along the line - alpha = 0 will be this
	 * vector, and alpha = 1 will be the given one.
	 *
	 * @param {Vector3} v - The vector to interpolate towards.
	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	 * @return {Vector3} A reference to this vector.
	 */
	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	/**
	 * Linearly interpolates between the given vectors, where alpha is the percent
	 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
	 * be the second one. The result is stored in this instance.
	 *
	 * @param {Vector3} v1 - The first vector.
	 * @param {Vector3} v2 - The second vector.
	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	 * @return {Vector3} A reference to this vector.
	 */
	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	/**
	 * Calculates the cross product of the given vector with this instance.
	 *
	 * @param {Vector3} v - The vector to compute the cross product with.
	 * @return {Vector3} The result of the cross product.
	 */
	cross( v ) {

		return this.crossVectors( this, v );

	}

	/**
	 * Calculates the cross product of the given vectors and stores the result
	 * in this instance.
	 *
	 * @param {Vector3} a - The first vector.
	 * @param {Vector3} b - The second vector.
	 * @return {Vector3} A reference to this vector.
	 */
	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	/**
	 * Projects this vector onto the given one.
	 *
	 * @param {Vector3} v - The vector to project to.
	 * @return {Vector3} A reference to this vector.
	 */
	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	/**
	 * Projects this vector onto a plane by subtracting this
	 * vector projected onto the plane's normal from this vector.
	 *
	 * @param {Vector3} planeNormal - The plane normal.
	 * @return {Vector3} A reference to this vector.
	 */
	projectOnPlane( planeNormal ) {

		_vector$c.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector$c );

	}

	/**
	 * Reflects this vector off a plane orthogonal to the given normal vector.
	 *
	 * @param {Vector3} normal - The (normalized) normal vector.
	 * @return {Vector3} A reference to this vector.
	 */
	reflect( normal ) {

		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}
	/**
	 * Returns the angle between the given vector and this instance in radians.
	 *
	 * @param {Vector3} v - The vector to compute the angle with.
	 * @return {number} The angle in radians.
	 */
	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp( theta, -1, 1 ) );

	}

	/**
	 * Computes the distance from the given vector to this instance.
	 *
	 * @param {Vector3} v - The vector to compute the distance to.
	 * @return {number} The distance.
	 */
	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	/**
	 * Computes the squared distance from the given vector to this instance.
	 * If you are just comparing the distance with another distance, you should compare
	 * the distance squared instead as it is slightly more efficient to calculate.
	 *
	 * @param {Vector3} v - The vector to compute the squared distance to.
	 * @return {number} The squared distance.
	 */
	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	/**
	 * Computes the Manhattan distance from the given vector to this instance.
	 *
	 * @param {Vector3} v - The vector to compute the Manhattan distance to.
	 * @return {number} The Manhattan distance.
	 */
	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	/**
	 * Sets the vector components from the given spherical coordinates.
	 *
	 * @param {Spherical} s - The spherical coordinates.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	/**
	 * Sets the vector components from the given spherical coordinates.
	 *
	 * @param {number} radius - The radius.
	 * @param {number} phi - The phi angle in radians.
	 * @param {number} theta - The theta angle in radians.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	/**
	 * Sets the vector components from the given cylindrical coordinates.
	 *
	 * @param {Cylindrical} c - The cylindrical coordinates.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	/**
	 * Sets the vector components from the given cylindrical coordinates.
	 *
	 * @param {number} radius - The radius.
	 * @param {number} theta - The theta angle in radians.
	 * @param {number} y - The y value.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	/**
	 * Sets the vector components to the position elements of the
	 * given transformation matrix.
	 *
	 * @param {Matrix4} m - The 4x4 matrix.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	/**
	 * Sets the vector components to the scale elements of the
	 * given transformation matrix.
	 *
	 * @param {Matrix4} m - The 4x4 matrix.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	/**
	 * Sets the vector components from the specified matrix column.
	 *
	 * @param {Matrix4} m - The 4x4 matrix.
	 * @param {number} index - The column index.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	/**
	 * Sets the vector components from the specified matrix column.
	 *
	 * @param {Matrix3} m - The 3x3 matrix.
	 * @param {number} index - The column index.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	/**
	 * Sets the vector components from the given Euler angles.
	 *
	 * @param {Euler} e - The Euler angles to set.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromEuler( e ) {

		this.x = e._x;
		this.y = e._y;
		this.z = e._z;

		return this;

	}

	/**
	 * Sets the vector components from the RGB components of the
	 * given color.
	 *
	 * @param {Color} c - The color to set.
	 * @return {Vector3} A reference to this vector.
	 */
	setFromColor( c ) {

		this.x = c.r;
		this.y = c.g;
		this.z = c.b;

		return this;

	}

	/**
	 * Returns `true` if this vector is equal with the given one.
	 *
	 * @param {Vector3} v - The vector to test for equality.
	 * @return {boolean} Whether this vector is equal with the given one.
	 */
	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	/**
	 * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
	 * and z value to be `array[ offset + 2 ]`.
	 *
	 * @param {Array<number>} array - An array holding the vector component values.
	 * @param {number} [offset=0] - The offset into the array.
	 * @return {Vector3} A reference to this vector.
	 */
	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	/**
	 * Writes the components of this vector to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number>} [array=[]] - The target array holding the vector components.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number>} The vector components.
	 */
	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	/**
	 * Sets the components of this vector from the given buffer attribute.
	 *
	 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
	 * @param {number} index - The index into the attribute.
	 * @return {Vector3} A reference to this vector.
	 */
	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	/**
	 * Sets each component of this vector to a pseudo-random value between `0` and
	 * `1`, excluding `1`.
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

	/**
	 * Sets this vector to a uniformly random point on a unit sphere.
	 *
	 * @return {Vector3} A reference to this vector.
	 */
	randomDirection() {

		// https://mathworld.wolfram.com/SpherePointPicking.html

		const theta = Math.random() * Math.PI * 2;
		const u = Math.random() * 2 - 1;
		const c = Math.sqrt( 1 - u * u );

		this.x = c * Math.cos( theta );
		this.y = u;
		this.z = c * Math.sin( theta );

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;

	}

}

const _vector$c = /*@__PURE__*/ new Vector3();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();

/**
 * Represents a 3x3 matrix.
 *
 * A Note on Row-Major and Column-Major Ordering:
 *
 * The constructor and {@link Matrix3#set} method take arguments in
 * [row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
 * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
 * This means that calling:
 * ```js
 * const m = new THREE.Matrix();
 * m.set( 11, 12, 13,
 *        21, 22, 23,
 *        31, 32, 33 );
 * ```
 * will result in the elements array containing:
 * ```js
 * m.elements = [ 11, 21, 31,
 *                12, 22, 32,
 *                13, 23, 33 ];
 * ```
 * and internally all calculations are performed using column-major ordering.
 * However, as the actual ordering makes no difference mathematically and
 * most people are used to thinking about matrices in row-major order, the
 * three.js documentation shows matrices in row-major order. Just bear in
 * mind that if you are reading the source code, you'll have to take the
 * transpose of any matrices outlined here to make sense of the calculations.
 */
class Matrix3 {

	/**
	 * Constructs a new 3x3 matrix. The arguments are supposed to be
	 * in row-major order. If no arguments are provided, the constructor
	 * initializes the matrix as an identity matrix.
	 *
	 * @param {number} [n11] - 1-1 matrix element.
	 * @param {number} [n12] - 1-2 matrix element.
	 * @param {number} [n13] - 1-3 matrix element.
	 * @param {number} [n21] - 2-1 matrix element.
	 * @param {number} [n22] - 2-2 matrix element.
	 * @param {number} [n23] - 2-3 matrix element.
	 * @param {number} [n31] - 3-1 matrix element.
	 * @param {number} [n32] - 3-2 matrix element.
	 * @param {number} [n33] - 3-3 matrix element.
	 */
	constructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		Matrix3.prototype.isMatrix3 = true;

		/**
		 * A column-major list of matrix values.
		 *
		 * @type {Array<number>}
		 */
		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( n11 !== undefined ) {

			this.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );

		}

	}

	/**
	 * Sets the elements of the matrix.The arguments are supposed to be
	 * in row-major order.
	 *
	 * @param {number} [n11] - 1-1 matrix element.
	 * @param {number} [n12] - 1-2 matrix element.
	 * @param {number} [n13] - 1-3 matrix element.
	 * @param {number} [n21] - 2-1 matrix element.
	 * @param {number} [n22] - 2-2 matrix element.
	 * @param {number} [n23] - 2-3 matrix element.
	 * @param {number} [n31] - 3-1 matrix element.
	 * @param {number} [n32] - 3-2 matrix element.
	 * @param {number} [n33] - 3-3 matrix element.
	 * @return {Matrix3} A reference to this matrix.
	 */
	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	/**
	 * Sets this matrix to the 3x3 identity matrix.
	 *
	 * @return {Matrix3} A reference to this matrix.
	 */
	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	/**
	 * Copies the values of the given matrix to this instance.
	 *
	 * @param {Matrix3} m - The matrix to copy.
	 * @return {Matrix3} A reference to this matrix.
	 */
	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	/**
	 * Extracts the basis of this matrix into the three axis vectors provided.
	 *
	 * @param {Vector3} xAxis - The basis's x axis.
	 * @param {Vector3} yAxis - The basis's y axis.
	 * @param {Vector3} zAxis - The basis's z axis.
	 * @return {Matrix3} A reference to this matrix.
	 */
	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	/**
	 * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
	 *
	 * @param {Matrix4} m - The 4x4 matrix.
	 * @return {Matrix3} A reference to this matrix.
	 */
	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	/**
	 * Post-multiplies this matrix by the given 3x3 matrix.
	 *
	 * @param {Matrix3} m - The matrix to multiply with.
	 * @return {Matrix3} A reference to this matrix.
	 */
	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	/**
	 * Pre-multiplies this matrix by the given 3x3 matrix.
	 *
	 * @param {Matrix3} m - The matrix to multiply with.
	 * @return {Matrix3} A reference to this matrix.
	 */
	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	/**
	 * Multiples the given 3x3 matrices and stores the result
	 * in this matrix.
	 *
	 * @param {Matrix3} a - The first matrix.
	 * @param {Matrix3} b - The second matrix.
	 * @return {Matrix3} A reference to this matrix.
	 */
	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	/**
	 * Multiplies every component of the matrix by the given scalar.
	 *
	 * @param {number} s - The scalar.
	 * @return {Matrix3} A reference to this matrix.
	 */
	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	/**
	 * Computes and returns the determinant of this matrix.
	 *
	 * @return {number} The determinant.
	 */
	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	/**
	 * Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
	 * You can not invert with a determinant of zero. If you attempt this, the method produces
	 * a zero matrix instead.
	 *
	 * @return {Matrix3} A reference to this matrix.
	 */
	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	/**
	 * Transposes this matrix in place.
	 *
	 * @return {Matrix3} A reference to this matrix.
	 */
	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	/**
	 * Computes the normal matrix which is the inverse transpose of the upper
	 * left 3x3 portion of the given 4x4 matrix.
	 *
	 * @param {Matrix4} matrix4 - The 4x4 matrix.
	 * @return {Matrix3} A reference to this matrix.
	 */
	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	}

	/**
	 * Transposes this matrix into the supplied array, and returns itself unchanged.
	 *
	 * @param {Array<number>} r - An array to store the transposed matrix elements.
	 * @return {Matrix3} A reference to this matrix.
	 */
	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	/**
	 * Sets the UV transform matrix from offset, repeat, rotation, and center.
	 *
	 * @param {number} tx - Offset x.
	 * @param {number} ty - Offset y.
	 * @param {number} sx - Repeat x.
	 * @param {number} sy - Repeat y.
	 * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
	 * @param {number} cx - Center x of rotation.
	 * @param {number} cy - Center y of rotation
	 * @return {Matrix3} A reference to this matrix.
	 */
	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	}

	/**
	 * Scales this matrix with the given scalar values.
	 *
	 * @param {number} sx - The amount to scale in the X axis.
	 * @param {number} sy - The amount to scale in the Y axis.
	 * @return {Matrix3} A reference to this matrix.
	 */
	scale( sx, sy ) {

		this.premultiply( _m3.makeScale( sx, sy ) );

		return this;

	}

	/**
	 * Rotates this matrix by the given angle.
	 *
	 * @param {number} theta - The rotation in radians.
	 * @return {Matrix3} A reference to this matrix.
	 */
	rotate( theta ) {

		this.premultiply( _m3.makeRotation( - theta ) );

		return this;

	}

	/**
	 * Translates this matrix by the given scalar values.
	 *
	 * @param {number} tx - The amount to translate in the X axis.
	 * @param {number} ty - The amount to translate in the Y axis.
	 * @return {Matrix3} A reference to this matrix.
	 */
	translate( tx, ty ) {

		this.premultiply( _m3.makeTranslation( tx, ty ) );

		return this;

	}

	// for 2D Transforms

	/**
	 * Sets this matrix as a 2D translation transform.
	 *
	 * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
	 * @param {number} y - The amount to translate in the Y axis.
	 * @return {Matrix3} A reference to this matrix.
	 */
	makeTranslation( x, y ) {

		if ( x.isVector2 ) {

			this.set(

				1, 0, x.x,
				0, 1, x.y,
				0, 0, 1

			);

		} else {

			this.set(

				1, 0, x,
				0, 1, y,
				0, 0, 1

			);

		}

		return this;

	}

	/**
	 * Sets this matrix as a 2D rotational transformation.
	 *
	 * @param {number} theta - The rotation in radians.
	 * @return {Matrix3} A reference to this matrix.
	 */
	makeRotation( theta ) {

		// counterclockwise

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		this.set(

			c, - s, 0,
			s, c, 0,
			0, 0, 1

		);

		return this;

	}

	/**
	 * Sets this matrix as a 2D scale transform.
	 *
	 * @param {number} x - The amount to scale in the X axis.
	 * @param {number} y - The amount to scale in the Y axis.
	 * @return {Matrix3} A reference to this matrix.
	 */
	makeScale( x, y ) {

		this.set(

			x, 0, 0,
			0, y, 0,
			0, 0, 1

		);

		return this;

	}

	/**
	 * Returns `true` if this matrix is equal with the given one.
	 *
	 * @param {Matrix3} matrix - The matrix to test for equality.
	 * @return {boolean} Whether this matrix is equal with the given one.
	 */
	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	/**
	 * Sets the elements of the matrix from the given array.
	 *
	 * @param {Array<number>} array - The matrix elements in column-major order.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Matrix3} A reference to this matrix.
	 */
	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	/**
	 * Writes the elements of this matrix to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number>} The matrix elements in column-major order.
	 */
	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

	/**
	 * Returns a matrix with copied values from this instance.
	 *
	 * @return {Matrix3} A clone of this instance.
	 */
	clone() {

		return new this.constructor().fromArray( this.elements );

	}

}

const _m3 = /*@__PURE__*/ new Matrix3();

const LINEAR_REC709_TO_XYZ = /*@__PURE__*/ new Matrix3().set(
	0.4123908, 0.3575843, 0.1804808,
	0.2126390, 0.7151687, 0.0721923,
	0.0193308, 0.1191948, 0.9505322
);

const XYZ_TO_LINEAR_REC709 = /*@__PURE__*/ new Matrix3().set(
	3.2409699, -1.5373832, -0.4986108,
	-0.9692436, 1.8759675, 0.0415551,
	0.0556301, -0.203977, 1.0569715
);

function createColorManagement() {

	const ColorManagement = {

		enabled: true,

		workingColorSpace: LinearSRGBColorSpace,

		/**
		 * Implementations of supported color spaces.
		 *
		 * Required:
		 *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
		 *	- whitePoint: reference white [ x y ]
		 *	- transfer: transfer function (pre-defined)
		 *	- toXYZ: Matrix3 RGB to XYZ transform
		 *	- fromXYZ: Matrix3 XYZ to RGB transform
		 *	- luminanceCoefficients: RGB luminance coefficients
		 *
		 * Optional:
		 *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace, toneMappingMode: 'extended' | 'standard' }
		 *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
		 *
		 * Reference:
		 * - https://www.russellcottrell.com/photo/matrixCalculator.htm
		 */
		spaces: {},

		convert: function ( color, sourceColorSpace, targetColorSpace ) {

			if ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

				return color;

			}

			if ( this.spaces[ sourceColorSpace ].transfer === SRGBTransfer ) {

				color.r = SRGBToLinear( color.r );
				color.g = SRGBToLinear( color.g );
				color.b = SRGBToLinear( color.b );

			}

			if ( this.spaces[ sourceColorSpace ].primaries !== this.spaces[ targetColorSpace ].primaries ) {

				color.applyMatrix3( this.spaces[ sourceColorSpace ].toXYZ );
				color.applyMatrix3( this.spaces[ targetColorSpace ].fromXYZ );

			}

			if ( this.spaces[ targetColorSpace ].transfer === SRGBTransfer ) {

				color.r = LinearToSRGB( color.r );
				color.g = LinearToSRGB( color.g );
				color.b = LinearToSRGB( color.b );

			}

			return color;

		},

		workingToColorSpace: function ( color, targetColorSpace ) {

			return this.convert( color, this.workingColorSpace, targetColorSpace );

		},

		colorSpaceToWorking: function ( color, sourceColorSpace ) {

			return this.convert( color, sourceColorSpace, this.workingColorSpace );

		},

		getPrimaries: function ( colorSpace ) {

			return this.spaces[ colorSpace ].primaries;

		},

		getTransfer: function ( colorSpace ) {

			if ( colorSpace === NoColorSpace ) return LinearTransfer;

			return this.spaces[ colorSpace ].transfer;

		},

		getToneMappingMode: function ( colorSpace ) {

			return this.spaces[ colorSpace ].outputColorSpaceConfig.toneMappingMode || 'standard';

		},

		getLuminanceCoefficients: function ( target, colorSpace = this.workingColorSpace ) {

			return target.fromArray( this.spaces[ colorSpace ].luminanceCoefficients );

		},

		define: function ( colorSpaces ) {

			Object.assign( this.spaces, colorSpaces );

		},

		// Internal APIs

		_getMatrix: function ( targetMatrix, sourceColorSpace, targetColorSpace ) {

			return targetMatrix
				.copy( this.spaces[ sourceColorSpace ].toXYZ )
				.multiply( this.spaces[ targetColorSpace ].fromXYZ );

		},

		_getDrawingBufferColorSpace: function ( colorSpace ) {

			return this.spaces[ colorSpace ].outputColorSpaceConfig.drawingBufferColorSpace;

		},

		_getUnpackColorSpace: function ( colorSpace = this.workingColorSpace ) {

			return this.spaces[ colorSpace ].workingColorSpaceConfig.unpackColorSpace;

		},

		// Deprecated

		fromWorkingColorSpace: function ( color, targetColorSpace ) {

			warnOnce( 'ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().' ); // @deprecated, r177

			return ColorManagement.workingToColorSpace( color, targetColorSpace );

		},

		toWorkingColorSpace: function ( color, sourceColorSpace ) {

			warnOnce( 'ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().' ); // @deprecated, r177

			return ColorManagement.colorSpaceToWorking( color, sourceColorSpace );

		},

	};

	/******************************************************************************
	 * sRGB definitions
	 */

	const REC709_PRIMARIES = [ 0.640, 0.330, 0.300, 0.600, 0.150, 0.060 ];
	const REC709_LUMINANCE_COEFFICIENTS = [ 0.2126, 0.7152, 0.0722 ];
	const D65 = [ 0.3127, 0.3290 ];

	ColorManagement.define( {

		[ LinearSRGBColorSpace ]: {
			primaries: REC709_PRIMARIES,
			whitePoint: D65,
			transfer: LinearTransfer,
			toXYZ: LINEAR_REC709_TO_XYZ,
			fromXYZ: XYZ_TO_LINEAR_REC709,
			luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
			workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
			outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
		},

		[ SRGBColorSpace ]: {
			primaries: REC709_PRIMARIES,
			whitePoint: D65,
			transfer: SRGBTransfer,
			toXYZ: LINEAR_REC709_TO_XYZ,
			fromXYZ: XYZ_TO_LINEAR_REC709,
			luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
			outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
		},

	} );

	return ColorManagement;

}

const ColorManagement = /*@__PURE__*/ createColorManagement();

function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

let _canvas;

/**
 * A class containing utility functions for images.
 *
 * @hideconstructor
 */
class ImageUtils {

	/**
	 * Returns a data URI containing a representation of the given image.
	 *
	 * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
	 * @param {string} [type='image/png'] - Indicates the image format.
	 * @return {string} The data URI.
	 */
	static getDataURL( image, type = 'image/png' ) {

		if ( /^data:/i.test( image.src ) ) {

			return image.src;

		}

		if ( typeof HTMLCanvasElement === 'undefined' ) {

			return image.src;

		}

		let canvas;

		if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			const context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		return canvas.toDataURL( type );

	}

	/**
	 * Converts the given sRGB image data to linear color space.
	 *
	 * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
	 * @return {HTMLCanvasElement|Object} The converted image.
	 */
	static sRGBToLinear( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			const canvas = createElementNS( 'canvas' );

			canvas.width = image.width;
			canvas.height = image.height;

			const context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height );

			const imageData = context.getImageData( 0, 0, image.width, image.height );
			const data = imageData.data;

			for ( let i = 0; i < data.length; i ++ ) {

				data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

			}

			context.putImageData( imageData, 0, 0 );

			return canvas;

		} else if ( image.data ) {

			const data = image.data.slice( 0 );

			for ( let i = 0; i < data.length; i ++ ) {

				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

					data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

				} else {

					// assuming float

					data[ i ] = SRGBToLinear( data[ i ] );

				}

			}

			return {
				data: data,
				width: image.width,
				height: image.height
			};

		} else {

			warn( 'ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
			return image;

		}

	}

}

let _sourceId = 0;

/**
 * Represents the data source of a texture.
 *
 * The main purpose of this class is to decouple the data definition from the texture
 * definition so the same data can be used with multiple texture instances.
 */
class Source {

	/**
	 * Constructs a new video texture.
	 *
	 * @param {any} [data=null] - The data definition of a texture.
	 */
	constructor( data = null ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isSource = true;

		/**
		 * The ID of the source.
		 *
		 * @name Source#id
		 * @type {number}
		 * @readonly
		 */
		Object.defineProperty( this, 'id', { value: _sourceId ++ } );

		/**
		 * The UUID of the source.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.uuid = generateUUID();

		/**
		 * The data definition of a texture.
		 *
		 * @type {any}
		 */
		this.data = data;

		/**
		 * This property is only relevant when {@link Source#needsUpdate} is set to `true` and
		 * provides more control on how texture data should be processed. When `dataReady` is set
		 * to `false`, the engine performs the memory allocation (if necessary) but does not transfer
		 * the data into the GPU memory.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.dataReady = true;

		/**
		 * This starts at `0` and counts how many times {@link Source#needsUpdate} is set to `true`.
		 *
		 * @type {number}
		 * @readonly
		 * @default 0
		 */
		this.version = 0;

	}

	/**
	 * Returns the dimensions of the source into the given target vector.
	 *
	 * @param {(Vector2|Vector3)} target - The target object the result is written into.
	 * @return {(Vector2|Vector3)} The dimensions of the source.
	 */
	getSize( target ) {

		const data = this.data;

		if ( ( typeof HTMLVideoElement !== 'undefined' ) && ( data instanceof HTMLVideoElement ) ) {

			target.set( data.videoWidth, data.videoHeight, 0 );

		} else if ( data instanceof VideoFrame ) {

			target.set( data.displayHeight, data.displayWidth, 0 );

		} else if ( data !== null ) {

			target.set( data.width, data.height, data.depth || 0 );

		} else {

			target.set( 0, 0, 0 );

		}

		return target;

	}

	/**
	 * When the property is set to `true`, the engine allocates the memory
	 * for the texture (if necessary) and triggers the actual texture upload
	 * to the GPU next time the source is used.
	 *
	 * @type {boolean}
	 * @default false
	 * @param {boolean} value
	 */
	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	/**
	 * Serializes the source into JSON.
	 *
	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	 * @return {Object} A JSON object representing the serialized source.
	 * @see {@link ObjectLoader#parse}
	 */
	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

			return meta.images[ this.uuid ];

		}

		const output = {
			uuid: this.uuid,
			url: ''
		};

		const data = this.data;

		if ( data !== null ) {

			let url;

			if ( Array.isArray( data ) ) {

				// cube texture

				url = [];

				for ( let i = 0, l = data.length; i < l; i ++ ) {

					if ( data[ i ].isDataTexture ) {

						url.push( serializeImage( data[ i ].image ) );

					} else {

						url.push( serializeImage( data[ i ] ) );

					}

				}

			} else {

				// texture

				url = serializeImage( data );

			}

			output.url = url;

		}

		if ( ! isRootObject ) {

			meta.images[ this.uuid ] = output;

		}

		return output;

	}

}

function serializeImage( image ) {

	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		// default images

		return ImageUtils.getDataURL( image );

	} else {

		if ( image.data ) {

			// images of DataTexture

			return {
				data: Array.from( image.data ),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};

		} else {

			warn( 'Texture: Unable to serialize Texture.' );
			return {};

		}

	}

}

let _textureId = 0;

const _tempVec3 = /*@__PURE__*/ new Vector3();

/**
 * Base class for all textures.
 *
 * Note: After the initial use of a texture, its dimensions, format, and type
 * cannot be changed. Instead, call {@link Texture#dispose} on the texture and instantiate a new one.
 *
 * @augments EventDispatcher
 */
class Texture extends EventDispatcher {

	/**
	 * Constructs a new texture.
	 *
	 * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
	 * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
	 * @param {number} [format=RGBAFormat] - The texture format.
	 * @param {number} [type=UnsignedByteType] - The texture type.
	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	 * @param {string} [colorSpace=NoColorSpace] - The color space.
	 */
	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isTexture = true;

		/**
		 * The ID of the texture.
		 *
		 * @name Texture#id
		 * @type {number}
		 * @readonly
		 */
		Object.defineProperty( this, 'id', { value: _textureId ++ } );

		/**
		 * The UUID of the material.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.uuid = generateUUID();

		/**
		 * The name of the material.
		 *
		 * @type {string}
		 */
		this.name = '';

		/**
		 * The data definition of a texture. A reference to the data source can be
		 * shared across textures. This is often useful in context of spritesheets
		 * where multiple textures render the same data but with different texture
		 * transformations.
		 *
		 * @type {Source}
		 */
		this.source = new Source( image );

		/**
		 * An array holding user-defined mipmaps.
		 *
		 * @type {Array<Object>}
		 */
		this.mipmaps = [];

		/**
		 * How the texture is applied to the object. The value `UVMapping`
		 * is the default, where texture or uv coordinates are used to apply the map.
		 *
		 * @type {(UVMapping|CubeReflectionMapping|CubeRefractionMapping|EquirectangularReflectionMapping|EquirectangularRefractionMapping|CubeUVReflectionMapping)}
		 * @default UVMapping
		*/
		this.mapping = mapping;

		/**
		 * Lets you select the uv attribute to map the texture to. `0` for `uv`,
		 * `1` for `uv1`, `2` for `uv2` and `3` for `uv3`.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.channel = 0;

		/**
		 * This defines how the texture is wrapped horizontally and corresponds to
		 * *U* in UV mapping.
		 *
		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
		 * @default ClampToEdgeWrapping
		 */
		this.wrapS = wrapS;

		/**
		 * This defines how the texture is wrapped horizontally and corresponds to
		 * *V* in UV mapping.
		 *
		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
		 * @default ClampToEdgeWrapping
		 */
		this.wrapT = wrapT;

		/**
		 * How the texture is sampled when a texel covers more than one pixel.
		 *
		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		 * @default LinearFilter
		 */
		this.magFilter = magFilter;

		/**
		 * How the texture is sampled when a texel covers less than one pixel.
		 *
		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		 * @default LinearMipmapLinearFilter
		 */
		this.minFilter = minFilter;

		/**
		 * The number of samples taken along the axis through the pixel that has the
		 * highest density of texels. By default, this value is `1`. A higher value
		 * gives a less blurry result than a basic mipmap, at the cost of more
		 * texture samples being used.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.anisotropy = anisotropy;

		/**
		 * The format of the texture.
		 *
		 * @type {number}
		 * @default RGBAFormat
		 */
		this.format = format;

		/**
		 * The default internal format is derived from {@link Texture#format} and {@link Texture#type} and
		 * defines how the texture data is going to be stored on the GPU.
		 *
		 * This property allows to overwrite the default format.
		 *
		 * @type {?string}
		 * @default null
		 */
		this.internalFormat = null;

		/**
		 * The data type of the texture.
		 *
		 * @type {number}
		 * @default UnsignedByteType
		 */
		this.type = type;

		/**
		 * How much a single repetition of the texture is offset from the beginning,
		 * in each direction U and V. Typical range is `0.0` to `1.0`.
		 *
		 * @type {Vector2}
		 * @default (0,0)
		 */
		this.offset = new Vector2( 0, 0 );

		/**
		 * How many times the texture is repeated across the surface, in each
		 * direction U and V. If repeat is set greater than `1` in either direction,
		 * the corresponding wrap parameter should also be set to `RepeatWrapping`
		 * or `MirroredRepeatWrapping` to achieve the desired tiling effect.
		 *
		 * @type {Vector2}
		 * @default (1,1)
		 */
		this.repeat = new Vector2( 1, 1 );

		/**
		 * The point around which rotation occurs. A value of `(0.5, 0.5)` corresponds
		 * to the center of the texture. Default is `(0, 0)`, the lower left.
		 *
		 * @type {Vector2}
		 * @default (0,0)
		 */
		this.center = new Vector2( 0, 0 );

		/**
		 * How much the texture is rotated around the center point, in radians.
		 * Positive values are counter-clockwise.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.rotation = 0;

		/**
		 * Whether to update the texture's uv-transformation {@link Texture#matrix}
		 * from the properties {@link Texture#offset}, {@link Texture#repeat},
		 * {@link Texture#rotation}, and {@link Texture#center}.
		 *
		 * Set this to `false` if you are specifying the uv-transform matrix directly.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.matrixAutoUpdate = true;

		/**
		 * The uv-transformation matrix of the texture.
		 *
		 * @type {Matrix3}
		 */
		this.matrix = new Matrix3();

		/**
		 * Whether to generate mipmaps (if possible) for a texture.
		 *
		 * Set this to `false` if you are creating mipmaps manually.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.generateMipmaps = true;

		/**
		 * If set to `true`, the alpha channel, if present, is multiplied into the
		 * color channels when the texture is uploaded to the GPU.
		 *
		 * Note that this property has no effect when using `ImageBitmap`. You need to
		 * configure premultiply alpha on bitmap creation instead.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.premultiplyAlpha = false;

		/**
		 * If set to `true`, the texture is flipped along the vertical axis when
		 * uploaded to the GPU.
		 *
		 * Note that this property has no effect when using `ImageBitmap`. You need to
		 * configure the flip on bitmap creation instead.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.flipY = true;

		/**
		 * Specifies the alignment requirements for the start of each pixel row in memory.
		 * The allowable values are `1` (byte-alignment), `2` (rows aligned to even-numbered bytes),
		 * `4` (word-alignment), and `8` (rows start on double-word boundaries).
		 *
		 * @type {number}
		 * @default 4
		 */
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		/**
		 * Textures containing color data should be annotated with `SRGBColorSpace` or `LinearSRGBColorSpace`.
		 *
		 * @type {string}
		 * @default NoColorSpace
		 */
		this.colorSpace = colorSpace;

		/**
		 * An object that can be used to store custom data about the texture. It
		 * should not hold references to functions as these will not be cloned.
		 *
		 * @type {Object}
		 */
		this.userData = {};

		/**
		 * This can be used to only update a subregion or specific rows of the texture (for example, just the
		 * first 3 rows). Use the `addUpdateRange()` function to add ranges to this array.
		 *
		 * @type {Array<Object>}
		 */
		this.updateRanges = [];

		/**
		 * This starts at `0` and counts how many times {@link Texture#needsUpdate} is set to `true`.
		 *
		 * @type {number}
		 * @readonly
		 * @default 0
		 */
		this.version = 0;

		/**
		 * A callback function, called when the texture is updated (e.g., when
		 * {@link Texture#needsUpdate} has been set to true and then the texture is used).
		 *
		 * @type {?Function}
		 * @default null
		 */
		this.onUpdate = null;

		/**
		 * An optional back reference to the textures render target.
		 *
		 * @type {?(RenderTarget|WebGLRenderTarget)}
		 * @default null
		 */
		this.renderTarget = null;

		/**
		 * Indicates whether a texture belongs to a render target or not.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default false
		 */
		this.isRenderTargetTexture = false;

		/**
		 * Indicates if a texture should be handled like a texture array.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default false
		 */
		this.isArrayTexture = image && image.depth && image.depth > 1 ? true : false;

		/**
		 * Indicates whether this texture should be processed by `PMREMGenerator` or not
		 * (only relevant for render target textures).
		 *
		 * @type {number}
		 * @readonly
		 * @default 0
		 */
		this.pmremVersion = 0;

	}

	/**
	 * The width of the texture in pixels.
	 */
	get width() {

		return this.source.getSize( _tempVec3 ).x;

	}

	/**
	 * The height of the texture in pixels.
	 */
	get height() {

		return this.source.getSize( _tempVec3 ).y;

	}

	/**
	 * The depth of the texture in pixels.
	 */
	get depth() {

		return this.source.getSize( _tempVec3 ).z;

	}

	/**
	 * The image object holding the texture data.
	 *
	 * @type {?Object}
	 */
	get image() {

		return this.source.data;

	}

	set image( value = null ) {

		this.source.data = value;

	}

	/**
	 * Updates the texture transformation matrix from the from the properties {@link Texture#offset},
	 * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
	 */
	updateMatrix() {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	}

	/**
	 * Adds a range of data in the data texture to be updated on the GPU.
	 *
	 * @param {number} start - Position at which to start update.
	 * @param {number} count - The number of components to update.
	 */
	addUpdateRange( start, count ) {

		this.updateRanges.push( { start, count } );

	}

	/**
	 * Clears the update ranges.
	 */
	clearUpdateRanges() {

		this.updateRanges.length = 0;

	}

	/**
	 * Returns a new texture with copied values from this instance.
	 *
	 * @return {Texture} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Copies the values of the given texture to this instance.
	 *
	 * @param {Texture} source - The texture to copy.
	 * @return {Texture} A reference to this instance.
	 */
	copy( source ) {

		this.name = source.name;

		this.source = source.source;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;
		this.channel = source.channel;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.colorSpace = source.colorSpace;

		this.renderTarget = source.renderTarget;
		this.isRenderTargetTexture = source.isRenderTargetTexture;
		this.isArrayTexture = source.isArrayTexture;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		this.needsUpdate = true;

		return this;

	}

	/**
	 * Sets this texture's properties based on `values`.
	 * @param {Object} values - A container with texture parameters.
	 */
	setValues( values ) {

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				warn( `Texture.setValues(): parameter '${ key }' has value of undefined.` );
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				warn( `Texture.setValues(): property '${ key }' does not exist.` );
				continue;

			}

			if ( ( currentValue && newValue ) && ( currentValue.isVector2 && newValue.isVector2 ) ) {

				currentValue.copy( newValue );

			} else if ( ( currentValue && newValue ) && ( currentValue.isVector3 && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else if ( ( currentValue && newValue ) && ( currentValue.isMatrix3 && newValue.isMatrix3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	}

	/**
	 * Serializes the texture into JSON.
	 *
	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	 * @return {Object} A JSON object representing the serialized texture.
	 * @see {@link ObjectLoader#parse}
	 */
	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		const output = {

			metadata: {
				version: 4.7,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			image: this.source.toJSON( meta ).uuid,

			mapping: this.mapping,
			channel: this.channel,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			internalFormat: this.internalFormat,
			type: this.type,
			colorSpace: this.colorSpace,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			generateMipmaps: this.generateMipmaps,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 *
	 * @fires Texture#dispose
	 */
	dispose() {

		/**
		 * Fires when the texture has been disposed of.
		 *
		 * @event Texture#dispose
		 * @type {Object}
		 */
		this.dispatchEvent( { type: 'dispose' } );

	}

	/**
	 * Transforms the given uv vector with the textures uv transformation matrix.
	 *
	 * @param {Vector2} uv - The uv vector.
	 * @return {Vector2} The transformed uv vector.
	 */
	transformUv( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

	/**
	 * Setting this property to `true` indicates the engine the texture
	 * must be updated in the next render. This triggers a texture upload
	 * to the GPU and ensures correct texture parameter configuration.
	 *
	 * @type {boolean}
	 * @default false
	 * @param {boolean} value
	 */
	set needsUpdate( value ) {

		if ( value === true ) {

			this.version ++;
			this.source.needsUpdate = true;

		}

	}

	/**
	 * Setting this property to `true` indicates the engine the PMREM
	 * must be regenerated.
	 *
	 * @type {boolean}
	 * @default false
	 * @param {boolean} value
	 */
	set needsPMREMUpdate( value ) {

		if ( value === true ) {

			this.pmremVersion ++;

		}

	}

}

/**
 * The default image for all textures.
 *
 * @static
 * @type {?Image}
 * @default null
 */
Texture.DEFAULT_IMAGE = null;

/**
 * The default mapping for all textures.
 *
 * @static
 * @type {number}
 * @default UVMapping
 */
Texture.DEFAULT_MAPPING = UVMapping;

/**
 * The default anisotropy value for all textures.
 *
 * @static
 * @type {number}
 * @default 1
 */
Texture.DEFAULT_ANISOTROPY = 1;

/**
 * Class representing a 4D vector. A 4D vector is an ordered quadruplet of numbers
 * (labeled x, y, z and w), which can be used to represent a number of things, such as:
 *
 * - A point in 4D space.
 * - A direction and length in 4D space. In three.js the length will
 * always be the Euclidean distance(straight-line distance) from `(0, 0, 0, 0)` to `(x, y, z, w)`
 * and the direction is also measured from `(0, 0, 0, 0)` towards `(x, y, z, w)`.
 * - Any arbitrary ordered quadruplet of numbers.
 *
 * There are other things a 4D vector can be used to represent, however these
 * are the most common uses in *three.js*.
 *
 * Iterating through a vector instance will yield its components `(x, y, z, w)` in
 * the corresponding order.
 * ```js
 * const a = new THREE.Vector4( 0, 1, 0, 0 );
 *
 * //no arguments; will be initialised to (0, 0, 0, 1)
 * const b = new THREE.Vector4( );
 *
 * const d = a.dot( b );
 * ```
 */
class Vector4 {

	/**
	 * Constructs a new 4D vector.
	 *
	 * @param {number} [x=0] - The x value of this vector.
	 * @param {number} [y=0] - The y value of this vector.
	 * @param {number} [z=0] - The z value of this vector.
	 * @param {number} [w=1] - The w value of this vector.
	 */
	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		Vector4.prototype.isVector4 = true;

		/**
		 * The x value of this vector.
		 *
		 * @type {number}
		 */
		this.x = x;

		/**
		 * The y value of this vector.
		 *
		 * @type {number}
		 */
		this.y = y;

		/**
		 * The z value of this vector.
		 *
		 * @type {number}
		 */
		this.z = z;

		/**
		 * The w value of this vector.
		 *
		 * @type {number}
		 */
		this.w = w;

	}

	/**
	 * Alias for {@link Vector4#z}.
	 *
	 * @type {number}
	 */
	get width() {

		return this.z;

	}

	set width( value ) {

		this.z = value;

	}

	/**
	 * Alias for {@link Vector4#w}.
	 *
	 * @type {number}
	 */
	get height() {

		return this.w;

	}

	set height( value ) {

		this.w = value;

	}

	/**
	 * Sets the vector components.
	 *
	 * @param {number} x - The value of the x component.
	 * @param {number} y - The value of the y component.
	 * @param {number} z - The value of the z component.
	 * @param {number} w - The value of the w component.
	 * @return {Vector4} A reference to this vector.
	 */
	set( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	}

	/**
	 * Sets the vector components to the same value.
	 *
	 * @param {number} scalar - The value to set for all vector components.
	 * @return {Vector4} A reference to this vector.
	 */
	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	}

	/**
	 * Sets the vector's x component to the given value
	 *
	 * @param {number} x - The value to set.
	 * @return {Vector4} A reference to this vector.
	 */
	setX( x ) {

		this.x = x;

		return this;

	}

	/**
	 * Sets the vector's y component to the given value
	 *
	 * @param {number} y - The value to set.
	 * @return {Vector4} A reference to this vector.
	 */
	setY( y ) {

		this.y = y;

		return this;

	}

	/**
	 * Sets the vector's z component to the given value
	 *
	 * @param {number} z - The value to set.
	 * @return {Vector4} A reference to this vector.
	 */
	setZ( z ) {

		this.z = z;

		return this;

	}

	/**
	 * Sets the vector's w component to the given value
	 *
	 * @param {number} w - The value to set.
	 * @return {Vector4} A reference to this vector.
	 */
	setW( w ) {

		this.w = w;

		return this;

	}

	/**
	 * Allows to set a vector component with an index.
	 *
	 * @param {number} index - The component index. `0` equals to x, `1` equals to y,
	 * `2` equals to z, `3` equals to w.
	 * @param {number} value - The value to set.
	 * @return {Vector4} A reference to this vector.
	 */
	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	/**
	 * Returns the value of the vector component which matches the given index.
	 *
	 * @param {number} index - The component index. `0` equals to x, `1` equals to y,
	 * `2` equals to z, `3` equals to w.
	 * @return {number} A vector component value.
	 */
	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	/**
	 * Returns a new vector with copied values from this instance.
	 *
	 * @return {Vector4} A clone of this instance.
	 */
	clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}

	/**
	 * Copies the values of the given vector to this instance.
	 *
	 * @param {Vector3|Vector4} v - The vector to copy.
	 * @return {Vector4} A reference to this vector.
	 */
	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	}

	/**
	 * Adds the given vector to this instance.
	 *
	 * @param {Vector4} v - The vector to add.
	 * @return {Vector4} A reference to this vector.
	 */
	add( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	}

	/**
	 * Adds the given scalar value to all components of this instance.
	 *
	 * @param {number} s - The scalar to add.
	 * @return {Vector4} A reference to this vector.
	 */
	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	}

	/**
	 * Adds the given vectors and stores the result in this instance.
	 *
	 * @param {Vector4} a - The first vector.
	 * @param {Vector4} b - The second vector.
	 * @return {Vector4} A reference to this vector.
	 */
	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	}

	/**
	 * Adds the given vector scaled by the given factor to this instance.
	 *
	 * @param {Vector4} v - The vector.
	 * @param {number} s - The factor that scales `v`.
	 * @return {Vector4} A reference to this vector.
	 */
	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	}

	/**
	 * Subtracts the given vector from this instance.
	 *
	 * @param {Vector4} v - The vector to subtract.
	 * @return {Vector4} A reference to this vector.
	 */
	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	}

	/**
	 * Subtracts the given scalar value from all components of this instance.
	 *
	 * @param {number} s - The scalar to subtract.
	 * @return {Vector4} A reference to this vector.
	 */
	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	}

	/**
	 * Subtracts the given vectors and stores the result in this instance.
	 *
	 * @param {Vector4} a - The first vector.
	 * @param {Vector4} b - The second vector.
	 * @return {Vector4} A reference to this vector.
	 */
	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	}

	/**
	 * Multiplies the given vector with this instance.
	 *
	 * @param {Vector4} v - The vector to multiply.
	 * @return {Vector4} A reference to this vector.
	 */
	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;

		return this;

	}

	/**
	 * Multiplies the given scalar value with all components of this instance.
	 *
	 * @param {number} scalar - The scalar to multiply.
	 * @return {Vector4} A reference to this vector.
	 */
	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	}

	/**
	 * Multiplies this vector with the given 4x4 matrix.
	 *
	 * @param {Matrix4} m - The 4x4 matrix.
	 * @return {Vector4} A reference to this vector.
	 */
	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	}

	/**
	 * Divides this instance by the given vector.
	 *
	 * @param {Vector4} v - The vector to divide.
	 * @return {Vector4} A reference to this vector.
	 */
	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;
		this.w /= v.w;

		return this;

	}

	/**
	 * Divides this vector by the given scalar.
	 *
	 * @param {number} scalar - The scalar to divide.
	 * @return {Vector4} A reference to this vector.
	 */
	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	/**
	 * Sets the x, y and z components of this
	 * vector to the quaternion's axis and w to the angle.
	 *
	 * @param {Quaternion} q - The Quaternion to set.
	 * @return {Vector4} A reference to this vector.
	 */
	setAxisAngleFromQuaternion( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		const s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	}

	/**
	 * Sets the x, y and z components of this
	 * vector to the axis of rotation and w to the angle.
	 *
	 * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
	 * @return {Vector4} A reference to this vector.
	 */
	setAxisAngleFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			const xx = ( m11 + 1 ) / 2;
			const yy = ( m22 + 1 ) / 2;
			const zz = ( m33 + 1 ) / 2;
			const xy = ( m12 + m21 ) / 4;
			const xz = ( m13 + m31 ) / 4;
			const yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	}

	/**
	 * Sets the vector components to the position elements of the
	 * given transformation matrix.
	 *
	 * @param {Matrix4} m - The 4x4 matrix.
	 * @return {Vector4} A reference to this vector.
	 */
	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];
		this.w = e[ 15 ];

		return this;

	}

	/**
	 * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
	 * value, replace that value with the corresponding min value.
	 *
	 * @param {Vector4} v - The vector.
	 * @return {Vector4} A reference to this vector.
	 */
	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	}

	/**
	 * If this vector's x, y, z or w value is less than the given vector's x, y, z or w
	 * value, replace that value with the corresponding max value.
	 *
	 * @param {Vector4} v - The vector.
	 * @return {Vector4} A reference to this vector.
	 */
	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	}

	/**
	 * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
	 * value, it is replaced by the corresponding value.
	 * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
	 * it is replaced by the corresponding value.
	 *
	 * @param {Vector4} min - The minimum x, y and z values.
	 * @param {Vector4} max - The maximum x, y and z values in the desired range.
	 * @return {Vector4} A reference to this vector.
	 */
	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = clamp( this.x, min.x, max.x );
		this.y = clamp( this.y, min.y, max.y );
		this.z = clamp( this.z, min.z, max.z );
		this.w = clamp( this.w, min.w, max.w );

		return this;

	}

	/**
	 * If this vector's x, y, z or w values are greater than the max value, they are
	 * replaced by the max value.
	 * If this vector's x, y, z or w values are less than the min value, they are
	 * replaced by the min value.
	 *
	 * @param {number} minVal - The minimum value the components will be clamped to.
	 * @param {number} maxVal - The maximum value the components will be clamped to.
	 * @return {Vector4} A reference to this vector.
	 */
	clampScalar( minVal, maxVal ) {

		this.x = clamp( this.x, minVal, maxVal );
		this.y = clamp( this.y, minVal, maxVal );
		this.z = clamp( this.z, minVal, maxVal );
		this.w = clamp( this.w, minVal, maxVal );

		return this;

	}

	/**
	 * If this vector's length is greater than the max value, it is replaced by
	 * the max value.
	 * If this vector's length is less than the min value, it is replaced by the
	 * min value.
	 *
	 * @param {number} min - The minimum value the vector length will be clamped to.
	 * @param {number} max - The maximum value the vector length will be clamped to.
	 * @return {Vector4} A reference to this vector.
	 */
	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );

	}

	/**
	 * The components of this vector are rounded down to the nearest integer value.
	 *
	 * @return {Vector4} A reference to this vector.
	 */
	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	}

	/**
	 * The components of this vector are rounded up to the nearest integer value.
	 *
	 * @return {Vector4} A reference to this vector.
	 */
	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	}

	/**
	 * The components of this vector are rounded to the nearest integer value
	 *
	 * @return {Vector4} A reference to this vector.
	 */
	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	}

	/**
	 * The components of this vector are rounded towards zero (up if negative,
	 * down if positive) to an integer value.
	 *
	 * @return {Vector4} A reference to this vector.
	 */
	roundToZero() {

		this.x = Math.trunc( this.x );
		this.y = Math.trunc( this.y );
		this.z = Math.trunc( this.z );
		this.w = Math.trunc( this.w );

		return this;

	}

	/**
	 * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
	 *
	 * @return {Vector4} A reference to this vector.
	 */
	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	}

	/**
	 * Calculates the dot product of the given vector with this instance.
	 *
	 * @param {Vector4} v - The vector to compute the dot product with.
	 * @return {number} The result of the dot product.
	 */
	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	}

	/**
	 * Computes the square of the Euclidean length (straight-line length) from
	 * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
	 * compare the length squared instead as it is slightly more efficient to calculate.
	 *
	 * @return {number} The square length of this vector.
	 */
	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}

	/**
	 * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
	 *
	 * @return {number} The length of this vector.
	 */
	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}

	/**
	 * Computes the Manhattan length of this vector.
	 *
	 * @return {number} The length of this vector.
	 */
	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}

	/**
	 * Converts this vector to a unit vector - that is, sets it equal to a vector
	 * with the same direction as this one, but with a vector length of `1`.
	 *
	 * @return {Vector4} A reference to this vector.
	 */
	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	/**
	 * Sets this vector to a vector with the same direction as this one, but
	 * with the specified length.
	 *
	 * @param {number} length - The new length of this vector.
	 * @return {Vector4} A reference to this vector.
	 */
	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	/**
	 * Linearly interpolates between the given vector and this instance, where
	 * alpha is the percent distance along the line - alpha = 0 will be this
	 * vector, and alpha = 1 will be the given one.
	 *
	 * @param {Vector4} v - The vector to interpolate towards.
	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	 * @return {Vector4} A reference to this vector.
	 */
	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

	/**
	 * Linearly interpolates between the given vectors, where alpha is the percent
	 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
	 * be the second one. The result is stored in this instance.
	 *
	 * @param {Vector4} v1 - The first vector.
	 * @param {Vector4} v2 - The second vector.
	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
	 * @return {Vector4} A reference to this vector.
	 */
	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	}

	/**
	 * Returns `true` if this vector is equal with the given one.
	 *
	 * @param {Vector4} v - The vector to test for equality.
	 * @return {boolean} Whether this vector is equal with the given one.
	 */
	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	}

	/**
	 * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
	 * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
	 *
	 * @param {Array<number>} array - An array holding the vector component values.
	 * @param {number} [offset=0] - The offset into the array.
	 * @return {Vector4} A reference to this vector.
	 */
	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	}

	/**
	 * Writes the components of this vector to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number>} [array=[]] - The target array holding the vector components.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number>} The vector components.
	 */
	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	}

	/**
	 * Sets the components of this vector from the given buffer attribute.
	 *
	 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
	 * @param {number} index - The index into the attribute.
	 * @return {Vector4} A reference to this vector.
	 */
	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

	/**
	 * Sets each component of this vector to a pseudo-random value between `0` and
	 * `1`, excluding `1`.
	 *
	 * @return {Vector4} A reference to this vector.
	 */
	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;
		yield this.w;

	}

}

/**
 * A render target is a buffer where the video card draws pixels for a scene
 * that is being rendered in the background. It is used in different effects,
 * such as applying postprocessing to a rendered image before displaying it
 * on the screen.
 *
 * @augments EventDispatcher
 */
class RenderTarget extends EventDispatcher {

	/**
	 * Render target options.
	 *
	 * @typedef {Object} RenderTarget~Options
	 * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.
	 * @property {number} [magFilter=LinearFilter] - The mag filter.
	 * @property {number} [minFilter=LinearFilter] - The min filter.
	 * @property {number} [format=RGBAFormat] - The texture format.
	 * @property {number} [type=UnsignedByteType] - The texture type.
	 * @property {?string} [internalFormat=null] - The texture's internal format.
	 * @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.
	 * @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.
	 * @property {number} [anisotropy=1] - The texture's anisotropy value.
	 * @property {string} [colorSpace=NoColorSpace] - The texture's color space.
	 * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.
	 * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.
	 * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.
	 * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.
	 * @property {?Texture} [depthTexture=null] - Reference to a depth texture.
	 * @property {number} [samples=0] - The MSAA samples count.
	 * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.
	 * @property {number} [depth=1] - The texture depth.
	 * @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.
	 */

	/**
	 * Constructs a new render target.
	 *
	 * @param {number} [width=1] - The width of the render target.
	 * @param {number} [height=1] - The height of the render target.
	 * @param {RenderTarget~Options} [options] - The configuration object.
	 */
	constructor( width = 1, height = 1, options = {} ) {

		super();

		options = Object.assign( {
			generateMipmaps: false,
			internalFormat: null,
			minFilter: LinearFilter,
			depthBuffer: true,
			stencilBuffer: false,
			resolveDepthBuffer: true,
			resolveStencilBuffer: true,
			depthTexture: null,
			samples: 0,
			count: 1,
			depth: 1,
			multiview: false
		}, options );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isRenderTarget = true;

		/**
		 * The width of the render target.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.width = width;

		/**
		 * The height of the render target.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.height = height;

		/**
		 * The depth of the render target.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.depth = options.depth;

		/**
		 * A rectangular area inside the render target's viewport. Fragments that are
		 * outside the area will be discarded.
		 *
		 * @type {Vector4}
		 * @default (0,0,width,height)
		 */
		this.scissor = new Vector4( 0, 0, width, height );

		/**
		 * Indicates whether the scissor test should be enabled when rendering into
		 * this render target or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.scissorTest = false;

		/**
		 * A rectangular area representing the render target's viewport.
		 *
		 * @type {Vector4}
		 * @default (0,0,width,height)
		 */
		this.viewport = new Vector4( 0, 0, width, height );

		const image = { width: width, height: height, depth: options.depth };

		const texture = new Texture( image );

		/**
		 * An array of textures. Each color attachment is represented as a separate texture.
		 * Has at least a single entry for the default color attachment.
		 *
		 * @type {Array<Texture>}
		 */
		this.textures = [];

		const count = options.count;
		for ( let i = 0; i < count; i ++ ) {

			this.textures[ i ] = texture.clone();
			this.textures[ i ].isRenderTargetTexture = true;
			this.textures[ i ].renderTarget = this;

		}

		this._setTextureOptions( options );

		/**
		 * Whether to allocate a depth buffer or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.depthBuffer = options.depthBuffer;

		/**
		 * Whether to allocate a stencil buffer or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.stencilBuffer = options.stencilBuffer;

		/**
		 * Whether to resolve the depth buffer or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.resolveDepthBuffer = options.resolveDepthBuffer;

		/**
		 * Whether to resolve the stencil buffer or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.resolveStencilBuffer = options.resolveStencilBuffer;

		this._depthTexture = null;
		this.depthTexture = options.depthTexture;

		/**
		 * The number of MSAA samples.
		 *
		 * A value of `0` disables MSAA.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.samples = options.samples;

		/**
		 * Whether to this target is used in multiview rendering.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.multiview = options.multiview;

	}

	_setTextureOptions( options = {} ) {

		const values = {
			minFilter: LinearFilter,
			generateMipmaps: false,
			flipY: false,
			internalFormat: null
		};

		if ( options.mapping !== undefined ) values.mapping = options.mapping;
		if ( options.wrapS !== undefined ) values.wrapS = options.wrapS;
		if ( options.wrapT !== undefined ) values.wrapT = options.wrapT;
		if ( options.wrapR !== undefined ) values.wrapR = options.wrapR;
		if ( options.magFilter !== undefined ) values.magFilter = options.magFilter;
		if ( options.minFilter !== undefined ) values.minFilter = options.minFilter;
		if ( options.format !== undefined ) values.format = options.format;
		if ( options.type !== undefined ) values.type = options.type;
		if ( options.anisotropy !== undefined ) values.anisotropy = options.anisotropy;
		if ( options.colorSpace !== undefined ) values.colorSpace = options.colorSpace;
		if ( options.flipY !== undefined ) values.flipY = options.flipY;
		if ( options.generateMipmaps !== undefined ) values.generateMipmaps = options.generateMipmaps;
		if ( options.internalFormat !== undefined ) values.internalFormat = options.internalFormat;

		for ( let i = 0; i < this.textures.length; i ++ ) {

			const texture = this.textures[ i ];
			texture.setValues( values );

		}

	}

	/**
	 * The texture representing the default color attachment.
	 *
	 * @type {Texture}
	 */
	get texture() {

		return this.textures[ 0 ];

	}

	set texture( value ) {

		this.textures[ 0 ] = value;

	}

	set depthTexture( current ) {

		if ( this._depthTexture !== null ) this._depthTexture.renderTarget = null;
		if ( current !== null ) current.renderTarget = this;

		this._depthTexture = current;

	}

	/**
	 * Instead of saving the depth in a renderbuffer, a texture
	 * can be used instead which is useful for further processing
	 * e.g. in context of post-processing.
	 *
	 * @type {?DepthTexture}
	 * @default null
	 */
	get depthTexture() {

		return this._depthTexture;

	}

	/**
	 * Sets the size of this render target.
	 *
	 * @param {number} width - The width.
	 * @param {number} height - The height.
	 * @param {number} [depth=1] - The depth.
	 */
	setSize( width, height, depth = 1 ) {

		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			this.width = width;
			this.height = height;
			this.depth = depth;

			for ( let i = 0, il = this.textures.length; i < il; i ++ ) {

				this.textures[ i ].image.width = width;
				this.textures[ i ].image.height = height;
				this.textures[ i ].image.depth = depth;

				if ( this.textures[ i ].isData3DTexture !== true ) { // Fix for #31693

					// TODO: Reconsider setting isArrayTexture flag here and in the ctor of Texture.
					// Maybe a method `isArrayTexture()` or just a getter could replace a flag since
					// both are evaluated on each call?

					this.textures[ i ].isArrayTexture = this.textures[ i ].image.depth > 1;

				}

			}

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	}

	/**
	 * Returns a new render target with copied values from this instance.
	 *
	 * @return {RenderTarget} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Copies the settings of the given render target. This is a structural copy so
	 * no resources are shared between render targets after the copy. That includes
	 * all MRT textures and the depth texture.
	 *
	 * @param {RenderTarget} source - The render target to copy.
	 * @return {RenderTarget} A reference to this instance.
	 */
	copy( source ) {

		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;

		this.scissor.copy( source.scissor );
		this.scissorTest = source.scissorTest;

		this.viewport.copy( source.viewport );

		this.textures.length = 0;

		for ( let i = 0, il = source.textures.length; i < il; i ++ ) {

			this.textures[ i ] = source.textures[ i ].clone();
			this.textures[ i ].isRenderTargetTexture = true;
			this.textures[ i ].renderTarget = this;

			// ensure image object is not shared, see #20328

			const image = Object.assign( {}, source.textures[ i ].image );
			this.textures[ i ].source = new Source( image );

		}

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;

		this.resolveDepthBuffer = source.resolveDepthBuffer;
		this.resolveStencilBuffer = source.resolveStencilBuffer;

		if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

		this.samples = source.samples;

		return this;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 *
	 * @fires RenderTarget#dispose
	 */
	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

/**
 * A render target used in context of {@link WebGLRenderer}.
 *
 * @augments RenderTarget
 */
class WebGLRenderTarget extends RenderTarget {

	/**
	 * Constructs a new 3D render target.
	 *
	 * @param {number} [width=1] - The width of the render target.
	 * @param {number} [height=1] - The height of the render target.
	 * @param {RenderTarget~Options} [options] - The configuration object.
	 */
	constructor( width = 1, height = 1, options = {} ) {

		super( width, height, options );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isWebGLRenderTarget = true;

	}

}

/**
 * Creates an array of textures directly from raw buffer data.
 *
 * @augments Texture
 */
class DataArrayTexture extends Texture {

	/**
	 * Constructs a new data array texture.
	 *
	 * @param {?TypedArray} [data=null] - The buffer data.
	 * @param {number} [width=1] - The width of the texture.
	 * @param {number} [height=1] - The height of the texture.
	 * @param {number} [depth=1] - The depth of the texture.
	 */
	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		super( null );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isDataArrayTexture = true;

		/**
		 * The image definition of a data texture.
		 *
		 * @type {{data:TypedArray,width:number,height:number,depth:number}}
		 */
		this.image = { data, width, height, depth };

		/**
		 * How the texture is sampled when a texel covers more than one pixel.
		 *
		 * Overwritten and set to `NearestFilter` by default.
		 *
		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		 * @default NearestFilter
		 */
		this.magFilter = NearestFilter;

		/**
		 * How the texture is sampled when a texel covers less than one pixel.
		 *
		 * Overwritten and set to `NearestFilter` by default.
		 *
		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		 * @default NearestFilter
		 */
		this.minFilter = NearestFilter;

		/**
		 * This defines how the texture is wrapped in the depth and corresponds to
		 * *W* in UVW mapping.
		 *
		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
		 * @default ClampToEdgeWrapping
		 */
		this.wrapR = ClampToEdgeWrapping;

		/**
		 * Whether to generate mipmaps (if possible) for a texture.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.generateMipmaps = false;

		/**
		 * If set to `true`, the texture is flipped along the vertical axis when
		 * uploaded to the GPU.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flipY = false;

		/**
		 * Specifies the alignment requirements for the start of each pixel row in memory.
		 *
		 * Overwritten and set to `1` by default.
		 *
		 * @type {boolean}
		 * @default 1
		 */
		this.unpackAlignment = 1;

		/**
		 * A set of all layers which need to be updated in the texture.
		 *
		 * @type {Set<number>}
		 */
		this.layerUpdates = new Set();

	}

	/**
	 * Describes that a specific layer of the texture needs to be updated.
	 * Normally when {@link Texture#needsUpdate} is set to `true`, the
	 * entire data texture array is sent to the GPU. Marking specific
	 * layers will only transmit subsets of all mipmaps associated with a
	 * specific depth in the array which is often much more performant.
	 *
	 * @param {number} layerIndex - The layer index that should be updated.
	 */
	addLayerUpdate( layerIndex ) {

		this.layerUpdates.add( layerIndex );

	}

	/**
	 * Resets the layer updates registry.
	 */
	clearLayerUpdates() {

		this.layerUpdates.clear();

	}

}

/**
 * Creates a three-dimensional texture from raw data, with parameters to
 * divide it into width, height, and depth.
 *
 * @augments Texture
 */
class Data3DTexture extends Texture {

	/**
	 * Constructs a new data array texture.
	 *
	 * @param {?TypedArray} [data=null] - The buffer data.
	 * @param {number} [width=1] - The width of the texture.
	 * @param {number} [height=1] - The height of the texture.
	 * @param {number} [depth=1] - The depth of the texture.
	 */
	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in Data3DTexture directly.
		//
		//	const texture = new THREE.Data3DTexture( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		super( null );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isData3DTexture = true;

		/**
		 * The image definition of a data texture.
		 *
		 * @type {{data:TypedArray,width:number,height:number,depth:number}}
		 */
		this.image = { data, width, height, depth };

		/**
		 * How the texture is sampled when a texel covers more than one pixel.
		 *
		 * Overwritten and set to `NearestFilter` by default.
		 *
		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		 * @default NearestFilter
		 */
		this.magFilter = NearestFilter;

		/**
		 * How the texture is sampled when a texel covers less than one pixel.
		 *
		 * Overwritten and set to `NearestFilter` by default.
		 *
		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
		 * @default NearestFilter
		 */
		this.minFilter = NearestFilter;

		/**
		 * This defines how the texture is wrapped in the depth and corresponds to
		 * *W* in UVW mapping.
		 *
		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
		 * @default ClampToEdgeWrapping
		 */
		this.wrapR = ClampToEdgeWrapping;

		/**
		 * Whether to generate mipmaps (if possible) for a texture.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.generateMipmaps = false;

		/**
		 * If set to `true`, the texture is flipped along the vertical axis when
		 * uploaded to the GPU.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flipY = false;

		/**
		 * Specifies the alignment requirements for the start of each pixel row in memory.
		 *
		 * Overwritten and set to `1` by default.
		 *
		 * @type {boolean}
		 * @default 1
		 */
		this.unpackAlignment = 1;

	}

}

/**
 * Represents an axis-aligned bounding box (AABB) in 3D space.
 */
class Box3 {

	/**
	 * Constructs a new bounding box.
	 *
	 * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
	 * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
	 */
	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isBox3 = true;

		/**
		 * The lower boundary of the box.
		 *
		 * @type {Vector3}
		 */
		this.min = min;

		/**
		 * The upper boundary of the box.
		 *
		 * @type {Vector3}
		 */
		this.max = max;

	}

	/**
	 * Sets the lower and upper boundaries of this box.
	 * Please note that this method only copies the values from the given objects.
	 *
	 * @param {Vector3} min - The lower boundary of the box.
	 * @param {Vector3} max - The upper boundary of the box.
	 * @return {Box3} A reference to this bounding box.
	 */
	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	/**
	 * Sets the upper and lower bounds of this box so it encloses the position data
	 * in the given array.
	 *
	 * @param {Array<number>} array - An array holding 3D position data.
	 * @return {Box3} A reference to this bounding box.
	 */
	setFromArray( array ) {

		this.makeEmpty();

		for ( let i = 0, il = array.length; i < il; i += 3 ) {

			this.expandByPoint( _vector$b.fromArray( array, i ) );

		}

		return this;

	}

	/**
	 * Sets the upper and lower bounds of this box so it encloses the position data
	 * in the given buffer attribute.
	 *
	 * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
	 * @return {Box3} A reference to this bounding box.
	 */
	setFromBufferAttribute( attribute ) {

		this.makeEmpty();

		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

			this.expandByPoint( _vector$b.fromBufferAttribute( attribute, i ) );

		}

		return this;

	}

	/**
	 * Sets the upper and lower bounds of this box so it encloses the position data
	 * in the given array.
	 *
	 * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
	 * @return {Box3} A reference to this bounding box.
	 */
	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	/**
	 * Centers this box on the given center vector and sets this box's width, height and
	 * depth to the given size values.
	 *
	 * @param {Vector3} center - The center of the box.
	 * @param {Vector3} size - The x, y and z dimensions of the box.
	 * @return {Box3} A reference to this bounding box.
	 */
	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	/**
	 * Computes the world-axis-aligned bounding box for the given 3D object
	 * (including its children), accounting for the object's, and children's,
	 * world transforms. The function may result in a larger box than strictly necessary.
	 *
	 * @param {Object3D} object - The 3D object to compute the bounding box for.
	 * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
	 * world-axis-aligned bounding box at the expense of more computation.
	 * @return {Box3} A reference to this bounding box.
	 */
	setFromObject( object, precise = false ) {

		this.makeEmpty();

		return this.expandByObject( object, precise );

	}

	/**
	 * Returns a new box with copied values from this instance.
	 *
	 * @return {Box3} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Copies the values of the given box to this instance.
	 *
	 * @param {Box3} box - The box to copy.
	 * @return {Box3} A reference to this bounding box.
	 */
	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	/**
	 * Makes this box empty which means in encloses a zero space in 3D.
	 *
	 * @return {Box3} A reference to this bounding box.
	 */
	makeEmpty() {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	}

	/**
	 * Returns true if this box includes zero points within its bounds.
	 * Note that a box with equal lower and upper bounds still includes one
	 * point, the one both bounds share.
	 *
	 * @return {boolean} Whether this box is empty or not.
	 */
	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	}

	/**
	 * Returns the center point of this box.
	 *
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The center point.
	 */
	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	/**
	 * Returns the dimensions of this box.
	 *
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The size.
	 */
	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	}

	/**
	 * Expands the boundaries of this box to include the given point.
	 *
	 * @param {Vector3} point - The point that should be included by the bounding box.
	 * @return {Box3} A reference to this bounding box.
	 */
	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	/**
	 * Expands this box equilaterally by the given vector. The width of this
	 * box will be expanded by the x component of the vector in both
	 * directions. The height of this box will be expanded by the y component of
	 * the vector in both directions. The depth of this box will be
	 * expanded by the z component of the vector in both directions.
	 *
	 * @param {Vector3} vector - The vector that should expand the bounding box.
	 * @return {Box3} A reference to this bounding box.
	 */
	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	/**
	 * Expands each dimension of the box by the given scalar. If negative, the
	 * dimensions of the box will be contracted.
	 *
	 * @param {number} scalar - The scalar value that should expand the bounding box.
	 * @return {Box3} A reference to this bounding box.
	 */
	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	/**
	 * Expands the boundaries of this box to include the given 3D object and
	 * its children, accounting for the object's, and children's, world
	 * transforms. The function may result in a larger box than strictly
	 * necessary (unless the precise parameter is set to true).
	 *
	 * @param {Object3D} object - The 3D object that should expand the bounding box.
	 * @param {boolean} precise - If set to `true`, the method expands the bounding box
	 * as little as necessary at the expense of more computation.
	 * @return {Box3} A reference to this bounding box.
	 */
	expandByObject( object, precise = false ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		const geometry = object.geometry;

		if ( geometry !== undefined ) {

			const positionAttribute = geometry.getAttribute( 'position' );

			// precise AABB computation based on vertex data requires at least a position attribute.
			// instancing isn't supported so far and uses the normal (conservative) code path.

			if ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {

				for ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {

					if ( object.isMesh === true ) {

						object.getVertexPosition( i, _vector$b );

					} else {

						_vector$b.fromBufferAttribute( positionAttribute, i );

					}

					_vector$b.applyMatrix4( object.matrixWorld );
					this.expandByPoint( _vector$b );

				}

			} else {

				if ( object.boundingBox !== undefined ) {

					// object-level bounding box

					if ( object.boundingBox === null ) {

						object.computeBoundingBox();

					}

					_box$4.copy( object.boundingBox );


				} else {

					// geometry-level bounding box

					if ( geometry.boundingBox === null ) {

						geometry.computeBoundingBox();

					}

					_box$4.copy( geometry.boundingBox );

				}

				_box$4.applyMatrix4( object.matrixWorld );

				this.union( _box$4 );

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ], precise );

		}

		return this;

	}

	/**
	 * Returns `true` if the given point lies within or on the boundaries of this box.
	 *
	 * @param {Vector3} point - The point to test.
	 * @return {boolean} Whether the bounding box contains the given point or not.
	 */
	containsPoint( point ) {

		return point.x >= this.min.x && point.x <= this.max.x &&
			point.y >= this.min.y && point.y <= this.max.y &&
			point.z >= this.min.z && point.z <= this.max.z;

	}

	/**
	 * Returns `true` if this bounding box includes the entirety of the given bounding box.
	 * If this box and the given one are identical, this function also returns `true`.
	 *
	 * @param {Box3} box - The bounding box to test.
	 * @return {boolean} Whether the bounding box contains the given bounding box or not.
	 */
	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	}

	/**
	 * Returns a point as a proportion of this box's width, height and depth.
	 *
	 * @param {Vector3} point - A point in 3D space.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} A point as a proportion of this box's width, height and depth.
	 */
	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	}

	/**
	 * Returns `true` if the given bounding box intersects with this bounding box.
	 *
	 * @param {Box3} box - The bounding box to test.
	 * @return {boolean} Whether the given bounding box intersects with this bounding box.
	 */
	intersectsBox( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x >= this.min.x && box.min.x <= this.max.x &&
			box.max.y >= this.min.y && box.min.y <= this.max.y &&
			box.max.z >= this.min.z && box.min.z <= this.max.z;

	}

	/**
	 * Returns `true` if the given bounding sphere intersects with this bounding box.
	 *
	 * @param {Sphere} sphere - The bounding sphere to test.
	 * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
	 */
	intersectsSphere( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$b );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	/**
	 * Returns `true` if the given plane intersects with this bounding box.
	 *
	 * @param {Plane} plane - The plane to test.
	 * @return {boolean} Whether the given plane intersects with this bounding box.
	 */
	intersectsPlane( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	}

	/**
	 * Returns `true` if the given triangle intersects with this bounding box.
	 *
	 * @param {Triangle} triangle - The triangle to test.
	 * @return {boolean} Whether the given triangle intersects with this bounding box.
	 */
	intersectsTriangle( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0$2.subVectors( triangle.a, _center );
		_v1$7.subVectors( triangle.b, _center );
		_v2$4.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1$7, _v0$2 );
		_f1.subVectors( _v2$4, _v1$7 );
		_f2.subVectors( _v0$2, _v2$4 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );

	}

	/**
	 * Clamps the given point within the bounds of this box.
	 *
	 * @param {Vector3} point - The point to clamp.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The clamped point.
	 */
	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	/**
	 * Returns the euclidean distance from any edge of this box to the specified point. If
	 * the given point lies inside of this box, the distance will be `0`.
	 *
	 * @param {Vector3} point - The point to compute the distance to.
	 * @return {number} The euclidean distance.
	 */
	distanceToPoint( point ) {

		return this.clampPoint( point, _vector$b ).distanceTo( point );

	}

	/**
	 * Returns a bounding sphere that encloses this bounding box.
	 *
	 * @param {Sphere} target - The target sphere that is used to store the method's result.
	 * @return {Sphere} The bounding sphere that encloses this bounding box.
	 */
	getBoundingSphere( target ) {

		if ( this.isEmpty() ) {

			target.makeEmpty();

		} else {

			this.getCenter( target.center );

			target.radius = this.getSize( _vector$b ).length() * 0.5;

		}

		return target;

	}

	/**
	 * Computes the intersection of this bounding box and the given one, setting the upper
	 * bound of this box to the lesser of the two boxes' upper bounds and the
	 * lower bound of this box to the greater of the two boxes' lower bounds. If
	 * there's no overlap, makes this box empty.
	 *
	 * @param {Box3} box - The bounding box to intersect with.
	 * @return {Box3} A reference to this bounding box.
	 */
	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	/**
	 * Computes the union of this box and another and the given one, setting the upper
	 * bound of this box to the greater of the two boxes' upper bounds and the
	 * lower bound of this box to the lesser of the two boxes' lower bounds.
	 *
	 * @param {Box3} box - The bounding box that will be unioned with this instance.
	 * @return {Box3} A reference to this bounding box.
	 */
	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	/**
	 * Transforms this bounding box by the given 4x4 transformation matrix.
	 *
	 * @param {Matrix4} matrix - The transformation matrix.
	 * @return {Box3} A reference to this bounding box.
	 */
	applyMatrix4( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	}

	/**
	 * Adds the given offset to both the upper and lower bounds of this bounding box,
	 * effectively moving it in 3D space.
	 *
	 * @param {Vector3} offset - The offset that should be used to translate the bounding box.
	 * @return {Box3} A reference to this bounding box.
	 */
	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	/**
	 * Returns `true` if this bounding box is equal with the given one.
	 *
	 * @param {Box3} box - The box to test for equality.
	 * @return {boolean} Whether this bounding box is equal with the given one.
	 */
	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

	/**
	 * Returns a serialized structure of the bounding box.
	 *
	 * @return {Object} Serialized structure with fields representing the object state.
	 */
	toJSON() {

		return {
			min: this.min.toArray(),
			max: this.max.toArray()
		};

	}

	/**
	 * Returns a serialized structure of the bounding box.
	 *
	 * @param {Object} json - The serialized json to set the box from.
	 * @return {Box3} A reference to this bounding box.
	 */
	fromJSON( json ) {

		this.min.fromArray( json.min );
		this.max.fromArray( json.max );
		return this;

	}

}

const _points = [
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3()
];

const _vector$b = /*@__PURE__*/ new Vector3();

const _box$4 = /*@__PURE__*/ new Box3();

// triangle centered vertices

const _v0$2 = /*@__PURE__*/ new Vector3();
const _v1$7 = /*@__PURE__*/ new Vector3();
const _v2$4 = /*@__PURE__*/ new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/ new Vector3();
const _f1 = /*@__PURE__*/ new Vector3();
const _f2 = /*@__PURE__*/ new Vector3();

const _center = /*@__PURE__*/ new Vector3();
const _extents = /*@__PURE__*/ new Vector3();
const _triangleNormal = /*@__PURE__*/ new Vector3();
const _testAxis = /*@__PURE__*/ new Vector3();

function satForAxes( axes, v0, v1, v2, extents ) {

	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the separating axis
		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the separating axis
		const p0 = v0.dot( _testAxis );
		const p1 = v1.dot( _testAxis );
		const p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is separating and we can exit
			return false;

		}

	}

	return true;

}

const _box$3 = /*@__PURE__*/ new Box3();
const _v1$6 = /*@__PURE__*/ new Vector3();
const _v2$3 = /*@__PURE__*/ new Vector3();

/**
 * An analytical 3D sphere defined by a center and radius. This class is mainly
 * used as a Bounding Sphere for 3D objects.
 */
class Sphere {

	/**
	 * Constructs a new sphere.
	 *
	 * @param {Vector3} [center=(0,0,0)] - The center of the sphere
	 * @param {number} [radius=-1] - The radius of the sphere.
	 */
	constructor( center = new Vector3(), radius = -1 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isSphere = true;

		/**
		 * The center of the sphere
		 *
		 * @type {Vector3}
		 */
		this.center = center;

		/**
		 * The radius of the sphere.
		 *
		 * @type {number}
		 */
		this.radius = radius;

	}

	/**
	 * Sets the sphere's components by copying the given values.
	 *
	 * @param {Vector3} center - The center.
	 * @param {number} radius - The radius.
	 * @return {Sphere} A reference to this sphere.
	 */
	set( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	}

	/**
	 * Computes the minimum bounding sphere for list of points.
	 * If the optional center point is given, it is used as the sphere's
	 * center. Otherwise, the center of the axis-aligned bounding box
	 * encompassing the points is calculated.
	 *
	 * @param {Array<Vector3>} points - A list of points in 3D space.
	 * @param {Vector3} [optionalCenter] - The center of the sphere.
	 * @return {Sphere} A reference to this sphere.
	 */
	setFromPoints( points, optionalCenter ) {

		const center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$3.setFromPoints( points ).getCenter( center );

		}

		let maxRadiusSq = 0;

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	}

	/**
	 * Copies the values of the given sphere to this instance.
	 *
	 * @param {Sphere} sphere - The sphere to copy.
	 * @return {Sphere} A reference to this sphere.
	 */
	copy( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	}

	/**
	 * Returns `true` if the sphere is empty (the radius set to a negative number).
	 *
	 * Spheres with a radius of `0` contain only their center point and are not
	 * considered to be empty.
	 *
	 * @return {boolean} Whether this sphere is empty or not.
	 */
	isEmpty() {

		return ( this.radius < 0 );

	}

	/**
	 * Makes this sphere empty which means in encloses a zero space in 3D.
	 *
	 * @return {Sphere} A reference to this sphere.
	 */
	makeEmpty() {

		this.center.set( 0, 0, 0 );
		this.radius = -1;

		return this;

	}

	/**
	 * Returns `true` if this sphere contains the given point inclusive of
	 * the surface of the sphere.
	 *
	 * @param {Vector3} point - The point to check.
	 * @return {boolean} Whether this sphere contains the given point or not.
	 */
	containsPoint( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	}

	/**
	 * Returns the closest distance from the boundary of the sphere to the
	 * given point. If the sphere contains the point, the distance will
	 * be negative.
	 *
	 * @param {Vector3} point - The point to compute the distance to.
	 * @return {number} The distance to the point.
	 */
	distanceToPoint( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	}

	/**
	 * Returns `true` if this sphere intersects with the given one.
	 *
	 * @param {Sphere} sphere - The sphere to test.
	 * @return {boolean} Whether this sphere intersects with the given one or not.
	 */
	intersectsSphere( sphere ) {

		const radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	}

	/**
	 * Returns `true` if this sphere intersects with the given box.
	 *
	 * @param {Box3} box - The box to test.
	 * @return {boolean} Whether this sphere intersects with the given box or not.
	 */
	intersectsBox( box ) {

		return box.intersectsSphere( this );

	}

	/**
	 * Returns `true` if this sphere intersects with the given plane.
	 *
	 * @param {Plane} plane - The plane to test.
	 * @return {boolean} Whether this sphere intersects with the given plane or not.
	 */
	intersectsPlane( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	}

	/**
	 * Clamps a point within the sphere. If the point is outside the sphere, it
	 * will clamp it to the closest point on the edge of the sphere. Points
	 * already inside the sphere will not be affected.
	 *
	 * @param {Vector3} point - The plane to clamp.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The clamped point.
	 */
	clampPoint( point, target ) {

		const deltaLengthSq = this.center.distanceToSquared( point );

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	}

	/**
	 * Returns a bounding box that encloses this sphere.
	 *
	 * @param {Box3} target - The target box that is used to store the method's result.
	 * @return {Box3} The bounding box that encloses this sphere.
	 */
	getBoundingBox( target ) {

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	}

	/**
	 * Transforms this sphere with the given 4x4 transformation matrix.
	 *
	 * @param {Matrix4} matrix - The transformation matrix.
	 * @return {Sphere} A reference to this sphere.
	 */
	applyMatrix4( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	}

	/**
	 * Translates the sphere's center by the given offset.
	 *
	 * @param {Vector3} offset - The offset.
	 * @return {Sphere} A reference to this sphere.
	 */
	translate( offset ) {

		this.center.add( offset );

		return this;

	}

	/**
	 * Expands the boundaries of this sphere to include the given point.
	 *
	 * @param {Vector3} point - The point to include.
	 * @return {Sphere} A reference to this sphere.
	 */
	expandByPoint( point ) {

		if ( this.isEmpty() ) {

			this.center.copy( point );

			this.radius = 0;

			return this;

		}

		_v1$6.subVectors( point, this.center );

		const lengthSq = _v1$6.lengthSq();

		if ( lengthSq > ( this.radius * this.radius ) ) {

			// calculate the minimal sphere

			const length = Math.sqrt( lengthSq );

			const delta = ( length - this.radius ) * 0.5;

			this.center.addScaledVector( _v1$6, delta / length );

			this.radius += delta;

		}

		return this;

	}

	/**
	 * Expands this sphere to enclose both the original sphere and the given sphere.
	 *
	 * @param {Sphere} sphere - The sphere to include.
	 * @return {Sphere} A reference to this sphere.
	 */
	union( sphere ) {

		if ( sphere.isEmpty() ) {

			return this;

		}

		if ( this.isEmpty() ) {

			this.copy( sphere );

			return this;

		}

		if ( this.center.equals( sphere.center ) === true ) {

			 this.radius = Math.max( this.radius, sphere.radius );

		} else {

			_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );

			this.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );

			this.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );

		}

		return this;

	}

	/**
	 * Returns `true` if this sphere is equal with the given one.
	 *
	 * @param {Sphere} sphere - The sphere to test for equality.
	 * @return {boolean} Whether this bounding sphere is equal with the given one.
	 */
	equals( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

	/**
	 * Returns a new sphere with copied values from this instance.
	 *
	 * @return {Sphere} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Returns a serialized structure of the bounding sphere.
	 *
	 * @return {Object} Serialized structure with fields representing the object state.
	 */
	toJSON() {

		return {
			radius: this.radius,
			center: this.center.toArray()
		};

	}

	/**
	 * Returns a serialized structure of the bounding sphere.
	 *
	 * @param {Object} json - The serialized json to set the sphere from.
	 * @return {Box3} A reference to this bounding sphere.
	 */
	fromJSON( json ) {

		this.radius = json.radius;
		this.center.fromArray( json.center );
		return this;

	}

}

const _vector$a = /*@__PURE__*/ new Vector3();
const _segCenter = /*@__PURE__*/ new Vector3();
const _segDir = /*@__PURE__*/ new Vector3();
const _diff = /*@__PURE__*/ new Vector3();

const _edge1 = /*@__PURE__*/ new Vector3();
const _edge2 = /*@__PURE__*/ new Vector3();
const _normal$1 = /*@__PURE__*/ new Vector3();

/**
 * A ray that emits from an origin in a certain direction. The class is used by
 * {@link Raycaster} to assist with raycasting. Raycasting is used for
 * mouse picking (working out what objects in the 3D space the mouse is over)
 * amongst other things.
 */
class Ray {

	/**
	 * Constructs a new ray.
	 *
	 * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
	 * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
	 */
	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, -1 ) ) {

		/**
		 * The origin of the ray.
		 *
		 * @type {Vector3}
		 */
		this.origin = origin;

		/**
		 * The (normalized) direction of the ray.
		 *
		 * @type {Vector3}
		 */
		this.direction = direction;

	}

	/**
	 * Sets the ray's components by copying the given values.
	 *
	 * @param {Vector3} origin - The origin.
	 * @param {Vector3} direction - The direction.
	 * @return {Ray} A reference to this ray.
	 */
	set( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	}

	/**
	 * Copies the values of the given ray to this instance.
	 *
	 * @param {Ray} ray - The ray to copy.
	 * @return {Ray} A reference to this ray.
	 */
	copy( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	}

	/**
	 * Returns a vector that is located at a given distance along this ray.
	 *
	 * @param {number} t - The distance along the ray to retrieve a position for.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} A position on the ray.
	 */
	at( t, target ) {

		return target.copy( this.origin ).addScaledVector( this.direction, t );

	}

	/**
	 * Adjusts the direction of the ray to point at the given vector in world space.
	 *
	 * @param {Vector3} v - The target position.
	 * @return {Ray} A reference to this ray.
	 */
	lookAt( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	}

	/**
	 * Shift the origin of this ray along its direction by the given distance.
	 *
	 * @param {number} t - The distance along the ray to interpolate.
	 * @return {Ray} A reference to this ray.
	 */
	recast( t ) {

		this.origin.copy( this.at( t, _vector$a ) );

		return this;

	}

	/**
	 * Returns the point along this ray that is closest to the given point.
	 *
	 * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The closest point on this ray.
	 */
	closestPointToPoint( point, target ) {

		target.subVectors( point, this.origin );

		const directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.origin ).addScaledVector( this.direction, directionDistance );

	}

	/**
	 * Returns the distance of the closest approach between this ray and the given point.
	 *
	 * @param {Vector3} point - A point in 3D space to compute the distance to.
	 * @return {number} The distance.
	 */
	distanceToPoint( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	}

	/**
	 * Returns the squared distance of the closest approach between this ray and the given point.
	 *
	 * @param {Vector3} point - A point in 3D space to compute the distance to.
	 * @return {number} The squared distance.
	 */
	distanceSqToPoint( point ) {

		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );

		return _vector$a.distanceToSquared( point );

	}

	/**
	 * Returns the squared distance between this ray and the given line segment.
	 *
	 * @param {Vector3} v0 - The start point of the line segment.
	 * @param {Vector3} v1 - The end point of the line segment.
	 * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
	 * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
	 * @return {number} The squared distance.
	 */
	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		const segExtent = v0.distanceTo( v1 ) * 0.5;
		const a01 = - this.direction.dot( _segDir );
		const b0 = _diff.dot( this.direction );
		const b1 = - _diff.dot( _segDir );
		const c = _diff.lengthSq();
		const det = Math.abs( 1 - a01 * a01 );
		let s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );

		}

		return sqrDist;

	}

	/**
	 * Intersects this ray with the given sphere, returning the intersection
	 * point or `null` if there is no intersection.
	 *
	 * @param {Sphere} sphere - The sphere to intersect.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The intersection point.
	 */
	intersectSphere( sphere, target ) {

		_vector$a.subVectors( sphere.center, this.origin );
		const tca = _vector$a.dot( this.direction );
		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		const thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if t1 is behind the ray - if so, return null
		if ( t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	}

	/**
	 * Returns `true` if this ray intersects with the given sphere.
	 *
	 * @param {Sphere} sphere - The sphere to intersect.
	 * @return {boolean} Whether this ray intersects with the given sphere or not.
	 */
	intersectsSphere( sphere ) {

		if ( sphere.radius < 0 ) return false; // handle empty spheres, see #31187

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	/**
	 * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
	 * does not intersect with the plane.
	 *
	 * @param {Plane} plane - The plane to compute the distance to.
	 * @return {?number} Whether this ray intersects with the given sphere or not.
	 */
	distanceToPlane( plane ) {

		const denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	}

	/**
	 * Intersects this ray with the given plane, returning the intersection
	 * point or `null` if there is no intersection.
	 *
	 * @param {Plane} plane - The plane to intersect.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The intersection point.
	 */
	intersectPlane( plane, target ) {

		const t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	}

	/**
	 * Returns `true` if this ray intersects with the given plane.
	 *
	 * @param {Plane} plane - The plane to intersect.
	 * @return {boolean} Whether this ray intersects with the given plane or not.
	 */
	intersectsPlane( plane ) {

		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		const denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	}

	/**
	 * Intersects this ray with the given bounding box, returning the intersection
	 * point or `null` if there is no intersection.
	 *
	 * @param {Box3} box - The box to intersect.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The intersection point.
	 */
	intersectBox( box, target ) {

		let tmin, tmax, tymin, tymax, tzmin, tzmax;

		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		const origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		if ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;

		if ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	}

	/**
	 * Returns `true` if this ray intersects with the given box.
	 *
	 * @param {Box3} box - The box to intersect.
	 * @return {boolean} Whether this ray intersects with the given box or not.
	 */
	intersectsBox( box ) {

		return this.intersectBox( box, _vector$a ) !== null;

	}

	/**
	 * Intersects this ray with the given triangle, returning the intersection
	 * point or `null` if there is no intersection.
	 *
	 * @param {Vector3} a - The first vertex of the triangle.
	 * @param {Vector3} b - The second vertex of the triangle.
	 * @param {Vector3} c - The third vertex of the triangle.
	 * @param {boolean} backfaceCulling - Whether to use backface culling or not.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The intersection point.
	 */
	intersectTriangle( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal$1.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot( _normal$1 );
		let sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = -1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		const QdN = - sign * _diff.dot( _normal$1 );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	}

	/**
	 * Transforms this ray with the given 4x4 transformation matrix.
	 *
	 * @param {Matrix4} matrix4 - The transformation matrix.
	 * @return {Ray} A reference to this ray.
	 */
	applyMatrix4( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	}

	/**
	 * Returns `true` if this ray is equal with the given one.
	 *
	 * @param {Ray} ray - The ray to test for equality.
	 * @return {boolean} Whether this ray is equal with the given one.
	 */
	equals( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

	/**
	 * Returns a new ray with copied values from this instance.
	 *
	 * @return {Ray} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

}

/**
 * Represents a 4x4 matrix.
 *
 * The most common use of a 4x4 matrix in 3D computer graphics is as a transformation matrix.
 * For an introduction to transformation matrices as used in WebGL, check out [this tutorial](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices)
 *
 * This allows a 3D vector representing a point in 3D space to undergo
 * transformations such as translation, rotation, shear, scale, reflection,
 * orthogonal or perspective projection and so on, by being multiplied by the
 * matrix. This is known as `applying` the matrix to the vector.
 *
 * A Note on Row-Major and Column-Major Ordering:
 *
 * The constructor and {@link Matrix3#set} method take arguments in
 * [row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
 * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
 * This means that calling:
 * ```js
 * const m = new THREE.Matrix4();
 * m.set( 11, 12, 13, 14,
 *        21, 22, 23, 24,
 *        31, 32, 33, 34,
 *        41, 42, 43, 44 );
 * ```
 * will result in the elements array containing:
 * ```js
 * m.elements = [ 11, 21, 31, 41,
 *                12, 22, 32, 42,
 *                13, 23, 33, 43,
 *                14, 24, 34, 44 ];
 * ```
 * and internally all calculations are performed using column-major ordering.
 * However, as the actual ordering makes no difference mathematically and
 * most people are used to thinking about matrices in row-major order, the
 * three.js documentation shows matrices in row-major order. Just bear in
 * mind that if you are reading the source code, you'll have to take the
 * transpose of any matrices outlined here to make sense of the calculations.
 */
class Matrix4 {

	/**
	 * Constructs a new 4x4 matrix. The arguments are supposed to be
	 * in row-major order. If no arguments are provided, the constructor
	 * initializes the matrix as an identity matrix.
	 *
	 * @param {number} [n11] - 1-1 matrix element.
	 * @param {number} [n12] - 1-2 matrix element.
	 * @param {number} [n13] - 1-3 matrix element.
	 * @param {number} [n14] - 1-4 matrix element.
	 * @param {number} [n21] - 2-1 matrix element.
	 * @param {number} [n22] - 2-2 matrix element.
	 * @param {number} [n23] - 2-3 matrix element.
	 * @param {number} [n24] - 2-4 matrix element.
	 * @param {number} [n31] - 3-1 matrix element.
	 * @param {number} [n32] - 3-2 matrix element.
	 * @param {number} [n33] - 3-3 matrix element.
	 * @param {number} [n34] - 3-4 matrix element.
	 * @param {number} [n41] - 4-1 matrix element.
	 * @param {number} [n42] - 4-2 matrix element.
	 * @param {number} [n43] - 4-3 matrix element.
	 * @param {number} [n44] - 4-4 matrix element.
	 */
	constructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		Matrix4.prototype.isMatrix4 = true;

		/**
		 * A column-major list of matrix values.
		 *
		 * @type {Array<number>}
		 */
		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( n11 !== undefined ) {

			this.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );

		}

	}

	/**
	 * Sets the elements of the matrix.The arguments are supposed to be
	 * in row-major order.
	 *
	 * @param {number} [n11] - 1-1 matrix element.
	 * @param {number} [n12] - 1-2 matrix element.
	 * @param {number} [n13] - 1-3 matrix element.
	 * @param {number} [n14] - 1-4 matrix element.
	 * @param {number} [n21] - 2-1 matrix element.
	 * @param {number} [n22] - 2-2 matrix element.
	 * @param {number} [n23] - 2-3 matrix element.
	 * @param {number} [n24] - 2-4 matrix element.
	 * @param {number} [n31] - 3-1 matrix element.
	 * @param {number} [n32] - 3-2 matrix element.
	 * @param {number} [n33] - 3-3 matrix element.
	 * @param {number} [n34] - 3-4 matrix element.
	 * @param {number} [n41] - 4-1 matrix element.
	 * @param {number} [n42] - 4-2 matrix element.
	 * @param {number} [n43] - 4-3 matrix element.
	 * @param {number} [n44] - 4-4 matrix element.
	 * @return {Matrix4} A reference to this matrix.
	 */
	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	/**
	 * Sets this matrix to the 4x4 identity matrix.
	 *
	 * @return {Matrix4} A reference to this matrix.
	 */
	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Returns a matrix with copied values from this instance.
	 *
	 * @return {Matrix4} A clone of this instance.
	 */
	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	/**
	 * Copies the values of the given matrix to this instance.
	 *
	 * @param {Matrix4} m - The matrix to copy.
	 * @return {Matrix4} A reference to this matrix.
	 */
	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	/**
	 * Copies the translation component of the given matrix
	 * into this matrix's translation component.
	 *
	 * @param {Matrix4} m - The matrix to copy the translation component.
	 * @return {Matrix4} A reference to this matrix.
	 */
	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	/**
	 * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
	 *
	 * @param {Matrix3} m - The 3x3 matrix.
	 * @return {Matrix4} A reference to this matrix.
	 */
	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Extracts the basis of this matrix into the three axis vectors provided.
	 *
	 * @param {Vector3} xAxis - The basis's x axis.
	 * @param {Vector3} yAxis - The basis's y axis.
	 * @param {Vector3} zAxis - The basis's z axis.
	 * @return {Matrix4} A reference to this matrix.
	 */
	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	/**
	 * Sets the given basis vectors to this matrix.
	 *
	 * @param {Vector3} xAxis - The basis's x axis.
	 * @param {Vector3} yAxis - The basis's y axis.
	 * @param {Vector3} zAxis - The basis's z axis.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	/**
	 * Extracts the rotation component of the given matrix
	 * into this matrix's rotation component.
	 *
	 * Note: This method does not support reflection matrices.
	 *
	 * @param {Matrix4} m - The matrix.
	 * @return {Matrix4} A reference to this matrix.
	 */
	extractRotation( m ) {

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	/**
	 * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
	 * the rotation specified by the given Euler angles. The rest of
	 * the matrix is set to the identity. Depending on the {@link Euler#order},
	 * there are six possible outcomes. See [this page](https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix)
	 * for a complete list.
	 *
	 * @param {Euler} euler - The Euler angles.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeRotationFromEuler( euler ) {

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	/**
	 * Sets the rotation component of this matrix to the rotation specified by
	 * the given Quaternion as outlined [here](https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion)
	 * The rest of the matrix is set to the identity.
	 *
	 * @param {Quaternion} q - The Quaternion.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	/**
	 * Sets the rotation component of the transformation matrix, looking from `eye` towards
	 * `target`, and oriented by the up-direction.
	 *
	 * @param {Vector3} eye - The eye vector.
	 * @param {Vector3} target - The target vector.
	 * @param {Vector3} up - The up vector.
	 * @return {Matrix4} A reference to this matrix.
	 */
	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	/**
	 * Post-multiplies this matrix by the given 4x4 matrix.
	 *
	 * @param {Matrix4} m - The matrix to multiply with.
	 * @return {Matrix4} A reference to this matrix.
	 */
	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	/**
	 * Pre-multiplies this matrix by the given 4x4 matrix.
	 *
	 * @param {Matrix4} m - The matrix to multiply with.
	 * @return {Matrix4} A reference to this matrix.
	 */
	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	/**
	 * Multiples the given 4x4 matrices and stores the result
	 * in this matrix.
	 *
	 * @param {Matrix4} a - The first matrix.
	 * @param {Matrix4} b - The second matrix.
	 * @return {Matrix4} A reference to this matrix.
	 */
	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	/**
	 * Multiplies every component of the matrix by the given scalar.
	 *
	 * @param {number} s - The scalar.
	 * @return {Matrix4} A reference to this matrix.
	 */
	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	/**
	 * Computes and returns the determinant of this matrix.
	 *
	 * Based on the method outlined [here](http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html).
	 *
	 * @return {number} The determinant.
	 */
	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	/**
	 * Transposes this matrix in place.
	 *
	 * @return {Matrix4} A reference to this matrix.
	 */
	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	/**
	 * Sets the position component for this matrix from the given vector,
	 * without affecting the rest of the matrix.
	 *
	 * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
	 * @param {number} y - The y component of the vector.
	 * @param {number} z - The z component of the vector.
	 * @return {Matrix4} A reference to this matrix.
	 */
	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	/**
	 * Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
	 * You can not invert with a determinant of zero. If you attempt this, the method produces
	 * a zero matrix instead.
	 *
	 * @return {Matrix4} A reference to this matrix.
	 */
	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	/**
	 * Multiplies the columns of this matrix by the given vector.
	 *
	 * @param {Vector3} v - The scale vector.
	 * @return {Matrix4} A reference to this matrix.
	 */
	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	/**
	 * Gets the maximum scale value of the three axes.
	 *
	 * @return {number} The maximum scale.
	 */
	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	/**
	 * Sets this matrix as a translation transform from the given vector.
	 *
	 * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
	 * @param {number} y - The amount to translate in the Y axis.
	 * @param {number} z - The amount to translate in the z axis.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeTranslation( x, y, z ) {

		if ( x.isVector3 ) {

			this.set(

				1, 0, 0, x.x,
				0, 1, 0, x.y,
				0, 0, 1, x.z,
				0, 0, 0, 1

			);

		} else {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

		}

		return this;

	}

	/**
	 * Sets this matrix as a rotational transformation around the X axis by
	 * the given angle.
	 *
	 * @param {number} theta - The rotation in radians.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Sets this matrix as a rotational transformation around the Y axis by
	 * the given angle.
	 *
	 * @param {number} theta - The rotation in radians.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Sets this matrix as a rotational transformation around the Z axis by
	 * the given angle.
	 *
	 * @param {number} theta - The rotation in radians.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Sets this matrix as a rotational transformation around the given axis by
	 * the given angle.
	 *
	 * This is a somewhat controversial but mathematically sound alternative to
	 * rotating via Quaternions. See the discussion [here](https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199).
	 *
	 * @param {Vector3} axis - The normalized rotation axis.
	 * @param {number} angle - The rotation in radians.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Sets this matrix as a scale transformation.
	 *
	 * @param {number} x - The amount to scale in the X axis.
	 * @param {number} y - The amount to scale in the Y axis.
	 * @param {number} z - The amount to scale in the Z axis.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Sets this matrix as a shear transformation.
	 *
	 * @param {number} xy - The amount to shear X by Y.
	 * @param {number} xz - The amount to shear X by Z.
	 * @param {number} yx - The amount to shear Y by X.
	 * @param {number} yz - The amount to shear Y by Z.
	 * @param {number} zx - The amount to shear Z by X.
	 * @param {number} zy - The amount to shear Z by Y.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeShear( xy, xz, yx, yz, zx, zy ) {

		this.set(

			1, yx, zx, 0,
			xy, 1, zy, 0,
			xz, yz, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	/**
	 * Sets this matrix to the transformation composed of the given position,
	 * rotation (Quaternion) and scale.
	 *
	 * @param {Vector3} position - The position vector.
	 * @param {Quaternion} quaternion - The rotation as a Quaternion.
	 * @param {Vector3} scale - The scale vector.
	 * @return {Matrix4} A reference to this matrix.
	 */
	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	/**
	 * Decomposes this matrix into its position, rotation and scale components
	 * and provides the result in the given objects.
	 *
	 * Note: Not all matrices are decomposable in this way. For example, if an
	 * object has a non-uniformly scaled parent, then the object's world matrix
	 * may not be decomposable, and this method may not be appropriate.
	 *
	 * @param {Vector3} position - The position vector.
	 * @param {Quaternion} quaternion - The rotation as a Quaternion.
	 * @param {Vector3} scale - The scale vector.
	 * @return {Matrix4} A reference to this matrix.
	 */
	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1$2.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1$2.elements[ 0 ] *= invSX;
		_m1$2.elements[ 1 ] *= invSX;
		_m1$2.elements[ 2 ] *= invSX;

		_m1$2.elements[ 4 ] *= invSY;
		_m1$2.elements[ 5 ] *= invSY;
		_m1$2.elements[ 6 ] *= invSY;

		_m1$2.elements[ 8 ] *= invSZ;
		_m1$2.elements[ 9 ] *= invSZ;
		_m1$2.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1$2 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	/**
	 * Creates a perspective projection matrix. This is used internally by
	 * {@link PerspectiveCamera#updateProjectionMatrix}.

	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
	 * @param {number} near - The distance from the camera to the near plane.
	 * @param {number} far - The distance from the camera to the far plane.
	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false ) {

		const te = this.elements;

		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );

		let c, d;

		if ( reversedDepth ) {

			c = near / ( far - near );
			d = ( far * near ) / ( far - near );

		} else {

			if ( coordinateSystem === WebGLCoordinateSystem ) {

				c = - ( far + near ) / ( far - near );
				d = ( -2 * far * near ) / ( far - near );

			} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

				c = - far / ( far - near );
				d = ( - far * near ) / ( far - near );

			} else {

				throw new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );

			}

		}

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a; 	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b; 	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c; 	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = -1;	te[ 15 ] = 0;

		return this;

	}

	/**
	 * Creates a orthographic projection matrix. This is used internally by
	 * {@link OrthographicCamera#updateProjectionMatrix}.

	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
	 * @param {number} near - The distance from the camera to the near plane.
	 * @param {number} far - The distance from the camera to the far plane.
	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
	 * @return {Matrix4} A reference to this matrix.
	 */
	makeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false ) {

		const te = this.elements;

		const x = 2 / ( right - left );
		const y = 2 / ( top - bottom );

		const a = - ( right + left ) / ( right - left );
		const b = - ( top + bottom ) / ( top - bottom );

		let c, d;

		if ( reversedDepth ) {

			c = 1 / ( far - near );
			d = far / ( far - near );

		} else {

			if ( coordinateSystem === WebGLCoordinateSystem ) {

				c = -2 / ( far - near );
				d = - ( far + near ) / ( far - near );

			} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

				c = -1 / ( far - near );
				d = - near / ( far - near );

			} else {

				throw new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );

			}

		}

		te[ 0 ] = x;		te[ 4 ] = 0;		te[ 8 ] = 0; 		te[ 12 ] = a;
		te[ 1 ] = 0; 		te[ 5 ] = y;		te[ 9 ] = 0; 		te[ 13 ] = b;
		te[ 2 ] = 0; 		te[ 6 ] = 0;		te[ 10 ] = c;		te[ 14 ] = d;
		te[ 3 ] = 0; 		te[ 7 ] = 0;		te[ 11 ] = 0;		te[ 15 ] = 1;

		return this;

	}

	/**
	 * Returns `true` if this matrix is equal with the given one.
	 *
	 * @param {Matrix4} matrix - The matrix to test for equality.
	 * @return {boolean} Whether this matrix is equal with the given one.
	 */
	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	/**
	 * Sets the elements of the matrix from the given array.
	 *
	 * @param {Array<number>} array - The matrix elements in column-major order.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Matrix4} A reference to this matrix.
	 */
	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	/**
	 * Writes the elements of this matrix to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number>} The matrix elements in column-major order.
	 */
	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

const _v1$5 = /*@__PURE__*/ new Vector3();
const _m1$2 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();

const _matrix$2 = /*@__PURE__*/ new Matrix4();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();

/**
 * A class representing Euler angles.
 *
 * Euler angles describe a rotational transformation by rotating an object on
 * its various axes in specified amounts per axis, and a specified axis
 * order.
 *
 * Iterating through an instance will yield its components (x, y, z,
 * order) in the corresponding order.
 *
 * ```js
 * const a = new THREE.Euler( 0, 1, 1.57, 'XYZ' );
 * const b = new THREE.Vector3( 1, 0, 1 );
 * b.applyEuler(a);
 * ```
 */
class Euler {

	/**
	 * Constructs a new euler instance.
	 *
	 * @param {number} [x=0] - The angle of the x axis in radians.
	 * @param {number} [y=0] - The angle of the y axis in radians.
	 * @param {number} [z=0] - The angle of the z axis in radians.
	 * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
	 */
	constructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isEuler = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	/**
	 * The angle of the x axis in radians.
	 *
	 * @type {number}
	 * @default 0
	 */
	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	/**
	 * The angle of the y axis in radians.
	 *
	 * @type {number}
	 * @default 0
	 */
	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	/**
	 * The angle of the z axis in radians.
	 *
	 * @type {number}
	 * @default 0
	 */
	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	/**
	 * A string representing the order that the rotations are applied.
	 *
	 * @type {string}
	 * @default 'XYZ'
	 */
	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	/**
	 * Sets the Euler components.
	 *
	 * @param {number} x - The angle of the x axis in radians.
	 * @param {number} y - The angle of the y axis in radians.
	 * @param {number} z - The angle of the z axis in radians.
	 * @param {string} [order] - A string representing the order that the rotations are applied.
	 * @return {Euler} A reference to this Euler instance.
	 */
	set( x, y, z, order = this._order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

		this._onChangeCallback();

		return this;

	}

	/**
	 * Returns a new Euler instance with copied values from this instance.
	 *
	 * @return {Euler} A clone of this instance.
	 */
	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	/**
	 * Copies the values of the given Euler instance to this instance.
	 *
	 * @param {Euler} euler - The Euler instance to copy.
	 * @return {Euler} A reference to this Euler instance.
	 */
	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	/**
	 * Sets the angles of this Euler instance from a pure rotation matrix.
	 *
	 * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
	 * @param {string} [order] - A string representing the order that the rotations are applied.
	 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
	 * @return {Euler} A reference to this Euler instance.
	 */
	setFromRotationMatrix( m, order = this._order, update = true ) {

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, -1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, -1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, -1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, -1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, -1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, -1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				warn( 'Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	/**
	 * Sets the angles of this Euler instance from a normalized quaternion.
	 *
	 * @param {Quaternion} q - A normalized Quaternion.
	 * @param {string} [order] - A string representing the order that the rotations are applied.
	 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
	 * @return {Euler} A reference to this Euler instance.
	 */
	setFromQuaternion( q, order, update ) {

		_matrix$2.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix$2, order, update );

	}

	/**
	 * Sets the angles of this Euler instance from the given vector.
	 *
	 * @param {Vector3} v - The vector.
	 * @param {string} [order] - A string representing the order that the rotations are applied.
	 * @return {Euler} A reference to this Euler instance.
	 */
	setFromVector3( v, order = this._order ) {

		return this.set( v.x, v.y, v.z, order );

	}

	/**
	 * Resets the euler angle with a new order by creating a quaternion from this
	 * euler angle and then setting this euler angle with the quaternion and the
	 * new order.
	 *
	 * Warning: This discards revolution information.
	 *
	 * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
	 * @return {Euler} A reference to this Euler instance.
	 */
	reorder( newOrder ) {

		_quaternion$3.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$3, newOrder );

	}

	/**
	 * Returns `true` if this Euler instance is equal with the given one.
	 *
	 * @param {Euler} euler - The Euler instance to test for equality.
	 * @return {boolean} Whether this Euler instance is equal with the given one.
	 */
	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	/**
	 * Sets this Euler instance's components to values from the given array. The first three
	 * entries of the array are assign to the x,y and z components. An optional fourth entry
	 * defines the Euler order.
	 *
	 * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
	 * @return {Euler} A reference to this Euler instance.
	 */
	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	/**
	 * Writes the components of this Euler instance to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number,number,number,string>} The Euler components.
	 */
	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._order;

	}

}

/**
 * The default Euler angle order.
 *
 * @static
 * @type {string}
 * @default 'XYZ'
 */
Euler.DEFAULT_ORDER = 'XYZ';

/**
 * A layers object assigns an 3D object to 1 or more of 32
 * layers numbered `0` to `31` - internally the layers are stored as a
 * bit mask], and by default all 3D objects are a member of layer `0`.
 *
 * This can be used to control visibility - an object must share a layer with
 * a camera to be visible when that camera's view is
 * rendered.
 *
 * All classes that inherit from {@link Object3D} have an `layers` property which
 * is an instance of this class.
 */
class Layers {

	/**
	 * Constructs a new layers instance, with membership
	 * initially set to layer `0`.
	 */
	constructor() {

		/**
		 * A bit mask storing which of the 32 layers this layers object is currently
		 * a member of.
		 *
		 * @type {number}
		 */
		this.mask = 1 | 0;

	}

	/**
	 * Sets membership to the given layer, and remove membership all other layers.
	 *
	 * @param {number} layer - The layer to set.
	 */
	set( layer ) {

		this.mask = ( 1 << layer | 0 ) >>> 0;

	}

	/**
	 * Adds membership of the given layer.
	 *
	 * @param {number} layer - The layer to enable.
	 */
	enable( layer ) {

		this.mask |= 1 << layer | 0;

	}

	/**
	 * Adds membership to all layers.
	 */
	enableAll() {

		this.mask = 0xffffffff | 0;

	}

	/**
	 * Toggles the membership of the given layer.
	 *
	 * @param {number} layer - The layer to toggle.
	 */
	toggle( layer ) {

		this.mask ^= 1 << layer | 0;

	}

	/**
	 * Removes membership of the given layer.
	 *
	 * @param {number} layer - The layer to enable.
	 */
	disable( layer ) {

		this.mask &= ~ ( 1 << layer | 0 );

	}

	/**
	 * Removes the membership from all layers.
	 */
	disableAll() {

		this.mask = 0;

	}

	/**
	 * Returns `true` if this and the given layers object have at least one
	 * layer in common.
	 *
	 * @param {Layers} layers - The layers to test.
	 * @return {boolean } Whether this and the given layers object have at least one layer in common or not.
	 */
	test( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

	/**
	 * Returns `true` if the given layer is enabled.
	 *
	 * @param {number} layer - The layer to test.
	 * @return {boolean } Whether the given layer is enabled or not.
	 */
	isEnabled( layer ) {

		return ( this.mask & ( 1 << layer | 0 ) ) !== 0;

	}

}

let _object3DId = 0;

const _v1$4 = /*@__PURE__*/ new Vector3();
const _q1 = /*@__PURE__*/ new Quaternion();
const _m1$1$1 = /*@__PURE__*/ new Matrix4();
const _target = /*@__PURE__*/ new Vector3();

const _position$3 = /*@__PURE__*/ new Vector3();
const _scale$2 = /*@__PURE__*/ new Vector3();
const _quaternion$2 = /*@__PURE__*/ new Quaternion();

const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

/**
 * Fires when the object has been added to its parent object.
 *
 * @event Object3D#added
 * @type {Object}
 */
const _addedEvent = { type: 'added' };

/**
 * Fires when the object has been removed from its parent object.
 *
 * @event Object3D#removed
 * @type {Object}
 */
const _removedEvent = { type: 'removed' };

/**
 * Fires when a new child object has been added.
 *
 * @event Object3D#childadded
 * @type {Object}
 */
const _childaddedEvent = { type: 'childadded', child: null };

/**
 * Fires when a child object has been removed.
 *
 * @event Object3D#childremoved
 * @type {Object}
 */
const _childremovedEvent = { type: 'childremoved', child: null };

/**
 * This is the base class for most objects in three.js and provides a set of
 * properties and methods for manipulating objects in 3D space.
 *
 * @augments EventDispatcher
 */
class Object3D extends EventDispatcher {

	/**
	 * Constructs a new 3D object.
	 */
	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isObject3D = true;

		/**
		 * The ID of the 3D object.
		 *
		 * @name Object3D#id
		 * @type {number}
		 * @readonly
		 */
		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		/**
		 * The UUID of the 3D object.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.uuid = generateUUID();

		/**
		 * The name of the 3D object.
		 *
		 * @type {string}
		 */
		this.name = '';

		/**
		 * The type property is used for detecting the object type
		 * in context of serialization/deserialization.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.type = 'Object3D';

		/**
		 * A reference to the parent object.
		 *
		 * @type {?Object3D}
		 * @default null
		 */
		this.parent = null;

		/**
		 * An array holding the child 3D objects of this instance.
		 *
		 * @type {Array<Object3D>}
		 */
		this.children = [];

		/**
		 * Defines the `up` direction of the 3D object which influences
		 * the orientation via methods like {@link Object3D#lookAt}.
		 *
		 * The default values for all 3D objects is defined by `Object3D.DEFAULT_UP`.
		 *
		 * @type {Vector3}
		 */
		this.up = Object3D.DEFAULT_UP.clone();

		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation._onChange( onRotationChange );
		quaternion._onChange( onQuaternionChange );

		Object.defineProperties( this, {
			/**
			 * Represents the object's local position.
			 *
			 * @name Object3D#position
			 * @type {Vector3}
			 * @default (0,0,0)
			 */
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			/**
			 * Represents the object's local rotation as Euler angles, in radians.
			 *
			 * @name Object3D#rotation
			 * @type {Euler}
			 * @default (0,0,0)
			 */
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			/**
			 * Represents the object's local rotation as Quaternions.
			 *
			 * @name Object3D#quaternion
			 * @type {Quaternion}
			 */
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			/**
			 * Represents the object's local scale.
			 *
			 * @name Object3D#scale
			 * @type {Vector3}
			 * @default (1,1,1)
			 */
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			/**
			 * Represents the object's model-view matrix.
			 *
			 * @name Object3D#modelViewMatrix
			 * @type {Matrix4}
			 */
			modelViewMatrix: {
				value: new Matrix4()
			},
			/**
			 * Represents the object's normal matrix.
			 *
			 * @name Object3D#normalMatrix
			 * @type {Matrix3}
			 */
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		/**
		 * Represents the object's transformation matrix in local space.
		 *
		 * @type {Matrix4}
		 */
		this.matrix = new Matrix4();

		/**
		 * Represents the object's transformation matrix in world space.
		 * If the 3D object has no parent, then it's identical to the local transformation matrix
		 *
		 * @type {Matrix4}
		 */
		this.matrixWorld = new Matrix4();

		/**
		 * When set to `true`, the engine automatically computes the local matrix from position,
		 * rotation and scale every frame.
		 *
		 * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_AUTO_UPDATE`.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;

		/**
		 * When set to `true`, the engine automatically computes the world matrix from the current local
		 * matrix and the object's transformation hierarchy.
		 *
		 * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE`.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer

		/**
		 * When set to `true`, it calculates the world matrix in that frame and resets this property
		 * to `false`.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.matrixWorldNeedsUpdate = false;

		/**
		 * The layer membership of the 3D object. The 3D object is only visible if it has
		 * at least one layer in common with the camera in use. This property can also be
		 * used to filter out unwanted objects in ray-intersection tests when using {@link Raycaster}.
		 *
		 * @type {Layers}
		 */
		this.layers = new Layers();

		/**
		 * When set to `true`, the 3D object gets rendered.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.visible = true;

		/**
		 * When set to `true`, the 3D object gets rendered into shadow maps.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.castShadow = false;

		/**
		 * When set to `true`, the 3D object is affected by shadows in the scene.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.receiveShadow = false;

		/**
		 * When set to `true`, the 3D object is honored by view frustum culling.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.frustumCulled = true;

		/**
		 * This value allows the default rendering order of scene graph objects to be
		 * overridden although opaque and transparent objects remain sorted independently.
		 * When this property is set for an instance of {@link Group},all descendants
		 * objects will be sorted and rendered together. Sorting is from lowest to highest
		 * render order.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.renderOrder = 0;

		/**
		 * An array holding the animation clips of the 3D object.
		 *
		 * @type {Array<AnimationClip>}
		 */
		this.animations = [];

		/**
		 * Custom depth material to be used when rendering to the depth map. Can only be used
		 * in context of meshes. When shadow-casting with a {@link DirectionalLight} or {@link SpotLight},
		 * if you are modifying vertex positions in the vertex shader you must specify a custom depth
		 * material for proper shadows.
		 *
		 * Only relevant in context of {@link WebGLRenderer}.
		 *
		 * @type {(Material|undefined)}
		 * @default undefined
		 */
		this.customDepthMaterial = undefined;

		/**
		 * Same as {@link Object3D#customDepthMaterial}, but used with {@link PointLight}.
		 *
		 * Only relevant in context of {@link WebGLRenderer}.
		 *
		 * @type {(Material|undefined)}
		 * @default undefined
		 */
		this.customDistanceMaterial = undefined;

		/**
		 * An object that can be used to store custom data about the 3D object. It
		 * should not hold references to functions as these will not be cloned.
		 *
		 * @type {Object}
		 */
		this.userData = {};

	}

	/**
	 * A callback that is executed immediately before a 3D object is rendered to a shadow map.
	 *
	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
	 * @param {Object3D} object - The 3D object.
	 * @param {Camera} camera - The camera that is used to render the scene.
	 * @param {Camera} shadowCamera - The shadow camera.
	 * @param {BufferGeometry} geometry - The 3D object's geometry.
	 * @param {Material} depthMaterial - The depth material.
	 * @param {Object} group - The geometry group data.
	 */
	onBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

	/**
	 * A callback that is executed immediately after a 3D object is rendered to a shadow map.
	 *
	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
	 * @param {Object3D} object - The 3D object.
	 * @param {Camera} camera - The camera that is used to render the scene.
	 * @param {Camera} shadowCamera - The shadow camera.
	 * @param {BufferGeometry} geometry - The 3D object's geometry.
	 * @param {Material} depthMaterial - The depth material.
	 * @param {Object} group - The geometry group data.
	 */
	onAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

	/**
	 * A callback that is executed immediately before a 3D object is rendered.
	 *
	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
	 * @param {Object3D} object - The 3D object.
	 * @param {Camera} camera - The camera that is used to render the scene.
	 * @param {BufferGeometry} geometry - The 3D object's geometry.
	 * @param {Material} material - The 3D object's material.
	 * @param {Object} group - The geometry group data.
	 */
	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	/**
	 * A callback that is executed immediately after a 3D object is rendered.
	 *
	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
	 * @param {Object3D} object - The 3D object.
	 * @param {Camera} camera - The camera that is used to render the scene.
	 * @param {BufferGeometry} geometry - The 3D object's geometry.
	 * @param {Material} material - The 3D object's material.
	 * @param {Object} group - The geometry group data.
	 */
	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	/**
	 * Applies the given transformation matrix to the object and updates the object's position,
	 * rotation and scale.
	 *
	 * @param {Matrix4} matrix - The transformation matrix.
	 */
	applyMatrix4( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	}

	/**
	 * Applies a rotation represented by given the quaternion to the 3D object.
	 *
	 * @param {Quaternion} q - The quaternion.
	 * @return {Object3D} A reference to this instance.
	 */
	applyQuaternion( q ) {

		this.quaternion.premultiply( q );

		return this;

	}

	/**
	 * Sets the given rotation represented as an axis/angle couple to the 3D object.
	 *
	 * @param {Vector3} axis - The (normalized) axis vector.
	 * @param {number} angle - The angle in radians.
	 */
	setRotationFromAxisAngle( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	}

	/**
	 * Sets the given rotation represented as Euler angles to the 3D object.
	 *
	 * @param {Euler} euler - The Euler angles.
	 */
	setRotationFromEuler( euler ) {

		this.quaternion.setFromEuler( euler, true );

	}

	/**
	 * Sets the given rotation represented as rotation matrix to the 3D object.
	 *
	 * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
	 * a pure rotation matrix (i.e, unscaled).
	 */
	setRotationFromMatrix( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	}

	/**
	 * Sets the given rotation represented as a Quaternion to the 3D object.
	 *
	 * @param {Quaternion} q - The Quaternion
	 */
	setRotationFromQuaternion( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	}

	/**
	 * Rotates the 3D object along an axis in local space.
	 *
	 * @param {Vector3} axis - The (normalized) axis vector.
	 * @param {number} angle - The angle in radians.
	 * @return {Object3D} A reference to this instance.
	 */
	rotateOnAxis( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	}

	/**
	 * Rotates the 3D object along an axis in world space.
	 *
	 * @param {Vector3} axis - The (normalized) axis vector.
	 * @param {number} angle - The angle in radians.
	 * @return {Object3D} A reference to this instance.
	 */
	rotateOnWorldAxis( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	}

	/**
	 * Rotates the 3D object around its X axis in local space.
	 *
	 * @param {number} angle - The angle in radians.
	 * @return {Object3D} A reference to this instance.
	 */
	rotateX( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	}

	/**
	 * Rotates the 3D object around its Y axis in local space.
	 *
	 * @param {number} angle - The angle in radians.
	 * @return {Object3D} A reference to this instance.
	 */
	rotateY( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	}

	/**
	 * Rotates the 3D object around its Z axis in local space.
	 *
	 * @param {number} angle - The angle in radians.
	 * @return {Object3D} A reference to this instance.
	 */
	rotateZ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	}

	/**
	 * Translate the 3D object by a distance along the given axis in local space.
	 *
	 * @param {Vector3} axis - The (normalized) axis vector.
	 * @param {number} distance - The distance in world units.
	 * @return {Object3D} A reference to this instance.
	 */
	translateOnAxis( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$4.multiplyScalar( distance ) );

		return this;

	}

	/**
	 * Translate the 3D object by a distance along its X-axis in local space.
	 *
	 * @param {number} distance - The distance in world units.
	 * @return {Object3D} A reference to this instance.
	 */
	translateX( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	}

	/**
	 * Translate the 3D object by a distance along its Y-axis in local space.
	 *
	 * @param {number} distance - The distance in world units.
	 * @return {Object3D} A reference to this instance.
	 */
	translateY( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	}

	/**
	 * Translate the 3D object by a distance along its Z-axis in local space.
	 *
	 * @param {number} distance - The distance in world units.
	 * @return {Object3D} A reference to this instance.
	 */
	translateZ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	}

	/**
	 * Converts the given vector from this 3D object's local space to world space.
	 *
	 * @param {Vector3} vector - The vector to convert.
	 * @return {Vector3} The converted vector.
	 */
	localToWorld( vector ) {

		this.updateWorldMatrix( true, false );

		return vector.applyMatrix4( this.matrixWorld );

	}

	/**
	 * Converts the given vector from this 3D object's word space to local space.
	 *
	 * @param {Vector3} vector - The vector to convert.
	 * @return {Vector3} The converted vector.
	 */
	worldToLocal( vector ) {

		this.updateWorldMatrix( true, false );

		return vector.applyMatrix4( _m1$1$1.copy( this.matrixWorld ).invert() );

	}

	/**
	 * Rotates the object to face a point in world space.
	 *
	 * This method does not support objects having non-uniformly-scaled parent(s).
	 *
	 * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
	 * @param {number} [y] - The y coordinate in world space.
	 * @param {number} [z] - The z coordinate in world space.
	 */
	lookAt( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position$3.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$1$1.lookAt( _position$3, _target, this.up );

		} else {

			_m1$1$1.lookAt( _target, _position$3, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$1$1 );

		if ( parent ) {

			_m1$1$1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$1$1 );
			this.quaternion.premultiply( _q1.invert() );

		}

	}

	/**
	 * Adds the given 3D object as a child to this 3D object. An arbitrary number of
	 * objects may be added. Any current parent on an object passed in here will be
	 * removed, since an object can have at most one parent.
	 *
	 * @fires Object3D#added
	 * @fires Object3D#childadded
	 * @param {Object3D} object - The 3D object to add.
	 * @return {Object3D} A reference to this instance.
	 */
	add( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			error( 'Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			object.removeFromParent();
			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

			_childaddedEvent.child = object;
			this.dispatchEvent( _childaddedEvent );
			_childaddedEvent.child = null;

		} else {

			error( 'Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	}

	/**
	 * Removes the given 3D object as child from this 3D object.
	 * An arbitrary number of objects may be removed.
	 *
	 * @fires Object3D#removed
	 * @fires Object3D#childremoved
	 * @param {Object3D} object - The 3D object to remove.
	 * @return {Object3D} A reference to this instance.
	 */
	remove( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== -1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

			_childremovedEvent.child = object;
			this.dispatchEvent( _childremovedEvent );
			_childremovedEvent.child = null;

		}

		return this;

	}

	/**
	 * Removes this 3D object from its current parent.
	 *
	 * @fires Object3D#removed
	 * @fires Object3D#childremoved
	 * @return {Object3D} A reference to this instance.
	 */
	removeFromParent() {

		const parent = this.parent;

		if ( parent !== null ) {

			parent.remove( this );

		}

		return this;

	}

	/**
	 * Removes all child objects.
	 *
	 * @fires Object3D#removed
	 * @fires Object3D#childremoved
	 * @return {Object3D} A reference to this instance.
	 */
	clear() {

		return this.remove( ... this.children );

	}

	/**
	 * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
	 * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
	 *
	 * @fires Object3D#added
	 * @fires Object3D#childadded
	 * @param {Object3D} object - The 3D object to attach.
	 * @return {Object3D} A reference to this instance.
	 */
	attach( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

		this.updateWorldMatrix( true, false );

		_m1$1$1.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$1$1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$1$1 );

		object.removeFromParent();
		object.parent = this;
		this.children.push( object );

		object.updateWorldMatrix( false, true );

		object.dispatchEvent( _addedEvent );

		_childaddedEvent.child = object;
		this.dispatchEvent( _childaddedEvent );
		_childaddedEvent.child = null;

		return this;

	}

	/**
	 * Searches through the 3D object and its children, starting with the 3D object
	 * itself, and returns the first with a matching ID.
	 *
	 * @param {number} id - The id.
	 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
	 */
	getObjectById( id ) {

		return this.getObjectByProperty( 'id', id );

	}

	/**
	 * Searches through the 3D object and its children, starting with the 3D object
	 * itself, and returns the first with a matching name.
	 *
	 * @param {string} name - The name.
	 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
	 */
	getObjectByName( name ) {

		return this.getObjectByProperty( 'name', name );

	}

	/**
	 * Searches through the 3D object and its children, starting with the 3D object
	 * itself, and returns the first with a matching property value.
	 *
	 * @param {string} name - The name of the property.
	 * @param {any} value - The value.
	 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
	 */
	getObjectByProperty( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = this.children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	}

	/**
	 * Searches through the 3D object and its children, starting with the 3D object
	 * itself, and returns all 3D objects with a matching property value.
	 *
	 * @param {string} name - The name of the property.
	 * @param {any} value - The value.
	 * @param {Array<Object3D>} result - The method stores the result in this array.
	 * @return {Array<Object3D>} The found 3D objects.
	 */
	getObjectsByProperty( name, value, result = [] ) {

		if ( this[ name ] === value ) result.push( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].getObjectsByProperty( name, value, result );

		}

		return result;

	}

	/**
	 * Returns a vector representing the position of the 3D object in world space.
	 *
	 * @param {Vector3} target - The target vector the result is stored to.
	 * @return {Vector3} The 3D object's position in world space.
	 */
	getWorldPosition( target ) {

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	}

	/**
	 * Returns a Quaternion representing the position of the 3D object in world space.
	 *
	 * @param {Quaternion} target - The target Quaternion the result is stored to.
	 * @return {Quaternion} The 3D object's rotation in world space.
	 */
	getWorldQuaternion( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, target, _scale$2 );

		return target;

	}

	/**
	 * Returns a vector representing the scale of the 3D object in world space.
	 *
	 * @param {Vector3} target - The target vector the result is stored to.
	 * @return {Vector3} The 3D object's scale in world space.
	 */
	getWorldScale( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

		return target;

	}

	/**
	 * Returns a vector representing the ("look") direction of the 3D object in world space.
	 *
	 * @param {Vector3} target - The target vector the result is stored to.
	 * @return {Vector3} The 3D object's direction in world space.
	 */
	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	}

	/**
	 * Abstract method to get intersections between a casted ray and this
	 * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
	 * implement this method in order to use raycasting.
	 *
	 * @abstract
	 * @param {Raycaster} raycaster - The raycaster.
	 * @param {Array<Object>} intersects - An array holding the result of the method.
	 */
	raycast( /* raycaster, intersects */ ) {}

	/**
	 * Executes the callback on this 3D object and all descendants.
	 *
	 * Note: Modifying the scene graph inside the callback is discouraged.
	 *
	 * @param {Function} callback - A callback function that allows to process the current 3D object.
	 */
	traverse( callback ) {

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	}

	/**
	 * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
	 * Descendants of invisible 3D objects are not traversed.
	 *
	 * Note: Modifying the scene graph inside the callback is discouraged.
	 *
	 * @param {Function} callback - A callback function that allows to process the current 3D object.
	 */
	traverseVisible( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	}

	/**
	 * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
	 *
	 * Note: Modifying the scene graph inside the callback is discouraged.
	 *
	 * @param {Function} callback - A callback function that allows to process the current 3D object.
	 */
	traverseAncestors( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	}

	/**
	 * Updates the transformation matrix in local space by computing it from the current
	 * position, rotation and scale values.
	 */
	updateMatrix() {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	}

	/**
	 * Updates the transformation matrix in world space of this 3D objects and its descendants.
	 *
	 * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
	 * local space. The computation of the local and world matrix can be controlled with the
	 * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
	 * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
	 *
	 * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
	 * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
	 */
	updateMatrixWorld( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.matrixWorldAutoUpdate === true ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// make sure descendants are updated if required

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			const child = children[ i ];

			child.updateMatrixWorld( force );

		}

	}

	/**
	 * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
	 * update of ancestor and descendant nodes.
	 *
	 * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
	 * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
	 */
	updateWorldMatrix( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldAutoUpdate === true ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

		}

		// make sure descendants are updated

		if ( updateChildren === true ) {

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				const child = children[ i ];

				child.updateWorldMatrix( false, true );

			}

		}

	}

	/**
	 * Serializes the 3D object into JSON.
	 *
	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	 * @return {Object} A JSON object representing the serialized 3D object.
	 * @see {@link ObjectLoader#parse}
	 */
	toJSON( meta ) {

		// meta is a string when called from JSON.stringify
		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {},
				nodes: {}
			};

			output.metadata = {
				version: 4.7,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		const object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();
		object.up = this.up.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

		}

		if ( this.isBatchedMesh ) {

			object.type = 'BatchedMesh';
			object.perObjectFrustumCulled = this.perObjectFrustumCulled;
			object.sortObjects = this.sortObjects;

			object.drawRanges = this._drawRanges;
			object.reservedRanges = this._reservedRanges;

			object.geometryInfo = this._geometryInfo.map( info => ( {
				...info,
				boundingBox: info.boundingBox ? info.boundingBox.toJSON() : undefined,
				boundingSphere: info.boundingSphere ? info.boundingSphere.toJSON() : undefined
			} ) );
			object.instanceInfo = this._instanceInfo.map( info => ( { ...info } ) );

			object.availableInstanceIds = this._availableInstanceIds.slice();
			object.availableGeometryIds = this._availableGeometryIds.slice();

			object.nextIndexStart = this._nextIndexStart;
			object.nextVertexStart = this._nextVertexStart;
			object.geometryCount = this._geometryCount;

			object.maxInstanceCount = this._maxInstanceCount;
			object.maxVertexCount = this._maxVertexCount;
			object.maxIndexCount = this._maxIndexCount;

			object.geometryInitialized = this._geometryInitialized;

			object.matricesTexture = this._matricesTexture.toJSON( meta );

			object.indirectTexture = this._indirectTexture.toJSON( meta );

			if ( this._colorsTexture !== null ) {

				object.colorsTexture = this._colorsTexture.toJSON( meta );

			}

			if ( this.boundingSphere !== null ) {

				object.boundingSphere = this.boundingSphere.toJSON();

			}

			if ( this.boundingBox !== null ) {

				object.boundingBox = this.boundingBox.toJSON();

			}

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isScene ) {

			if ( this.background ) {

				if ( this.background.isColor ) {

					object.background = this.background.toJSON();

				} else if ( this.background.isTexture ) {

					object.background = this.background.toJSON( meta ).uuid;

				}

			}

			if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

				object.environment = this.environment.toJSON( meta ).uuid;

			}

		} else if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			const parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				const shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						const shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.isSkinnedMesh ) {

			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();

			if ( this.skeleton !== undefined ) {

				serialize( meta.skeletons, this.skeleton );

				object.skeleton = this.skeleton.uuid;

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				const uuids = [];

				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( let i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		//

		if ( this.animations.length > 0 ) {

			object.animations = [];

			for ( let i = 0; i < this.animations.length; i ++ ) {

				const animation = this.animations[ i ];

				object.animations.push( serialize( meta.animations, animation ) );

			}

		}

		if ( isRootObject ) {

			const geometries = extractFromCache( meta.geometries );
			const materials = extractFromCache( meta.materials );
			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const shapes = extractFromCache( meta.shapes );
			const skeletons = extractFromCache( meta.skeletons );
			const animations = extractFromCache( meta.animations );
			const nodes = extractFromCache( meta.nodes );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;
			if ( skeletons.length > 0 ) output.skeletons = skeletons;
			if ( animations.length > 0 ) output.animations = animations;
			if ( nodes.length > 0 ) output.nodes = nodes;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			const values = [];
			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	}

	/**
	 * Returns a new 3D object with copied values from this instance.
	 *
	 * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
	 * @return {Object3D} A clone of this instance.
	 */
	clone( recursive ) {

		return new this.constructor().copy( this, recursive );

	}

	/**
	 * Copies the values of the given 3D object to this instance.
	 *
	 * @param {Object3D} source - The 3D object to copy.
	 * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
	 * @return {Object3D} A reference to this instance.
	 */
	copy( source, recursive = true ) {

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.rotation.order = source.rotation.order;
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;

		this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.animations = source.animations.slice();

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( let i = 0; i < source.children.length; i ++ ) {

				const child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

}

/**
 * The default up direction for objects, also used as the default
 * position for {@link DirectionalLight} and {@link HemisphereLight}.
 *
 * @static
 * @type {Vector3}
 * @default (0,1,0)
 */
Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );

/**
 * The default setting for {@link Object3D#matrixAutoUpdate} for
 * newly created 3D objects.
 *
 * @static
 * @type {boolean}
 * @default true
 */
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;

/**
 * The default setting for {@link Object3D#matrixWorldAutoUpdate} for
 * newly created 3D objects.
 *
 * @static
 * @type {boolean}
 * @default true
 */
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

const _v0$1 = /*@__PURE__*/ new Vector3();
const _v1$3 = /*@__PURE__*/ new Vector3();
const _v2$2 = /*@__PURE__*/ new Vector3();
const _v3$2 = /*@__PURE__*/ new Vector3();

const _vab = /*@__PURE__*/ new Vector3();
const _vac = /*@__PURE__*/ new Vector3();
const _vbc = /*@__PURE__*/ new Vector3();
const _vap = /*@__PURE__*/ new Vector3();
const _vbp = /*@__PURE__*/ new Vector3();
const _vcp = /*@__PURE__*/ new Vector3();

const _v40 = /*@__PURE__*/ new Vector4();
const _v41 = /*@__PURE__*/ new Vector4();
const _v42 = /*@__PURE__*/ new Vector4();

/**
 * A geometric triangle as defined by three vectors representing its three corners.
 */
class Triangle {

	/**
	 * Constructs a new triangle.
	 *
	 * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
	 * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
	 * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
	 */
	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

		/**
		 * The first corner of the triangle.
		 *
		 * @type {Vector3}
		 */
		this.a = a;

		/**
		 * The second corner of the triangle.
		 *
		 * @type {Vector3}
		 */
		this.b = b;

		/**
		 * The third corner of the triangle.
		 *
		 * @type {Vector3}
		 */
		this.c = c;

	}

	/**
	 * Computes the normal vector of a triangle.
	 *
	 * @param {Vector3} a - The first corner of the triangle.
	 * @param {Vector3} b - The second corner of the triangle.
	 * @param {Vector3} c - The third corner of the triangle.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The triangle's normal.
	 */
	static getNormal( a, b, c, target ) {

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		const targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	}

	/**
	 * Computes a barycentric coordinates from the given vector.
	 * Returns `null` if the triangle is degenerate.
	 *
	 * @param {Vector3} point - A point in 3D space.
	 * @param {Vector3} a - The first corner of the triangle.
	 * @param {Vector3} b - The second corner of the triangle.
	 * @param {Vector3} c - The third corner of the triangle.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The barycentric coordinates for the given point
	 */
	static getBarycoord( point, a, b, c, target ) {

		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$2.subVectors( point, a );

		const dot00 = _v0$1.dot( _v0$1 );
		const dot01 = _v0$1.dot( _v1$3 );
		const dot02 = _v0$1.dot( _v2$2 );
		const dot11 = _v1$3.dot( _v1$3 );
		const dot12 = _v1$3.dot( _v2$2 );

		const denom = ( dot00 * dot11 - dot01 * dot01 );

		// collinear or singular triangle
		if ( denom === 0 ) {

			target.set( 0, 0, 0 );
			return null;

		}

		const invDenom = 1 / denom;
		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	}

	/**
	 * Returns `true` if the given point, when projected onto the plane of the
	 * triangle, lies within the triangle.
	 *
	 * @param {Vector3} point - The point in 3D space to test.
	 * @param {Vector3} a - The first corner of the triangle.
	 * @param {Vector3} b - The second corner of the triangle.
	 * @param {Vector3} c - The third corner of the triangle.
	 * @return {boolean} Whether the given point, when projected onto the plane of the
	 * triangle, lies within the triangle or not.
	 */
	static containsPoint( point, a, b, c ) {

		// if the triangle is degenerate then we can't contain a point
		if ( this.getBarycoord( point, a, b, c, _v3$2 ) === null ) {

			return false;

		}

		return ( _v3$2.x >= 0 ) && ( _v3$2.y >= 0 ) && ( ( _v3$2.x + _v3$2.y ) <= 1 );

	}

	/**
	 * Computes the value barycentrically interpolated for the given point on the
	 * triangle. Returns `null` if the triangle is degenerate.
	 *
	 * @param {Vector3} point - Position of interpolated point.
	 * @param {Vector3} p1 - The first corner of the triangle.
	 * @param {Vector3} p2 - The second corner of the triangle.
	 * @param {Vector3} p3 - The third corner of the triangle.
	 * @param {Vector3} v1 - Value to interpolate of first vertex.
	 * @param {Vector3} v2 - Value to interpolate of second vertex.
	 * @param {Vector3} v3 - Value to interpolate of third vertex.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The interpolated value.
	 */
	static getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {

		if ( this.getBarycoord( point, p1, p2, p3, _v3$2 ) === null ) {

			target.x = 0;
			target.y = 0;
			if ( 'z' in target ) target.z = 0;
			if ( 'w' in target ) target.w = 0;
			return null;

		}

		target.setScalar( 0 );
		target.addScaledVector( v1, _v3$2.x );
		target.addScaledVector( v2, _v3$2.y );
		target.addScaledVector( v3, _v3$2.z );

		return target;

	}

	/**
	 * Computes the value barycentrically interpolated for the given attribute and indices.
	 *
	 * @param {BufferAttribute} attr - The attribute to interpolate.
	 * @param {number} i1 - Index of first vertex.
	 * @param {number} i2 - Index of second vertex.
	 * @param {number} i3 - Index of third vertex.
	 * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The interpolated attribute value.
	 */
	static getInterpolatedAttribute( attr, i1, i2, i3, barycoord, target ) {

		_v40.setScalar( 0 );
		_v41.setScalar( 0 );
		_v42.setScalar( 0 );

		_v40.fromBufferAttribute( attr, i1 );
		_v41.fromBufferAttribute( attr, i2 );
		_v42.fromBufferAttribute( attr, i3 );

		target.setScalar( 0 );
		target.addScaledVector( _v40, barycoord.x );
		target.addScaledVector( _v41, barycoord.y );
		target.addScaledVector( _v42, barycoord.z );

		return target;

	}

	/**
	 * Returns `true` if the triangle is oriented towards the given direction.
	 *
	 * @param {Vector3} a - The first corner of the triangle.
	 * @param {Vector3} b - The second corner of the triangle.
	 * @param {Vector3} c - The third corner of the triangle.
	 * @param {Vector3} direction - The (normalized) direction vector.
	 * @return {boolean} Whether the triangle is oriented towards the given direction or not.
	 */
	static isFrontFacing( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

	/**
	 * Sets the triangle's vertices by copying the given values.
	 *
	 * @param {Vector3} a - The first corner of the triangle.
	 * @param {Vector3} b - The second corner of the triangle.
	 * @param {Vector3} c - The third corner of the triangle.
	 * @return {Triangle} A reference to this triangle.
	 */
	set( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	}

	/**
	 * Sets the triangle's vertices by copying the given array values.
	 *
	 * @param {Array<Vector3>} points - An array with 3D points.
	 * @param {number} i0 - The array index representing the first corner of the triangle.
	 * @param {number} i1 - The array index representing the second corner of the triangle.
	 * @param {number} i2 - The array index representing the third corner of the triangle.
	 * @return {Triangle} A reference to this triangle.
	 */
	setFromPointsAndIndices( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	}

	/**
	 * Sets the triangle's vertices by copying the given attribute values.
	 *
	 * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
	 * @param {number} i0 - The attribute index representing the first corner of the triangle.
	 * @param {number} i1 - The attribute index representing the second corner of the triangle.
	 * @param {number} i2 - The attribute index representing the third corner of the triangle.
	 * @return {Triangle} A reference to this triangle.
	 */
	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

		this.a.fromBufferAttribute( attribute, i0 );
		this.b.fromBufferAttribute( attribute, i1 );
		this.c.fromBufferAttribute( attribute, i2 );

		return this;

	}

	/**
	 * Returns a new triangle with copied values from this instance.
	 *
	 * @return {Triangle} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Copies the values of the given triangle to this instance.
	 *
	 * @param {Triangle} triangle - The triangle to copy.
	 * @return {Triangle} A reference to this triangle.
	 */
	copy( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	}

	/**
	 * Computes the area of the triangle.
	 *
	 * @return {number} The triangle's area.
	 */
	getArea() {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	}

	/**
	 * Computes the midpoint of the triangle.
	 *
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The triangle's midpoint.
	 */
	getMidpoint( target ) {

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}

	/**
	 * Computes the normal of the triangle.
	 *
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The triangle's normal.
	 */
	getNormal( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	}

	/**
	 * Computes a plane the triangle lies within.
	 *
	 * @param {Plane} target - The target vector that is used to store the method's result.
	 * @return {Plane} The plane the triangle lies within.
	 */
	getPlane( target ) {

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	}

	/**
	 * Computes a barycentric coordinates from the given vector.
	 * Returns `null` if the triangle is degenerate.
	 *
	 * @param {Vector3} point - A point in 3D space.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The barycentric coordinates for the given point
	 */
	getBarycoord( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	}

	/**
	 * Computes the value barycentrically interpolated for the given point on the
	 * triangle. Returns `null` if the triangle is degenerate.
	 *
	 * @param {Vector3} point - Position of interpolated point.
	 * @param {Vector3} v1 - Value to interpolate of first vertex.
	 * @param {Vector3} v2 - Value to interpolate of second vertex.
	 * @param {Vector3} v3 - Value to interpolate of third vertex.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The interpolated value.
	 */
	getInterpolation( point, v1, v2, v3, target ) {

		return Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );

	}

	/**
	 * Returns `true` if the given point, when projected onto the plane of the
	 * triangle, lies within the triangle.
	 *
	 * @param {Vector3} point - The point in 3D space to test.
	 * @return {boolean} Whether the given point, when projected onto the plane of the
	 * triangle, lies within the triangle or not.
	 */
	containsPoint( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	}

	/**
	 * Returns `true` if the triangle is oriented towards the given direction.
	 *
	 * @param {Vector3} direction - The (normalized) direction vector.
	 * @return {boolean} Whether the triangle is oriented towards the given direction or not.
	 */
	isFrontFacing( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	}

	/**
	 * Returns `true` if this triangle intersects with the given box.
	 *
	 * @param {Box3} box - The box to intersect.
	 * @return {boolean} Whether this triangle intersects with the given box or not.
	 */
	intersectsBox( box ) {

		return box.intersectsTriangle( this );

	}

	/**
	 * Returns the closest point on the triangle to the given point.
	 *
	 * @param {Vector3} p - The point to compute the closest point for.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The closest point on the triangle.
	 */
	closestPointToPoint( p, target ) {

		const a = this.a, b = this.b, c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		const d1 = _vab.dot( _vap );
		const d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		const d3 = _vab.dot( _vbp );
		const d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		const vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		const d5 = _vab.dot( _vcp );
		const d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		const vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		const va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		const denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	}

	/**
	 * Returns `true` if this triangle is equal with the given one.
	 *
	 * @param {Triangle} triangle - The triangle to test for equality.
	 * @return {boolean} Whether this triangle is equal with the given one.
	 */
	equals( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

}

const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

/**
 * A Color instance is represented by RGB components in the linear <i>working
 * color space</i>, which defaults to `LinearSRGBColorSpace`. Inputs
 * conventionally using `SRGBColorSpace` (such as hexadecimals and CSS
 * strings) are converted to the working color space automatically.
 *
 * ```js
 * // converted automatically from SRGBColorSpace to LinearSRGBColorSpace
 * const color = new THREE.Color().setHex( 0x112233 );
 * ```
 * Source color spaces may be specified explicitly, to ensure correct conversions.
 * ```js
 * // assumed already LinearSRGBColorSpace; no conversion
 * const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5 );
 *
 * // converted explicitly from SRGBColorSpace to LinearSRGBColorSpace
 * const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5, SRGBColorSpace );
 * ```
 * If THREE.ColorManagement is disabled, no conversions occur. For details,
 * see <i>Color management</i>. Iterating through a Color instance will yield
 * its components (r, g, b) in the corresponding order. A Color can be initialised
 * in any of the following ways:
 * ```js
 * //empty constructor - will default white
 * const color1 = new THREE.Color();
 *
 * //Hexadecimal color (recommended)
 * const color2 = new THREE.Color( 0xff0000 );
 *
 * //RGB string
 * const color3 = new THREE.Color("rgb(255, 0, 0)");
 * const color4 = new THREE.Color("rgb(100%, 0%, 0%)");
 *
 * //X11 color name - all 140 color names are supported.
 * //Note the lack of CamelCase in the name
 * const color5 = new THREE.Color( 'skyblue' );
 * //HSL string
 * const color6 = new THREE.Color("hsl(0, 100%, 50%)");
 *
 * //Separate RGB values between 0 and 1
 * const color7 = new THREE.Color( 1, 0, 0 );
 * ```
 */
class Color {

	/**
	 * Constructs a new color.
	 *
	 * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
	 * and that method is used throughout the rest of the documentation.
	 *
	 * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
	 * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
	 * @param {number} [g] - The green component.
	 * @param {number} [b] - The blue component.
	 */
	constructor( r, g, b ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isColor = true;

		/**
		 * The red component.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.r = 1;

		/**
		 * The green component.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.g = 1;

		/**
		 * The blue component.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.b = 1;

		return this.set( r, g, b );

	}

	/**
	 * Sets the colors's components from the given values.
	 *
	 * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
	 * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
	 * @param {number} [g] - The green component.
	 * @param {number} [b] - The blue component.
	 * @return {Color} A reference to this color.
	 */
	set( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string

			const value = r;

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

		} else {

			this.setRGB( r, g, b );

		}

		return this;

	}

	/**
	 * Sets the colors's components to the given scalar value.
	 *
	 * @param {number} scalar - The scalar value.
	 * @return {Color} A reference to this color.
	 */
	setScalar( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	}

	/**
	 * Sets this color from a hexadecimal value.
	 *
	 * @param {number} hex - The hexadecimal value.
	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
	 * @return {Color} A reference to this color.
	 */
	setHex( hex, colorSpace = SRGBColorSpace ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		ColorManagement.colorSpaceToWorking( this, colorSpace );

		return this;

	}

	/**
	 * Sets this color from RGB values.
	 *
	 * @param {number} r - Red channel value between `0.0` and `1.0`.
	 * @param {number} g - Green channel value between `0.0` and `1.0`.
	 * @param {number} b - Blue channel value between `0.0` and `1.0`.
	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
	 * @return {Color} A reference to this color.
	 */
	setRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {

		this.r = r;
		this.g = g;
		this.b = b;

		ColorManagement.colorSpaceToWorking( this, colorSpace );

		return this;

	}

	/**
	 * Sets this color from RGB values.
	 *
	 * @param {number} h - Hue value between `0.0` and `1.0`.
	 * @param {number} s - Saturation value between `0.0` and `1.0`.
	 * @param {number} l - Lightness value between `0.0` and `1.0`.
	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
	 * @return {Color} A reference to this color.
	 */
	setHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = euclideanModulo( h, 1 );
		s = clamp( s, 0, 1 );
		l = clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			const q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		ColorManagement.colorSpaceToWorking( this, colorSpace );

		return this;

	}

	/**
	 * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
	 * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
	 * any [X11 color name](https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart) -
	 * all 140 color names are supported).
	 *
	 * @param {string} style - Color as a CSS-style string.
	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
	 * @return {Color} A reference to this color.
	 */
	setStyle( style, colorSpace = SRGBColorSpace ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				warn( 'Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		let m;

		if ( m = /^(\w+)\(([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			let color;
			const name = m[ 1 ];
			const components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)

						handleAlpha( color[ 4 ] );

						return this.setRGB(
							Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,
							Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,
							Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,
							colorSpace
						);

					}

					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

						handleAlpha( color[ 4 ] );

						return this.setRGB(
							Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,
							Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,
							Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,
							colorSpace
						);

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)

						handleAlpha( color[ 4 ] );

						return this.setHSL(
							parseFloat( color[ 1 ] ) / 360,
							parseFloat( color[ 2 ] ) / 100,
							parseFloat( color[ 3 ] ) / 100,
							colorSpace
						);

					}

					break;

				default:

					warn( 'Color: Unknown color model ' + style );

			}

		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			// hex color

			const hex = m[ 1 ];
			const size = hex.length;

			if ( size === 3 ) {

				// #ff0
				return this.setRGB(
					parseInt( hex.charAt( 0 ), 16 ) / 15,
					parseInt( hex.charAt( 1 ), 16 ) / 15,
					parseInt( hex.charAt( 2 ), 16 ) / 15,
					colorSpace
				);

			} else if ( size === 6 ) {

				// #ff0000
				return this.setHex( parseInt( hex, 16 ), colorSpace );

			} else {

				warn( 'Color: Invalid hex color ' + style );

			}

		} else if ( style && style.length > 0 ) {

			return this.setColorName( style, colorSpace );

		}

		return this;

	}

	/**
	 * Sets this color from a color name. Faster than {@link Color#setStyle} if
	 * you don't need the other CSS-style formats.
	 *
	 * For convenience, the list of names is exposed in `Color.NAMES` as a hash.
	 * ```js
	 * Color.NAMES.aliceblue // returns 0xF0F8FF
	 * ```
	 *
	 * @param {string} style - The color name.
	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
	 * @return {Color} A reference to this color.
	 */
	setColorName( style, colorSpace = SRGBColorSpace ) {

		// color keywords
		const hex = _colorKeywords[ style.toLowerCase() ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex, colorSpace );

		} else {

			// unknown color
			warn( 'Color: Unknown color ' + style );

		}

		return this;

	}

	/**
	 * Returns a new color with copied values from this instance.
	 *
	 * @return {Color} A clone of this instance.
	 */
	clone() {

		return new this.constructor( this.r, this.g, this.b );

	}

	/**
	 * Copies the values of the given color to this instance.
	 *
	 * @param {Color} color - The color to copy.
	 * @return {Color} A reference to this color.
	 */
	copy( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	}

	/**
	 * Copies the given color into this color, and then converts this color from
	 * `SRGBColorSpace` to `LinearSRGBColorSpace`.
	 *
	 * @param {Color} color - The color to copy/convert.
	 * @return {Color} A reference to this color.
	 */
	copySRGBToLinear( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	}

	/**
	 * Copies the given color into this color, and then converts this color from
	 * `LinearSRGBColorSpace` to `SRGBColorSpace`.
	 *
	 * @param {Color} color - The color to copy/convert.
	 * @return {Color} A reference to this color.
	 */
	copyLinearToSRGB( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	}

	/**
	 * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
	 *
	 * @return {Color} A reference to this color.
	 */
	convertSRGBToLinear() {

		this.copySRGBToLinear( this );

		return this;

	}

	/**
	 * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
	 *
	 * @return {Color} A reference to this color.
	 */
	convertLinearToSRGB() {

		this.copyLinearToSRGB( this );

		return this;

	}

	/**
	 * Returns the hexadecimal value of this color.
	 *
	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
	 * @return {number} The hexadecimal value.
	 */
	getHex( colorSpace = SRGBColorSpace ) {

		ColorManagement.workingToColorSpace( _color$1.copy( this ), colorSpace );

		return Math.round( clamp( _color$1.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp( _color$1.g * 255, 0, 255 ) ) * 256 + Math.round( clamp( _color$1.b * 255, 0, 255 ) );

	}

	/**
	 * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
	 *
	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
	 * @return {string} The hexadecimal value as a string.
	 */
	getHexString( colorSpace = SRGBColorSpace ) {

		return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( -6 );

	}

	/**
	 * Converts the colors RGB values into the HSL format and stores them into the
	 * given target object.
	 *
	 * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
	 * @return {{h:number,s:number,l:number}} The HSL representation of this color.
	 */
	getHSL( target, colorSpace = ColorManagement.workingColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0

		ColorManagement.workingToColorSpace( _color$1.copy( this ), colorSpace );

		const r = _color$1.r, g = _color$1.g, b = _color$1.b;

		const max = Math.max( r, g, b );
		const min = Math.min( r, g, b );

		let hue, saturation;
		const lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			const delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	}

	/**
	 * Returns the RGB values of this color and stores them into the given target object.
	 *
	 * @param {Color} target - The target color that is used to store the method's result.
	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
	 * @return {Color} The RGB representation of this color.
	 */
	getRGB( target, colorSpace = ColorManagement.workingColorSpace ) {

		ColorManagement.workingToColorSpace( _color$1.copy( this ), colorSpace );

		target.r = _color$1.r;
		target.g = _color$1.g;
		target.b = _color$1.b;

		return target;

	}

	/**
	 * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
	 *
	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
	 * @return {string} The CSS representation of this color.
	 */
	getStyle( colorSpace = SRGBColorSpace ) {

		ColorManagement.workingToColorSpace( _color$1.copy( this ), colorSpace );

		const r = _color$1.r, g = _color$1.g, b = _color$1.b;

		if ( colorSpace !== SRGBColorSpace ) {

			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
			return `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;

		}

		return `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;

	}

	/**
	 * Adds the given HSL values to this color's values.
	 * Internally, this converts the color's RGB values to HSL, adds HSL
	 * and then converts the color back to RGB.
	 *
	 * @param {number} h - Hue value between `0.0` and `1.0`.
	 * @param {number} s - Saturation value between `0.0` and `1.0`.
	 * @param {number} l - Lightness value between `0.0` and `1.0`.
	 * @return {Color} A reference to this color.
	 */
	offsetHSL( h, s, l ) {

		this.getHSL( _hslA );

		return this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );

	}

	/**
	 * Adds the RGB values of the given color to the RGB values of this color.
	 *
	 * @param {Color} color - The color to add.
	 * @return {Color} A reference to this color.
	 */
	add( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	}

	/**
	 * Adds the RGB values of the given colors and stores the result in this instance.
	 *
	 * @param {Color} color1 - The first color.
	 * @param {Color} color2 - The second color.
	 * @return {Color} A reference to this color.
	 */
	addColors( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	}

	/**
	 * Adds the given scalar value to the RGB values of this color.
	 *
	 * @param {number} s - The scalar to add.
	 * @return {Color} A reference to this color.
	 */
	addScalar( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	}

	/**
	 * Subtracts the RGB values of the given color from the RGB values of this color.
	 *
	 * @param {Color} color - The color to subtract.
	 * @return {Color} A reference to this color.
	 */
	sub( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	}

	/**
	 * Multiplies the RGB values of the given color with the RGB values of this color.
	 *
	 * @param {Color} color - The color to multiply.
	 * @return {Color} A reference to this color.
	 */
	multiply( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	}

	/**
	 * Multiplies the given scalar value with the RGB values of this color.
	 *
	 * @param {number} s - The scalar to multiply.
	 * @return {Color} A reference to this color.
	 */
	multiplyScalar( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	}

	/**
	 * Linearly interpolates this color's RGB values toward the RGB values of the
	 * given color. The alpha argument can be thought of as the ratio between
	 * the two colors, where `0.0` is this color and `1.0` is the first argument.
	 *
	 * @param {Color} color - The color to converge on.
	 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
	 * @return {Color} A reference to this color.
	 */
	lerp( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	}

	/**
	 * Linearly interpolates between the given colors and stores the result in this instance.
	 * The alpha argument can be thought of as the ratio between the two colors, where `0.0`
	 * is the first and `1.0` is the second color.
	 *
	 * @param {Color} color1 - The first color.
	 * @param {Color} color2 - The second color.
	 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
	 * @return {Color} A reference to this color.
	 */
	lerpColors( color1, color2, alpha ) {

		this.r = color1.r + ( color2.r - color1.r ) * alpha;
		this.g = color1.g + ( color2.g - color1.g ) * alpha;
		this.b = color1.b + ( color2.b - color1.b ) * alpha;

		return this;

	}

	/**
	 * Linearly interpolates this color's HSL values toward the HSL values of the
	 * given color. It differs from {@link Color#lerp} by not interpolating straight
	 * from one color to the other, but instead going through all the hues in between
	 * those two colors. The alpha argument can be thought of as the ratio between
	 * the two colors, where 0.0 is this color and 1.0 is the first argument.
	 *
	 * @param {Color} color - The color to converge on.
	 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
	 * @return {Color} A reference to this color.
	 */
	lerpHSL( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		const h = lerp( _hslA.h, _hslB.h, alpha );
		const s = lerp( _hslA.s, _hslB.s, alpha );
		const l = lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	}

	/**
	 * Sets the color's RGB components from the given 3D vector.
	 *
	 * @param {Vector3} v - The vector to set.
	 * @return {Color} A reference to this color.
	 */
	setFromVector3( v ) {

		this.r = v.x;
		this.g = v.y;
		this.b = v.z;

		return this;

	}

	/**
	 * Transforms this color with the given 3x3 matrix.
	 *
	 * @param {Matrix3} m - The matrix.
	 * @return {Color} A reference to this color.
	 */
	applyMatrix3( m ) {

		const r = this.r, g = this.g, b = this.b;
		const e = m.elements;

		this.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;
		this.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;
		this.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;

		return this;

	}

	/**
	 * Returns `true` if this color is equal with the given one.
	 *
	 * @param {Color} c - The color to test for equality.
	 * @return {boolean} Whether this bounding color is equal with the given one.
	 */
	equals( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	}

	/**
	 * Sets this color's RGB components from the given array.
	 *
	 * @param {Array<number>} array - An array holding the RGB values.
	 * @param {number} [offset=0] - The offset into the array.
	 * @return {Color} A reference to this color.
	 */
	fromArray( array, offset = 0 ) {

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	}

	/**
	 * Writes the RGB components of this color to the given array. If no array is provided,
	 * the method returns a new instance.
	 *
	 * @param {Array<number>} [array=[]] - The target array holding the color components.
	 * @param {number} [offset=0] - Index of the first element in the array.
	 * @return {Array<number>} The color components.
	 */
	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

	/**
	 * Sets the components of this color from the given buffer attribute.
	 *
	 * @param {BufferAttribute} attribute - The buffer attribute holding color data.
	 * @param {number} index - The index into the attribute.
	 * @return {Color} A reference to this color.
	 */
	fromBufferAttribute( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		return this;

	}

	/**
	 * This methods defines the serialization result of this class. Returns the color
	 * as a hexadecimal value.
	 *
	 * @return {number} The hexadecimal value.
	 */
	toJSON() {

		return this.getHex();

	}

	*[ Symbol.iterator ]() {

		yield this.r;
		yield this.g;
		yield this.b;

	}

}

const _color$1 = /*@__PURE__*/ new Color();

/**
 * A dictionary with X11 color names.
 *
 * Note that multiple words such as Dark Orange become the string 'darkorange'.
 *
 * @static
 * @type {Object}
 */
Color.NAMES = _colorKeywords;

let _materialId = 0;

/**
 * Abstract base class for materials.
 *
 * Materials define the appearance of renderable 3D objects.
 *
 * @abstract
 * @augments EventDispatcher
 */
class Material extends EventDispatcher {

	/**
	 * Constructs a new material.
	 */
	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMaterial = true;

		/**
		 * The ID of the material.
		 *
		 * @name Material#id
		 * @type {number}
		 * @readonly
		 */
		Object.defineProperty( this, 'id', { value: _materialId ++ } );

		/**
		 * The UUID of the material.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.uuid = generateUUID();

		/**
		 * The name of the material.
		 *
		 * @type {string}
		 */
		this.name = '';

		/**
		 * The type property is used for detecting the object type
		 * in context of serialization/deserialization.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.type = 'Material';

		/**
		 * Defines the blending type of the material.
		 *
		 * It must be set to `CustomBlending` if custom blending properties like
		 * {@link Material#blendSrc}, {@link Material#blendDst} or {@link Material#blendEquation}
		 * should have any effect.
		 *
		 * @type {(NoBlending|NormalBlending|AdditiveBlending|SubtractiveBlending|MultiplyBlending|CustomBlending)}
		 * @default NormalBlending
		 */
		this.blending = NormalBlending;

		/**
		 * Defines which side of faces will be rendered - front, back or both.
		 *
		 * @type {(FrontSide|BackSide|DoubleSide)}
		 * @default FrontSide
		 */
		this.side = FrontSide;

		/**
		 * If set to `true`, vertex colors should be used.
		 *
		 * The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or
		 * four (RGBA) component color buffer attribute is used.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.vertexColors = false;

		/**
		 * Defines how transparent the material is.
		 * A value of `0.0` indicates fully transparent, `1.0` is fully opaque.
		 *
		 * If the {@link Material#transparent} is not set to `true`,
		 * the material will remain fully opaque and this value will only affect its color.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.opacity = 1;

		/**
		 * Defines whether this material is transparent. This has an effect on
		 * rendering as transparent objects need special treatment and are rendered
		 * after non-transparent objects.
		 *
		 * When set to true, the extent to which the material is transparent is
		 * controlled by {@link Material#opacity}.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.transparent = false;

		/**
		 * Enables alpha hashed transparency, an alternative to {@link Material#transparent} or
		 * {@link Material#alphaTest}. The material will not be rendered if opacity is lower than
		 * a random threshold. Randomization introduces some grain or noise, but approximates alpha
		 * blending without the associated problems of sorting. Using TAA can reduce the resulting noise.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.alphaHash = false;

		/**
		 * Defines the blending source factor.
		 *
		 * @type {(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
		 * @default SrcAlphaFactor
		 */
		this.blendSrc = SrcAlphaFactor;

		/**
		 * Defines the blending destination factor.
		 *
		 * @type {(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
		 * @default OneMinusSrcAlphaFactor
		 */
		this.blendDst = OneMinusSrcAlphaFactor;

		/**
		 * Defines the blending equation.
		 *
		 * @type {(AddEquation|SubtractEquation|ReverseSubtractEquation|MinEquation|MaxEquation)}
		 * @default AddEquation
		 */
		this.blendEquation = AddEquation;

		/**
		 * Defines the blending source alpha factor.
		 *
		 * @type {?(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
		 * @default null
		 */
		this.blendSrcAlpha = null;

		/**
		 * Defines the blending destination alpha factor.
		 *
		 * @type {?(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
		 * @default null
		 */
		this.blendDstAlpha = null;

		/**
		 * Defines the blending equation of the alpha channel.
		 *
		 * @type {?(AddEquation|SubtractEquation|ReverseSubtractEquation|MinEquation|MaxEquation)}
		 * @default null
		 */
		this.blendEquationAlpha = null;

		/**
		 * Represents the RGB values of the constant blend color.
		 *
		 * This property has only an effect when using custom blending with `ConstantColor` or `OneMinusConstantColor`.
		 *
		 * @type {Color}
		 * @default (0,0,0)
		 */
		this.blendColor = new Color( 0, 0, 0 );

		/**
		 * Represents the alpha value of the constant blend color.
		 *
		 * This property has only an effect when using custom blending with `ConstantAlpha` or `OneMinusConstantAlpha`.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.blendAlpha = 0;

		/**
		 * Defines the depth function.
		 *
		 * @type {(NeverDepth|AlwaysDepth|LessDepth|LessEqualDepth|EqualDepth|GreaterEqualDepth|GreaterDepth|NotEqualDepth)}
		 * @default LessEqualDepth
		 */
		this.depthFunc = LessEqualDepth;

		/**
		 * Whether to have depth test enabled when rendering this material.
		 * When the depth test is disabled, the depth write will also be implicitly disabled.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.depthTest = true;

		/**
		 * Whether rendering this material has any effect on the depth buffer.
		 *
		 * When drawing 2D overlays it can be useful to disable the depth writing in
		 * order to layer several things together without creating z-index artifacts.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.depthWrite = true;

		/**
		 * The bit mask to use when writing to the stencil buffer.
		 *
		 * @type {number}
		 * @default 0xff
		 */
		this.stencilWriteMask = 0xff;

		/**
		 * The stencil comparison function to use.
		 *
		 * @type {NeverStencilFunc|LessStencilFunc|EqualStencilFunc|LessEqualStencilFunc|GreaterStencilFunc|NotEqualStencilFunc|GreaterEqualStencilFunc|AlwaysStencilFunc}
		 * @default AlwaysStencilFunc
		 */
		this.stencilFunc = AlwaysStencilFunc;

		/**
		 * The value to use when performing stencil comparisons or stencil operations.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.stencilRef = 0;

		/**
		 * The bit mask to use when comparing against the stencil buffer.
		 *
		 * @type {number}
		 * @default 0xff
		 */
		this.stencilFuncMask = 0xff;

		/**
		 * Which stencil operation to perform when the comparison function returns `false`.
		 *
		 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
		 * @default KeepStencilOp
		 */
		this.stencilFail = KeepStencilOp;

		/**
		 * Which stencil operation to perform when the comparison function returns
		 * `true` but the depth test fails.
		 *
		 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
		 * @default KeepStencilOp
		 */
		this.stencilZFail = KeepStencilOp;

		/**
		 * Which stencil operation to perform when the comparison function returns
		 * `true` and the depth test passes.
		 *
		 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
		 * @default KeepStencilOp
		 */
		this.stencilZPass = KeepStencilOp;

		/**
		 * Whether stencil operations are performed against the stencil buffer. In
		 * order to perform writes or comparisons against the stencil buffer this
		 * value must be `true`.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.stencilWrite = false;

		/**
		 * User-defined clipping planes specified as THREE.Plane objects in world
		 * space. These planes apply to the objects this material is attached to.
		 * Points in space whose signed distance to the plane is negative are clipped
		 * (not rendered). This requires {@link WebGLRenderer#localClippingEnabled} to
		 * be `true`.
		 *
		 * @type {?Array<Plane>}
		 * @default null
		 */
		this.clippingPlanes = null;

		/**
		 * Changes the behavior of clipping planes so that only their intersection is
		 * clipped, rather than their union.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.clipIntersection = false;

		/**
		 * Defines whether to clip shadows according to the clipping planes specified
		 * on this material.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.clipShadows = false;

		/**
		 * Defines which side of faces cast shadows. If `null`, the side casting shadows
		 * is determined as follows:
		 *
		 * - When {@link Material#side} is set to `FrontSide`, the back side cast shadows.
		 * - When {@link Material#side} is set to `BackSide`, the front side cast shadows.
		 * - When {@link Material#side} is set to `DoubleSide`, both sides cast shadows.
		 *
		 * @type {?(FrontSide|BackSide|DoubleSide)}
		 * @default null
		 */
		this.shadowSide = null;

		/**
		 * Whether to render the material's color.
		 *
		 * This can be used in conjunction with {@link Object3D#renderOder} to create invisible
		 * objects that occlude other objects.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.colorWrite = true;

		/**
		 * Override the renderer's default precision for this material.
		 *
		 * @type {?('highp'|'mediump'|'lowp')}
		 * @default null
		 */
		this.precision = null;

		/**
		 * Whether to use polygon offset or not. When enabled, each fragment's depth value will
		 * be offset after it is interpolated from the depth values of the appropriate vertices.
		 * The offset is added before the depth test is performed and before the value is written
		 * into the depth buffer.
		 *
		 * Can be useful for rendering hidden-line images, for applying decals to surfaces, and for
		 * rendering solids with highlighted edges.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.polygonOffset = false;

		/**
		 * Specifies a scale factor that is used to create a variable depth offset for each polygon.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.polygonOffsetFactor = 0;

		/**
		 * Is multiplied by an implementation-specific value to create a constant depth offset.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.polygonOffsetUnits = 0;

		/**
		 * Whether to apply dithering to the color to remove the appearance of banding.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.dithering = false;

		/**
		 * Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts
		 * (meaning when the renderer was created with *antialias* parameter set to `true`). Enabling this
		 * will smooth aliasing on clip plane edges and alphaTest-clipped edges.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.alphaToCoverage = false;

		/**
		 * Whether to premultiply the alpha (transparency) value.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.premultipliedAlpha = false;

		/**
		 * Whether double-sided, transparent objects should be rendered with a single pass or not.
		 *
		 * The engine renders double-sided, transparent objects with two draw calls (back faces first,
		 * then front faces) to mitigate transparency artifacts. There are scenarios however where this
		 * approach produces no quality gains but still doubles draw calls e.g. when rendering flat
		 * vegetation like grass sprites. In these cases, set the `forceSinglePass` flag to `true` to
		 * disable the two pass rendering to avoid performance issues.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.forceSinglePass = false;

		/**
		 * Whether it's possible to override the material with {@link Scene#overrideMaterial} or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.allowOverride = true;

		/**
		 * Defines whether 3D objects using this material are visible.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.visible = true;

		/**
		 * Defines whether this material is tone mapped according to the renderer's tone mapping setting.
		 *
		 * It is ignored when rendering to a render target or using post processing or when using
		 * `WebGPURenderer`. In all these cases, all materials are honored by tone mapping.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.toneMapped = true;

		/**
		 * An object that can be used to store custom data about the Material. It
		 * should not hold references to functions as these will not be cloned.
		 *
		 * @type {Object}
		 */
		this.userData = {};

		/**
		 * This starts at `0` and counts how many times {@link Material#needsUpdate} is set to `true`.
		 *
		 * @type {number}
		 * @readonly
		 * @default 0
		 */
		this.version = 0;

		this._alphaTest = 0;

	}

	/**
	 * Sets the alpha value to be used when running an alpha test. The material
	 * will not be rendered if the opacity is lower than this value.
	 *
	 * @type {number}
	 * @readonly
	 * @default 0
	 */
	get alphaTest() {

		return this._alphaTest;

	}

	set alphaTest( value ) {

		if ( this._alphaTest > 0 !== value > 0 ) {

			this.version ++;

		}

		this._alphaTest = value;

	}

	/**
	 * An optional callback that is executed immediately before the material is used to render a 3D object.
	 *
	 * This method can only be used when rendering with {@link WebGLRenderer}.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {Scene} scene - The scene.
	 * @param {Camera} camera - The camera that is used to render the scene.
	 * @param {BufferGeometry} geometry - The 3D object's geometry.
	 * @param {Object3D} object - The 3D object.
	 * @param {Object} group - The geometry group data.
	 */
	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

	/**
	 * An optional callback that is executed immediately before the shader
	 * program is compiled. This function is called with the shader source code
	 * as a parameter. Useful for the modification of built-in materials.
	 *
	 * This method can only be used when rendering with {@link WebGLRenderer}. The
	 * recommended approach when customizing materials is to use `WebGPURenderer` with the new
	 * Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language).
	 *
	 * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
	 * @param {WebGLRenderer} renderer - A reference to the renderer.
	 */
	onBeforeCompile( /* shaderobject, renderer */ ) {}

	/**
	 * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
	 * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
	 * shader or recompile the shader for this material as needed.
	 *
	 * This method can only be used when rendering with {@link WebGLRenderer}.
	 *
	 * @return {string} The custom program cache key.
	 */
	customProgramCacheKey() {

		return this.onBeforeCompile.toString();

	}

	/**
	 * This method can be used to set default values from parameter objects.
	 * It is a generic implementation so it can be used with different types
	 * of materials.
	 *
	 * @param {Object} [values] - The material values to set.
	 */
	setValues( values ) {

		if ( values === undefined ) return;

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				warn( `Material: parameter '${ key }' has value of undefined.` );
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				warn( `Material: '${ key }' is not a property of THREE.${ this.type }.` );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	}

	/**
	 * Serializes the material into JSON.
	 *
	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
	 * @return {Object} A JSON object representing the serialized material.
	 * @see {@link ObjectLoader#parse}
	 */
	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( isRootObject ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		const data = {
			metadata: {
				version: 4.7,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen !== undefined ) data.sheen = this.sheen;
		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.sheenColorMap && this.sheenColorMap.isTexture ) {

			data.sheenColorMap = this.sheenColorMap.toJSON( meta ).uuid;

		}

		if ( this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture ) {

			data.sheenRoughnessMap = this.sheenRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.dispersion !== undefined ) data.dispersion = this.dispersion;

		if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
		if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
		if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

		if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

			data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

		}

		if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

		}

		if ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;
		if ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;

		if ( this.anisotropyMap && this.anisotropyMap.isTexture ) {

			data.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		if ( this.lightMap && this.lightMap.isTexture ) {

			data.lightMap = this.lightMap.toJSON( meta ).uuid;
			data.lightMapIntensity = this.lightMapIntensity;

		}

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;

			if ( this.combine !== undefined ) data.combine = this.combine;

		}

		if ( this.envMapRotation !== undefined ) data.envMapRotation = this.envMapRotation.toArray();
		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.transmission !== undefined ) data.transmission = this.transmission;
		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
		if ( this.thickness !== undefined ) data.thickness = this.thickness;
		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
		if ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;
		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors === true ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = true;

		if ( this.blendSrc !== SrcAlphaFactor ) data.blendSrc = this.blendSrc;
		if ( this.blendDst !== OneMinusSrcAlphaFactor ) data.blendDst = this.blendDst;
		if ( this.blendEquation !== AddEquation ) data.blendEquation = this.blendEquation;
		if ( this.blendSrcAlpha !== null ) data.blendSrcAlpha = this.blendSrcAlpha;
		if ( this.blendDstAlpha !== null ) data.blendDstAlpha = this.blendDstAlpha;
		if ( this.blendEquationAlpha !== null ) data.blendEquationAlpha = this.blendEquationAlpha;
		if ( this.blendColor && this.blendColor.isColor ) data.blendColor = this.blendColor.getHex();
		if ( this.blendAlpha !== 0 ) data.blendAlpha = this.blendAlpha;

		if ( this.depthFunc !== LessEqualDepth ) data.depthFunc = this.depthFunc;
		if ( this.depthTest === false ) data.depthTest = this.depthTest;
		if ( this.depthWrite === false ) data.depthWrite = this.depthWrite;
		if ( this.colorWrite === false ) data.colorWrite = this.colorWrite;

		if ( this.stencilWriteMask !== 0xff ) data.stencilWriteMask = this.stencilWriteMask;
		if ( this.stencilFunc !== AlwaysStencilFunc ) data.stencilFunc = this.stencilFunc;
		if ( this.stencilRef !== 0 ) data.stencilRef = this.stencilRef;
		if ( this.stencilFuncMask !== 0xff ) data.stencilFuncMask = this.stencilFuncMask;
		if ( this.stencilFail !== KeepStencilOp ) data.stencilFail = this.stencilFail;
		if ( this.stencilZFail !== KeepStencilOp ) data.stencilZFail = this.stencilZFail;
		if ( this.stencilZPass !== KeepStencilOp ) data.stencilZPass = this.stencilZPass;
		if ( this.stencilWrite === true ) data.stencilWrite = this.stencilWrite;

		// rotation (SpriteMaterial)
		if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.alphaHash === true ) data.alphaHash = true;
		if ( this.alphaToCoverage === true ) data.alphaToCoverage = true;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = true;
		if ( this.forceSinglePass === true ) data.forceSinglePass = true;

		if ( this.wireframe === true ) data.wireframe = true;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.flatShading === true ) data.flatShading = true;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( this.fog === false ) data.fog = false;

		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRootObject ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	}

	/**
	 * Returns a new material with copied values from this instance.
	 *
	 * @return {Material} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Copies the values of the given material to this instance.
	 *
	 * @param {Material} source - The material to copy.
	 * @return {Material} A reference to this instance.
	 */
	copy( source ) {

		this.name = source.name;

		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;
		this.blendColor.copy( source.blendColor );
		this.blendAlpha = source.blendAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;

		if ( srcPlanes !== null ) {

			const n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( let i = 0; i !== n; ++ i ) {

				dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.alphaHash = source.alphaHash;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;
		this.forceSinglePass = source.forceSinglePass;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 *
	 * @fires Material#dispose
	 */
	dispose() {

		/**
		 * Fires when the material has been disposed of.
		 *
		 * @event Material#dispose
		 * @type {Object}
		 */
		this.dispatchEvent( { type: 'dispose' } );

	}

	/**
	 * Setting this property to `true` indicates the engine the material
	 * needs to be recompiled.
	 *
	 * @type {boolean}
	 * @default false
	 * @param {boolean} value
	 */
	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

}

/**
 * A material for drawing geometries in a simple shaded (flat or wireframe) way.
 *
 * This material is not affected by lights.
 *
 * @augments Material
 * @demo scenes/material-browser.html#MeshBasicMaterial
 */
class MeshBasicMaterial extends Material {

	/**
	 * Constructs a new mesh basic material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshBasicMaterial = true;

		this.type = 'MeshBasicMaterial';

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.color = new Color( 0xffffff ); // diffuse

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		 * color is modulated by the diffuse `color`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The light map. Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.lightMap = null;

		/**
		 * Intensity of the baked light.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.lightMapIntensity = 1.0;

		/**
		 * The red channel of this texture is used as the ambient occlusion map.
		 * Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.aoMap = null;

		/**
		 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
		 * disables ambient occlusion. Where intensity is `1` and the AO map's
		 * red channel is also `1`, ambient light is fully occluded on a surface.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.aoMapIntensity = 1.0;

		/**
		 * Specular map used by the material.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.specularMap = null;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * The environment map.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.envMap = null;

		/**
		 * The rotation of the environment map in radians.
		 *
		 * @type {Euler}
		 * @default (0,0,0)
		 */
		this.envMapRotation = new Euler();

		/**
		 * How to combine the result of the surface's color with the environment map, if any.
		 *
		 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
		 * blend between the two colors.
		 *
		 * @type {(MultiplyOperation|MixOperation|AddOperation)}
		 * @default MultiplyOperation
		 */
		this.combine = MultiplyOperation;

		/**
		 * How much the environment map affects the surface.
		 * The valid range is between `0` (no reflections) and `1` (full reflections).
		 *
		 * @type {number}
		 * @default 1
		 */
		this.reflectivity = 1;

		/**
		 * The index of refraction (IOR) of air (approximately 1) divided by the
		 * index of refraction of the material. It is used with environment mapping
		 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
		 * The refraction ratio should not exceed `1`.
		 *
		 * @type {number}
		 * @default 0.98
		 */
		this.refractionRatio = 0.98;

		/**
		 * Renders the geometry as a wireframe.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.wireframe = false;

		/**
		 * Controls the thickness of the wireframe.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.wireframeLinewidth = 1;

		/**
		 * Defines appearance of wireframe ends.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinecap = 'round';

		/**
		 * Defines appearance of wireframe joints.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinejoin = 'round';

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf

const _tables = /*@__PURE__*/ _generateTables();

function _generateTables() {

	// float32 to float16 helpers

	const buffer = new ArrayBuffer( 4 );
	const floatView = new Float32Array( buffer );
	const uint32View = new Uint32Array( buffer );

	const baseTable = new Uint32Array( 512 );
	const shiftTable = new Uint32Array( 512 );

	for ( let i = 0; i < 256; ++ i ) {

		const e = i - 127;

		// very small number (0, -0)

		if ( e < -27 ) {

			baseTable[ i ] = 0x0000;
			baseTable[ i | 0x100 ] = 0x8000;
			shiftTable[ i ] = 24;
			shiftTable[ i | 0x100 ] = 24;

			// small number (denorm)

		} else if ( e < -14 ) {

			baseTable[ i ] = 0x0400 >> ( - e - 14 );
			baseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;
			shiftTable[ i ] = - e - 1;
			shiftTable[ i | 0x100 ] = - e - 1;

			// normal number

		} else if ( e <= 15 ) {

			baseTable[ i ] = ( e + 15 ) << 10;
			baseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;
			shiftTable[ i ] = 13;
			shiftTable[ i | 0x100 ] = 13;

			// large number (Infinity, -Infinity)

		} else if ( e < 128 ) {

			baseTable[ i ] = 0x7c00;
			baseTable[ i | 0x100 ] = 0xfc00;
			shiftTable[ i ] = 24;
			shiftTable[ i | 0x100 ] = 24;

			// stay (NaN, Infinity, -Infinity)

		} else {

			baseTable[ i ] = 0x7c00;
			baseTable[ i | 0x100 ] = 0xfc00;
			shiftTable[ i ] = 13;
			shiftTable[ i | 0x100 ] = 13;

		}

	}

	// float16 to float32 helpers

	const mantissaTable = new Uint32Array( 2048 );
	const exponentTable = new Uint32Array( 64 );
	const offsetTable = new Uint32Array( 64 );

	for ( let i = 1; i < 1024; ++ i ) {

		let m = i << 13; // zero pad mantissa bits
		let e = 0; // zero exponent

		// normalized
		while ( ( m & 0x00800000 ) === 0 ) {

			m <<= 1;
			e -= 0x00800000; // decrement exponent

		}

		m &= -8388609; // clear leading 1 bit
		e += 0x38800000; // adjust bias

		mantissaTable[ i ] = m | e;

	}

	for ( let i = 1024; i < 2048; ++ i ) {

		mantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );

	}

	for ( let i = 1; i < 31; ++ i ) {

		exponentTable[ i ] = i << 23;

	}

	exponentTable[ 31 ] = 0x47800000;
	exponentTable[ 32 ] = 0x80000000;

	for ( let i = 33; i < 63; ++ i ) {

		exponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );

	}

	exponentTable[ 63 ] = 0xc7800000;

	for ( let i = 1; i < 64; ++ i ) {

		if ( i !== 32 ) {

			offsetTable[ i ] = 1024;

		}

	}

	return {
		floatView: floatView,
		uint32View: uint32View,
		baseTable: baseTable,
		shiftTable: shiftTable,
		mantissaTable: mantissaTable,
		exponentTable: exponentTable,
		offsetTable: offsetTable
	};

}

/**
 * Returns a half precision floating point value (FP16) from the given single
 * precision floating point value (FP32).
 *
 * @param {number} val - A single precision floating point value.
 * @return {number} The FP16 value.
 */
function toHalfFloat( val ) {

	if ( Math.abs( val ) > 65504 ) warn( 'DataUtils.toHalfFloat(): Value out of range.' );

	val = clamp( val, -65504, 65504 );

	_tables.floatView[ 0 ] = val;
	const f = _tables.uint32View[ 0 ];
	const e = ( f >> 23 ) & 0x1ff;
	return _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );

}

/**
 * Returns a single precision floating point value (FP32) from the given half
 * precision floating point value (FP16).
 *
 * @param {number} val - A half precision floating point value.
 * @return {number} The FP32 value.
 */
function fromHalfFloat( val ) {

	const m = val >> 10;
	_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];
	return _tables.floatView[ 0 ];

}

/**
 * A class containing utility functions for data.
 *
 * @hideconstructor
 */
class DataUtils {

	/**
	 * Returns a half precision floating point value (FP16) from the given single
	 * precision floating point value (FP32).
	 *
	 * @param {number} val - A single precision floating point value.
	 * @return {number} The FP16 value.
	 */
	static toHalfFloat( val ) {

		return toHalfFloat( val );

	}

	/**
	 * Returns a single precision floating point value (FP32) from the given half
	 * precision floating point value (FP16).
	 *
	 * @param {number} val - A half precision floating point value.
	 * @return {number} The FP32 value.
	 */
	static fromHalfFloat( val ) {

		return fromHalfFloat( val );

	}

}

const _vector$9 = /*@__PURE__*/ new Vector3();
const _vector2$1 = /*@__PURE__*/ new Vector2();

let _id$2 = 0;

/**
 * This class stores data for an attribute (such as vertex positions, face
 * indices, normals, colors, UVs, and any custom attributes ) associated with
 * a geometry, which allows for more efficient passing of data to the GPU.
 *
 * When working with vector-like data, the `fromBufferAttribute( attribute, index )`
 * helper methods on vector and color class might be helpful. E.g. {@link Vector3#fromBufferAttribute}.
 */
class BufferAttribute {

	/**
	 * Constructs a new buffer attribute.
	 *
	 * @param {TypedArray} array - The array holding the attribute data.
	 * @param {number} itemSize - The item size.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( array, itemSize, normalized = false ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isBufferAttribute = true;

		/**
		 * The ID of the buffer attribute.
		 *
		 * @name BufferAttribute#id
		 * @type {number}
		 * @readonly
		 */
		Object.defineProperty( this, 'id', { value: _id$2 ++ } );

		/**
		 * The name of the buffer attribute.
		 *
		 * @type {string}
		 */
		this.name = '';

		/**
		 * The array holding the attribute data. It should have `itemSize * numVertices`
		 * elements, where `numVertices` is the number of vertices in the associated geometry.
		 *
		 * @type {TypedArray}
		 */
		this.array = array;

		/**
		 * The number of values of the array that should be associated with a particular vertex.
		 * For instance, if this attribute is storing a 3-component vector (such as a position,
		 * normal, or color), then the value should be `3`.
		 *
		 * @type {number}
		 */
		this.itemSize = itemSize;

		/**
		 * Represents the number of items this buffer attribute stores. It is internally computed
		 * by dividing the `array` length by the `itemSize`.
		 *
		 * @type {number}
		 * @readonly
		 */
		this.count = array !== undefined ? array.length / itemSize : 0;

		/**
		 * Applies to integer data only. Indicates how the underlying data in the buffer maps to
		 * the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
		 * and `normalized` is `true`, the values `0 - +65535` in the array data will be mapped to
		 * `0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
		 * to floats unmodified, i.e. `65535` becomes `65535.0f`.
		 *
		 * @type {boolean}
		 */
		this.normalized = normalized;

		/**
		 * Defines the intended usage pattern of the data store for optimization purposes.
		 *
		 * Note: After the initial use of a buffer, its usage cannot be changed. Instead,
		 * instantiate a new one and set the desired usage before the next render.
		 *
		 * @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}
		 * @default StaticDrawUsage
		 */
		this.usage = StaticDrawUsage;

		/**
		 * This can be used to only update some components of stored vectors (for example, just the
		 * component related to color). Use the `addUpdateRange()` function to add ranges to this array.
		 *
		 * @type {Array<Object>}
		 */
		this.updateRanges = [];

		/**
		 * Configures the bound GPU type for use in shaders.
		 *
		 * Note: this only has an effect for integer arrays and is not configurable for float arrays.
		 * For lower precision float types, use `Float16BufferAttribute`.
		 *
		 * @type {(FloatType|IntType)}
		 * @default FloatType
		 */
		this.gpuType = FloatType;

		/**
		 * A version number, incremented every time the `needsUpdate` is set to `true`.
		 *
		 * @type {number}
		 */
		this.version = 0;

	}

	/**
	 * A callback function that is executed after the renderer has transferred the attribute
	 * array data to the GPU.
	 */
	onUploadCallback() {}

	/**
	 * Flag to indicate that this attribute has changed and should be re-sent to
	 * the GPU. Set this to `true` when you modify the value of the array.
	 *
	 * @type {number}
	 * @default false
	 * @param {boolean} value
	 */
	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	/**
	 * Sets the usage of this buffer attribute.
	 *
	 * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
	 * @return {BufferAttribute} A reference to this buffer attribute.
	 */
	setUsage( value ) {

		this.usage = value;

		return this;

	}

	/**
	 * Adds a range of data in the data array to be updated on the GPU.
	 *
	 * @param {number} start - Position at which to start update.
	 * @param {number} count - The number of components to update.
	 */
	addUpdateRange( start, count ) {

		this.updateRanges.push( { start, count } );

	}

	/**
	 * Clears the update ranges.
	 */
	clearUpdateRanges() {

		this.updateRanges.length = 0;

	}

	/**
	 * Copies the values of the given buffer attribute to this instance.
	 *
	 * @param {BufferAttribute} source - The buffer attribute to copy.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	copy( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;
		this.gpuType = source.gpuType;

		return this;

	}

	/**
	 * Copies a vector from the given buffer attribute to this one. The start
	 * and destination position in the attribute buffers are represented by the
	 * given indices.
	 *
	 * @param {number} index1 - The destination index into this buffer attribute.
	 * @param {BufferAttribute} attribute - The buffer attribute to copy from.
	 * @param {number} index2 - The source index into the given buffer attribute.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	copyAt( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	/**
	 * Copies the given array data into this buffer attribute.
	 *
	 * @param {(TypedArray|Array)} array - The array to copy.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	copyArray( array ) {

		this.array.set( array );

		return this;

	}

	/**
	 * Applies the given 3x3 matrix to the given attribute. Works with
	 * item size `2` and `3`.
	 *
	 * @param {Matrix3} m - The matrix to apply.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	applyMatrix3( m ) {

		if ( this.itemSize === 2 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector2$1.fromBufferAttribute( this, i );
				_vector2$1.applyMatrix3( m );

				this.setXY( i, _vector2$1.x, _vector2$1.y );

			}

		} else if ( this.itemSize === 3 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.fromBufferAttribute( this, i );
				_vector$9.applyMatrix3( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

		}

		return this;

	}

	/**
	 * Applies the given 4x4 matrix to the given attribute. Only works with
	 * item size `3`.
	 *
	 * @param {Matrix4} m - The matrix to apply.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	applyMatrix4( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyMatrix4( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	/**
	 * Applies the given 3x3 normal matrix to the given attribute. Only works with
	 * item size `3`.
	 *
	 * @param {Matrix3} m - The normal matrix to apply.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyNormalMatrix( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	/**
	 * Applies the given 4x4 matrix to the given attribute. Only works with
	 * item size `3` and with direction vectors.
	 *
	 * @param {Matrix4} m - The matrix to apply.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.transformDirection( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	/**
	 * Sets the given array data in the buffer attribute.
	 *
	 * @param {(TypedArray|Array)} value - The array data to set.
	 * @param {number} [offset=0] - The offset in this buffer attribute's array.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	set( value, offset = 0 ) {

		// Matching BufferAttribute constructor, do not normalize the array.
		this.array.set( value, offset );

		return this;

	}

	/**
	 * Returns the given component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} component - The component index.
	 * @return {number} The returned value.
	 */
	getComponent( index, component ) {

		let value = this.array[ index * this.itemSize + component ];

		if ( this.normalized ) value = denormalize( value, this.array );

		return value;

	}

	/**
	 * Sets the given value to the given component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} component - The component index.
	 * @param {number} value - The value to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setComponent( index, component, value ) {

		if ( this.normalized ) value = normalize$1( value, this.array );

		this.array[ index * this.itemSize + component ] = value;

		return this;

	}

	/**
	 * Returns the x component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The x component.
	 */
	getX( index ) {

		let x = this.array[ index * this.itemSize ];

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	/**
	 * Sets the x component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setX( index, x ) {

		if ( this.normalized ) x = normalize$1( x, this.array );

		this.array[ index * this.itemSize ] = x;

		return this;

	}

	/**
	 * Returns the y component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The y component.
	 */
	getY( index ) {

		let y = this.array[ index * this.itemSize + 1 ];

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	/**
	 * Sets the y component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} y - The value to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setY( index, y ) {

		if ( this.normalized ) y = normalize$1( y, this.array );

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	}

	/**
	 * Returns the z component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The z component.
	 */
	getZ( index ) {

		let z = this.array[ index * this.itemSize + 2 ];

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	/**
	 * Sets the z component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} z - The value to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setZ( index, z ) {

		if ( this.normalized ) z = normalize$1( z, this.array );

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	}

	/**
	 * Returns the w component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The w component.
	 */
	getW( index ) {

		let w = this.array[ index * this.itemSize + 3 ];

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	/**
	 * Sets the w component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} w - The value to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setW( index, w ) {

		if ( this.normalized ) w = normalize$1( w, this.array );

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	}

	/**
	 * Sets the x and y component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value for the x component to set.
	 * @param {number} y - The value for the y component to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setXY( index, x, y ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize$1( x, this.array );
			y = normalize$1( y, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	}

	/**
	 * Sets the x, y and z component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value for the x component to set.
	 * @param {number} y - The value for the y component to set.
	 * @param {number} z - The value for the z component to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize$1( x, this.array );
			y = normalize$1( y, this.array );
			z = normalize$1( z, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	}

	/**
	 * Sets the x, y, z and w component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value for the x component to set.
	 * @param {number} y - The value for the y component to set.
	 * @param {number} z - The value for the z component to set.
	 * @param {number} w - The value for the w component to set.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize$1( x, this.array );
			y = normalize$1( y, this.array );
			z = normalize$1( z, this.array );
			w = normalize$1( w, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	}

	/**
	 * Sets the given callback function that is executed after the Renderer has transferred
	 * the attribute array data to the GPU. Can be used to perform clean-up operations after
	 * the upload when attribute data are not needed anymore on the CPU side.
	 *
	 * @param {Function} callback - The `onUpload()` callback.
	 * @return {BufferAttribute} A reference to this instance.
	 */
	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	/**
	 * Returns a new buffer attribute with copied values from this instance.
	 *
	 * @return {BufferAttribute} A clone of this instance.
	 */
	clone() {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	}

	/**
	 * Serializes the buffer attribute into JSON.
	 *
	 * @return {Object} A JSON object representing the serialized buffer attribute.
	 */
	toJSON() {

		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.from( this.array ),
			normalized: this.normalized
		};

		if ( this.name !== '' ) data.name = this.name;
		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;

		return data;

	}

}

/**
 * Convenient class that can be used when creating a `UInt16` buffer attribute with
 * a plain `Array` instance.
 *
 * @augments BufferAttribute
 */
class Uint16BufferAttribute extends BufferAttribute {

	/**
	 * Constructs a new buffer attribute.
	 *
	 * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
	 * @param {number} itemSize - The item size.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

	}

}

/**
 * Convenient class that can be used when creating a `UInt32` buffer attribute with
 * a plain `Array` instance.
 *
 * @augments BufferAttribute
 */
class Uint32BufferAttribute extends BufferAttribute {

	/**
	 * Constructs a new buffer attribute.
	 *
	 * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
	 * @param {number} itemSize - The item size.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( array, itemSize, normalized ) {

		super( new Uint32Array( array ), itemSize, normalized );

	}

}

/**
 * Convenient class that can be used when creating a `Float32` buffer attribute with
 * a plain `Array` instance.
 *
 * @augments BufferAttribute
 */
class Float32BufferAttribute extends BufferAttribute {

	/**
	 * Constructs a new buffer attribute.
	 *
	 * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
	 * @param {number} itemSize - The item size.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( array, itemSize, normalized ) {

		super( new Float32Array( array ), itemSize, normalized );

	}

}

let _id$1 = 0;

const _m1$3 = /*@__PURE__*/ new Matrix4();
const _obj = /*@__PURE__*/ new Object3D();
const _offset = /*@__PURE__*/ new Vector3();
const _box$2 = /*@__PURE__*/ new Box3();
const _boxMorphTargets = /*@__PURE__*/ new Box3();
const _vector$8 = /*@__PURE__*/ new Vector3();

/**
 * A representation of mesh, line, or point geometry. Includes vertex
 * positions, face indices, normals, colors, UVs, and custom attributes
 * within buffers, reducing the cost of passing all this data to the GPU.
 *
 * ```js
 * const geometry = new THREE.BufferGeometry();
 * // create a simple square shape. We duplicate the top left and bottom right
 * // vertices because each vertex needs to appear once per triangle.
 * const vertices = new Float32Array( [
 * 	-1.0, -1.0,  1.0, // v0
 * 	 1.0, -1.0,  1.0, // v1
 * 	 1.0,  1.0,  1.0, // v2
 *
 * 	 1.0,  1.0,  1.0, // v3
 * 	-1.0,  1.0,  1.0, // v4
 * 	-1.0, -1.0,  1.0  // v5
 * ] );
 * // itemSize = 3 because there are 3 values (components) per vertex
 * geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
 * const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
 * const mesh = new THREE.Mesh( geometry, material );
 * ```
 *
 * @augments EventDispatcher
 */
class BufferGeometry extends EventDispatcher {

	/**
	 * Constructs a new geometry.
	 */
	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isBufferGeometry = true;

		/**
		 * The ID of the geometry.
		 *
		 * @name BufferGeometry#id
		 * @type {number}
		 * @readonly
		 */
		Object.defineProperty( this, 'id', { value: _id$1 ++ } );

		/**
		 * The UUID of the geometry.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.uuid = generateUUID();

		/**
		 * The name of the geometry.
		 *
		 * @type {string}
		 */
		this.name = '';
		this.type = 'BufferGeometry';

		/**
		 * Allows for vertices to be re-used across multiple triangles; this is
		 * called using "indexed triangles". Each triangle is associated with the
		 * indices of three vertices. This attribute therefore stores the index of
		 * each vertex for each triangular face. If this attribute is not set, the
		 * renderer assumes that each three contiguous positions represent a single triangle.
		 *
		 * @type {?BufferAttribute}
		 * @default null
		 */
		this.index = null;

		/**
		 * A (storage) buffer attribute which was generated with a compute shader and
		 * now defines indirect draw calls.
		 *
		 * Can only be used with {@link WebGPURenderer} and a WebGPU backend.
		 *
		 * @type {?BufferAttribute}
		 * @default null
		 */
		this.indirect = null;

		/**
		 * This dictionary has as id the name of the attribute to be set and as value
		 * the buffer attribute to set it to. Rather than accessing this property directly,
		 * use `setAttribute()` and `getAttribute()` to access attributes of this geometry.
		 *
		 * @type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}
		 */
		this.attributes = {};

		/**
		 * This dictionary holds the morph targets of the geometry.
		 *
		 * Note: Once the geometry has been rendered, the morph attribute data cannot
		 * be changed. You will have to call `dispose()?, and create a new geometry instance.
		 *
		 * @type {Object}
		 */
		this.morphAttributes = {};

		/**
		 * Used to control the morph target behavior; when set to `true`, the morph
		 * target data is treated as relative offsets, rather than as absolute
		 * positions/normals.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.morphTargetsRelative = false;

		/**
		 * Split the geometry into groups, each of which will be rendered in a
		 * separate draw call. This allows an array of materials to be used with the geometry.
		 *
		 * Use `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.
		 *
		 * Every vertex and index must belong to exactly one group — groups must not share vertices or
		 * indices, and must not leave vertices or indices unused.
		 *
		 * @type {Array<Object>}
		 */
		this.groups = [];

		/**
		 * Bounding box for the geometry which can be calculated with `computeBoundingBox()`.
		 *
		 * @type {?Box3}
		 * @default null
		 */
		this.boundingBox = null;

		/**
		 * Bounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.
		 *
		 * @type {?Sphere}
		 * @default null
		 */
		this.boundingSphere = null;

		/**
		 * Determines the part of the geometry to render. This should not be set directly,
		 * instead use `setDrawRange()`.
		 *
		 * @type {{start:number,count:number}}
		 */
		this.drawRange = { start: 0, count: Infinity };

		/**
		 * An object that can be used to store custom data about the geometry.
		 * It should not hold references to functions as these will not be cloned.
		 *
		 * @type {Object}
		 */
		this.userData = {};

	}

	/**
	 * Returns the index of this geometry.
	 *
	 * @return {?BufferAttribute} The index. Returns `null` if no index is defined.
	 */
	getIndex() {

		return this.index;

	}

	/**
	 * Sets the given index to this geometry.
	 *
	 * @param {Array<number>|BufferAttribute} index - The index to set.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	setIndex( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

		return this;

	}

	/**
	 * Sets the given indirect attribute to this geometry.
	 *
	 * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	setIndirect( indirect ) {

		this.indirect = indirect;

		return this;

	}

	/**
	 * Returns the indirect attribute of this geometry.
	 *
	 * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
	 */
	getIndirect() {

		return this.indirect;

	}

	/**
	 * Returns the buffer attribute for the given name.
	 *
	 * @param {string} name - The attribute name.
	 * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
	 * Returns `undefined` if not attribute has been found.
	 */
	getAttribute( name ) {

		return this.attributes[ name ];

	}

	/**
	 * Sets the given attribute for the given name.
	 *
	 * @param {string} name - The attribute name.
	 * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	setAttribute( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	}

	/**
	 * Deletes the attribute for the given name.
	 *
	 * @param {string} name - The attribute name to delete.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	deleteAttribute( name ) {

		delete this.attributes[ name ];

		return this;

	}

	/**
	 * Returns `true` if this geometry has an attribute for the given name.
	 *
	 * @param {string} name - The attribute name.
	 * @return {boolean} Whether this geometry has an attribute for the given name or not.
	 */
	hasAttribute( name ) {

		return this.attributes[ name ] !== undefined;

	}

	/**
	 * Adds a group to this geometry.
	 *
	 * @param {number} start - The first element in this draw call. That is the first
	 * vertex for non-indexed geometry, otherwise the first triangle index.
	 * @param {number} count - Specifies how many vertices (or indices) are part of this group.
	 * @param {number} [materialIndex=0] - The material array index to use.
	 */
	addGroup( start, count, materialIndex = 0 ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	}

	/**
	 * Clears all groups.
	 */
	clearGroups() {

		this.groups = [];

	}

	/**
	 * Sets the draw range for this geometry.
	 *
	 * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
	 * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
	 * For indexed BufferGeometry, `count` is the number of indices to render.
	 */
	setDrawRange( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	}

	/**
	 * Applies the given 4x4 transformation matrix to the geometry.
	 *
	 * @param {Matrix4} matrix - The matrix to apply.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	applyMatrix4( matrix ) {

		const position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		const normal = this.attributes.normal;

		if ( normal !== undefined ) {

			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		const tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	}

	/**
	 * Applies the rotation represented by the Quaternion to the geometry.
	 *
	 * @param {Quaternion} q - The Quaternion to apply.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	applyQuaternion( q ) {

		_m1$3.makeRotationFromQuaternion( q );

		this.applyMatrix4( _m1$3 );

		return this;

	}

	/**
	 * Rotates the geometry about the X axis. This is typically done as a one time
	 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
	 * real-time mesh rotation.
	 *
	 * @param {number} angle - The angle in radians.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	rotateX( angle ) {

		// rotate geometry around world x-axis

		_m1$3.makeRotationX( angle );

		this.applyMatrix4( _m1$3 );

		return this;

	}

	/**
	 * Rotates the geometry about the Y axis. This is typically done as a one time
	 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
	 * real-time mesh rotation.
	 *
	 * @param {number} angle - The angle in radians.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	rotateY( angle ) {

		// rotate geometry around world y-axis

		_m1$3.makeRotationY( angle );

		this.applyMatrix4( _m1$3 );

		return this;

	}

	/**
	 * Rotates the geometry about the Z axis. This is typically done as a one time
	 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
	 * real-time mesh rotation.
	 *
	 * @param {number} angle - The angle in radians.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	rotateZ( angle ) {

		// rotate geometry around world z-axis

		_m1$3.makeRotationZ( angle );

		this.applyMatrix4( _m1$3 );

		return this;

	}

	/**
	 * Translates the geometry. This is typically done as a one time
	 * operation, and not during a loop. Use {@link Object3D#position} for typical
	 * real-time mesh rotation.
	 *
	 * @param {number} x - The x offset.
	 * @param {number} y - The y offset.
	 * @param {number} z - The z offset.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	translate( x, y, z ) {

		// translate geometry

		_m1$3.makeTranslation( x, y, z );

		this.applyMatrix4( _m1$3 );

		return this;

	}

	/**
	 * Scales the geometry. This is typically done as a one time
	 * operation, and not during a loop. Use {@link Object3D#scale} for typical
	 * real-time mesh rotation.
	 *
	 * @param {number} x - The x scale.
	 * @param {number} y - The y scale.
	 * @param {number} z - The z scale.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	scale( x, y, z ) {

		// scale geometry

		_m1$3.makeScale( x, y, z );

		this.applyMatrix4( _m1$3 );

		return this;

	}

	/**
	 * Rotates the geometry to face a point in 3D space. This is typically done as a one time
	 * operation, and not during a loop. Use {@link Object3D#lookAt} for typical
	 * real-time mesh rotation.
	 *
	 * @param {Vector3} vector - The target point.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	lookAt( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	}

	/**
	 * Center the geometry based on its bounding box.
	 *
	 * @return {BufferGeometry} A reference to this instance.
	 */
	center() {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	}

	/**
	 * Defines a geometry by creating a `position` attribute based on the given array of points. The array
	 * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
	 * set to `0`.
	 *
	 * If the method is used with an existing `position` attribute, the vertex data are overwritten with the
	 * data from the array. The length of the array must match the vertex count.
	 *
	 * @param {Array<Vector2>|Array<Vector3>} points - The points.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	setFromPoints( points ) {

		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute === undefined ) {

			const position = [];

			for ( let i = 0, l = points.length; i < l; i ++ ) {

				const point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		} else {

			const l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size

			for ( let i = 0; i < l; i ++ ) {

				const point = points[ i ];
				positionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );

			}

			if ( points.length > positionAttribute.count ) {

				warn( 'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );

			}

			positionAttribute.needsUpdate = true;

		}

		return this;

	}

	/**
	 * Computes the bounding box of the geometry, and updates the `boundingBox` member.
	 * The bounding box is not computed by the engine; it must be computed by your app.
	 * You may need to recompute the bounding box if the geometry vertices are modified.
	 */
	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			error( 'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );

			this.boundingBox.set(
				new Vector3( - Infinity, - Infinity, - Infinity ),
				new Vector3( + Infinity, + Infinity, + Infinity )
			);

			return;

		}

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_box$2.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( this.boundingBox.min, _box$2.min );
						this.boundingBox.expandByPoint( _vector$8 );

						_vector$8.addVectors( this.boundingBox.max, _box$2.max );
						this.boundingBox.expandByPoint( _vector$8 );

					} else {

						this.boundingBox.expandByPoint( _box$2.min );
						this.boundingBox.expandByPoint( _box$2.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			error( 'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	}

	/**
	 * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
	 * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
	 * You may need to recompute the bounding sphere if the geometry vertices are modified.
	 */
	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			error( 'BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );

			this.boundingSphere.set( new Vector3(), Infinity );

			return;

		}

		if ( position ) {

			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;

			_box$2.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( _box$2.min, _boxMorphTargets.min );
						_box$2.expandByPoint( _vector$8 );

						_vector$8.addVectors( _box$2.max, _boxMorphTargets.max );
						_box$2.expandByPoint( _vector$8 );

					} else {

						_box$2.expandByPoint( _boxMorphTargets.min );
						_box$2.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$2.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;

			for ( let i = 0, il = position.count; i < il; i ++ ) {

				_vector$8.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					const morphTargetsRelative = this.morphTargetsRelative;

					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$8.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$8.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				error( 'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	}

	/**
	 * Calculates and adds a tangent attribute to this geometry.
	 *
	 * The computation is only supported for indexed geometries and if position, normal, and uv attributes
	 * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
	 * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
	 */
	computeTangents() {

		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( index === null ||
			 attributes.position === undefined ||
			 attributes.normal === undefined ||
			 attributes.uv === undefined ) {

			error( 'BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			return;

		}

		const positionAttribute = attributes.position;
		const normalAttribute = attributes.normal;
		const uvAttribute = attributes.uv;

		if ( this.hasAttribute( 'tangent' ) === false ) {

			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );

		}

		const tangentAttribute = this.getAttribute( 'tangent' );

		const tan1 = [], tan2 = [];

		for ( let i = 0; i < positionAttribute.count; i ++ ) {

			tan1[ i ] = new Vector3();
			tan2[ i ] = new Vector3();

		}

		const vA = new Vector3(),
			vB = new Vector3(),
			vC = new Vector3(),

			uvA = new Vector2(),
			uvB = new Vector2(),
			uvC = new Vector2(),

			sdir = new Vector3(),
			tdir = new Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromBufferAttribute( positionAttribute, a );
			vB.fromBufferAttribute( positionAttribute, b );
			vC.fromBufferAttribute( positionAttribute, c );

			uvA.fromBufferAttribute( uvAttribute, a );
			uvB.fromBufferAttribute( uvAttribute, b );
			uvC.fromBufferAttribute( uvAttribute, c );

			vB.sub( vA );
			vC.sub( vA );

			uvB.sub( uvA );
			uvC.sub( uvA );

			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if ( ! isFinite( r ) ) return;

			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		let groups = this.groups;

		if ( groups.length === 0 ) {

			groups = [ {
				start: 0,
				count: index.count
			} ];

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleTriangle(
					index.getX( j + 0 ),
					index.getX( j + 1 ),
					index.getX( j + 2 )
				);

			}

		}

		const tmp = new Vector3(), tmp2 = new Vector3();
		const n = new Vector3(), n2 = new Vector3();

		function handleVertex( v ) {

			n.fromBufferAttribute( normalAttribute, v );
			n2.copy( n );

			const t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			const test = tmp2.dot( tan2[ v ] );
			const w = ( test < 0.0 ) ? -1 : 1.0;

			tangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleVertex( index.getX( j + 0 ) );
				handleVertex( index.getX( j + 1 ) );
				handleVertex( index.getX( j + 2 ) );

			}

		}

	}

	/**
	 * Computes vertex normals for the given vertex data. For indexed geometries, the method sets
	 * each vertex normal to be the average of the face normals of the faces that share that vertex.
	 * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
	 * to be the same as the face normal.
	 */
	computeVertexNormals() {

		const index = this.index;
		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute !== undefined ) {

			let normalAttribute = this.getAttribute( 'normal' );

			if ( normalAttribute === undefined ) {

				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
				this.setAttribute( 'normal', normalAttribute );

			} else {

				// reset existing normals to zero

				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					normalAttribute.setXYZ( i, 0, 0, 0 );

				}

			}

			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
			const cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				for ( let i = 0, il = index.count; i < il; i += 3 ) {

					const vA = index.getX( i + 0 );
					const vB = index.getX( i + 1 );
					const vC = index.getX( i + 2 );

					pA.fromBufferAttribute( positionAttribute, vA );
					pB.fromBufferAttribute( positionAttribute, vB );
					pC.fromBufferAttribute( positionAttribute, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					nA.fromBufferAttribute( normalAttribute, vA );
					nB.fromBufferAttribute( normalAttribute, vB );
					nC.fromBufferAttribute( normalAttribute, vC );

					nA.add( cb );
					nB.add( cb );
					nC.add( cb );

					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					pA.fromBufferAttribute( positionAttribute, i + 0 );
					pB.fromBufferAttribute( positionAttribute, i + 1 );
					pC.fromBufferAttribute( positionAttribute, i + 2 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				}

			}

			this.normalizeNormals();

			normalAttribute.needsUpdate = true;

		}

	}

	/**
	 * Ensures every normal vector in a geometry will have a magnitude of `1`. This will
	 * correct lighting on the geometry surfaces.
	 */
	normalizeNormals() {

		const normals = this.attributes.normal;

		for ( let i = 0, il = normals.count; i < il; i ++ ) {

			_vector$8.fromBufferAttribute( normals, i );

			_vector$8.normalize();

			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

		}

	}

	/**
	 * Return a new non-index version of this indexed geometry. If the geometry
	 * is already non-indexed, the method is a NOOP.
	 *
	 * @return {BufferGeometry} The non-indexed version of this indexed geometry.
	 */
	toNonIndexed() {

		function convertBufferAttribute( attribute, indices ) {

			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;

			const array2 = new array.constructor( indices.length * itemSize );

			let index = 0, index2 = 0;

			for ( let i = 0, l = indices.length; i < l; i ++ ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					index = indices[ i ] * attribute.data.stride + attribute.offset;

				} else {

					index = indices[ i ] * itemSize;

				}

				for ( let j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			warn( 'BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			return this;

		}

		const geometry2 = new BufferGeometry();

		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			const newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		const morphAttributes = this.morphAttributes;

		for ( const name in morphAttributes ) {

			const morphArray = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const attribute = morphAttribute[ i ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	}

	/**
	 * Serializes the geometry into JSON.
	 *
	 * @return {Object} A JSON object representing the serialized geometry.
	 */
	toJSON() {

		const data = {
			metadata: {
				version: 4.7,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		// for simplicity the code assumes attributes are not shared across geometries, see #15811

		data.data = { attributes: {} };

		const index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			data.data.attributes[ key ] = attribute.toJSON( data.data );

		}

		const morphAttributes = {};
		let hasMorphAttributes = false;

		for ( const key in this.morphAttributes ) {

			const attributeArray = this.morphAttributes[ key ];

			const array = [];

			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				const attribute = attributeArray[ i ];

				array.push( attribute.toJSON( data.data ) );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		const groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		const boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = boundingSphere.toJSON();

		}

		return data;

	}

	/**
	 * Returns a new geometry with copied values from this instance.
	 *
	 * @return {BufferGeometry} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Copies the values of the given geometry to this instance.
	 *
	 * @param {BufferGeometry} source - The geometry to copy.
	 * @return {BufferGeometry} A reference to this instance.
	 */
	copy( source ) {

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		// attributes

		const attributes = source.attributes;

		for ( const name in attributes ) {

			const attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone( data ) );

		}

		// morph attributes

		const morphAttributes = source.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone( data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		return this;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 *
	 * @fires BufferGeometry#dispose
	 */
	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

const _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();
const _ray$3 = /*@__PURE__*/ new Ray();
const _sphere$6 = /*@__PURE__*/ new Sphere();
const _sphereHitAt = /*@__PURE__*/ new Vector3();

const _vA$1 = /*@__PURE__*/ new Vector3();
const _vB$1 = /*@__PURE__*/ new Vector3();
const _vC$1 = /*@__PURE__*/ new Vector3();

const _tempA = /*@__PURE__*/ new Vector3();
const _morphA = /*@__PURE__*/ new Vector3();

const _intersectionPoint = /*@__PURE__*/ new Vector3();
const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

/**
 * Class representing triangular polygon mesh based objects.
 *
 * ```js
 * const geometry = new THREE.BoxGeometry( 1, 1, 1 );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const mesh = new THREE.Mesh( geometry, material );
 * scene.add( mesh );
 * ```
 *
 * @augments Object3D
 */
class Mesh extends Object3D {

	/**
	 * Constructs a new mesh.
	 *
	 * @param {BufferGeometry} [geometry] - The mesh geometry.
	 * @param {Material|Array<Material>} [material] - The mesh material.
	 */
	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMesh = true;

		this.type = 'Mesh';

		/**
		 * The mesh geometry.
		 *
		 * @type {BufferGeometry}
		 */
		this.geometry = geometry;

		/**
		 * The mesh material.
		 *
		 * @type {Material|Array<Material>}
		 * @default MeshBasicMaterial
		 */
		this.material = material;

		/**
		 * A dictionary representing the morph targets in the geometry. The key is the
		 * morph targets name, the value its attribute index. This member is `undefined`
		 * by default and only set when morph targets are detected in the geometry.
		 *
		 * @type {Object<String,number>|undefined}
		 * @default undefined
		 */
		this.morphTargetDictionary = undefined;

		/**
		 * An array of weights typically in the range `[0,1]` that specify how much of the morph
		 * is applied. This member is `undefined` by default and only set when morph targets are
		 * detected in the geometry.
		 *
		 * @type {Array<number>|undefined}
		 * @default undefined
		 */
		this.morphTargetInfluences = undefined;

		/**
		 * The number of instances of this mesh.
		 * Can only be used with {@link WebGPURenderer}.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.count = 1;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
		this.geometry = source.geometry;

		return this;

	}

	/**
	 * Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}
	 * to make sure existing morph targets can influence this 3D object.
	 */
	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

	/**
	 * Returns the local-space position of the vertex at the given index, taking into
	 * account the current animation state of both morph targets and skinning.
	 *
	 * @param {number} index - The vertex index.
	 * @param {Vector3} target - The target object that is used to store the method's result.
	 * @return {Vector3} The vertex position in local space.
	 */
	getVertexPosition( index, target ) {

		const geometry = this.geometry;
		const position = geometry.attributes.position;
		const morphPosition = geometry.morphAttributes.position;
		const morphTargetsRelative = geometry.morphTargetsRelative;

		target.fromBufferAttribute( position, index );

		const morphInfluences = this.morphTargetInfluences;

		if ( morphPosition && morphInfluences ) {

			_morphA.set( 0, 0, 0 );

			for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

				const influence = morphInfluences[ i ];
				const morphAttribute = morphPosition[ i ];

				if ( influence === 0 ) continue;

				_tempA.fromBufferAttribute( morphAttribute, index );

				if ( morphTargetsRelative ) {

					_morphA.addScaledVector( _tempA, influence );

				} else {

					_morphA.addScaledVector( _tempA.sub( target ), influence );

				}

			}

			target.add( _morphA );

		}

		return target;

	}

	/**
	 * Computes intersection points between a casted ray and this line.
	 *
	 * @param {Raycaster} raycaster - The raycaster.
	 * @param {Array<Object>} intersects - The target array that holds the intersection points.
	 */
	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// test with bounding sphere in world space

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$6.copy( geometry.boundingSphere );
		_sphere$6.applyMatrix4( matrixWorld );

		// check distance from ray origin to bounding sphere

		_ray$3.copy( raycaster.ray ).recast( raycaster.near );

		if ( _sphere$6.containsPoint( _ray$3.origin ) === false ) {

			if ( _ray$3.intersectSphere( _sphere$6, _sphereHitAt ) === null ) return;

			if ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;

		}

		// convert ray to local space of mesh

		_inverseMatrix$3.copy( matrixWorld ).invert();
		_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );

		// test with bounding box in local space

		if ( geometry.boundingBox !== null ) {

			if ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		// test for intersections with geometry

		this._computeIntersections( raycaster, intersects, _ray$3 );

	}

	_computeIntersections( raycaster, intersects, rayLocalSpace ) {

		let intersection;

		const geometry = this.geometry;
		const material = this.material;

		const index = geometry.index;
		const position = geometry.attributes.position;
		const uv = geometry.attributes.uv;
		const uv1 = geometry.attributes.uv1;
		const normal = geometry.attributes.normal;
		const groups = geometry.groups;
		const drawRange = geometry.drawRange;

		if ( index !== null ) {

			// indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = index.getX( j );
						const b = index.getX( j + 1 );
						const c = index.getX( j + 2 );

						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = index.getX( i );
					const b = index.getX( i + 1 );
					const c = index.getX( i + 2 );

					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		} else if ( position !== undefined ) {

			// non-indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = j;
						const b = j + 1;
						const c = j + 2;

						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = i;
					const b = i + 1;
					const c = i + 2;

					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		}

	}

}

function checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {

	let intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {

	object.getVertexPosition( a, _vA$1 );
	object.getVertexPosition( b, _vB$1 );
	object.getVertexPosition( c, _vC$1 );

	const intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

	if ( intersection ) {

		const barycoord = new Vector3();
		Triangle.getBarycoord( _intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord );

		if ( uv ) {

			intersection.uv = Triangle.getInterpolatedAttribute( uv, a, b, c, barycoord, new Vector2() );

		}

		if ( uv1 ) {

			intersection.uv1 = Triangle.getInterpolatedAttribute( uv1, a, b, c, barycoord, new Vector2() );

		}

		if ( normal ) {

			intersection.normal = Triangle.getInterpolatedAttribute( normal, a, b, c, barycoord, new Vector3() );

			if ( intersection.normal.dot( ray.direction ) > 0 ) {

				intersection.normal.multiplyScalar( -1 );

			}

		}

		const face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3(),
			materialIndex: 0
		};

		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

		intersection.face = face;
		intersection.barycoord = barycoord;

	}

	return intersection;

}

/**
 * A geometry class for a rectangular cuboid with a given width, height, and depth.
 * On creation, the cuboid is centred on the origin, with each edge parallel to one
 * of the axes.
 *
 * ```js
 * const geometry = new THREE.BoxGeometry( 1, 1, 1 );
 * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
 * const cube = new THREE.Mesh( geometry, material );
 * scene.add( cube );
 * ```
 *
 * @augments BufferGeometry
 * @demo scenes/geometry-browser.html#BoxGeometry
 */
class BoxGeometry extends BufferGeometry {

	/**
	 * Constructs a new box geometry.
	 *
	 * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
	 * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
	 * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
	 * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
	 * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
	 * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
	 */
	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		super();

		this.type = 'BoxGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		const scope = this;

		// segments

		widthSegments = Math.floor( widthSegments );
		heightSegments = Math.floor( heightSegments );
		depthSegments = Math.floor( depthSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, -1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, -1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', -1, -1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : -1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {BoxGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

	}

}

/**
 * Provides utility functions for managing uniforms.
 *
 * @module UniformsUtils
 */

/**
 * Clones the given uniform definitions by performing a deep-copy. That means
 * if the value of a uniform refers to an object like a Vector3 or Texture,
 * the cloned uniform will refer to a new object reference.
 *
 * @param {Object} src - An object representing uniform definitions.
 * @return {Object} The cloned uniforms.
 */
function cloneUniforms( src ) {

	const dst = {};

	for ( const u in src ) {

		dst[ u ] = {};

		for ( const p in src[ u ] ) {

			const property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture || property.isQuaternion ) ) {

				if ( property.isRenderTargetTexture ) {

					warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );
					dst[ u ][ p ] = null;

				} else {

					dst[ u ][ p ] = property.clone();

				}

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

/**
 * Merges the given uniform definitions into a single object. Since the
 * method internally uses cloneUniforms(), it performs a deep-copy when
 * producing the merged uniform definitions.
 *
 * @param {Array} uniforms - An array of objects containing uniform definitions.
 * @return {Object} The merged uniforms.
 */
function mergeUniforms( uniforms ) {

	const merged = {};

	for ( let u = 0; u < uniforms.length; u ++ ) {

		const tmp = cloneUniforms( uniforms[ u ] );

		for ( const p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

function cloneUniformsGroups( src ) {

	const dst = [];

	for ( let u = 0; u < src.length; u ++ ) {

		dst.push( src[ u ].clone() );

	}

	return dst;

}

function getUnlitUniformColorSpace( renderer ) {

	const currentRenderTarget = renderer.getRenderTarget();

	if ( currentRenderTarget === null ) {

		// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
		return renderer.outputColorSpace;

	}

	// https://github.com/mrdoob/three.js/issues/27868
	if ( currentRenderTarget.isXRRenderTarget === true ) {

		return currentRenderTarget.texture.colorSpace;

	}

	return ColorManagement.workingColorSpace;

}

// Legacy

const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

/**
 * A material rendered with custom shaders. A shader is a small program written in GLSL.
 * that runs on the GPU. You may want to use a custom shader if you need to implement an
 * effect not included with any of the built-in materials.
 *
 * There are the following notes to bear in mind when using a `ShaderMaterial`:
 *
 * - `ShaderMaterial` can only be used with {@link WebGLRenderer}.
 * - Built in attributes and uniforms are passed to the shaders along with your code. If
 * you don't want that, use {@link RawShaderMaterial} instead.
 * - You can use the directive `#pragma unroll_loop_start` and `#pragma unroll_loop_end`
 * in order to unroll a `for` loop in GLSL by the shader preprocessor. The directive has
 * to be placed right above the loop. The loop formatting has to correspond to a defined standard.
 *   - The loop has to be [normalized](https://en.wikipedia.org/wiki/Normalized_loop).
 *   - The loop variable has to be *i*.
 *   - The value `UNROLLED_LOOP_INDEX` will be replaced with the explicitly
 * value of *i* for the given iteration and can be used in preprocessor
 * statements.
 *
 * ```js
 * const material = new THREE.ShaderMaterial( {
 * 	uniforms: {
 * 		time: { value: 1.0 },
 * 		resolution: { value: new THREE.Vector2() }
 * 	},
 * 	vertexShader: document.getElementById( 'vertexShader' ).textContent,
 * 	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
 * } );
 * ```
 *
 * @augments Material
 */
class ShaderMaterial extends Material {

	/**
	 * Constructs a new shader material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isShaderMaterial = true;

		this.type = 'ShaderMaterial';

		/**
		 * Defines custom constants using `#define` directives within the GLSL code
		 * for both the vertex shader and the fragment shader; each key/value pair
		 * yields another directive.
		 * ```js
		 * defines: {
		 * 	FOO: 15,
		 * 	BAR: true
		 * }
		 * ```
		 * Yields the lines:
		 * ```
		 * #define FOO 15
		 * #define BAR true
		 * ```
		 *
		 * @type {Object}
		 */
		this.defines = {};

		/**
		 * An object of the form:
		 * ```js
		 * {
		 * 	"uniform1": { value: 1.0 },
		 * 	"uniform2": { value: 2 }
		 * }
		 * ```
		 * specifying the uniforms to be passed to the shader code; keys are uniform
		 * names, values are definitions of the form
		 * ```
		 * {
		 * 	value: 1.0
		 * }
		 * ```
		 * where `value` is the value of the uniform. Names must match the name of
		 * the uniform, as defined in the GLSL code. Note that uniforms are refreshed
		 * on every frame, so updating the value of the uniform will immediately
		 * update the value available to the GLSL code.
		 *
		 * @type {Object}
		 */
		this.uniforms = {};

		/**
		 * An array holding uniforms groups for configuring UBOs.
		 *
		 * @type {Array<UniformsGroup>}
		 */
		this.uniformsGroups = [];

		/**
		 * Vertex shader GLSL code. This is the actual code for the shader.
		 *
		 * @type {string}
		 */
		this.vertexShader = default_vertex;

		/**
		 * Fragment shader GLSL code. This is the actual code for the shader.
		 *
		 * @type {string}
		 */
		this.fragmentShader = default_fragment;

		/**
		 * Controls line thickness or lines.
		 *
		 * WebGL and WebGPU ignore this setting and always render line primitives with a
		 * width of one pixel.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.linewidth = 1;

		/**
		 * Renders the geometry as a wireframe.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.wireframe = false;

		/**
		 * Controls the thickness of the wireframe.
		 *
		 * WebGL and WebGPU ignore this property and always render
		 * 1 pixel wide lines.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.wireframeLinewidth = 1;

		/**
		 * Define whether the material color is affected by global fog settings; `true`
		 * to pass fog uniforms to the shader.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.fog = false;

		/**
		 * Defines whether this material uses lighting; `true` to pass uniform data
		 * related to lighting to this shader.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.lights = false;

		/**
		 * Defines whether this material supports clipping; `true` to let the renderer
		 * pass the clippingPlanes uniform.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.clipping = false;

		/**
		 * Overwritten and set to `true` by default.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.forceSinglePass = true;

		/**
		 * This object allows to enable certain WebGL 2 extensions.
		 *
		 * - clipCullDistance: set to `true` to use vertex shader clipping
		 * - multiDraw: set to `true` to use vertex shader multi_draw / enable gl_DrawID
		 *
		 * @type {{clipCullDistance:false,multiDraw:false}}
		 */
		this.extensions = {
			clipCullDistance: false, // set to use vertex shader clipping
			multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
		};

		/**
		 * When the rendered geometry doesn't include these attributes but the
		 * material does, these default values will be passed to the shaders. This
		 * avoids errors when buffer data is missing.
		 *
		 * - color: [ 1, 1, 1 ]
		 * - uv: [ 0, 0 ]
		 * - uv1: [ 0, 0 ]
		 *
		 * @type {Object}
		 */
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv1': [ 0, 0 ]
		};

		/**
		 * If set, this calls [gl.bindAttribLocation](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation)
		 * to bind a generic vertex index to an attribute variable.
		 *
		 * @type {string|undefined}
		 * @default undefined
		 */
		this.index0AttributeName = undefined;

		/**
		 * Can be used to force a uniform update while changing uniforms in
		 * {@link Object3D#onBeforeRender}.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.uniformsNeedUpdate = false;

		/**
		 * Defines the GLSL version of custom shader code.
		 *
		 * @type {?(GLSL1|GLSL3)}
		 * @default null
		 */
		this.glslVersion = null;

		if ( parameters !== undefined ) {

			this.setValues( parameters );

		}

	}

	copy( source ) {

		super.copy( source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );
		this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.fog = source.fog;
		this.lights = source.lights;
		this.clipping = source.clipping;

		this.extensions = Object.assign( {}, source.extensions );

		this.glslVersion = source.glslVersion;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.glslVersion = this.glslVersion;
		data.uniforms = {};

		for ( const name in this.uniforms ) {

			const uniform = this.uniforms[ name ];
			const value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		data.lights = this.lights;
		data.clipping = this.clipping;

		const extensions = {};

		for ( const key in this.extensions ) {

			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		}

		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		return data;

	}

}

/**
 * Abstract base class for cameras. This class should always be inherited
 * when you build a new camera.
 *
 * @abstract
 * @augments Object3D
 */
class Camera extends Object3D {

	/**
	 * Constructs a new camera.
	 */
	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isCamera = true;

		this.type = 'Camera';

		/**
		 * The inverse of the camera's world matrix.
		 *
		 * @type {Matrix4}
		 */
		this.matrixWorldInverse = new Matrix4();

		/**
		 * The camera's projection matrix.
		 *
		 * @type {Matrix4}
		 */
		this.projectionMatrix = new Matrix4();

		/**
		 * The inverse of the camera's projection matrix.
		 *
		 * @type {Matrix4}
		 */
		this.projectionMatrixInverse = new Matrix4();

		/**
		 * The coordinate system in which the camera is used.
		 *
		 * @type {(WebGLCoordinateSystem|WebGPUCoordinateSystem)}
		 */
		this.coordinateSystem = WebGLCoordinateSystem;

		this._reversedDepth = false;

	}

	/**
	 * The flag that indicates whether the camera uses a reversed depth buffer.
	 *
	 * @type {boolean}
	 * @default false
	 */
	get reversedDepth() {

		return this._reversedDepth;

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		this.coordinateSystem = source.coordinateSystem;

		return this;

	}

	/**
	 * Returns a vector representing the ("look") direction of the 3D object in world space.
	 *
	 * This method is overwritten since cameras have a different forward vector compared to other
	 * 3D objects. A camera looks down its local, negative z-axis by default.
	 *
	 * @param {Vector3} target - The target vector the result is stored to.
	 * @return {Vector3} The 3D object's direction in world space.
	 */
	getWorldDirection( target ) {

		return super.getWorldDirection( target ).negate();

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		super.updateWorldMatrix( updateParents, updateChildren );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _v3$1 = /*@__PURE__*/ new Vector3();
const _minTarget = /*@__PURE__*/ new Vector2();
const _maxTarget = /*@__PURE__*/ new Vector2();

/**
 * Camera that uses [perspective projection](https://en.wikipedia.org/wiki/Perspective_(graphical)).
 *
 * This projection mode is designed to mimic the way the human eye sees. It
 * is the most common projection mode used for rendering a 3D scene.
 *
 * ```js
 * const camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
 * scene.add( camera );
 * ```
 *
 * @augments Camera
 */
class PerspectiveCamera extends Camera {

	/**
	 * Constructs a new perspective camera.
	 *
	 * @param {number} [fov=50] - The vertical field of view.
	 * @param {number} [aspect=1] - The aspect ratio.
	 * @param {number} [near=0.1] - The camera's near plane.
	 * @param {number} [far=2000] - The camera's far plane.
	 */
	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isPerspectiveCamera = true;

		this.type = 'PerspectiveCamera';

		/**
		 * The vertical field of view, from bottom to top of view,
		 * in degrees.
		 *
		 * @type {number}
		 * @default 50
		 */
		this.fov = fov;

		/**
		 * The zoom factor of the camera.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.zoom = 1;

		/**
		 * The camera's near plane. The valid range is greater than `0`
		 * and less than the current value of {@link PerspectiveCamera#far}.
		 *
		 * Note that, unlike for the {@link OrthographicCamera}, `0` is <em>not</em> a
		 * valid value for a perspective camera's near plane.
		 *
		 * @type {number}
		 * @default 0.1
		 */
		this.near = near;

		/**
		 * The camera's far plane. Must be greater than the
		 * current value of {@link PerspectiveCamera#near}.
		 *
		 * @type {number}
		 * @default 2000
		 */
		this.far = far;

		/**
		 * Object distance used for stereoscopy and depth-of-field effects. This
		 * parameter does not influence the projection matrix unless a
		 * {@link StereoCamera} is being used.
		 *
		 * @type {number}
		 * @default 10
		 */
		this.focus = 10;

		/**
		 * The aspect ratio, usually the canvas width / canvas height.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.aspect = aspect;

		/**
		 * Represents the frustum window specification. This property should not be edited
		 * directly but via {@link PerspectiveCamera#setViewOffset} and {@link PerspectiveCamera#clearViewOffset}.
		 *
		 * @type {?Object}
		 * @default null
		 */
		this.view = null;

		/**
		 * Film size used for the larger axis. Default is `35` (millimeters). This
		 * parameter does not influence the projection matrix unless {@link PerspectiveCamera#filmOffset}
		 * is set to a nonzero value.
		 *
		 * @type {number}
		 * @default 35
		 */
		this.filmGauge = 35;

		/**
		 * Horizontal off-center offset in the same unit as {@link PerspectiveCamera#filmGauge}.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.filmOffset = 0;

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	}

	/**
	 * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength( focalLength ) {

		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	}

	/**
	 * Returns the focal length from the current {@link PerspectiveCamera#fov} and
	 * {@link PerspectiveCamera#filmGauge}.
	 *
	 * @return {number} The computed focal length.
	 */
	getFocalLength() {

		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	}

	/**
	 * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
	 *
	 * @return {number} The effective FOV.
	 */
	getEffectiveFOV() {

		return RAD2DEG * 2 * Math.atan(
			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

	}

	/**
	 * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
	 * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
	 *
	 * @return {number} The film width.
	 */
	getFilmWidth() {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	}

	/**
	 * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
	 * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
	 *
	 * @return {number} The film width.
	 */
	getFilmHeight() {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	}

	/**
	 * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
	 * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
	 *
	 * @param {number} distance - The viewing distance.
	 * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
	 * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
	 */
	getViewBounds( distance, minTarget, maxTarget ) {

		_v3$1.set( -1, -1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

		minTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

		_v3$1.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

		maxTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

	}

	/**
	 * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
	 *
	 * @param {number} distance - The viewing distance.
	 * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
	 * @returns {Vector2} The view size.
	 */
	getViewSize( distance, target ) {

		this.getViewBounds( distance, _minTarget, _maxTarget );

		return target.subVectors( _maxTarget, _minTarget );

	}

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *```
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *```
	 * then for each monitor you would call it like this:
	 *```js
	 * const w = 1920;
	 * const h = 1080;
	 * const fullWidth = w * 3;
	 * const fullHeight = h * 2;
	 *
	 * // --A--
	 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 * // --B--
	 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 * // --C--
	 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 * // --D--
	 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 * // --E--
	 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 * // --F--
	 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 * ```
	 *
	 * Note there is no reason monitors have to be the same size or in a grid.
	 *
	 * @param {number} fullWidth - The full width of multiview setup.
	 * @param {number} fullHeight - The full height of multiview setup.
	 * @param {number} x - The horizontal offset of the subcamera.
	 * @param {number} y - The vertical offset of the subcamera.
	 * @param {number} width - The width of subcamera.
	 * @param {number} height - The height of subcamera.
	 */
	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	/**
	 * Removes the view offset from the projection matrix.
	 */
	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	/**
	 * Updates the camera's projection matrix. Must be called after any change of
	 * camera properties.
	 */
	updateProjectionMatrix() {

		const near = this.near;
		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = -0.5 * width;
		const view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		const skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem, this.reversedDepth );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

}

const fov = -90; // negative fov is not an error
const aspect = 1;

/**
 * A special type of camera that is positioned in 3D space to render its surroundings into a
 * cube render target. The render target can then be used as an environment map for rendering
 * realtime reflections in your scene.
 *
 * ```js
 * // Create cube render target
 * const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256, { generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter } );
 *
 * // Create cube camera
 * const cubeCamera = new THREE.CubeCamera( 1, 100000, cubeRenderTarget );
 * scene.add( cubeCamera );
 *
 * // Create car
 * const chromeMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff, envMap: cubeRenderTarget.texture } );
 * const car = new THREE.Mesh( carGeometry, chromeMaterial );
 * scene.add( car );
 *
 * // Update the render target cube
 * car.visible = false;
 * cubeCamera.position.copy( car.position );
 * cubeCamera.update( renderer, scene );
 *
 * // Render the scene
 * car.visible = true;
 * renderer.render( scene, camera );
 * ```
 *
 * @augments Object3D
 */
class CubeCamera extends Object3D {

	/**
	 * Constructs a new cube camera.
	 *
	 * @param {number} near - The camera's near plane.
	 * @param {number} far - The camera's far plane.
	 * @param {WebGLCubeRenderTarget} renderTarget - The cube render target.
	 */
	constructor( near, far, renderTarget ) {

		super();

		this.type = 'CubeCamera';

		/**
		 * A reference to the cube render target.
		 *
		 * @type {WebGLCubeRenderTarget}
		 */
		this.renderTarget = renderTarget;

		/**
		 * The current active coordinate system.
		 *
		 * @type {?(WebGLCoordinateSystem|WebGPUCoordinateSystem)}
		 * @default null
		 */
		this.coordinateSystem = null;

		/**
		 * The current active mipmap level
		 *
		 * @type {number}
		 * @default 0
		 */
		this.activeMipmapLevel = 0;

		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.layers = this.layers;
		this.add( cameraPX );

		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.layers = this.layers;
		this.add( cameraNX );

		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.layers = this.layers;
		this.add( cameraPY );

		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.layers = this.layers;
		this.add( cameraNY );

		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.layers = this.layers;
		this.add( cameraPZ );

		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.layers = this.layers;
		this.add( cameraNZ );

	}

	/**
	 * Must be called when the coordinate system of the cube camera is changed.
	 */
	updateCoordinateSystem() {

		const coordinateSystem = this.coordinateSystem;

		const cameras = this.children.concat();

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;

		for ( const camera of cameras ) this.remove( camera );

		if ( coordinateSystem === WebGLCoordinateSystem ) {

			cameraPX.up.set( 0, 1, 0 );
			cameraPX.lookAt( 1, 0, 0 );

			cameraNX.up.set( 0, 1, 0 );
			cameraNX.lookAt( -1, 0, 0 );

			cameraPY.up.set( 0, 0, -1 );
			cameraPY.lookAt( 0, 1, 0 );

			cameraNY.up.set( 0, 0, 1 );
			cameraNY.lookAt( 0, -1, 0 );

			cameraPZ.up.set( 0, 1, 0 );
			cameraPZ.lookAt( 0, 0, 1 );

			cameraNZ.up.set( 0, 1, 0 );
			cameraNZ.lookAt( 0, 0, -1 );

		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

			cameraPX.up.set( 0, -1, 0 );
			cameraPX.lookAt( -1, 0, 0 );

			cameraNX.up.set( 0, -1, 0 );
			cameraNX.lookAt( 1, 0, 0 );

			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( 0, 1, 0 );

			cameraNY.up.set( 0, 0, -1 );
			cameraNY.lookAt( 0, -1, 0 );

			cameraPZ.up.set( 0, -1, 0 );
			cameraPZ.lookAt( 0, 0, 1 );

			cameraNZ.up.set( 0, -1, 0 );
			cameraNZ.lookAt( 0, 0, -1 );

		} else {

			throw new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );

		}

		for ( const camera of cameras ) {

			this.add( camera );

			camera.updateMatrixWorld();

		}

	}

	/**
	 * Calling this method will render the given scene with the given renderer
	 * into the cube render target of the camera.
	 *
	 * @param {(Renderer|WebGLRenderer)} renderer - The renderer.
	 * @param {Scene} scene - The scene to render.
	 */
	update( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		const { renderTarget, activeMipmapLevel } = this;

		if ( this.coordinateSystem !== renderer.coordinateSystem ) {

			this.coordinateSystem = renderer.coordinateSystem;

			this.updateCoordinateSystem();

		}

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

		const currentRenderTarget = renderer.getRenderTarget();
		const currentActiveCubeFace = renderer.getActiveCubeFace();
		const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();

		const currentXrEnabled = renderer.xr.enabled;

		renderer.xr.enabled = false;

		const generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );
		renderer.render( scene, cameraPX );

		renderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );
		renderer.render( scene, cameraNX );

		renderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );
		renderer.render( scene, cameraPY );

		renderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );
		renderer.render( scene, cameraNY );

		renderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );
		renderer.render( scene, cameraPZ );

		// mipmaps are generated during the last call of render()
		// at this point, all sides of the cube render target are defined

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );
		renderer.render( scene, cameraNZ );

		renderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );

		renderer.xr.enabled = currentXrEnabled;

		renderTarget.texture.needsPMREMUpdate = true;

	}

}

/**
 * Creates a cube texture made up of six images.
 *
 * ```js
 * const loader = new THREE.CubeTextureLoader();
 * loader.setPath( 'textures/cube/pisa/' );
 *
 * const textureCube = loader.load( [
 * 	'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'
 * ] );
 *
 * const material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );
 * ```
 *
 * @augments Texture
 */
class CubeTexture extends Texture {

	/**
	 * Constructs a new cube texture.
	 *
	 * @param {Array<Image>} [images=[]] - An array holding a image for each side of a cube.
	 * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
	 * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
	 * @param {number} [format=RGBAFormat] - The texture format.
	 * @param {number} [type=UnsignedByteType] - The texture type.
	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	 * @param {string} [colorSpace=NoColorSpace] - The color space value.
	 */
	constructor( images = [], mapping = CubeReflectionMapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {

		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isCubeTexture = true;

		/**
		 * If set to `true`, the texture is flipped along the vertical axis when
		 * uploaded to the GPU.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flipY = false;

	}

	/**
	 * Alias for {@link CubeTexture#image}.
	 *
	 * @type {Array<Image>}
	 */
	get images() {

		return this.image;

	}

	set images( value ) {

		this.image = value;

	}

}

/**
 * A cube render target used in context of {@link WebGLRenderer}.
 *
 * @augments WebGLRenderTarget
 */
class WebGLCubeRenderTarget extends WebGLRenderTarget {

	/**
	 * Constructs a new cube render target.
	 *
	 * @param {number} [size=1] - The size of the render target.
	 * @param {RenderTarget~Options} [options] - The configuration object.
	 */
	constructor( size = 1, options = {} ) {

		super( size, size, options );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isWebGLCubeRenderTarget = true;

		const image = { width: size, height: size, depth: 1 };
		const images = [ image, image, image, image, image, image ];

		/**
		 * Overwritten with a different texture type.
		 *
		 * @type {DataArrayTexture}
		 */
		this.texture = new CubeTexture( images );
		this._setTextureOptions( options );

		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

		this.texture.isRenderTargetTexture = true;

	}

	/**
	 * Converts the given equirectangular texture to a cube map.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {Texture} texture - The equirectangular texture.
	 * @return {WebGLCubeRenderTarget} A reference to this cube render target.
	 */
	fromEquirectangularTexture( renderer, texture ) {

		this.texture.type = texture.type;
		this.texture.colorSpace = texture.colorSpace;

		this.texture.generateMipmaps = texture.generateMipmaps;
		this.texture.minFilter = texture.minFilter;
		this.texture.magFilter = texture.magFilter;

		const shader = {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
		};

		const geometry = new BoxGeometry( 5, 5, 5 );

		const material = new ShaderMaterial( {

			name: 'CubemapFromEquirect',

			uniforms: cloneUniforms( shader.uniforms ),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			blending: NoBlending

		} );

		material.uniforms.tEquirect.value = texture;

		const mesh = new Mesh( geometry, material );

		const currentMinFilter = texture.minFilter;

		// Avoid blurred poles
		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

		const camera = new CubeCamera( 1, 10, this );
		camera.update( renderer, mesh );

		texture.minFilter = currentMinFilter;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	}

	/**
	 * Clears this cube render target.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
	 * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
	 * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
	 */
	clear( renderer, color = true, depth = true, stencil = true ) {

		const currentRenderTarget = renderer.getRenderTarget();

		for ( let i = 0; i < 6; i ++ ) {

			renderer.setRenderTarget( this, i );

			renderer.clear( color, depth, stencil );

		}

		renderer.setRenderTarget( currentRenderTarget );

	}

}

/**
 * This is almost identical to an {@link Object3D}. Its purpose is to
 * make working with groups of objects syntactically clearer.
 *
 * ```js
 * // Create a group and add the two cubes.
 * // These cubes can now be rotated / scaled etc as a group.
 * const group = new THREE.Group();
 *
 * group.add( meshA );
 * group.add( meshB );
 *
 * scene.add( group );
 * ```
 *
 * @augments Object3D
 */
class Group extends Object3D {

	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isGroup = true;

		this.type = 'Group';

	}

}

const _moveEvent = { type: 'move' };

/**
 * Class for representing a XR controller with its
 * different coordinate systems.
 *
 * @private
 */
class WebXRController {

	/**
	 * Constructs a new XR controller.
	 */
	constructor() {

		/**
		 * A group representing the target ray space
		 * of the XR controller.
		 *
		 * @private
		 * @type {?Group}
		 * @default null
		 */
		this._targetRay = null;

		/**
		 * A group representing the grip space
		 * of the XR controller.
		 *
		 * @private
		 * @type {?Group}
		 * @default null
		 */
		this._grip = null;

		/**
		 * A group representing the hand space
		 * of the XR controller.
		 *
		 * @private
		 * @type {?Group}
		 * @default null
		 */
		this._hand = null;

	}

	/**
	 * Returns a group representing the hand space of the XR controller.
	 *
	 * @return {Group} A group representing the hand space of the XR controller.
	 */
	getHandSpace() {

		if ( this._hand === null ) {

			this._hand = new Group();
			this._hand.matrixAutoUpdate = false;
			this._hand.visible = false;

			this._hand.joints = {};
			this._hand.inputState = { pinching: false };

		}

		return this._hand;

	}

	/**
	 * Returns a group representing the target ray space of the XR controller.
	 *
	 * @return {Group} A group representing the target ray space of the XR controller.
	 */
	getTargetRaySpace() {

		if ( this._targetRay === null ) {

			this._targetRay = new Group();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;
			this._targetRay.hasLinearVelocity = false;
			this._targetRay.linearVelocity = new Vector3();
			this._targetRay.hasAngularVelocity = false;
			this._targetRay.angularVelocity = new Vector3();

		}

		return this._targetRay;

	}

	/**
	 * Returns a group representing the grip space of the XR controller.
	 *
	 * @return {Group} A group representing the grip space of the XR controller.
	 */
	getGripSpace() {

		if ( this._grip === null ) {

			this._grip = new Group();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;
			this._grip.hasLinearVelocity = false;
			this._grip.linearVelocity = new Vector3();
			this._grip.hasAngularVelocity = false;
			this._grip.angularVelocity = new Vector3();

		}

		return this._grip;

	}

	/**
	 * Dispatches the given event to the groups representing
	 * the different coordinate spaces of the XR controller.
	 *
	 * @param {Object} event - The event to dispatch.
	 * @return {WebXRController} A reference to this instance.
	 */
	dispatchEvent( event ) {

		if ( this._targetRay !== null ) {

			this._targetRay.dispatchEvent( event );

		}

		if ( this._grip !== null ) {

			this._grip.dispatchEvent( event );

		}

		if ( this._hand !== null ) {

			this._hand.dispatchEvent( event );

		}

		return this;

	}

	/**
	 * Connects the controller with the given XR input source.
	 *
	 * @param {XRInputSource} inputSource - The input source.
	 * @return {WebXRController} A reference to this instance.
	 */
	connect( inputSource ) {

		if ( inputSource && inputSource.hand ) {

			const hand = this._hand;

			if ( hand ) {

				for ( const inputjoint of inputSource.hand.values() ) {

					// Initialize hand with joints when connected
					this._getHandJoint( hand, inputjoint );

				}

			}

		}

		this.dispatchEvent( { type: 'connected', data: inputSource } );

		return this;

	}

	/**
	 * Disconnects the controller from the given XR input source.
	 *
	 * @param {XRInputSource} inputSource - The input source.
	 * @return {WebXRController} A reference to this instance.
	 */
	disconnect( inputSource ) {

		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

		if ( this._targetRay !== null ) {

			this._targetRay.visible = false;

		}

		if ( this._grip !== null ) {

			this._grip.visible = false;

		}

		if ( this._hand !== null ) {

			this._hand.visible = false;

		}

		return this;

	}

	/**
	 * Updates the controller with the given input source, XR frame and reference space.
	 * This updates the transformations of the groups that represent the different
	 * coordinate systems of the controller.
	 *
	 * @param {XRInputSource} inputSource - The input source.
	 * @param {XRFrame} frame - The XR frame.
	 * @param {XRReferenceSpace} referenceSpace - The reference space.
	 * @return {WebXRController} A reference to this instance.
	 */
	update( inputSource, frame, referenceSpace ) {

		let inputPose = null;
		let gripPose = null;
		let handPose = null;

		const targetRay = this._targetRay;
		const grip = this._grip;
		const hand = this._hand;

		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

			if ( hand && inputSource.hand ) {

				handPose = true;

				for ( const inputjoint of inputSource.hand.values() ) {

					// Update the joints groups with the XRJoint poses
					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

					// The transform of this joint will be updated with the joint pose on each frame
					const joint = this._getHandJoint( hand, inputjoint );

					if ( jointPose !== null ) {

						joint.matrix.fromArray( jointPose.transform.matrix );
						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
						joint.matrixWorldNeedsUpdate = true;
						joint.jointRadius = jointPose.radius;

					}

					joint.visible = jointPose !== null;

				}

				// Custom events

				// Check pinchz
				const indexTip = hand.joints[ 'index-finger-tip' ];
				const thumbTip = hand.joints[ 'thumb-tip' ];
				const distance = indexTip.position.distanceTo( thumbTip.position );

				const distanceToPinch = 0.02;
				const threshold = 0.005;

				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

					hand.inputState.pinching = false;
					this.dispatchEvent( {
						type: 'pinchend',
						handedness: inputSource.handedness,
						target: this
					} );

				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

					hand.inputState.pinching = true;
					this.dispatchEvent( {
						type: 'pinchstart',
						handedness: inputSource.handedness,
						target: this
					} );

				}

			} else {

				if ( grip !== null && inputSource.gripSpace ) {

					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

					if ( gripPose !== null ) {

						grip.matrix.fromArray( gripPose.transform.matrix );
						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );
						grip.matrixWorldNeedsUpdate = true;

						if ( gripPose.linearVelocity ) {

							grip.hasLinearVelocity = true;
							grip.linearVelocity.copy( gripPose.linearVelocity );

						} else {

							grip.hasLinearVelocity = false;

						}

						if ( gripPose.angularVelocity ) {

							grip.hasAngularVelocity = true;
							grip.angularVelocity.copy( gripPose.angularVelocity );

						} else {

							grip.hasAngularVelocity = false;

						}

					}

				}

			}

			if ( targetRay !== null ) {

				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

				// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
				if ( inputPose === null && gripPose !== null ) {

					inputPose = gripPose;

				}

				if ( inputPose !== null ) {

					targetRay.matrix.fromArray( inputPose.transform.matrix );
					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );
					targetRay.matrixWorldNeedsUpdate = true;

					if ( inputPose.linearVelocity ) {

						targetRay.hasLinearVelocity = true;
						targetRay.linearVelocity.copy( inputPose.linearVelocity );

					} else {

						targetRay.hasLinearVelocity = false;

					}

					if ( inputPose.angularVelocity ) {

						targetRay.hasAngularVelocity = true;
						targetRay.angularVelocity.copy( inputPose.angularVelocity );

					} else {

						targetRay.hasAngularVelocity = false;

					}

					this.dispatchEvent( _moveEvent );

				}

			}


		}

		if ( targetRay !== null ) {

			targetRay.visible = ( inputPose !== null );

		}

		if ( grip !== null ) {

			grip.visible = ( gripPose !== null );

		}

		if ( hand !== null ) {

			hand.visible = ( handPose !== null );

		}

		return this;

	}

	/**
	 * Returns a group representing the hand joint for the given input joint.
	 *
	 * @private
	 * @param {Group} hand - The group representing the hand space.
	 * @param {XRJointSpace} inputjoint - The hand joint data.
	 * @return {Group} A group representing the hand joint for the given input joint.
	 */
	_getHandJoint( hand, inputjoint ) {

		if ( hand.joints[ inputjoint.jointName ] === undefined ) {

			const joint = new Group();
			joint.matrixAutoUpdate = false;
			joint.visible = false;
			hand.joints[ inputjoint.jointName ] = joint;

			hand.add( joint );

		}

		return hand.joints[ inputjoint.jointName ];

	}

}

/**
 * Scenes allow you to set up what is to be rendered and where by three.js.
 * This is where you place 3D objects like meshes, lines or lights.
 *
 * @augments Object3D
 */
class Scene extends Object3D {

	/**
	 * Constructs a new scene.
	 */
	constructor() {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isScene = true;

		this.type = 'Scene';

		/**
		 * Defines the background of the scene. Valid inputs are:
		 *
		 * - A color for defining a uniform colored background.
		 * - A texture for defining a (flat) textured background.
		 * - Cube textures or equirectangular textures for defining a skybox.
		 *
		 * @type {?(Color|Texture)}
		 * @default null
		 */
		this.background = null;

		/**
		 * Sets the environment map for all physical materials in the scene. However,
		 * it's not possible to overwrite an existing texture assigned to the `envMap`
		 * material property.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.environment = null;

		/**
		 * A fog instance defining the type of fog that affects everything
		 * rendered in the scene.
		 *
		 * @type {?(Fog|FogExp2)}
		 * @default null
		 */
		this.fog = null;

		/**
		 * Sets the blurriness of the background. Only influences environment maps
		 * assigned to {@link Scene#background}. Valid input is a float between `0`
		 * and `1`.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.backgroundBlurriness = 0;

		/**
		 * Attenuates the color of the background. Only applies to background textures.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.backgroundIntensity = 1;

		/**
		 * The rotation of the background in radians. Only influences environment maps
		 * assigned to {@link Scene#background}.
		 *
		 * @type {Euler}
		 * @default (0,0,0)
		 */
		this.backgroundRotation = new Euler();

		/**
		 * Attenuates the color of the environment. Only influences environment maps
		 * assigned to {@link Scene#environment}.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.environmentIntensity = 1;

		/**
		 * The rotation of the environment map in radians. Only influences physical materials
		 * in the scene when {@link Scene#environment} is used.
		 *
		 * @type {Euler}
		 * @default (0,0,0)
		 */
		this.environmentRotation = new Euler();

		/**
		 * Forces everything in the scene to be rendered with the defined material. It is possible
		 * to exclude materials from override by setting {@link Material#allowOverride} to `false`.
		 *
		 * @type {?Material}
		 * @default null
		 */
		this.overrideMaterial = null;

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.environment !== null ) this.environment = source.environment.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();

		this.backgroundBlurriness = source.backgroundBlurriness;
		this.backgroundIntensity = source.backgroundIntensity;
		this.backgroundRotation.copy( source.backgroundRotation );

		this.environmentIntensity = source.environmentIntensity;
		this.environmentRotation.copy( source.environmentRotation );

		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		if ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;
		if ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;
		data.object.backgroundRotation = this.backgroundRotation.toArray();

		if ( this.environmentIntensity !== 1 ) data.object.environmentIntensity = this.environmentIntensity;
		data.object.environmentRotation = this.environmentRotation.toArray();

		return data;

	}

}

/**
 * "Interleaved" means that multiple attributes, possibly of different types,
 * (e.g., position, normal, uv, color) are packed into a single array buffer.
 *
 * An introduction into interleaved arrays can be found here: [Interleaved array basics](https://blog.tojicode.com/2011/05/interleaved-array-basics.html)
 */
class InterleavedBuffer {

	/**
	 * Constructs a new interleaved buffer.
	 *
	 * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
	 * @param {number} stride - The number of typed-array elements per vertex.
	 */
	constructor( array, stride ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isInterleavedBuffer = true;

		/**
		 * A typed array with a shared buffer storing attribute data.
		 *
		 * @type {TypedArray}
		 */
		this.array = array;

		/**
		 * The number of typed-array elements per vertex.
		 *
		 * @type {number}
		 */
		this.stride = stride;

		/**
		 * The total number of elements in the array
		 *
		 * @type {number}
		 * @readonly
		 */
		this.count = array !== undefined ? array.length / stride : 0;

		/**
		 * Defines the intended usage pattern of the data store for optimization purposes.
		 *
		 * Note: After the initial use of a buffer, its usage cannot be changed. Instead,
		 * instantiate a new one and set the desired usage before the next render.
		 *
		 * @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}
		 * @default StaticDrawUsage
		 */
		this.usage = StaticDrawUsage;

		/**
		 * This can be used to only update some components of stored vectors (for example, just the
		 * component related to color). Use the `addUpdateRange()` function to add ranges to this array.
		 *
		 * @type {Array<Object>}
		 */
		this.updateRanges = [];

		/**
		 * A version number, incremented every time the `needsUpdate` is set to `true`.
		 *
		 * @type {number}
		 */
		this.version = 0;

		/**
		 * The UUID of the interleaved buffer.
		 *
		 * @type {string}
		 * @readonly
		 */
		this.uuid = generateUUID();

	}

	/**
	 * A callback function that is executed after the renderer has transferred the attribute array
	 * data to the GPU.
	 */
	onUploadCallback() {}

	/**
	 * Flag to indicate that this attribute has changed and should be re-sent to
	 * the GPU. Set this to `true` when you modify the value of the array.
	 *
	 * @type {number}
	 * @default false
	 * @param {boolean} value
	 */
	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	/**
	 * Sets the usage of this interleaved buffer.
	 *
	 * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
	 * @return {InterleavedBuffer} A reference to this interleaved buffer.
	 */
	setUsage( value ) {

		this.usage = value;

		return this;

	}

	/**
	 * Adds a range of data in the data array to be updated on the GPU.
	 *
	 * @param {number} start - Position at which to start update.
	 * @param {number} count - The number of components to update.
	 */
	addUpdateRange( start, count ) {

		this.updateRanges.push( { start, count } );

	}

	/**
	 * Clears the update ranges.
	 */
	clearUpdateRanges() {

		this.updateRanges.length = 0;

	}

	/**
	 * Copies the values of the given interleaved buffer to this instance.
	 *
	 * @param {InterleavedBuffer} source - The interleaved buffer to copy.
	 * @return {InterleavedBuffer} A reference to this instance.
	 */
	copy( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	}

	/**
	 * Copies a vector from the given interleaved buffer to this one. The start
	 * and destination position in the attribute buffers are represented by the
	 * given indices.
	 *
	 * @param {number} index1 - The destination index into this interleaved buffer.
	 * @param {InterleavedBuffer} interleavedBuffer - The interleaved buffer to copy from.
	 * @param {number} index2 - The source index into the given interleaved buffer.
	 * @return {InterleavedBuffer} A reference to this instance.
	 */
	copyAt( index1, interleavedBuffer, index2 ) {

		index1 *= this.stride;
		index2 *= interleavedBuffer.stride;

		for ( let i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = interleavedBuffer.array[ index2 + i ];

		}

		return this;

	}

	/**
	 * Sets the given array data in the interleaved buffer.
	 *
	 * @param {(TypedArray|Array)} value - The array data to set.
	 * @param {number} [offset=0] - The offset in this interleaved buffer's array.
	 * @return {InterleavedBuffer} A reference to this instance.
	 */
	set( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	}

	/**
	 * Returns a new interleaved buffer with copied values from this instance.
	 *
	 * @param {Object} [data] - An object with shared array buffers that allows to retain shared structures.
	 * @return {InterleavedBuffer} A clone of this instance.
	 */
	clone( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		}

		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		const ib = new this.constructor( array, this.stride );
		ib.setUsage( this.usage );

		return ib;

	}

	/**
	 * Sets the given callback function that is executed after the Renderer has transferred
	 * the array data to the GPU. Can be used to perform clean-up operations after
	 * the upload when data are not needed anymore on the CPU side.
	 *
	 * @param {Function} callback - The `onUpload()` callback.
	 * @return {InterleavedBuffer} A reference to this instance.
	 */
	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	/**
	 * Serializes the interleaved buffer into JSON.
	 *
	 * @param {Object} [data] - An optional value holding meta information about the serialization.
	 * @return {Object} A JSON object representing the serialized interleaved buffer.
	 */
	toJSON( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		// generate UUID for array buffer if necessary

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );

		}

		//

		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};

	}

}

const _vector$7 = /*@__PURE__*/ new Vector3();

/**
 * An alternative version of a buffer attribute with interleaved data. Interleaved
 * attributes share a common interleaved data storage ({@link InterleavedBuffer}) and refer with
 * different offsets into the buffer.
 */
class InterleavedBufferAttribute {

	/**
	 * Constructs a new interleaved buffer attribute.
	 *
	 * @param {InterleavedBuffer} interleavedBuffer - The buffer holding the interleaved data.
	 * @param {number} itemSize - The item size.
	 * @param {number} offset - The attribute offset into the buffer.
	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
	 */
	constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isInterleavedBufferAttribute = true;

		/**
		 * The name of the buffer attribute.
		 *
		 * @type {string}
		 */
		this.name = '';

		/**
		 * The buffer holding the interleaved data.
		 *
		 * @type {InterleavedBuffer}
		 */
		this.data = interleavedBuffer;

		/**
		 * The item size, see {@link BufferAttribute#itemSize}.
		 *
		 * @type {number}
		 */
		this.itemSize = itemSize;

		/**
		 * The attribute offset into the buffer.
		 *
		 * @type {number}
		 */
		this.offset = offset;

		/**
		 * Whether the data are normalized or not, see {@link BufferAttribute#normalized}
		 *
		 * @type {InterleavedBuffer}
		 */
		this.normalized = normalized;

	}

	/**
	 * The item count of this buffer attribute.
	 *
	 * @type {number}
	 * @readonly
	 */
	get count() {

		return this.data.count;

	}

	/**
	 * The array holding the interleaved buffer attribute data.
	 *
	 * @type {TypedArray}
	 */
	get array() {

		return this.data.array;

	}

	/**
	 * Flag to indicate that this attribute has changed and should be re-sent to
	 * the GPU. Set this to `true` when you modify the value of the array.
	 *
	 * @type {number}
	 * @default false
	 * @param {boolean} value
	 */
	set needsUpdate( value ) {

		this.data.needsUpdate = value;

	}

	/**
	 * Applies the given 4x4 matrix to the given attribute. Only works with
	 * item size `3`.
	 *
	 * @param {Matrix4} m - The matrix to apply.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	applyMatrix4( m ) {

		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			_vector$7.fromBufferAttribute( this, i );

			_vector$7.applyMatrix4( m );

			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

		}

		return this;

	}

	/**
	 * Applies the given 3x3 normal matrix to the given attribute. Only works with
	 * item size `3`.
	 *
	 * @param {Matrix3} m - The normal matrix to apply.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$7.fromBufferAttribute( this, i );

			_vector$7.applyNormalMatrix( m );

			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

		}

		return this;

	}

	/**
	 * Applies the given 4x4 matrix to the given attribute. Only works with
	 * item size `3` and with direction vectors.
	 *
	 * @param {Matrix4} m - The matrix to apply.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$7.fromBufferAttribute( this, i );

			_vector$7.transformDirection( m );

			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

		}

		return this;

	}

	/**
	 * Returns the given component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} component - The component index.
	 * @return {number} The returned value.
	 */
	getComponent( index, component ) {

		let value = this.array[ index * this.data.stride + this.offset + component ];

		if ( this.normalized ) value = denormalize( value, this.array );

		return value;

	}

	/**
	 * Sets the given value to the given component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} component - The component index.
	 * @param {number} value - The value to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setComponent( index, component, value ) {

		if ( this.normalized ) value = normalize$1( value, this.array );

		this.data.array[ index * this.data.stride + this.offset + component ] = value;

		return this;

	}

	/**
	 * Sets the x component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setX( index, x ) {

		if ( this.normalized ) x = normalize$1( x, this.array );

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	}

	/**
	 * Sets the y component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} y - The value to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setY( index, y ) {

		if ( this.normalized ) y = normalize$1( y, this.array );

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	}

	/**
	 * Sets the z component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} z - The value to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setZ( index, z ) {

		if ( this.normalized ) z = normalize$1( z, this.array );

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	}

	/**
	 * Sets the w component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} w - The value to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setW( index, w ) {

		if ( this.normalized ) w = normalize$1( w, this.array );

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	}

	/**
	 * Returns the x component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The x component.
	 */
	getX( index ) {

		let x = this.data.array[ index * this.data.stride + this.offset ];

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	/**
	 * Returns the y component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The y component.
	 */
	getY( index ) {

		let y = this.data.array[ index * this.data.stride + this.offset + 1 ];

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	/**
	 * Returns the z component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The z component.
	 */
	getZ( index ) {

		let z = this.data.array[ index * this.data.stride + this.offset + 2 ];

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	/**
	 * Returns the w component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @return {number} The w component.
	 */
	getW( index ) {

		let w = this.data.array[ index * this.data.stride + this.offset + 3 ];

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	/**
	 * Sets the x and y component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value for the x component to set.
	 * @param {number} y - The value for the y component to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setXY( index, x, y ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize$1( x, this.array );
			y = normalize$1( y, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	}

	/**
	 * Sets the x, y and z component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value for the x component to set.
	 * @param {number} y - The value for the y component to set.
	 * @param {number} z - The value for the z component to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setXYZ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize$1( x, this.array );
			y = normalize$1( y, this.array );
			z = normalize$1( z, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	}

	/**
	 * Sets the x, y, z and w component of the vector at the given index.
	 *
	 * @param {number} index - The index into the buffer attribute.
	 * @param {number} x - The value for the x component to set.
	 * @param {number} y - The value for the y component to set.
	 * @param {number} z - The value for the z component to set.
	 * @param {number} w - The value for the w component to set.
	 * @return {InterleavedBufferAttribute} A reference to this instance.
	 */
	setXYZW( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		if ( this.normalized ) {

			x = normalize$1( x, this.array );
			y = normalize$1( y, this.array );
			z = normalize$1( z, this.array );
			w = normalize$1( w, this.array );

		}

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

	/**
	 * Returns a new buffer attribute with copied values from this instance.
	 *
	 * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
	 *
	 * @param {Object} [data] - An object with interleaved buffers that allows to retain the interleaved property.
	 * @return {BufferAttribute|InterleavedBufferAttribute} A clone of this instance.
	 */
	clone( data ) {

		if ( data === undefined ) {

			log( 'InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

		} else {

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			}

			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		}

	}

	/**
	 * Serializes the buffer attribute into JSON.
	 *
	 * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
	 *
	 * @param {Object} [data] - An optional value holding meta information about the serialization.
	 * @return {Object} A JSON object representing the serialized buffer attribute.
	 */
	toJSON( data ) {

		if ( data === undefined ) {

			log( 'InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			// de-interleave data and save it as an ordinary buffer attribute for now

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			};

		} else {

			// save as true interleaved attribute

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			}

			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};

		}

	}

}

/**
 * A material for rendering instances of {@link Sprite}.
 *
 * ```js
 * const map = new THREE.TextureLoader().load( 'textures/sprite.png' );
 * const material = new THREE.SpriteMaterial( { map: map, color: 0xffffff } );
 *
 * const sprite = new THREE.Sprite( material );
 * sprite.scale.set(200, 200, 1)
 * scene.add( sprite );
 * ```
 *
 * @augments Material
 */
class SpriteMaterial extends Material {

	/**
	 * Constructs a new sprite material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isSpriteMaterial = true;

		this.type = 'SpriteMaterial';

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.color = new Color( 0xffffff );

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		 * color is modulated by the diffuse `color`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * The rotation of the sprite in radians.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.rotation = 0;

		/**
		 * Specifies whether size of the sprite is attenuated by the camera depth (perspective camera only).
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.sizeAttenuation = true;

		/**
		 * Overwritten since sprite materials are transparent
		 * by default.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.transparent = true;

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.rotation = source.rotation;

		this.sizeAttenuation = source.sizeAttenuation;

		this.fog = source.fog;

		return this;

	}

}

let _geometry$1;

const _intersectPoint = /*@__PURE__*/ new Vector3();
const _worldScale = /*@__PURE__*/ new Vector3();
const _mvPosition = /*@__PURE__*/ new Vector3();

const _alignedPosition = /*@__PURE__*/ new Vector2();
const _rotatedPosition = /*@__PURE__*/ new Vector2();
const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();

const _vA$2 = /*@__PURE__*/ new Vector3();
const _vB$2 = /*@__PURE__*/ new Vector3();
const _vC$2 = /*@__PURE__*/ new Vector3();

const _uvA = /*@__PURE__*/ new Vector2();
const _uvB = /*@__PURE__*/ new Vector2();
const _uvC = /*@__PURE__*/ new Vector2();

/**
 * A sprite is a plane that always faces towards the camera, generally with a
 * partially transparent texture applied.
 *
 * Sprites do not cast shadows, setting {@link Object3D#castShadow} to `true` will
 * have no effect.
 *
 * ```js
 * const map = new THREE.TextureLoader().load( 'sprite.png' );
 * const material = new THREE.SpriteMaterial( { map: map } );
 *
 * const sprite = new THREE.Sprite( material );
 * scene.add( sprite );
 * ```
 *
 * @augments Object3D
 */
class Sprite extends Object3D {

	/**
	 * Constructs a new sprite.
	 *
	 * @param {(SpriteMaterial|SpriteNodeMaterial)} [material] - The sprite material.
	 */
	constructor( material = new SpriteMaterial() ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isSprite = true;

		this.type = 'Sprite';

		if ( _geometry$1 === undefined ) {

			_geometry$1 = new BufferGeometry();

			const float32Array = new Float32Array( [
				-0.5, -0.5, 0, 0, 0,
				0.5, -0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				-0.5, 0.5, 0, 0, 1
			] );

			const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

			_geometry$1.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			_geometry$1.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
			_geometry$1.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

		}

		/**
		 * The sprite geometry.
		 *
		 * @type {BufferGeometry}
		 */
		this.geometry = _geometry$1;

		/**
		 * The sprite material.
		 *
		 * @type {(SpriteMaterial|SpriteNodeMaterial)}
		 */
		this.material = material;

		/**
		 * The sprite's anchor point, and the point around which the sprite rotates.
		 * A value of `(0.5, 0.5)` corresponds to the midpoint of the sprite. A value
		 * of `(0, 0)` corresponds to the lower left corner of the sprite.
		 *
		 * @type {Vector2}
		 * @default (0.5,0.5)
		 */
		this.center = new Vector2( 0.5, 0.5 );

		/**
		 * The number of instances of this sprite.
		 * Can only be used with {@link WebGPURenderer}.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.count = 1;

	}

	/**
	 * Computes intersection points between a casted ray and this sprite.
	 *
	 * @param {Raycaster} raycaster - The raycaster.
	 * @param {Array<Object>} intersects - The target array that holds the intersection points.
	 */
	raycast( raycaster, intersects ) {

		if ( raycaster.camera === null ) {

			error( 'Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

		}

		_worldScale.setFromMatrixScale( this.matrixWorld );

		_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
		this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

		_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

		if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

			_worldScale.multiplyScalar( - _mvPosition.z );

		}

		const rotation = this.material.rotation;
		let sin, cos;

		if ( rotation !== 0 ) {

			cos = Math.cos( rotation );
			sin = Math.sin( rotation );

		}

		const center = this.center;

		transformVertex( _vA$2.set( -0.5, -0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vB$2.set( 0.5, -0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vC$2.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

		_uvA.set( 0, 0 );
		_uvB.set( 1, 0 );
		_uvC.set( 1, 1 );

		// check first triangle
		let intersect = raycaster.ray.intersectTriangle( _vA$2, _vB$2, _vC$2, false, _intersectPoint );

		if ( intersect === null ) {

			// check second triangle
			transformVertex( _vB$2.set( -0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			_uvB.set( 0, 1 );

			intersect = raycaster.ray.intersectTriangle( _vA$2, _vC$2, _vB$2, false, _intersectPoint );
			if ( intersect === null ) {

				return;

			}

		}

		const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			point: _intersectPoint.clone(),
			uv: Triangle.getInterpolation( _intersectPoint, _vA$2, _vB$2, _vC$2, _uvA, _uvB, _uvC, new Vector2() ),
			face: null,
			object: this

		} );

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.center !== undefined ) this.center.copy( source.center );

		this.material = source.material;

		return this;

	}

}

function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

	// compute position in camera space
	_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

	// to check if rotation is not zero
	if ( sin !== undefined ) {

		_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
		_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

	} else {

		_rotatedPosition.copy( _alignedPosition );

	}


	vertexPosition.copy( mvPosition );
	vertexPosition.x += _rotatedPosition.x;
	vertexPosition.y += _rotatedPosition.y;

	// transform to world space
	vertexPosition.applyMatrix4( _viewWorldMatrix );

}

/**
 * Creates a texture directly from raw buffer data.
 *
 * The interpretation of the data depends on type and format: If the type is
 * `UnsignedByteType`, a `Uint8Array` will be useful for addressing the
 * texel data. If the format is `RGBAFormat`, data needs four values for
 * one texel; Red, Green, Blue and Alpha (typically the opacity).
 *
 * @augments Texture
 */
class DataTexture extends Texture {

	/**
	 * Constructs a new data texture.
	 *
	 * @param {?TypedArray} [data=null] - The buffer data.
	 * @param {number} [width=1] - The width of the texture.
	 * @param {number} [height=1] - The height of the texture.
	 * @param {number} [format=RGBAFormat] - The texture format.
	 * @param {number} [type=UnsignedByteType] - The texture type.
	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	 * @param {number} [magFilter=NearestFilter] - The mag filter value.
	 * @param {number} [minFilter=NearestFilter] - The min filter value.
	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	 * @param {string} [colorSpace=NoColorSpace] - The color space.
	 */
	constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isDataTexture = true;

		/**
		 * The image definition of a data texture.
		 *
		 * @type {{data:TypedArray,width:number,height:number}}
		 */
		this.image = { data: data, width: width, height: height };

		/**
		 * Whether to generate mipmaps (if possible) for a texture.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.generateMipmaps = false;

		/**
		 * If set to `true`, the texture is flipped along the vertical axis when
		 * uploaded to the GPU.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flipY = false;

		/**
		 * Specifies the alignment requirements for the start of each pixel row in memory.
		 *
		 * Overwritten and set to `1` by default.
		 *
		 * @type {boolean}
		 * @default 1
		 */
		this.unpackAlignment = 1;

	}

}

const _vector1 = /*@__PURE__*/ new Vector3();
const _vector2 = /*@__PURE__*/ new Vector3();
const _normalMatrix = /*@__PURE__*/ new Matrix3();

/**
 * A two dimensional surface that extends infinitely in 3D space, represented
 * in [Hessian normal form](http://mathworld.wolfram.com/HessianNormalForm.html)
 * by a unit length normal vector and a constant.
 */
class Plane {

	/**
	 * Constructs a new plane.
	 *
	 * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
	 * @param {number} [constant=0] - The signed distance from the origin to the plane.
	 */
	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isPlane = true;

		/**
		 * A unit length vector defining the normal of the plane.
		 *
		 * @type {Vector3}
		 */
		this.normal = normal;

		/**
		 * The signed distance from the origin to the plane.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.constant = constant;

	}

	/**
	 * Sets the plane components by copying the given values.
	 *
	 * @param {Vector3} normal - The normal.
	 * @param {number} constant - The constant.
	 * @return {Plane} A reference to this plane.
	 */
	set( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	}

	/**
	 * Sets the plane components by defining `x`, `y`, `z` as the
	 * plane normal and `w` as the constant.
	 *
	 * @param {number} x - The value for the normal's x component.
	 * @param {number} y - The value for the normal's y component.
	 * @param {number} z - The value for the normal's z component.
	 * @param {number} w - The constant value.
	 * @return {Plane} A reference to this plane.
	 */
	setComponents( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	}

	/**
	 * Sets the plane from the given normal and coplanar point (that is a point
	 * that lies onto the plane).
	 *
	 * @param {Vector3} normal - The normal.
	 * @param {Vector3} point - A coplanar point.
	 * @return {Plane} A reference to this plane.
	 */
	setFromNormalAndCoplanarPoint( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	}

	/**
	 * Sets the plane from three coplanar points. The winding order is
	 * assumed to be counter-clockwise, and determines the direction of
	 * the plane normal.
	 *
	 * @param {Vector3} a - The first coplanar point.
	 * @param {Vector3} b - The second coplanar point.
	 * @param {Vector3} c - The third coplanar point.
	 * @return {Plane} A reference to this plane.
	 */
	setFromCoplanarPoints( a, b, c ) {

		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	}

	/**
	 * Copies the values of the given plane to this instance.
	 *
	 * @param {Plane} plane - The plane to copy.
	 * @return {Plane} A reference to this plane.
	 */
	copy( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	}

	/**
	 * Normalizes the plane normal and adjusts the constant accordingly.
	 *
	 * @return {Plane} A reference to this plane.
	 */
	normalize() {

		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	}

	/**
	 * Negates both the plane normal and the constant.
	 *
	 * @return {Plane} A reference to this plane.
	 */
	negate() {

		this.constant *= -1;
		this.normal.negate();

		return this;

	}

	/**
	 * Returns the signed distance from the given point to this plane.
	 *
	 * @param {Vector3} point - The point to compute the distance for.
	 * @return {number} The signed distance.
	 */
	distanceToPoint( point ) {

		return this.normal.dot( point ) + this.constant;

	}

	/**
	 * Returns the signed distance from the given sphere to this plane.
	 *
	 * @param {Sphere} sphere - The sphere to compute the distance for.
	 * @return {number} The signed distance.
	 */
	distanceToSphere( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	}

	/**
	 * Projects a the given point onto the plane.
	 *
	 * @param {Vector3} point - The point to project.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The projected point on the plane.
	 */
	projectPoint( point, target ) {

		return target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );

	}

	/**
	 * Returns the intersection point of the passed line and the plane. Returns
	 * `null` if the line does not intersect. Returns the line's starting point if
	 * the line is coplanar with the plane.
	 *
	 * @param {Line3} line - The line to compute the intersection for.
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {?Vector3} The intersection point.
	 */
	intersectLine( line, target ) {

		const direction = line.delta( _vector1 );

		const denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return null;

		}

		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return null;

		}

		return target.copy( line.start ).addScaledVector( direction, t );

	}

	/**
	 * Returns `true` if the given line segment intersects with (passes through) the plane.
	 *
	 * @param {Line3} line - The line to test.
	 * @return {boolean} Whether the given line segment intersects with the plane or not.
	 */
	intersectsLine( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint( line.start );
		const endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	}

	/**
	 * Returns `true` if the given bounding box intersects with the plane.
	 *
	 * @param {Box3} box - The bounding box to test.
	 * @return {boolean} Whether the given bounding box intersects with the plane or not.
	 */
	intersectsBox( box ) {

		return box.intersectsPlane( this );

	}

	/**
	 * Returns `true` if the given bounding sphere intersects with the plane.
	 *
	 * @param {Sphere} sphere - The bounding sphere to test.
	 * @return {boolean} Whether the given bounding sphere intersects with the plane or not.
	 */
	intersectsSphere( sphere ) {

		return sphere.intersectsPlane( this );

	}

	/**
	 * Returns a coplanar vector to the plane, by calculating the
	 * projection of the normal at the origin onto the plane.
	 *
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The coplanar point.
	 */
	coplanarPoint( target ) {

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	}

	/**
	 * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
	 *
	 * The optional normal matrix can be pre-computed like so:
	 * ```js
	 * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
	 * ```
	 *
	 * @param {Matrix4} matrix - The transformation matrix.
	 * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
	 * @return {Plane} A reference to this plane.
	 */
	applyMatrix4( matrix, optionalNormalMatrix ) {

		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	}

	/**
	 * Translates the plane by the distance defined by the given offset vector.
	 * Note that this only affects the plane constant and will not affect the normal vector.
	 *
	 * @param {Vector3} offset - The offset vector.
	 * @return {Plane} A reference to this plane.
	 */
	translate( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	}

	/**
	 * Returns `true` if this plane is equal with the given one.
	 *
	 * @param {Plane} plane - The plane to test for equality.
	 * @return {boolean} Whether this plane is equal with the given one.
	 */
	equals( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

	/**
	 * Returns a new plane with copied values from this instance.
	 *
	 * @return {Plane} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

}

const _sphere$3 = /*@__PURE__*/ new Sphere();
const _defaultSpriteCenter = /*@__PURE__*/ new Vector2( 0.5, 0.5 );
const _vector$6 = /*@__PURE__*/ new Vector3();

/**
 * Frustums are used to determine what is inside the camera's field of view.
 * They help speed up the rendering process - objects which lie outside a camera's
 * frustum can safely be excluded from rendering.
 *
 * This class is mainly intended for use internally by a renderer.
 */
class Frustum {

	/**
	 * Constructs a new frustum.
	 *
	 * @param {Plane} [p0] - The first plane that encloses the frustum.
	 * @param {Plane} [p1] - The second plane that encloses the frustum.
	 * @param {Plane} [p2] - The third plane that encloses the frustum.
	 * @param {Plane} [p3] - The fourth plane that encloses the frustum.
	 * @param {Plane} [p4] - The fifth plane that encloses the frustum.
	 * @param {Plane} [p5] - The sixth plane that encloses the frustum.
	 */
	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

		/**
		 * This array holds the planes that enclose the frustum.
		 *
		 * @type {Array<Plane>}
		 */
		this.planes = [ p0, p1, p2, p3, p4, p5 ];

	}

	/**
	 * Sets the frustum planes by copying the given planes.
	 *
	 * @param {Plane} [p0] - The first plane that encloses the frustum.
	 * @param {Plane} [p1] - The second plane that encloses the frustum.
	 * @param {Plane} [p2] - The third plane that encloses the frustum.
	 * @param {Plane} [p3] - The fourth plane that encloses the frustum.
	 * @param {Plane} [p4] - The fifth plane that encloses the frustum.
	 * @param {Plane} [p5] - The sixth plane that encloses the frustum.
	 * @return {Frustum} A reference to this frustum.
	 */
	set( p0, p1, p2, p3, p4, p5 ) {

		const planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	}

	/**
	 * Copies the values of the given frustum to this instance.
	 *
	 * @param {Frustum} frustum - The frustum to copy.
	 * @return {Frustum} A reference to this frustum.
	 */
	copy( frustum ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	}

	/**
	 * Sets the frustum planes from the given projection matrix.
	 *
	 * @param {Matrix4} m - The projection matrix.
	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.
	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
	 * @return {Frustum} A reference to this frustum.
	 */
	setFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false ) {

		const planes = this.planes;
		const me = m.elements;
		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();

		if ( reversedDepth ) {

			planes[ 4 ].setComponents( me2, me6, me10, me14 ).normalize(); // far
			planes[ 5 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize(); // near

		} else {

			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize(); // far

			if ( coordinateSystem === WebGLCoordinateSystem ) {

				planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize(); // near

			} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

				planes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize(); // near

			} else {

				throw new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );

			}

		}

		return this;

	}

	/**
	 * Returns `true` if the 3D object's bounding sphere is intersecting this frustum.
	 *
	 * Note that the 3D object must have a geometry so that the bounding sphere can be calculated.
	 *
	 * @param {Object3D} object - The 3D object to test.
	 * @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.
	 */
	intersectsObject( object ) {

		if ( object.boundingSphere !== undefined ) {

			if ( object.boundingSphere === null ) object.computeBoundingSphere();

			_sphere$3.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );

		} else {

			const geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		}

		return this.intersectsSphere( _sphere$3 );

	}

	/**
	 * Returns `true` if the given sprite is intersecting this frustum.
	 *
	 * @param {Sprite} sprite - The sprite to test.
	 * @return {boolean} Whether the sprite is intersecting this frustum or not.
	 */
	intersectsSprite( sprite ) {

		_sphere$3.center.set( 0, 0, 0 );

		const offset = _defaultSpriteCenter.distanceTo( sprite.center );

		_sphere$3.radius = 0.7071067811865476 + offset;
		_sphere$3.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$3 );

	}

	/**
	 * Returns `true` if the given bounding sphere is intersecting this frustum.
	 *
	 * @param {Sphere} sphere - The bounding sphere to test.
	 * @return {boolean} Whether the bounding sphere is intersecting this frustum or not.
	 */
	intersectsSphere( sphere ) {

		const planes = this.planes;
		const center = sphere.center;
		const negRadius = - sphere.radius;

		for ( let i = 0; i < 6; i ++ ) {

			const distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	}

	/**
	 * Returns `true` if the given bounding box is intersecting this frustum.
	 *
	 * @param {Box3} box - The bounding box to test.
	 * @return {boolean} Whether the bounding box is intersecting this frustum or not.
	 */
	intersectsBox( box ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			const plane = planes[ i ];

			// corner at max distance

			_vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$6 ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	/**
	 * Returns `true` if the given point lies within the frustum.
	 *
	 * @param {Vector3} point - The point to test.
	 * @return {boolean} Whether the point lies within this frustum or not.
	 */
	containsPoint( point ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	/**
	 * Returns a new frustum with copied values from this instance.
	 *
	 * @return {Frustum} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

}

/**
 * A material for rendering line primitives.
 *
 * Materials define the appearance of renderable 3D objects.
 *
 * ```js
 * const material = new THREE.LineBasicMaterial( { color: 0xffffff } );
 * ```
 *
 * @augments Material
 */
class LineBasicMaterial extends Material {

	/**
	 * Constructs a new line basic material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isLineBasicMaterial = true;

		this.type = 'LineBasicMaterial';

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.color = new Color( 0xffffff );

		/**
		 * Sets the color of the lines using data from a texture. The texture map
		 * color is modulated by the diffuse `color`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * Controls line thickness or lines.
		 *
		 * Can only be used with {@link SVGRenderer}. WebGL and WebGPU
		 * ignore this setting and always render line primitives with a
		 * width of one pixel.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.linewidth = 1;

		/**
		 * Defines appearance of line ends.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('butt'|'round'|'square')}
		 * @default 'round'
		 */
		this.linecap = 'round';

		/**
		 * Defines appearance of line joints.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.linejoin = 'round';

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		this.fog = source.fog;

		return this;

	}

}

const _vStart = /*@__PURE__*/ new Vector3();
const _vEnd = /*@__PURE__*/ new Vector3();

const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
const _ray$1 = /*@__PURE__*/ new Ray();
const _sphere$1 = /*@__PURE__*/ new Sphere();

const _intersectPointOnRay = /*@__PURE__*/ new Vector3();
const _intersectPointOnSegment = /*@__PURE__*/ new Vector3();

/**
 * A continuous line. The line are rendered by connecting consecutive
 * vertices with straight lines.
 *
 * ```js
 * const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
 *
 * const points = [];
 * points.push( new THREE.Vector3( - 10, 0, 0 ) );
 * points.push( new THREE.Vector3( 0, 10, 0 ) );
 * points.push( new THREE.Vector3( 10, 0, 0 ) );
 *
 * const geometry = new THREE.BufferGeometry().setFromPoints( points );
 *
 * const line = new THREE.Line( geometry, material );
 * scene.add( line );
 * ```
 *
 * @augments Object3D
 */
class Line extends Object3D {

	/**
	 * Constructs a new line.
	 *
	 * @param {BufferGeometry} [geometry] - The line geometry.
	 * @param {Material|Array<Material>} [material] - The line material.
	 */
	constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isLine = true;

		this.type = 'Line';

		/**
		 * The line geometry.
		 *
		 * @type {BufferGeometry}
		 */
		this.geometry = geometry;

		/**
		 * The line material.
		 *
		 * @type {Material|Array<Material>}
		 * @default LineBasicMaterial
		 */
		this.material = material;

		/**
		 * A dictionary representing the morph targets in the geometry. The key is the
		 * morph targets name, the value its attribute index. This member is `undefined`
		 * by default and only set when morph targets are detected in the geometry.
		 *
		 * @type {Object<String,number>|undefined}
		 * @default undefined
		 */
		this.morphTargetDictionary = undefined;

		/**
		 * An array of weights typically in the range `[0,1]` that specify how much of the morph
		 * is applied. This member is `undefined` by default and only set when morph targets are
		 * detected in the geometry.
		 *
		 * @type {Array<number>|undefined}
		 * @default undefined
		 */
		this.morphTargetInfluences = undefined;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
		this.geometry = source.geometry;

		return this;

	}

	/**
	 * Computes an array of distance values which are necessary for rendering dashed lines.
	 * For each vertex in the geometry, the method calculates the cumulative length from the
	 * current point to the very beginning of the line.
	 *
	 * @return {Line} A reference to this line.
	 */
	computeLineDistances() {

		const geometry = this.geometry;

		// we assume non-indexed geometry

		if ( geometry.index === null ) {

			const positionAttribute = geometry.attributes.position;
			const lineDistances = [ 0 ];

			for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

				_vStart.fromBufferAttribute( positionAttribute, i - 1 );
				_vEnd.fromBufferAttribute( positionAttribute, i );

				lineDistances[ i ] = lineDistances[ i - 1 ];
				lineDistances[ i ] += _vStart.distanceTo( _vEnd );

			}

			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

		} else {

			warn( 'Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

		}

		return this;

	}

	/**
	 * Computes intersection points between a casted ray and this line.
	 *
	 * @param {Raycaster} raycaster - The raycaster.
	 * @param {Array<Object>} intersects - The target array that holds the intersection points.
	 */
	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$1.copy( geometry.boundingSphere );
		_sphere$1.applyMatrix4( matrixWorld );
		_sphere$1.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

		//

		_inverseMatrix$1.copy( matrixWorld ).invert();
		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const step = this.isLineSegments ? 2 : 1;

		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;

		if ( index !== null ) {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end - 1; i < l; i += step ) {

				const a = index.getX( i );
				const b = index.getX( i + 1 );

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b, i );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

			if ( this.isLineLoop ) {

				const a = index.getX( end - 1 );
				const b = index.getX( start );

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b, end - 1 );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

		} else {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end - 1; i < l; i += step ) {

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, i, i + 1, i );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

			if ( this.isLineLoop ) {

				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, end - 1, start, end - 1 );

				if ( intersect ) {

					intersects.push( intersect );

				}

			}

		}

	}

	/**
	 * Sets the values of {@link Line#morphTargetDictionary} and {@link Line#morphTargetInfluences}
	 * to make sure existing morph targets can influence this 3D object.
	 */
	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

}

function checkIntersection( object, raycaster, ray, thresholdSq, a, b, i ) {

	const positionAttribute = object.geometry.attributes.position;

	_vStart.fromBufferAttribute( positionAttribute, a );
	_vEnd.fromBufferAttribute( positionAttribute, b );

	const distSq = ray.distanceSqToSegment( _vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment );

	if ( distSq > thresholdSq ) return;

	_intersectPointOnRay.applyMatrix4( object.matrixWorld ); // Move back to world space for distance calculation

	const distance = raycaster.ray.origin.distanceTo( _intersectPointOnRay );

	if ( distance < raycaster.near || distance > raycaster.far ) return;

	return {

		distance: distance,
		// What do we want? intersection point on the ray or on the segment??
		// point: raycaster.ray.at( distance ),
		point: _intersectPointOnSegment.clone().applyMatrix4( object.matrixWorld ),
		index: i,
		face: null,
		faceIndex: null,
		barycoord: null,
		object: object

	};

}

const _start = /*@__PURE__*/ new Vector3();
const _end = /*@__PURE__*/ new Vector3();

/**
 * A series of lines drawn between pairs of vertices.
 *
 * @augments Line
 */
class LineSegments extends Line {

	/**
	 * Constructs a new line segments.
	 *
	 * @param {BufferGeometry} [geometry] - The line geometry.
	 * @param {Material|Array<Material>} [material] - The line material.
	 */
	constructor( geometry, material ) {

		super( geometry, material );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isLineSegments = true;

		this.type = 'LineSegments';

	}

	computeLineDistances() {

		const geometry = this.geometry;

		// we assume non-indexed geometry

		if ( geometry.index === null ) {

			const positionAttribute = geometry.attributes.position;
			const lineDistances = [];

			for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

				_start.fromBufferAttribute( positionAttribute, i );
				_end.fromBufferAttribute( positionAttribute, i + 1 );

				lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
				lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

			}

			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

		} else {

			warn( 'LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

		}

		return this;

	}

}

/**
 * A material for rendering point primitives.
 *
 * Materials define the appearance of renderable 3D objects.
 *
 * ```js
 * const vertices = [];
 *
 * for ( let i = 0; i < 10000; i ++ ) {
 * 	const x = THREE.MathUtils.randFloatSpread( 2000 );
 * 	const y = THREE.MathUtils.randFloatSpread( 2000 );
 * 	const z = THREE.MathUtils.randFloatSpread( 2000 );
 *
 * 	vertices.push( x, y, z );
 * }
 *
 * const geometry = new THREE.BufferGeometry();
 * geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
 * const material = new THREE.PointsMaterial( { color: 0x888888 } );
 * const points = new THREE.Points( geometry, material );
 * scene.add( points );
 * ```
 *
 * @augments Material
 */
class PointsMaterial extends Material {

	/**
	 * Constructs a new points material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isPointsMaterial = true;

		this.type = 'PointsMaterial';

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.color = new Color( 0xffffff );

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		 * color is modulated by the diffuse `color`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * Defines the size of the points in pixels.
		 *
		 * Might be capped if the value exceeds hardware dependent parameters like [gl.ALIASED_POINT_SIZE_RANGE](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getParamete).
		 *
		 * @type {number}
		 * @default 1
		 */
		this.size = 1;

		/**
		 * Specifies whether size of individual points is attenuated by the camera depth (perspective camera only).
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.sizeAttenuation = true;

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.fog = source.fog;

		return this;

	}

}

const _inverseMatrix = /*@__PURE__*/ new Matrix4();
const _ray$2 = /*@__PURE__*/ new Ray();
const _sphere = /*@__PURE__*/ new Sphere();
const _position$2 = /*@__PURE__*/ new Vector3();

/**
 * A class for displaying points or point clouds.
 *
 * @augments Object3D
 */
class Points extends Object3D {

	/**
	 * Constructs a new point cloud.
	 *
	 * @param {BufferGeometry} [geometry] - The points geometry.
	 * @param {Material|Array<Material>} [material] - The points material.
	 */
	constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isPoints = true;

		this.type = 'Points';

		/**
		 * The points geometry.
		 *
		 * @type {BufferGeometry}
		 */
		this.geometry = geometry;

		/**
		 * The line material.
		 *
		 * @type {Material|Array<Material>}
		 * @default PointsMaterial
		 */
		this.material = material;

		/**
		 * A dictionary representing the morph targets in the geometry. The key is the
		 * morph targets name, the value its attribute index. This member is `undefined`
		 * by default and only set when morph targets are detected in the geometry.
		 *
		 * @type {Object<String,number>|undefined}
		 * @default undefined
		 */
		this.morphTargetDictionary = undefined;

		/**
		 * An array of weights typically in the range `[0,1]` that specify how much of the morph
		 * is applied. This member is `undefined` by default and only set when morph targets are
		 * detected in the geometry.
		 *
		 * @type {Array<number>|undefined}
		 * @default undefined
		 */
		this.morphTargetInfluences = undefined;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
		this.geometry = source.geometry;

		return this;

	}

	/**
	 * Computes intersection points between a casted ray and this point cloud.
	 *
	 * @param {Raycaster} raycaster - The raycaster.
	 * @param {Array<Object>} intersects - The target array that holds the intersection points.
	 */
	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );
		_sphere.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;

		if ( index !== null ) {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, il = end; i < il; i ++ ) {

				const a = index.getX( i );

				_position$2.fromBufferAttribute( positionAttribute, a );

				testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		} else {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end; i < l; i ++ ) {

				_position$2.fromBufferAttribute( positionAttribute, i );

				testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		}

	}

	/**
	 * Sets the values of {@link Points#morphTargetDictionary} and {@link Points#morphTargetInfluences}
	 * to make sure existing morph targets can influence this 3D object.
	 */
	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

}

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	const rayPointDistanceSq = _ray$2.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		const intersectPoint = new Vector3();

		_ray$2.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			faceIndex: null,
			barycoord: null,
			object: object

		} );

	}

}

/**
 * Creates a texture from a canvas element.
 *
 * This is almost the same as the base texture class, except that it sets {@link Texture#needsUpdate}
 * to `true` immediately since a canvas can directly be used for rendering.
 *
 * @augments Texture
 */
class CanvasTexture extends Texture {

	/**
	 * Constructs a new texture.
	 *
	 * @param {HTMLCanvasElement} [canvas] - The HTML canvas element.
	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
	 * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
	 * @param {number} [format=RGBAFormat] - The texture format.
	 * @param {number} [type=UnsignedByteType] - The texture type.
	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	 */
	constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isCanvasTexture = true;

		this.needsUpdate = true;

	}

}

/**
 * This class can be used to automatically save the depth information of a
 * rendering into a texture.
 *
 * @augments Texture
 */
class DepthTexture extends Texture {

	/**
	 * Constructs a new depth texture.
	 *
	 * @param {number} width - The width of the texture.
	 * @param {number} height - The height of the texture.
	 * @param {number} [type=UnsignedIntType] - The texture type.
	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
	 * @param {number} [minFilter=LinearFilter] - The min filter value.
	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
	 * @param {number} [format=DepthFormat] - The texture format.
	 * @param {number} [depth=1] - The depth of the texture.
	 */
	constructor( width, height, type = UnsignedIntType, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, format = DepthFormat, depth = 1 ) {

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		const image = { width: width, height: height, depth: depth };

		super( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isDepthTexture = true;

		/**
		 * If set to `true`, the texture is flipped along the vertical axis when
		 * uploaded to the GPU.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flipY = false;

		/**
		 * Whether to generate mipmaps (if possible) for a texture.
		 *
		 * Overwritten and set to `false` by default.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.generateMipmaps = false;

		/**
		 * Code corresponding to the depth compare function.
		 *
		 * @type {?(NeverCompare|LessCompare|EqualCompare|LessEqualCompare|GreaterCompare|NotEqualCompare|GreaterEqualCompare|AlwaysCompare)}
		 * @default null
		 */
		this.compareFunction = null;

	}


	copy( source ) {

		super.copy( source );

		this.source = new Source( Object.assign( {}, source.image ) ); // see #30540
		this.compareFunction = source.compareFunction;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;

		return data;

	}

}

/**
 * Represents a texture created externally with the same renderer context.
 *
 * This may be a texture from a protected media stream, device camera feed,
 * or other data feeds like a depth sensor.
 *
 * Note that this class is only supported in {@link WebGLRenderer}, and in
 * the {@link WebGPURenderer} WebGPU backend.
 *
 * @augments Texture
 */
class ExternalTexture extends Texture {

	/**
	 * Creates a new raw texture.
	 *
	 * @param {?(WebGLTexture|GPUTexture)} [sourceTexture=null] - The external texture.
	 */
	constructor( sourceTexture = null ) {

		super();

		/**
		 * The external source texture.
		 *
		 * @type {?(WebGLTexture|GPUTexture)}
		 * @default null
		 */
		this.sourceTexture = sourceTexture;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isExternalTexture = true;

	}

	copy( source ) {

		super.copy( source );

		this.sourceTexture = source.sourceTexture;

		return this;

	}

}

/**
 * A simple shape of Euclidean geometry. It is constructed from a
 * number of triangular segments that are oriented around a central point and
 * extend as far out as a given radius. It is built counter-clockwise from a
 * start angle and a given central angle. It can also be used to create
 * regular polygons, where the number of segments determines the number of
 * sides.
 *
 * ```js
 * const geometry = new THREE.CircleGeometry( 5, 32 );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const circle = new THREE.Mesh( geometry, material );
 * scene.add( circle )
 * ```
 *
 * @augments BufferGeometry
 * @demo scenes/geometry-browser.html#CircleGeometry
 */
class CircleGeometry extends BufferGeometry {

	/**
	 * Constructs a new circle geometry.
	 *
	 * @param {number} [radius=1] - Radius of the circle.
	 * @param {number} [segments=32] - Number of segments (triangles), minimum = `3`.
	 * @param {number} [thetaStart=0] - Start angle for first segment in radians.
	 * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta,
	 * of the circular sector in radians. The default value results in a complete circle.
	 */
	constructor( radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CircleGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		segments = Math.max( 3, segments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			const segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( let i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {CircleGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );

	}

}

/**
 * A polyhedron is a solid in three dimensions with flat faces. This class
 * will take an array of vertices, project them onto a sphere, and then
 * divide them up to the desired level of detail.
 *
 * @augments BufferGeometry
 */
class PolyhedronGeometry extends BufferGeometry {

	/**
	 * Constructs a new polyhedron geometry.
	 *
	 * @param {Array<number>} [vertices] - A flat array of vertices describing the base shape.
	 * @param {Array<number>} [indices] - A flat array of indices describing the base shape.
	 * @param {number} [radius=1] - The radius of the shape.
	 * @param {number} [detail=0] - How many levels to subdivide the geometry. The more detail, the smoother the shape.
	 */
	constructor( vertices = [], indices = [], radius = 1, detail = 0 ) {

		super();

		this.type = 'PolyhedronGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		applyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			// iterate over all faces and apply a subdivision with the given detail value

			for ( let i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			const cols = detail + 1;

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			// construct all of the vertices for this subdivision

			for ( let i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				const aj = a.clone().lerp( c, i / cols );
				const bj = b.clone().lerp( c, i / cols );

				const rows = cols - i;

				for ( let j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( let i = 0; i < cols; i ++ ) {

				for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					const k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function applyRadius( radius ) {

			const vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			const vertex = new Vector3();

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				const v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( let i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				const x0 = uvBuffer[ i + 0 ];
				const x1 = uvBuffer[ i + 2 ];
				const x2 = uvBuffer[ i + 4 ];

				const max = Math.max( x0, x1, x2 );
				const min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			const stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			const centroid = new Vector3();

			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();

			for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				const azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {PolyhedronGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );

	}

}

/**
 * A geometry class for representing a dodecahedron.
 *
 * ```js
 * const geometry = new THREE.DodecahedronGeometry();
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const dodecahedron = new THREE.Mesh( geometry, material );
 * scene.add( dodecahedron );
 * ```
 *
 * @augments PolyhedronGeometry
 * @demo scenes/geometry-browser.html#DodecahedronGeometry
 */
class DodecahedronGeometry extends PolyhedronGeometry {

	/**
	 * Constructs a new dodecahedron geometry.
	 *
	 * @param {number} [radius=1] - Radius of the dodecahedron.
	 * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a dodecahedron.
	 */
	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;
		const r = 1 / t;

		const vertices = [

			// (±1, ±1, ±1)
			-1, -1, -1,	-1, -1, 1,
			-1, 1, -1, -1, 1, 1,
			1, -1, -1, 1, -1, 1,
			1, 1, -1, 1, 1, 1,

			// (0, ±1/φ, ±φ)
			0, - r, - t, 0, - r, t,
			0, r, - t, 0, r, t,

			// (±1/φ, ±φ, 0)
			- r, - t, 0, - r, t, 0,
			r, - t, 0, r, t, 0,

			// (±φ, 0, ±1/φ)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		const indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		super( vertices, indices, radius, detail );

		this.type = 'DodecahedronGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {DodecahedronGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new DodecahedronGeometry( data.radius, data.detail );

	}

}

/**
 * A geometry class for representing an icosahedron.
 *
 * ```js
 * const geometry = new THREE.IcosahedronGeometry();
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const icosahedron = new THREE.Mesh( geometry, material );
 * scene.add( icosahedron );
 * ```
 *
 * @augments PolyhedronGeometry
 * @demo scenes/geometry-browser.html#IcosahedronGeometry
 */
class IcosahedronGeometry extends PolyhedronGeometry {

	/**
	 * Constructs a new icosahedron geometry.
	 *
	 * @param {number} [radius=1] - Radius of the icosahedron.
	 * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a icosahedron.
	 */
	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;

		const vertices = [
			-1, t, 0, 	1, t, 0, 	-1, - t, 0, 	1, - t, 0,
			0, -1, t, 	0, 1, t,	0, -1, - t, 	0, 1, - t,
			t, 0, -1, 	t, 0, 1, 	- t, 0, -1, 	- t, 0, 1
		];

		const indices = [
			0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {IcosahedronGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new IcosahedronGeometry( data.radius, data.detail );

	}

}

/**
 * A geometry class for representing an octahedron.
 *
 * ```js
 * const geometry = new THREE.OctahedronGeometry();
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const octahedron = new THREE.Mesh( geometry, material );
 * scene.add( octahedron );
 * ```
 *
 * @augments PolyhedronGeometry
 * @demo scenes/geometry-browser.html#OctahedronGeometry
 */
class OctahedronGeometry extends PolyhedronGeometry {

	/**
	 * Constructs a new octahedron geometry.
	 *
	 * @param {number} [radius=1] - Radius of the octahedron.
	 * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a octahedron.
	 */
	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 0, 0, 	-1, 0, 0,	0, 1, 0,
			0, -1, 0, 	0, 0, 1,	0, 0, -1
		];

		const indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		super( vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {OctahedronGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new OctahedronGeometry( data.radius, data.detail );

	}

}

/**
 * A geometry class for representing a plane.
 *
 * ```js
 * const geometry = new THREE.PlaneGeometry( 1, 1 );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
 * const plane = new THREE.Mesh( geometry, material );
 * scene.add( plane );
 * ```
 *
 * @augments BufferGeometry
 * @demo scenes/geometry-browser.html#PlaneGeometry
 */
class PlaneGeometry extends BufferGeometry {

	/**
	 * Constructs a new plane geometry.
	 *
	 * @param {number} [width=1] - The width along the X axis.
	 * @param {number} [height=1] - The height along the Y axis
	 * @param {number} [widthSegments=1] - The number of segments along the X axis.
	 * @param {number} [heightSegments=1] - The number of segments along the Y axis.
	 */
	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		super();

		this.type = 'PlaneGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		const width_half = width / 2;
		const height_half = height / 2;

		const gridX = Math.floor( widthSegments );
		const gridY = Math.floor( heightSegments );

		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;

		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		for ( let iy = 0; iy < gridY1; iy ++ ) {

			const y = iy * segment_height - height_half;

			for ( let ix = 0; ix < gridX1; ix ++ ) {

				const x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		for ( let iy = 0; iy < gridY; iy ++ ) {

			for ( let ix = 0; ix < gridX; ix ++ ) {

				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * ( iy + 1 );
				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				const d = ( ix + 1 ) + gridX1 * iy;

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {PlaneGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

	}

}

/**
 * A class for generating a two-dimensional ring geometry.
 *
 * ```js
 * const geometry = new THREE.RingGeometry( 1, 5, 32 );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
 * const mesh = new THREE.Mesh( geometry, material );
 * scene.add( mesh );
 * ```
 *
 * @augments BufferGeometry
 * @demo scenes/geometry-browser.html#RingGeometry
 */
class RingGeometry extends BufferGeometry {

	/**
	 * Constructs a new ring geometry.
	 *
	 * @param {number} [innerRadius=0.5] - The inner radius of the ring.
	 * @param {number} [outerRadius=1] - The outer radius of the ring.
	 * @param {number} [thetaSegments=32] - Number of segments. A higher number means the ring will be more round. Minimum is `3`.
	 * @param {number} [phiSegments=1] - Number of segments per ring segment. Minimum is `1`.
	 * @param {number} [thetaStart=0] - Starting angle in radians.
	 * @param {number} [thetaLength=Math.PI*2] - Central angle in radians.
	 */
	constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'RingGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		thetaSegments = Math.max( 3, thetaSegments );
		phiSegments = Math.max( 1, phiSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// some helper variables

		let radius = innerRadius;
		const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		const vertex = new Vector3();
		const uv = new Vector2();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= phiSegments; j ++ ) {

			for ( let i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				const segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( let j = 0; j < phiSegments; j ++ ) {

			const thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( let i = 0; i < thetaSegments; i ++ ) {

				const segment = i + thetaSegmentLevel;

				const a = segment;
				const b = segment + thetaSegments + 1;
				const c = segment + thetaSegments + 2;
				const d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {RingGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );

	}

}

/**
 * A class for generating a sphere geometry.
 *
 * ```js
 * const geometry = new THREE.SphereGeometry( 15, 32, 16 );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const sphere = new THREE.Mesh( geometry, material );
 * scene.add( sphere );
 * ```
 *
 * @augments BufferGeometry
 * @demo scenes/geometry-browser.html#SphereGeometry
 */
class SphereGeometry extends BufferGeometry {

	/**
	 * Constructs a new sphere geometry.
	 *
	 * @param {number} [radius=1] - The sphere radius.
	 * @param {number} [widthSegments=32] - The number of horizontal segments. Minimum value is `3`.
	 * @param {number} [heightSegments=16] - The number of vertical segments. Minimum value is `2`.
	 * @param {number} [phiStart=0] - The horizontal starting angle in radians.
	 * @param {number} [phiLength=Math.PI*2] - The horizontal sweep angle size.
	 * @param {number} [thetaStart=0] - The vertical starting angle in radians.
	 * @param {number} [thetaLength=Math.PI] - The vertical sweep angle size.
	 */
	constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

		super();

		this.type = 'SphereGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

		let index = 0;
		const grid = [];

		const vertex = new Vector3();
		const normal = new Vector3();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

			const verticesRow = [];

			const v = iy / heightSegments;

			// special case for the poles

			let uOffset = 0;

			if ( iy === 0 && thetaStart === 0 ) {

				uOffset = 0.5 / widthSegments;

			} else if ( iy === heightSegments && thetaEnd === Math.PI ) {

				uOffset = -0.5 / widthSegments;

			}

			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

				const u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( let iy = 0; iy < heightSegments; iy ++ ) {

			for ( let ix = 0; ix < widthSegments; ix ++ ) {

				const a = grid[ iy ][ ix + 1 ];
				const b = grid[ iy ][ ix ];
				const c = grid[ iy + 1 ][ ix ];
				const d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {SphereGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

	}

}

/**
 * A geometry class for representing an torus.
 *
 * ```js
 * const geometry = new THREE.TorusGeometry( 10, 3, 16, 100 );
 * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
 * const torus = new THREE.Mesh( geometry, material );
 * scene.add( torus );
 * ```
 *
 * @augments BufferGeometry
 * @demo scenes/geometry-browser.html#TorusGeometry
 */
class TorusGeometry extends BufferGeometry {

	/**
	 * Constructs a new torus geometry.
	 *
	 * @param {number} [radius=1] - Radius of the torus, from the center of the torus to the center of the tube.
	 * @param {number} [tube=0.4] - Radius of the tube. Must be smaller than `radius`.
	 * @param {number} [radialSegments=12] - The number of radial segments.
	 * @param {number} [tubularSegments=48] - The number of tubular segments.
	 * @param {number} [arc=Math.PI*2] - Central angle in radians.
	 */
	constructor( radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2 ) {

		super();

		this.type = 'TorusGeometry';

		/**
		 * Holds the constructor parameters that have been
		 * used to generate the geometry. Any modification
		 * after instantiation does not change the geometry.
		 *
		 * @type {Object}
		 */
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radialSegments = Math.floor( radialSegments );
		tubularSegments = Math.floor( tubularSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new Vector3();
		const vertex = new Vector3();
		const normal = new Vector3();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= radialSegments; j ++ ) {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= radialSegments; j ++ ) {

			for ( let i = 1; i <= tubularSegments; i ++ ) {

				// indices

				const a = ( tubularSegments + 1 ) * j + i - 1;
				const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				const d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	copy( source ) {

		super.copy( source );

		this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	/**
	 * Factory method for creating an instance of this class from the given
	 * JSON object.
	 *
	 * @param {Object} data - A JSON object representing the serialized geometry.
	 * @return {TorusGeometry} A new instance.
	 */
	static fromJSON( data ) {

		return new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );

	}

}

/**
 * A standard physically based material, using Metallic-Roughness workflow.
 *
 * Physically based rendering (PBR) has recently become the standard in many
 * 3D applications, such as [Unity](https://blogs.unity3d.com/2014/10/29/physically-based-shading-in-unity-5-a-primer/),
 * [Unreal](https://docs.unrealengine.com/latest/INT/Engine/Rendering/Materials/PhysicallyBased/) and
 * [3D Studio Max](http://area.autodesk.com/blogs/the-3ds-max-blog/what039s-new-for-rendering-in-3ds-max-2017).
 *
 * This approach differs from older approaches in that instead of using
 * approximations for the way in which light interacts with a surface, a
 * physically correct model is used. The idea is that, instead of tweaking
 * materials to look good under specific lighting, a material can be created
 * that will react 'correctly' under all lighting scenarios.
 *
 * In practice this gives a more accurate and realistic looking result than
 * the {@link MeshLambertMaterial} or {@link MeshPhongMaterial}, at the cost of
 * being somewhat more computationally expensive. `MeshStandardMaterial` uses per-fragment
 * shading.
 *
 * Note that for best results you should always specify an environment map when using this material.
 *
 * For a non-technical introduction to the concept of PBR and how to set up a
 * PBR material, check out these articles by the people at [marmoset](https://www.marmoset.co):
 *
 * - [Basic Theory of Physically Based Rendering](https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/)
 * - [Physically Based Rendering and You Can Too](https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/)
 *
 * Technical details of the approach used in three.js (and most other PBR systems) can be found is this
 * [paper from Disney](https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf)
 * (pdf), by Brent Burley.
 *
 * @augments Material
 * @demo scenes/material-browser.html#MeshStandardMaterial
 */
class MeshStandardMaterial extends Material {

	/**
	 * Constructs a new mesh standard material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshStandardMaterial = true;

		this.type = 'MeshStandardMaterial';

		this.defines = { 'STANDARD': '' };

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.color = new Color( 0xffffff ); // diffuse

		/**
		 * How rough the material appears. `0.0` means a smooth mirror reflection, `1.0`
		 * means fully diffuse. If `roughnessMap` is also provided,
		 * both values are multiplied.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.roughness = 1.0;

		/**
		 * How much the material is like a metal. Non-metallic materials such as wood
		 * or stone use `0.0`, metallic use `1.0`, with nothing (usually) in between.
		 * A value between `0.0` and `1.0` could be used for a rusty metal look.
		 * If `metalnessMap` is also provided, both values are multiplied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.metalness = 0.0;

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		 * color is modulated by the diffuse `color`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The light map. Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.lightMap = null;

		/**
		 * Intensity of the baked light.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.lightMapIntensity = 1.0;

		/**
		 * The red channel of this texture is used as the ambient occlusion map.
		 * Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.aoMap = null;

		/**
		 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
		 * disables ambient occlusion. Where intensity is `1` and the AO map's
		 * red channel is also `1`, ambient light is fully occluded on a surface.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.aoMapIntensity = 1.0;

		/**
		 * Emissive (light) color of the material, essentially a solid color
		 * unaffected by other lighting.
		 *
		 * @type {Color}
		 * @default (0,0,0)
		 */
		this.emissive = new Color( 0x000000 );

		/**
		 * Intensity of the emissive light. Modulates the emissive color.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.emissiveIntensity = 1.0;

		/**
		 * Set emissive (glow) map. The emissive map color is modulated by the
		 * emissive color and the emissive intensity. If you have an emissive map,
		 * be sure to set the emissive color to something other than black.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.emissiveMap = null;

		/**
		 * The texture to create a bump map. The black and white values map to the
		 * perceived depth in relation to the lights. Bump doesn't actually affect
		 * the geometry of the object, only the lighting. If a normal map is defined
		 * this will be ignored.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.bumpMap = null;

		/**
		 * How much the bump map affects the material. Typical range is `[0,1]`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.bumpScale = 1;

		/**
		 * The texture to create a normal map. The RGB values affect the surface
		 * normal for each pixel fragment and change the way the color is lit. Normal
		 * maps do not change the actual shape of the surface, only the lighting. In
		 * case the material has a normal map authored using the left handed
		 * convention, the `y` component of `normalScale` should be negated to compensate
		 * for the different handedness.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.normalMap = null;

		/**
		 * The type of normal map.
		 *
		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		 * @default TangentSpaceNormalMap
		 */
		this.normalMapType = TangentSpaceNormalMap;

		/**
		 * How much the normal map affects the material. Typical value range is `[0,1]`.
		 *
		 * @type {Vector2}
		 * @default (1,1)
		 */
		this.normalScale = new Vector2( 1, 1 );

		/**
		 * The displacement map affects the position of the mesh's vertices. Unlike
		 * other maps which only affect the light and shade of the material the
		 * displaced vertices can cast shadows, block other objects, and otherwise
		 * act as real geometry. The displacement texture is an image where the value
		 * of each pixel (white being the highest) is mapped against, and
		 * repositions, the vertices of the mesh.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.displacementMap = null;

		/**
		 * How much the displacement map affects the mesh (where black is no
		 * displacement, and white is maximum displacement). Without a displacement
		 * map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementScale = 1;

		/**
		 * The offset of the displacement map's values on the mesh's vertices.
		 * The bias is added to the scaled sample of the displacement map.
		 * Without a displacement map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementBias = 0;

		/**
		 * The green channel of this texture is used to alter the roughness of the
		 * material.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.roughnessMap = null;

		/**
		 * The blue channel of this texture is used to alter the metalness of the
		 * material.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.metalnessMap = null;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * The environment map. To ensure a physically correct rendering, environment maps
		 * are internally pre-processed with {@link PMREMGenerator}.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.envMap = null;

		/**
		 * The rotation of the environment map in radians.
		 *
		 * @type {Euler}
		 * @default (0,0,0)
		 */
		this.envMapRotation = new Euler();

		/**
		 * Scales the effect of the environment map by multiplying its color.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.envMapIntensity = 1.0;

		/**
		 * Renders the geometry as a wireframe.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.wireframe = false;

		/**
		 * Controls the thickness of the wireframe.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.wireframeLinewidth = 1;

		/**
		 * Defines appearance of wireframe ends.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinecap = 'round';

		/**
		 * Defines appearance of wireframe joints.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinejoin = 'round';

		/**
		 * Whether the material is rendered with flat shading or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flatShading = false;

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.envMapIntensity = source.envMapIntensity;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

/**
 * An extension of the {@link MeshStandardMaterial}, providing more advanced
 * physically-based rendering properties:
 *
 * - Anisotropy: Ability to represent the anisotropic property of materials
 * as observable with brushed metals.
 * - Clearcoat: Some materials — like car paints, carbon fiber, and wet surfaces — require
 * a clear, reflective layer on top of another layer that may be irregular or rough.
 * Clearcoat approximates this effect, without the need for a separate transparent surface.
 * - Iridescence: Allows to render the effect where hue varies  depending on the viewing
 * angle and illumination angle. This can be seen on soap bubbles, oil films, or on the
 * wings of many insects.
 * - Physically-based transparency: One limitation of {@link Material#opacity} is that highly
 * transparent materials are less reflective. Physically-based transmission provides a more
 * realistic option for thin, transparent surfaces like glass.
 * - Advanced reflectivity: More flexible reflectivity for non-metallic materials.
 * - Sheen: Can be used for representing cloth and fabric materials.
 *
 * As a result of these complex shading features, `MeshPhysicalMaterial` has a
 * higher performance cost, per pixel, than other three.js materials. Most
 * effects are disabled by default, and add cost as they are enabled. For
 * best results, always specify an environment map when using this material.
 *
 * @augments MeshStandardMaterial
 * @demo scenes/material-browser.html#MeshPhysicalMaterial
 */
class MeshPhysicalMaterial extends MeshStandardMaterial {

	/**
	 * Constructs a new mesh physical material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshPhysicalMaterial = true;

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.type = 'MeshPhysicalMaterial';

		/**
		 * The rotation of the anisotropy in tangent, bitangent space, measured in radians
		 * counter-clockwise from the tangent. When `anisotropyMap` is present, this
		 * property provides additional rotation to the vectors in the texture.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.anisotropyRotation = 0;

		/**
		 * Red and green channels represent the anisotropy direction in `[-1, 1]` tangent,
		 * bitangent space, to be rotated by `anisotropyRotation`. The blue channel
		 * contains strength as `[0, 1]` to be multiplied by `anisotropy`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.anisotropyMap = null;

		/**
		 * The red channel of this texture is multiplied against `clearcoat`,
		 * for per-pixel control over a coating's intensity.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.clearcoatMap = null;

		/**
		 * Roughness of the clear coat layer, from `0.0` to `1.0`.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.clearcoatRoughness = 0.0;

		/**
		 * The green channel of this texture is multiplied against
		 * `clearcoatRoughness`, for per-pixel control over a coating's roughness.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.clearcoatRoughnessMap = null;

		/**
		 * How much `clearcoatNormalMap` affects the clear coat layer, from
		 * `(0,0)` to `(1,1)`.
		 *
		 * @type {Vector2}
		 * @default (1,1)
		 */
		this.clearcoatNormalScale = new Vector2( 1, 1 );

		/**
		 * Can be used to enable independent normals for the clear coat layer.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.clearcoatNormalMap = null;

		/**
		 * Index-of-refraction for non-metallic materials, from `1.0` to `2.333`.
		 *
		 * @type {number}
		 * @default 1.5
		 */
		this.ior = 1.5;

		/**
		 * Degree of reflectivity, from `0.0` to `1.0`. Default is `0.5`, which
		 * corresponds to an index-of-refraction of `1.5`.
		 *
		 * This models the reflectivity of non-metallic materials. It has no effect
		 * when `metalness` is `1.0`
		 *
		 * @name MeshPhysicalMaterial#reflectivity
		 * @type {number}
		 * @default 0.5
		 */
		Object.defineProperty( this, 'reflectivity', {
			get: function () {

				return ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

			},
			set: function ( reflectivity ) {

				this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

			}
		} );

		/**
		 * The red channel of this texture is multiplied against `iridescence`, for per-pixel
		 * control over iridescence.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.iridescenceMap = null;

		/**
		 * Strength of the iridescence RGB color shift effect, represented by an index-of-refraction.
		 * Between `1.0` to `2.333`.
		 *
		 * @type {number}
		 * @default 1.3
		 */
		this.iridescenceIOR = 1.3;

		/**
		 *Array of exactly 2 elements, specifying minimum and maximum thickness of the iridescence layer.
		 Thickness of iridescence layer has an equivalent effect of the one `thickness` has on `ior`.
		 *
		 * @type {Array<number,number>}
		 * @default [100,400]
		 */
		this.iridescenceThicknessRange = [ 100, 400 ];

		/**
		 * A texture that defines the thickness of the iridescence layer, stored in the green channel.
		 * Minimum and maximum values of thickness are defined by `iridescenceThicknessRange` array:
		 * - `0.0` in the green channel will result in thickness equal to first element of the array.
		 * - `1.0` in the green channel will result in thickness equal to second element of the array.
		 * - Values in-between will linearly interpolate between the elements of the array.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.iridescenceThicknessMap = null;

		/**
		 * The sheen tint.
		 *
		 * @type {Color}
		 * @default (0,0,0)
		 */
		this.sheenColor = new Color( 0x000000 );

		/**
		 * The RGB channels of this texture are multiplied against  `sheenColor`, for per-pixel control
		 * over sheen tint.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.sheenColorMap = null;

		/**
		 * Roughness of the sheen layer, from `0.0` to `1.0`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.sheenRoughness = 1.0;

		/**
		 * The alpha channel of this texture is multiplied against `sheenRoughness`, for per-pixel control
		 * over sheen roughness.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.sheenRoughnessMap = null;

		/**
		 * The red channel of this texture is multiplied against `transmission`, for per-pixel control over
		 * optical transparency.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.transmissionMap = null;

		/**
		 * The thickness of the volume beneath the surface. The value is given in the
		 * coordinate space of the mesh. If the value is `0` the material is
		 * thin-walled. Otherwise the material is a volume boundary.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.thickness = 0;

		/**
		 * A texture that defines the thickness, stored in the green channel. This will
		 * be multiplied by `thickness`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.thicknessMap = null;

		/**
		 * Density of the medium given as the average distance that light travels in
		 * the medium before interacting with a particle. The value is given in world
		 * space units, and must be greater than zero.
		 *
		 * @type {number}
		 * @default Infinity
		 */
		this.attenuationDistance = Infinity;

		/**
		 * The color that white light turns into due to absorption when reaching the
		 * attenuation distance.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.attenuationColor = new Color( 1, 1, 1 );

		/**
		 * A float that scales the amount of specular reflection for non-metals only.
		 * When set to zero, the model is effectively Lambertian. From `0.0` to `1.0`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.specularIntensity = 1.0;

		/**
		 * The alpha channel of this texture is multiplied against `specularIntensity`,
		 * for per-pixel control over specular intensity.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.specularIntensityMap = null;

		/**
		 * Tints the specular reflection at normal incidence for non-metals only.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.specularColor = new Color( 1, 1, 1 );

		/**
		 * The RGB channels of this texture are multiplied against `specularColor`,
		 * for per-pixel control over specular color.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.specularColorMap = null;

		this._anisotropy = 0;
		this._clearcoat = 0;
		this._dispersion = 0;
		this._iridescence = 0;
		this._sheen = 0.0;
		this._transmission = 0;

		this.setValues( parameters );

	}

	/**
	 * The anisotropy strength, from `0.0` to `1.0`.
	 *
	 * @type {number}
	 * @default 0
	 */
	get anisotropy() {

		return this._anisotropy;

	}

	set anisotropy( value ) {

		if ( this._anisotropy > 0 !== value > 0 ) {

			this.version ++;

		}

		this._anisotropy = value;

	}

	/**
	 * Represents the intensity of the clear coat layer, from `0.0` to `1.0`. Use
	 * clear coat related properties to enable multilayer materials that have a
	 * thin translucent layer over the base layer.
	 *
	 * @type {number}
	 * @default 0
	 */
	get clearcoat() {

		return this._clearcoat;

	}

	set clearcoat( value ) {

		if ( this._clearcoat > 0 !== value > 0 ) {

			this.version ++;

		}

		this._clearcoat = value;

	}
	/**
	 * The intensity of the iridescence layer, simulating RGB color shift based on the angle between
	 * the surface and the viewer, from `0.0` to `1.0`.
	 *
	 * @type {number}
	 * @default 0
	 */
	get iridescence() {

		return this._iridescence;

	}

	set iridescence( value ) {

		if ( this._iridescence > 0 !== value > 0 ) {

			this.version ++;

		}

		this._iridescence = value;

	}

	/**
	 * Defines the strength of the angular separation of colors (chromatic aberration) transmitting
	 * through a relatively clear volume. Any value zero or larger is valid, the typical range of
	 * realistic values is `[0, 1]`. This property can be only be used with transmissive objects.
	 *
	 * @type {number}
	 * @default 0
	 */
	get dispersion() {

		return this._dispersion;

	}

	set dispersion( value ) {

		if ( this._dispersion > 0 !== value > 0 ) {

			this.version ++;

		}

		this._dispersion = value;

	}

	/**
	 * The intensity of the sheen layer, from `0.0` to `1.0`.
	 *
	 * @type {number}
	 * @default 0
	 */
	get sheen() {

		return this._sheen;

	}

	set sheen( value ) {

		if ( this._sheen > 0 !== value > 0 ) {

			this.version ++;

		}

		this._sheen = value;

	}

	/**
	 * Degree of transmission (or optical transparency), from `0.0` to `1.0`.
	 *
	 * Thin, transparent or semitransparent, plastic or glass materials remain
	 * largely reflective even if they are fully transmissive. The transmission
	 * property can be used to model these materials.
	 *
	 * When transmission is non-zero, `opacity` should be  set to `1`.
	 *
	 * @type {number}
	 * @default 0
	 */
	get transmission() {

		return this._transmission;

	}

	set transmission( value ) {

		if ( this._transmission > 0 !== value > 0 ) {

			this.version ++;

		}

		this._transmission = value;

	}

	copy( source ) {

		super.copy( source );

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.anisotropy = source.anisotropy;
		this.anisotropyRotation = source.anisotropyRotation;
		this.anisotropyMap = source.anisotropyMap;

		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

		this.dispersion = source.dispersion;
		this.ior = source.ior;

		this.iridescence = source.iridescence;
		this.iridescenceMap = source.iridescenceMap;
		this.iridescenceIOR = source.iridescenceIOR;
		this.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];
		this.iridescenceThicknessMap = source.iridescenceThicknessMap;

		this.sheen = source.sheen;
		this.sheenColor.copy( source.sheenColor );
		this.sheenColorMap = source.sheenColorMap;
		this.sheenRoughness = source.sheenRoughness;
		this.sheenRoughnessMap = source.sheenRoughnessMap;

		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;

		this.thickness = source.thickness;
		this.thicknessMap = source.thicknessMap;
		this.attenuationDistance = source.attenuationDistance;
		this.attenuationColor.copy( source.attenuationColor );

		this.specularIntensity = source.specularIntensity;
		this.specularIntensityMap = source.specularIntensityMap;
		this.specularColor.copy( source.specularColor );
		this.specularColorMap = source.specularColorMap;

		return this;

	}

}

/**
 * A material for shiny surfaces with specular highlights.
 *
 * The material uses a non-physically based [Blinn-Phong](https://en.wikipedia.org/wiki/Blinn-Phong_shading_model)
 * model for calculating reflectance. Unlike the Lambertian model used in the
 * {@link MeshLambertMaterial} this can simulate shiny surfaces with specular
 * highlights (such as varnished wood). `MeshPhongMaterial` uses per-fragment shading.
 *
 * Performance will generally be greater when using this material over the
 * {@link MeshStandardMaterial} or {@link MeshPhysicalMaterial}, at the cost of
 * some graphical accuracy.
 *
 * @augments Material
 * @demo scenes/material-browser.html#MeshPhongMaterial
 */
class MeshPhongMaterial extends Material {

	/**
	 * Constructs a new mesh phong material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshPhongMaterial = true;

		this.type = 'MeshPhongMaterial';

		/**
		 * Color of the material.
		 *
		 * @type {Color}
		 * @default (1,1,1)
		 */
		this.color = new Color( 0xffffff ); // diffuse

		/**
		 * Specular color of the material. The default color is set to `0x111111` (very dark grey)
		 *
		 * This defines how shiny the material is and the color of its shine.
		 *
		 * @type {Color}
		 */
		this.specular = new Color( 0x111111 );

		/**
		 * How shiny the specular highlight is; a higher value gives a sharper highlight.
		 *
		 * @type {number}
		 * @default 30
		 */
		this.shininess = 30;

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
		 * color is modulated by the diffuse `color`.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The light map. Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.lightMap = null;

		/**
		 * Intensity of the baked light.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.lightMapIntensity = 1.0;

		/**
		 * The red channel of this texture is used as the ambient occlusion map.
		 * Requires a second set of UVs.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.aoMap = null;

		/**
		 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
		 * disables ambient occlusion. Where intensity is `1` and the AO map's
		 * red channel is also `1`, ambient light is fully occluded on a surface.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.aoMapIntensity = 1.0;

		/**
		 * Emissive (light) color of the material, essentially a solid color
		 * unaffected by other lighting.
		 *
		 * @type {Color}
		 * @default (0,0,0)
		 */
		this.emissive = new Color( 0x000000 );

		/**
		 * Intensity of the emissive light. Modulates the emissive color.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.emissiveIntensity = 1.0;

		/**
		 * Set emissive (glow) map. The emissive map color is modulated by the
		 * emissive color and the emissive intensity. If you have an emissive map,
		 * be sure to set the emissive color to something other than black.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.emissiveMap = null;

		/**
		 * The texture to create a bump map. The black and white values map to the
		 * perceived depth in relation to the lights. Bump doesn't actually affect
		 * the geometry of the object, only the lighting. If a normal map is defined
		 * this will be ignored.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.bumpMap = null;

		/**
		 * How much the bump map affects the material. Typical range is `[0,1]`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.bumpScale = 1;

		/**
		 * The texture to create a normal map. The RGB values affect the surface
		 * normal for each pixel fragment and change the way the color is lit. Normal
		 * maps do not change the actual shape of the surface, only the lighting. In
		 * case the material has a normal map authored using the left handed
		 * convention, the `y` component of `normalScale` should be negated to compensate
		 * for the different handedness.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.normalMap = null;

		/**
		 * The type of normal map.
		 *
		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		 * @default TangentSpaceNormalMap
		 */
		this.normalMapType = TangentSpaceNormalMap;

		/**
		 * How much the normal map affects the material. Typical value range is `[0,1]`.
		 *
		 * @type {Vector2}
		 * @default (1,1)
		 */
		this.normalScale = new Vector2( 1, 1 );

		/**
		 * The displacement map affects the position of the mesh's vertices. Unlike
		 * other maps which only affect the light and shade of the material the
		 * displaced vertices can cast shadows, block other objects, and otherwise
		 * act as real geometry. The displacement texture is an image where the value
		 * of each pixel (white being the highest) is mapped against, and
		 * repositions, the vertices of the mesh.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.displacementMap = null;

		/**
		 * How much the displacement map affects the mesh (where black is no
		 * displacement, and white is maximum displacement). Without a displacement
		 * map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementScale = 1;

		/**
		 * The offset of the displacement map's values on the mesh's vertices.
		 * The bias is added to the scaled sample of the displacement map.
		 * Without a displacement map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementBias = 0;

		/**
		 * The specular map value affects both how much the specular surface
		 * highlight contributes and how much of the environment map affects the
		 * surface.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.specularMap = null;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * The environment map.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.envMap = null;

		/**
		 * The rotation of the environment map in radians.
		 *
		 * @type {Euler}
		 * @default (0,0,0)
		 */
		this.envMapRotation = new Euler();

		/**
		 * How to combine the result of the surface's color with the environment map, if any.
		 *
		 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
		 * blend between the two colors.
		 *
		 * @type {(MultiplyOperation|MixOperation|AddOperation)}
		 * @default MultiplyOperation
		 */
		this.combine = MultiplyOperation;

		/**
		 * How much the environment map affects the surface.
		 * The valid range is between `0` (no reflections) and `1` (full reflections).
		 *
		 * @type {number}
		 * @default 1
		 */
		this.reflectivity = 1;

		/**
		 * The index of refraction (IOR) of air (approximately 1) divided by the
		 * index of refraction of the material. It is used with environment mapping
		 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
		 * The refraction ratio should not exceed `1`.
		 *
		 * @type {number}
		 * @default 0.98
		 */
		this.refractionRatio = 0.98;

		/**
		 * Renders the geometry as a wireframe.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.wireframe = false;

		/**
		 * Controls the thickness of the wireframe.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.wireframeLinewidth = 1;

		/**
		 * Defines appearance of wireframe ends.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinecap = 'round';

		/**
		 * Defines appearance of wireframe joints.
		 *
		 * Can only be used with {@link SVGRenderer}.
		 *
		 * @type {('round'|'bevel'|'miter')}
		 * @default 'round'
		 */
		this.wireframeLinejoin = 'round';

		/**
		 * Whether the material is rendered with flat shading or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.flatShading = false;

		/**
		 * Whether the material is affected by fog or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapRotation.copy( source.envMapRotation );
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

/**
 * A material for drawing geometry by depth. Depth is based off of the camera
 * near and far plane. White is nearest, black is farthest.
 *
 * @augments Material
 * @demo scenes/material-browser.html#MeshDepthMaterial
 */
class MeshDepthMaterial extends Material {

	/**
	 * Constructs a new mesh depth material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshDepthMaterial = true;

		this.type = 'MeshDepthMaterial';

		/**
		 * Type for depth packing.
		 *
		 * @type {(BasicDepthPacking|RGBADepthPacking|RGBDepthPacking|RGDepthPacking)}
		 * @default BasicDepthPacking
		 */
		this.depthPacking = BasicDepthPacking;

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * The displacement map affects the position of the mesh's vertices. Unlike
		 * other maps which only affect the light and shade of the material the
		 * displaced vertices can cast shadows, block other objects, and otherwise
		 * act as real geometry. The displacement texture is an image where the value
		 * of each pixel (white being the highest) is mapped against, and
		 * repositions, the vertices of the mesh.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.displacementMap = null;

		/**
		 * How much the displacement map affects the mesh (where black is no
		 * displacement, and white is maximum displacement). Without a displacement
		 * map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementScale = 1;

		/**
		 * The offset of the displacement map's values on the mesh's vertices.
		 * The bias is added to the scaled sample of the displacement map.
		 * Without a displacement map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementBias = 0;

		/**
		 * Renders the geometry as a wireframe.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.wireframe = false;

		/**
		 * Controls the thickness of the wireframe.
		 *
		 * WebGL and WebGPU ignore this property and always render
		 * 1 pixel wide lines.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.wireframeLinewidth = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.depthPacking = source.depthPacking;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	}

}

/**
 * A material used internally for implementing shadow mapping with
 * point lights.
 *
 * Can also be used to customize the shadow casting of an object by assigning
 * an instance of `MeshDistanceMaterial` to {@link Object3D#customDistanceMaterial}.
 * The following examples demonstrates this approach in order to ensure
 * transparent parts of objects do not cast shadows.
 *
 * @augments Material
 */
class MeshDistanceMaterial extends Material {

	/**
	 * Constructs a new mesh distance material.
	 *
	 * @param {Object} [parameters] - An object with one or more properties
	 * defining the material's appearance. Any property of the material
	 * (including any property from inherited materials) can be passed
	 * in here. Color values can be passed any type of value accepted
	 * by {@link Color#set}.
	 */
	constructor( parameters ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isMeshDistanceMaterial = true;

		this.type = 'MeshDistanceMaterial';

		/**
		 * The color map. May optionally include an alpha channel, typically combined
		 * with {@link Material#transparent} or {@link Material#alphaTest}.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.map = null;

		/**
		 * The alpha map is a grayscale texture that controls the opacity across the
		 * surface (black: fully transparent; white: fully opaque).
		 *
		 * Only the color of the texture is used, ignoring the alpha channel if one
		 * exists. For RGB and RGBA textures, the renderer will use the green channel
		 * when sampling this texture due to the extra bit of precision provided for
		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
		 * luminance/alpha textures will also still work as expected.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.alphaMap = null;

		/**
		 * The displacement map affects the position of the mesh's vertices. Unlike
		 * other maps which only affect the light and shade of the material the
		 * displaced vertices can cast shadows, block other objects, and otherwise
		 * act as real geometry. The displacement texture is an image where the value
		 * of each pixel (white being the highest) is mapped against, and
		 * repositions, the vertices of the mesh.
		 *
		 * @type {?Texture}
		 * @default null
		 */
		this.displacementMap = null;

		/**
		 * How much the displacement map affects the mesh (where black is no
		 * displacement, and white is maximum displacement). Without a displacement
		 * map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementScale = 1;

		/**
		 * The offset of the displacement map's values on the mesh's vertices.
		 * The bias is added to the scaled sample of the displacement map.
		 * Without a displacement map set, this value is not applied.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.displacementBias = 0;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	}

}

/**
 * @class
 * @classdesc A simple caching system, used internally by {@link FileLoader}.
 * To enable caching across all loaders that use {@link FileLoader}, add `THREE.Cache.enabled = true.` once in your app.
 * @hideconstructor
 */
const Cache = {

	/**
	 * Whether caching is enabled or not.
	 *
	 * @static
	 * @type {boolean}
	 * @default false
	 */
	enabled: false,

	/**
	 * A dictionary that holds cached files.
	 *
	 * @static
	 * @type {Object<string,Object>}
	 */
	files: {},

	/**
	 * Adds a cache entry with a key to reference the file. If this key already
	 * holds a file, it is overwritten.
	 *
	 * @static
	 * @param {string} key - The key to reference the cached file.
	 * @param {Object} file -  The file to be cached.
	 */
	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// log( 'Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	/**
	 * Gets the cached value for the given key.
	 *
	 * @static
	 * @param {string} key - The key to reference the cached file.
	 * @return {Object|undefined} The cached file. If the key does not exist `undefined` is returned.
	 */
	get: function ( key ) {

		if ( this.enabled === false ) return;

		// log( 'Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	/**
	 * Removes the cached file associated with the given key.
	 *
	 * @static
	 * @param {string} key - The key to reference the cached file.
	 */
	remove: function ( key ) {

		delete this.files[ key ];

	},

	/**
	 * Remove all values from the cache.
	 *
	 * @static
	 */
	clear: function () {

		this.files = {};

	}

};

/**
 * Handles and keeps track of loaded and pending data. A default global
 * instance of this class is created and used by loaders if not supplied
 * manually.
 *
 * In general that should be sufficient, however there are times when it can
 * be useful to have separate loaders - for example if you want to show
 * separate loading bars for objects and textures.
 *
 * ```js
 * const manager = new THREE.LoadingManager();
 * manager.onLoad = () => console.log( 'Loading complete!' );
 *
 * const loader1 = new OBJLoader( manager );
 * const loader2 = new ColladaLoader( manager );
 * ```
 */
class LoadingManager {

	/**
	 * Constructs a new loading manager.
	 *
	 * @param {Function} [onLoad] - Executes when all items have been loaded.
	 * @param {Function} [onProgress] - Executes when single items have been loaded.
	 * @param {Function} [onError] - Executes when an error occurs.
	 */
	constructor( onLoad, onProgress, onError ) {

		const scope = this;

		let isLoading = false;
		let itemsLoaded = 0;
		let itemsTotal = 0;
		let urlModifier = undefined;
		const handlers = [];

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		/**
		 * Executes when an item starts loading.
		 *
		 * @type {Function|undefined}
		 * @default undefined
		 */
		this.onStart = undefined;

		/**
		 * Executes when all items have been loaded.
		 *
		 * @type {Function|undefined}
		 * @default undefined
		 */
		this.onLoad = onLoad;

		/**
		 * Executes when single items have been loaded.
		 *
		 * @type {Function|undefined}
		 * @default undefined
		 */
		this.onProgress = onProgress;

		/**
		 * Executes when an error occurs.
		 *
		 * @type {Function|undefined}
		 * @default undefined
		 */
		this.onError = onError;

		/**
		 * Used for aborting ongoing requests in loaders using this manager.
		 *
		 * @private
		 * @type {AbortController | null}
		 */
		this._abortController = null;

		/**
		 * This should be called by any loader using the manager when the loader
		 * starts loading an item.
		 *
		 * @param {string} url - The URL to load.
		 */
		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		/**
		 * This should be called by any loader using the manager when the loader
		 * ended loading an item.
		 *
		 * @param {string} url - The URL of the loaded item.
		 */
		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		/**
		 * This should be called by any loader using the manager when the loader
		 * encounters an error when loading an item.
		 *
		 * @param {string} url - The URL of the item that produces an error.
		 */
		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		/**
		 * Given a URL, uses the URL modifier callback (if any) and returns a
		 * resolved URL. If no URL modifier is set, returns the original URL.
		 *
		 * @param {string} url - The URL to load.
		 * @return {string} The resolved URL.
		 */
		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		/**
		 * If provided, the callback will be passed each resource URL before a
		 * request is sent. The callback may return the original URL, or a new URL to
		 * override loading behavior. This behavior can be used to load assets from
		 * .ZIP files, drag-and-drop APIs, and Data URIs.
		 *
		 * ```js
		 * const blobs = {'fish.gltf': blob1, 'diffuse.png': blob2, 'normal.png': blob3};
		 *
		 * const manager = new THREE.LoadingManager();
		 *
		 * // Initialize loading manager with URL callback.
		 * const objectURLs = [];
		 * manager.setURLModifier( ( url ) => {
		 *
		 * 	url = URL.createObjectURL( blobs[ url ] );
		 * 	objectURLs.push( url );
		 * 	return url;
		 *
		 * } );
		 *
		 * // Load as usual, then revoke the blob URLs.
		 * const loader = new GLTFLoader( manager );
		 * loader.load( 'fish.gltf', (gltf) => {
		 *
		 * 	scene.add( gltf.scene );
		 * 	objectURLs.forEach( ( url ) => URL.revokeObjectURL( url ) );
		 *
		 * } );
		 * ```
		 *
		 * @param {function(string):string} transform - URL modifier callback. Called with an URL and must return a resolved URL.
		 * @return {LoadingManager} A reference to this loading manager.
		 */
		this.setURLModifier = function ( transform ) {

			urlModifier = transform;

			return this;

		};

		/**
		 * Registers a loader with the given regular expression. Can be used to
		 * define what loader should be used in order to load specific files. A
		 * typical use case is to overwrite the default loader for textures.
		 *
		 * ```js
		 * // add handler for TGA textures
		 * manager.addHandler( /\.tga$/i, new TGALoader() );
		 * ```
		 *
		 * @param {string} regex - A regular expression.
		 * @param {Loader} loader - A loader that should handle matched cases.
		 * @return {LoadingManager} A reference to this loading manager.
		 */
		this.addHandler = function ( regex, loader ) {

			handlers.push( regex, loader );

			return this;

		};

		/**
		 * Removes the loader for the given regular expression.
		 *
		 * @param {string} regex - A regular expression.
		 * @return {LoadingManager} A reference to this loading manager.
		 */
		this.removeHandler = function ( regex ) {

			const index = handlers.indexOf( regex );

			if ( index !== -1 ) {

				handlers.splice( index, 2 );

			}

			return this;

		};

		/**
		 * Can be used to retrieve the registered loader for the given file path.
		 *
		 * @param {string} file - The file path.
		 * @return {?Loader} The registered loader. Returns `null` if no loader was found.
		 */
		this.getHandler = function ( file ) {

			for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

				const regex = handlers[ i ];
				const loader = handlers[ i + 1 ];

				if ( regex.global ) regex.lastIndex = 0; // see #17920

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		};

		/**
		 * Can be used to abort ongoing loading requests in loaders using this manager.
		 * The abort only works if the loaders implement {@link Loader#abort} and `AbortSignal.any()`
		 * is supported in the browser.
		 *
		 * @return {LoadingManager} A reference to this loading manager.
		 */
		this.abort = function () {


			this.abortController.abort();
			this._abortController = null;

			return this;

		};

	}

	// TODO: Revert this back to a single member variable once this issue has been fixed
	// https://github.com/cloudflare/workerd/issues/3657

	/**
	 * Used for aborting ongoing requests in loaders using this manager.
	 *
	 * @type {AbortController}
	 */
	get abortController() {

		if ( ! this._abortController ) {

			this._abortController = new AbortController();

		}

		return this._abortController;

	}

}

/**
 * The global default loading manager.
 *
 * @constant
 * @type {LoadingManager}
 */
const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();

/**
 * Abstract base class for loaders.
 *
 * @abstract
 */
class Loader {

	/**
	 * Constructs a new loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		/**
		 * The loading manager.
		 *
		 * @type {LoadingManager}
		 * @default DefaultLoadingManager
		 */
		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		/**
		 * The crossOrigin string to implement CORS for loading the url from a
		 * different domain that allows CORS.
		 *
		 * @type {string}
		 * @default 'anonymous'
		 */
		this.crossOrigin = 'anonymous';

		/**
		 * Whether the XMLHttpRequest uses credentials.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.withCredentials = false;

		/**
		 * The base path from which the asset will be loaded.
		 *
		 * @type {string}
		 */
		this.path = '';

		/**
		 * The base path from which additional resources like textures will be loaded.
		 *
		 * @type {string}
		 */
		this.resourcePath = '';

		/**
		 * The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header)
		 * used in HTTP request.
		 *
		 * @type {Object<string, any>}
		 */
		this.requestHeader = {};

	}

	/**
	 * This method needs to be implemented by all concrete loaders. It holds the
	 * logic for loading assets from the backend.
	 *
	 * @abstract
	 * @param {string} url - The path/URL of the file to be loaded.
	 * @param {Function} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
	 * @param {onErrorCallback} [onError] - Executed when errors occur.
	 */
	load( /* url, onLoad, onProgress, onError */ ) {}

	/**
	 * A async version of {@link Loader#load}.
	 *
	 * @param {string} url - The path/URL of the file to be loaded.
	 * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
	 * @return {Promise} A Promise that resolves when the asset has been loaded.
	 */
	loadAsync( url, onProgress ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.load( url, resolve, onProgress, reject );

		} );

	}

	/**
	 * This method needs to be implemented by all concrete loaders. It holds the
	 * logic for parsing the asset into three.js entities.
	 *
	 * @abstract
	 * @param {any} data - The data to parse.
	 */
	parse( /* data */ ) {}

	/**
	 * Sets the `crossOrigin` String to implement CORS for loading the URL
	 * from a different domain that allows CORS.
	 *
	 * @param {string} crossOrigin - The `crossOrigin` value.
	 * @return {Loader} A reference to this instance.
	 */
	setCrossOrigin( crossOrigin ) {

		this.crossOrigin = crossOrigin;
		return this;

	}

	/**
	 * Whether the XMLHttpRequest uses credentials such as cookies, authorization
	 * headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials).
	 *
	 * Note: This setting has no effect if you are loading files locally or from the same domain.
	 *
	 * @param {boolean} value - The `withCredentials` value.
	 * @return {Loader} A reference to this instance.
	 */
	setWithCredentials( value ) {

		this.withCredentials = value;
		return this;

	}

	/**
	 * Sets the base path for the asset.
	 *
	 * @param {string} path - The base path.
	 * @return {Loader} A reference to this instance.
	 */
	setPath( path ) {

		this.path = path;
		return this;

	}

	/**
	 * Sets the base path for dependent resources like textures.
	 *
	 * @param {string} resourcePath - The resource path.
	 * @return {Loader} A reference to this instance.
	 */
	setResourcePath( resourcePath ) {

		this.resourcePath = resourcePath;
		return this;

	}

	/**
	 * Sets the given request header.
	 *
	 * @param {Object} requestHeader - A [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header)
	 * for configuring the HTTP request.
	 * @return {Loader} A reference to this instance.
	 */
	setRequestHeader( requestHeader ) {

		this.requestHeader = requestHeader;
		return this;

	}

	/**
	 * This method can be implemented in loaders for aborting ongoing requests.
	 *
	 * @abstract
	 * @return {Loader} A reference to this instance.
	 */
	abort() {

		return this;

	}

}

/**
 * Callback for onProgress in loaders.
 *
 * @callback onProgressCallback
 * @param {ProgressEvent} event - An instance of `ProgressEvent` that represents the current loading status.
 */

/**
 * Callback for onError in loaders.
 *
 * @callback onErrorCallback
 * @param {Error} error - The error which occurred during the loading process.
 */

/**
 * The default material name that is used by loaders
 * when creating materials for loaded 3D objects.
 *
 * Note: Not all loaders might honor this setting.
 *
 * @static
 * @type {string}
 * @default '__DEFAULT'
 */
Loader.DEFAULT_MATERIAL_NAME = '__DEFAULT';

const loading = {};

class HttpError extends Error {

	constructor( message, response ) {

		super( message );
		this.response = response;

	}

}

/**
 * A low level class for loading resources with the Fetch API, used internally by
 * most loaders. It can also be used directly to load any file type that does
 * not have a loader.
 *
 * This loader supports caching. If you want to use it, add `THREE.Cache.enabled = true;`
 * once to your application.
 *
 * ```js
 * const loader = new THREE.FileLoader();
 * const data = await loader.loadAsync( 'example.txt' );
 * ```
 *
 * @augments Loader
 */
class FileLoader extends Loader {

	/**
	 * Constructs a new file loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

		/**
		 * The expected mime type. Valid values can be found
		 * [here](hhttps://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#mimetype)
		 *
		 * @type {string}
		 */
		this.mimeType = '';

		/**
		 * The expected response type.
		 *
		 * @type {('arraybuffer'|'blob'|'document'|'json'|'')}
		 * @default ''
		 */
		this.responseType = '';

		/**
		 * Used for aborting requests.
		 *
		 * @private
		 * @type {AbortController}
		 */
		this._abortController = new AbortController();

	}

	/**
	 * Starts loading from the given URL and pass the loaded response to the `onLoad()` callback.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(any)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
	 * @param {onErrorCallback} [onError] - Executed when errors occur.
	 * @return {any|undefined} The cached resource if available.
	 */
	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const cached = Cache.get( `file:${url}` );

		if ( cached !== undefined ) {

			this.manager.itemStart( url );

			setTimeout( () => {

				if ( onLoad ) onLoad( cached );

				this.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check if request is duplicate

		if ( loading[ url ] !== undefined ) {

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			return;

		}

		// Initialise array for duplicate requests
		loading[ url ] = [];

		loading[ url ].push( {
			onLoad: onLoad,
			onProgress: onProgress,
			onError: onError,
		} );

		// create request
		const req = new Request( url, {
			headers: new Headers( this.requestHeader ),
			credentials: this.withCredentials ? 'include' : 'same-origin',
			signal: ( typeof AbortSignal.any === 'function' ) ? AbortSignal.any( [ this._abortController.signal, this.manager.abortController.signal ] ) : this._abortController.signal
		} );

		// record states ( avoid data race )
		const mimeType = this.mimeType;
		const responseType = this.responseType;

		// start the fetch
		fetch( req )
			.then( response => {

				if ( response.status === 200 || response.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					if ( response.status === 0 ) {

						warn( 'FileLoader: HTTP Status 0 received.' );

					}

					// Workaround: Checking if response.body === undefined for Alipay browser #23548

					if ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {

						return response;

					}

					const callbacks = loading[ url ];
					const reader = response.body.getReader();

					// Nginx needs X-File-Size check
					// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content
					const contentLength = response.headers.get( 'X-File-Size' ) || response.headers.get( 'Content-Length' );
					const total = contentLength ? parseInt( contentLength ) : 0;
					const lengthComputable = total !== 0;
					let loaded = 0;

					// periodically read data into the new stream tracking while download progress
					const stream = new ReadableStream( {
						start( controller ) {

							readData();

							function readData() {

								reader.read().then( ( { done, value } ) => {

									if ( done ) {

										controller.close();

									} else {

										loaded += value.byteLength;

										const event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );
										for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

											const callback = callbacks[ i ];
											if ( callback.onProgress ) callback.onProgress( event );

										}

										controller.enqueue( value );
										readData();

									}

								}, ( e ) => {

									controller.error( e );

								} );

							}

						}

					} );

					return new Response( stream );

				} else {

					throw new HttpError( `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response );

				}

			} )
			.then( response => {

				switch ( responseType ) {

					case 'arraybuffer':

						return response.arrayBuffer();

					case 'blob':

						return response.blob();

					case 'document':

						return response.text()
							.then( text => {

								const parser = new DOMParser();
								return parser.parseFromString( text, mimeType );

							} );

					case 'json':

						return response.json();

					default:

						if ( mimeType === '' ) {

							return response.text();

						} else {

							// sniff encoding
							const re = /charset="?([^;"\s]*)"?/i;
							const exec = re.exec( mimeType );
							const label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;
							const decoder = new TextDecoder( label );
							return response.arrayBuffer().then( ab => decoder.decode( ab ) );

						}

				}

			} )
			.then( data => {

				// Add to cache only on HTTP success, so that we do not cache
				// error response bodies as proper responses to requests.
				Cache.add( `file:${url}`, data );

				const callbacks = loading[ url ];
				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onLoad ) callback.onLoad( data );

				}

			} )
			.catch( err => {

				// Abort errors and other errors are handled the same

				const callbacks = loading[ url ];

				if ( callbacks === undefined ) {

					// When onLoad was called and url was deleted in `loading`
					this.manager.itemError( url );
					throw err;

				}

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( err );

				}

				this.manager.itemError( url );

			} )
			.finally( () => {

				this.manager.itemEnd( url );

			} );

		this.manager.itemStart( url );

	}

	/**
	 * Sets the expected response type.
	 *
	 * @param {('arraybuffer'|'blob'|'document'|'json'|'')} value - The response type.
	 * @return {FileLoader} A reference to this file loader.
	 */
	setResponseType( value ) {

		this.responseType = value;
		return this;

	}

	/**
	 * Sets the expected mime type of the loaded file.
	 *
	 * @param {string} value - The mime type.
	 * @return {FileLoader} A reference to this file loader.
	 */
	setMimeType( value ) {

		this.mimeType = value;
		return this;

	}

	/**
	 * Aborts ongoing fetch requests.
	 *
	 * @return {FileLoader} A reference to this instance.
	 */
	abort() {

		this._abortController.abort();
		this._abortController = new AbortController();

		return this;

	}

}

const _loading = new WeakMap();

/**
 * A loader for loading images. The class loads images with the HTML `Image` API.
 *
 * ```js
 * const loader = new THREE.ImageLoader();
 * const image = await loader.loadAsync( 'image.png' );
 * ```
 * Please note that `ImageLoader` has dropped support for progress
 * events in `r84`. For an `ImageLoader` that supports progress events, see
 * [this thread](https://github.com/mrdoob/three.js/issues/10439#issuecomment-275785639).
 *
 * @augments Loader
 */
class ImageLoader extends Loader {

	/**
	 * Constructs a new image loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

	}

	/**
	 * Starts loading from the given URL and passes the loaded image
	 * to the `onLoad()` callback. The method also returns a new `Image` object which can
	 * directly be used for texture creation. If you do it this way, the texture
	 * may pop up in your scene once the respective loading process is finished.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(Image)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} onProgress - Unsupported in this loader.
	 * @param {onErrorCallback} onError - Executed when errors occur.
	 * @return {Image} The image.
	 */
	load( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( `image:${url}` );

		if ( cached !== undefined ) {

			if ( cached.complete === true ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

			} else {

				let arr = _loading.get( cached );

				if ( arr === undefined ) {

					arr = [];
					_loading.set( cached, arr );

				}

				arr.push( { onLoad, onError } );

			}

			return cached;

		}

		const image = createElementNS( 'img' );

		function onImageLoad() {

			removeEventListeners();

			if ( onLoad ) onLoad( this );

			//

			const callbacks = _loading.get( this ) || [];

			for ( let i = 0; i < callbacks.length; i ++ ) {

				const callback = callbacks[ i ];
				if ( callback.onLoad ) callback.onLoad( this );

			}

			_loading.delete( this );

			scope.manager.itemEnd( url );

		}

		function onImageError( event ) {

			removeEventListeners();

			if ( onError ) onError( event );

			Cache.remove( `image:${url}` );

			//

			const callbacks = _loading.get( this ) || [];

			for ( let i = 0; i < callbacks.length; i ++ ) {

				const callback = callbacks[ i ];
				if ( callback.onError ) callback.onError( event );

			}

			_loading.delete( this );


			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		}

		function removeEventListeners() {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

		}

		image.addEventListener( 'load', onImageLoad, false );
		image.addEventListener( 'error', onImageError, false );

		if ( url.slice( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		Cache.add( `image:${url}`, image );
		scope.manager.itemStart( url );

		image.src = url;

		return image;

	}

}

/**
 * Abstract base class for loading binary texture formats RGBE, EXR or TGA.
 * Textures are internally loaded via {@link FileLoader}.
 *
 * Derived classes have to implement the `parse()` method which holds the parsing
 * for the respective format.
 *
 * @abstract
 * @augments Loader
 */
class DataTextureLoader extends Loader {

	/**
	 * Constructs a new data texture loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

	}

	/**
	 * Starts loading from the given URL and passes the loaded data texture
	 * to the `onLoad()` callback. The method also returns a new texture object which can
	 * directly be used for material creation. If you do it this way, the texture
	 * may pop up in your scene once the respective loading process is finished.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(DataTexture)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
	 * @param {onErrorCallback} onError - Executed when errors occur.
	 * @return {DataTexture} The data texture.
	 */
	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const texture = new DataTexture();

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setPath( this.path );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( buffer ) {

			let texData;

			try {

				texData = scope.parse( buffer );

			} catch ( error ) {

				if ( onError !== undefined ) {

					onError( error );

				} else {

					error( error );
					return;

				}

			}

			if ( texData.image !== undefined ) {

				texture.image = texData.image;

			} else if ( texData.data !== undefined ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

			if ( texData.colorSpace !== undefined ) {

				texture.colorSpace = texData.colorSpace;

			}

			if ( texData.flipY !== undefined ) {

				texture.flipY = texData.flipY;

			}

			if ( texData.format !== undefined ) {

				texture.format = texData.format;

			}

			if ( texData.type !== undefined ) {

				texture.type = texData.type;

			}

			if ( texData.mipmaps !== undefined ) {

				texture.mipmaps = texData.mipmaps;
				texture.minFilter = LinearMipmapLinearFilter; // presumably...

			}

			if ( texData.mipmapCount === 1 ) {

				texture.minFilter = LinearFilter;

			}

			if ( texData.generateMipmaps !== undefined ) {

				texture.generateMipmaps = texData.generateMipmaps;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

}

/**
 * Class for loading textures. Images are internally
 * loaded via {@link ImageLoader}.
 *
 * ```js
 * const loader = new THREE.TextureLoader();
 * const texture = await loader.loadAsync( 'textures/land_ocean_ice_cloud_2048.jpg' );
 *
 * const material = new THREE.MeshBasicMaterial( { map:texture } );
 * ```
 * Please note that `TextureLoader` has dropped support for progress
 * events in `r84`. For a `TextureLoader` that supports progress events, see
 * [this thread](https://github.com/mrdoob/three.js/issues/10439#issuecomment-293260145).
 *
 * @augments Loader
 */
class TextureLoader extends Loader {

	/**
	 * Constructs a new texture loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

	}

	/**
	 * Starts loading from the given URL and pass the fully loaded texture
	 * to the `onLoad()` callback. The method also returns a new texture object which can
	 * directly be used for material creation. If you do it this way, the texture
	 * may pop up in your scene once the respective loading process is finished.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(Texture)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} onProgress - Unsupported in this loader.
	 * @param {onErrorCallback} onError - Executed when errors occur.
	 * @return {Texture} The texture.
	 */
	load( url, onLoad, onProgress, onError ) {

		const texture = new Texture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	}

}

/**
 * Abstract base class for lights - all other light types inherit the
 * properties and methods described here.
 *
 * @abstract
 * @augments Object3D
 */
class Light extends Object3D {

	/**
	 * Constructs a new light.
	 *
	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
	 * @param {number} [intensity=1] - The light's strength/intensity.
	 */
	constructor( color, intensity = 1 ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isLight = true;

		this.type = 'Light';

		/**
		 * The light's color.
		 *
		 * @type {Color}
		 */
		this.color = new Color( color );

		/**
		 * The light's intensity.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.intensity = intensity;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		// Empty here in base class; some subclasses override.

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
		if ( this.target !== undefined ) data.object.target = this.target.uuid;

		return data;

	}

}

/**
 * A light source positioned directly above the scene, with color fading from
 * the sky color to the ground color.
 *
 * This light cannot be used to cast shadows.
 *
 * ```js
 * const light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
 * scene.add( light );
 * ```
 *
 * @augments Light
 */
class HemisphereLight extends Light {

	/**
	 * Constructs a new hemisphere light.
	 *
	 * @param {(number|Color|string)} [skyColor=0xffffff] - The light's sky color.
	 * @param {(number|Color|string)} [groundColor=0xffffff] - The light's ground color.
	 * @param {number} [intensity=1] - The light's strength/intensity.
	 */
	constructor( skyColor, groundColor, intensity ) {

		super( skyColor, intensity );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isHemisphereLight = true;

		this.type = 'HemisphereLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		/**
		 * The light's ground color.
		 *
		 * @type {Color}
		 */
		this.groundColor = new Color( groundColor );

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.groundColor.copy( source.groundColor );

		return this;

	}

}

const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
const _lookTarget$1 = /*@__PURE__*/ new Vector3();

/**
 * Abstract base class for light shadow classes. These classes
 * represent the shadow configuration for different light types.
 *
 * @abstract
 */
class LightShadow {

	/**
	 * Constructs a new light shadow.
	 *
	 * @param {Camera} camera - The light's view of the world.
	 */
	constructor( camera ) {

		/**
		 * The light's view of the world.
		 *
		 * @type {Camera}
		 */
		this.camera = camera;

		/**
		 * The intensity of the shadow. The default is `1`.
		 * Valid values are in the range `[0, 1]`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.intensity = 1;

		/**
		 * Shadow map bias, how much to add or subtract from the normalized depth
		 * when deciding whether a surface is in shadow.
		 *
		 * The default is `0`. Very tiny adjustments here (in the order of `0.0001`)
		 * may help reduce artifacts in shadows.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.bias = 0;

		/**
		 * Defines how much the position used to query the shadow map is offset along
		 * the object normal. The default is `0`. Increasing this value can be used to
		 * reduce shadow acne especially in large scenes where light shines onto
		 * geometry at a shallow angle. The cost is that shadows may appear distorted.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.normalBias = 0;

		/**
		 * Setting this to values greater than 1 will blur the edges of the shadow.
		 * High values will cause unwanted banding effects in the shadows - a greater
		 * map size will allow for a higher value to be used here before these effects
		 * become visible.
		 *
		 * The property has no effect when the shadow map type is `PCFSoftShadowMap` and
		 * and it is recommended to increase softness by decreasing the shadow map size instead.
		 *
		 * The property has no effect when the shadow map type is `BasicShadowMap`.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.radius = 1;

		/**
		 * The amount of samples to use when blurring a VSM shadow map.
		 *
		 * @type {number}
		 * @default 8
		 */
		this.blurSamples = 8;

		/**
		 * Defines the width and height of the shadow map. Higher values give better quality
		 * shadows at the cost of computation time. Values must be powers of two.
		 *
		 * @type {Vector2}
		 * @default (512,512)
		 */
		this.mapSize = new Vector2( 512, 512 );

		/**
		 * The type of shadow texture. The default is `UnsignedByteType`.
		 *
		 * @type {number}
		 * @default UnsignedByteType
		 */
		this.mapType = UnsignedByteType;

		/**
		 * The depth map generated using the internal camera; a location beyond a
		 * pixel's depth is in shadow. Computed internally during rendering.
		 *
		 * @type {?RenderTarget}
		 * @default null
		 */
		this.map = null;

		/**
		 * The distribution map generated using the internal camera; an occlusion is
		 * calculated based on the distribution of depths. Computed internally during
		 * rendering.
		 *
		 * @type {?RenderTarget}
		 * @default null
		 */
		this.mapPass = null;

		/**
		 * Model to shadow camera space, to compute location and depth in shadow map.
		 * This is computed internally during rendering.
		 *
		 * @type {Matrix4}
		 */
		this.matrix = new Matrix4();

		/**
		 * Enables automatic updates of the light's shadow. If you do not require dynamic
		 * lighting / shadows, you may set this to `false`.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.autoUpdate = true;

		/**
		 * When set to `true`, shadow maps will be updated in the next `render` call.
		 * If you have set {@link LightShadow#autoUpdate} to `false`, you will need to
		 * set this property to `true` and then make a render call to update the light's shadow.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.needsUpdate = false;

		this._frustum = new Frustum();
		this._frameExtents = new Vector2( 1, 1 );

		this._viewportCount = 1;

		this._viewports = [

			new Vector4( 0, 0, 1, 1 )

		];

	}

	/**
	 * Used internally by the renderer to get the number of viewports that need
	 * to be rendered for this shadow.
	 *
	 * @return {number} The viewport count.
	 */
	getViewportCount() {

		return this._viewportCount;

	}

	/**
	 * Gets the shadow cameras frustum. Used internally by the renderer to cull objects.
	 *
	 * @return {Frustum} The shadow camera frustum.
	 */
	getFrustum() {

		return this._frustum;

	}

	/**
	 * Update the matrices for the camera and shadow, used internally by the renderer.
	 *
	 * @param {Light} light - The light for which the shadow is being rendered.
	 */
	updateMatrices( light ) {

		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;

		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( _lightPositionWorld$1 );

		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( _lookTarget$1 );
		shadowCamera.updateMatrixWorld();

		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1, shadowCamera.coordinateSystem, shadowCamera.reversedDepth );

		if ( shadowCamera.reversedDepth ) {

			shadowMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 1.0, 0.0,
				0.0, 0.0, 0.0, 1.0
			);

		} else {

			shadowMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			);

		}

		shadowMatrix.multiply( _projScreenMatrix$1 );

	}

	/**
	 * Returns a viewport definition for the given viewport index.
	 *
	 * @param {number} viewportIndex - The viewport index.
	 * @return {Vector4} The viewport.
	 */
	getViewport( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	}

	/**
	 * Returns the frame extends.
	 *
	 * @return {Vector2} The frame extends.
	 */
	getFrameExtents() {

		return this._frameExtents;

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever this instance is no longer used in your app.
	 */
	dispose() {

		if ( this.map ) {

			this.map.dispose();

		}

		if ( this.mapPass ) {

			this.mapPass.dispose();

		}

	}

	/**
	 * Copies the values of the given light shadow instance to this instance.
	 *
	 * @param {LightShadow} source - The light shadow to copy.
	 * @return {LightShadow} A reference to this light shadow instance.
	 */
	copy( source ) {

		this.camera = source.camera.clone();

		this.intensity = source.intensity;

		this.bias = source.bias;
		this.radius = source.radius;

		this.autoUpdate = source.autoUpdate;
		this.needsUpdate = source.needsUpdate;
		this.normalBias = source.normalBias;
		this.blurSamples = source.blurSamples;

		this.mapSize.copy( source.mapSize );

		return this;

	}

	/**
	 * Returns a new light shadow instance with copied values from this instance.
	 *
	 * @return {LightShadow} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Serializes the light shadow into JSON.
	 *
	 * @return {Object} A JSON object representing the serialized light shadow.
	 * @see {@link ObjectLoader#parse}
	 */
	toJSON() {

		const object = {};

		if ( this.intensity !== 1 ) object.intensity = this.intensity;
		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

}

const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld = /*@__PURE__*/ new Vector3();
const _lookTarget = /*@__PURE__*/ new Vector3();

/**
 * Represents the shadow configuration of point lights.
 *
 * @augments LightShadow
 */
class PointLightShadow extends LightShadow {

	/**
	 * Constructs a new point light shadow.
	 */
	constructor() {

		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isPointLightShadow = true;

		this._frameExtents = new Vector2( 4, 2 );

		this._viewportCount = 6;

		this._viewports = [
			// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//  xzXZ
			//   y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction

			// positive X
			new Vector4( 2, 1, 1, 1 ),
			// negative X
			new Vector4( 0, 1, 1, 1 ),
			// positive Z
			new Vector4( 3, 1, 1, 1 ),
			// negative Z
			new Vector4( 1, 1, 1, 1 ),
			// positive Y
			new Vector4( 3, 0, 1, 1 ),
			// negative Y
			new Vector4( 1, 0, 1, 1 )
		];

		this._cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( -1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, -1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, -1, 0 )
		];

		this._cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, -1 )
		];

	}

	/**
	 * Update the matrices for the camera and shadow, used internally by the renderer.
	 *
	 * @param {Light} light - The light for which the shadow is being rendered.
	 * @param {number} [viewportIndex=0] - The viewport index.
	 */
	updateMatrices( light, viewportIndex = 0 ) {

		const camera = this.camera;
		const shadowMatrix = this.matrix;

		const far = light.distance || camera.far;

		if ( far !== camera.far ) {

			camera.far = far;
			camera.updateProjectionMatrix();

		}

		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( _lightPositionWorld );

		_lookTarget.copy( camera.position );
		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( _lookTarget );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix, camera.coordinateSystem, camera.reversedDepth );

	}

}

/**
 * A light that gets emitted from a single point in all directions. A common
 * use case for this is to replicate the light emitted from a bare
 * lightbulb.
 *
 * This light can cast shadows - see the {@link PointLightShadow} for details.
 *
 * ```js
 * const light = new THREE.PointLight( 0xff0000, 1, 100 );
 * light.position.set( 50, 50, 50 );
 * scene.add( light );
 * ```
 *
 * @augments Light
 */
class PointLight extends Light {

	/**
	 * Constructs a new point light.
	 *
	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
	 * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
	 * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
	 * @param {number} [decay=2] - The amount the light dims along the distance of the light.
	 */
	constructor( color, intensity, distance = 0, decay = 2 ) {

		super( color, intensity );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isPointLight = true;

		this.type = 'PointLight';

		/**
		 * When distance is zero, light will attenuate according to inverse-square
		 * law to infinite distance. When distance is non-zero, light will attenuate
		 * according to inverse-square law until near the distance cutoff, where it
		 * will then attenuate quickly and smoothly to 0. Inherently, cutoffs are not
		 * physically correct.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.distance = distance;

		/**
		 * The amount the light dims along the distance of the light. In context of
		 * physically-correct rendering the default value should not be changed.
		 *
		 * @type {number}
		 * @default 2
		 */
		this.decay = decay;

		/**
		 * This property holds the light's shadow configuration.
		 *
		 * @type {PointLightShadow}
		 */
		this.shadow = new PointLightShadow();

	}

	/**
	 * The light's power. Power is the luminous power of the light measured in lumens (lm).
	 * Changing the power will also change the light's intensity.
	 *
	 * @type {number}
	 */
	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
		return this.intensity * 4 * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / ( 4 * Math.PI );

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

}

/**
 * Camera that uses [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection).
 *
 * In this projection mode, an object's size in the rendered image stays
 * constant regardless of its distance from the camera. This can be useful
 * for rendering 2D scenes and UI elements, amongst other things.
 *
 * ```js
 * const camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
 * scene.add( camera );
 * ```
 *
 * @augments Camera
 */
class OrthographicCamera extends Camera {

	/**
	 * Constructs a new orthographic camera.
	 *
	 * @param {number} [left=-1] - The left plane of the camera's frustum.
	 * @param {number} [right=1] - The right plane of the camera's frustum.
	 * @param {number} [top=1] - The top plane of the camera's frustum.
	 * @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
	 * @param {number} [near=0.1] - The camera's near plane.
	 * @param {number} [far=2000] - The camera's far plane.
	 */
	constructor( left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000 ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isOrthographicCamera = true;

		this.type = 'OrthographicCamera';

		/**
		 * The zoom factor of the camera.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.zoom = 1;

		/**
		 * Represents the frustum window specification. This property should not be edited
		 * directly but via {@link PerspectiveCamera#setViewOffset} and {@link PerspectiveCamera#clearViewOffset}.
		 *
		 * @type {?Object}
		 * @default null
		 */
		this.view = null;

		/**
		 * The left plane of the camera's frustum.
		 *
		 * @type {number}
		 * @default -1
		 */
		this.left = left;

		/**
		 * The right plane of the camera's frustum.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.right = right;

		/**
		 * The top plane of the camera's frustum.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.top = top;

		/**
		 * The bottom plane of the camera's frustum.
		 *
		 * @type {number}
		 * @default -1
		 */
		this.bottom = bottom;

		/**
		 * The camera's near plane. The valid range is greater than `0`
		 * and less than the current value of {@link OrthographicCamera#far}.
		 *
		 * Note that, unlike for the {@link PerspectiveCamera}, `0` is a
		 * valid value for an orthographic camera's near plane.
		 *
		 * @type {number}
		 * @default 0.1
		 */
		this.near = near;

		/**
		 * The camera's far plane. Must be greater than the
		 * current value of {@link OrthographicCamera#near}.
		 *
		 * @type {number}
		 * @default 2000
		 */
		this.far = far;

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	}

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * @param {number} fullWidth - The full width of multiview setup.
	 * @param {number} fullHeight - The full height of multiview setup.
	 * @param {number} x - The horizontal offset of the subcamera.
	 * @param {number} y - The vertical offset of the subcamera.
	 * @param {number} width - The width of subcamera.
	 * @param {number} height - The height of subcamera.
	 * @see {@link PerspectiveCamera#setViewOffset}
	 */
	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	/**
	 * Removes the view offset from the projection matrix.
	 */
	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	/**
	 * Updates the camera's projection matrix. Must be called after any change of
	 * camera properties.
	 */
	updateProjectionMatrix() {

		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		const cx = ( this.right + this.left ) / 2;
		const cy = ( this.top + this.bottom ) / 2;

		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem, this.reversedDepth );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

}

/**
 * Represents the shadow configuration of directional lights.
 *
 * @augments LightShadow
 */
class DirectionalLightShadow extends LightShadow {

	/**
	 * Constructs a new directional light shadow.
	 */
	constructor() {

		super( new OrthographicCamera( -5, 5, 5, -5, 0.5, 500 ) );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isDirectionalLightShadow = true;

	}

}

/**
 * A light that gets emitted in a specific direction. This light will behave
 * as though it is infinitely far away and the rays produced from it are all
 * parallel. The common use case for this is to simulate daylight; the sun is
 * far enough away that its position can be considered to be infinite, and
 * all light rays coming from it are parallel.
 *
 * A common point of confusion for directional lights is that setting the
 * rotation has no effect. This is because three.js's DirectionalLight is the
 * equivalent to what is often called a 'Target Direct Light' in other
 * applications.
 *
 * This means that its direction is calculated as pointing from the light's
 * {@link Object3D#position} to the {@link DirectionalLight#target} position
 * (as opposed to a 'Free Direct Light' that just has a rotation
 * component).
 *
 * This light can cast shadows - see the {@link DirectionalLightShadow} for details.
 *
 * ```js
 * // White directional light at half intensity shining from the top.
 * const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
 * scene.add( directionalLight );
 * ```
 *
 * @augments Light
 */
class DirectionalLight extends Light {

	/**
	 * Constructs a new directional light.
	 *
	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
	 * @param {number} [intensity=1] - The light's strength/intensity.
	 */
	constructor( color, intensity ) {

		super( color, intensity );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isDirectionalLight = true;

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DEFAULT_UP );
		this.updateMatrix();

		/**
		 * The directional light points from its position to the
		 * target's position.
		 *
		 * For the target's position to be changed to anything other
		 * than the default, it must be added to the scene.
		 *
		 * It is also possible to set the target to be another 3D object
		 * in the scene. The light will now track the target object.
		 *
		 * @type {Object3D}
		 */
		this.target = new Object3D();

		/**
		 * This property holds the light's shadow configuration.
		 *
		 * @type {DirectionalLightShadow}
		 */
		this.shadow = new DirectionalLightShadow();

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source ) {

		super.copy( source );

		this.target = source.target.clone();
		this.shadow = source.shadow.clone();

		return this;

	}

}

/**
 * This light globally illuminates all objects in the scene equally.
 *
 * It cannot be used to cast shadows as it does not have a direction.
 *
 * ```js
 * const light = new THREE.AmbientLight( 0x404040 ); // soft white light
 * scene.add( light );
 * ```
 *
 * @augments Light
 */
class AmbientLight extends Light {

	/**
	 * Constructs a new ambient light.
	 *
	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
	 * @param {number} [intensity=1] - The light's strength/intensity.
	 */
	constructor( color, intensity ) {

		super( color, intensity );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isAmbientLight = true;

		this.type = 'AmbientLight';

	}

}

/**
 * This type of camera can be used in order to efficiently render a scene with a
 * predefined set of cameras. This is an important performance aspect for
 * rendering VR scenes.
 *
 * An instance of `ArrayCamera` always has an array of sub cameras. It's mandatory
 * to define for each sub camera the `viewport` property which determines the
 * part of the viewport that is rendered with this camera.
 *
 * @augments PerspectiveCamera
 */
class ArrayCamera extends PerspectiveCamera {

	/**
	 * Constructs a new array camera.
	 *
	 * @param {Array<PerspectiveCamera>} [array=[]] - An array of perspective sub cameras.
	 */
	constructor( array = [] ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isArrayCamera = true;

		/**
		 * Whether this camera is used with multiview rendering or not.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default false
		 */
		this.isMultiViewCamera = false;

		/**
		 * An array of perspective sub cameras.
		 *
		 * @type {Array<PerspectiveCamera>}
		 */
		this.cameras = array;

	}

}

/**
 * Class for keeping track of time.
 */
class Clock {

	/**
	 * Constructs a new clock.
	 *
	 * @param {boolean} [autoStart=true] - Whether to automatically start the clock when
	 * `getDelta()` is called for the first time.
	 */
	constructor( autoStart = true ) {

		/**
		 * If set to `true`, the clock starts automatically when `getDelta()` is called
		 * for the first time.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.autoStart = autoStart;

		/**
		 * Holds the time at which the clock's `start()` method was last called.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.startTime = 0;

		/**
		 * Holds the time at which the clock's `start()`, `getElapsedTime()` or
		 * `getDelta()` methods were last called.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.oldTime = 0;

		/**
		 * Keeps track of the total time that the clock has been running.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.elapsedTime = 0;

		/**
		 * Whether the clock is running or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.running = false;

	}

	/**
	 * Starts the clock. When `autoStart` is set to `true`, the method is automatically
	 * called by the class.
	 */
	start() {

		this.startTime = performance.now();

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	}

	/**
	 * Stops the clock.
	 */
	stop() {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	}

	/**
	 * Returns the elapsed time in seconds.
	 *
	 * @return {number} The elapsed time.
	 */
	getElapsedTime() {

		this.getDelta();
		return this.elapsedTime;

	}

	/**
	 * Returns the delta time in seconds.
	 *
	 * @return {number} The delta time.
	 */
	getDelta() {

		let diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			const newTime = performance.now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

}

/**
 * This class can be used to represent points in 3D space as
 * [Spherical coordinates](https://en.wikipedia.org/wiki/Spherical_coordinate_system).
 */
class Spherical {

	/**
	 * Constructs a new spherical.
	 *
	 * @param {number} [radius=1] - The radius, or the Euclidean distance (straight-line distance) from the point to the origin.
	 * @param {number} [phi=0] - The polar angle in radians from the y (up) axis.
	 * @param {number} [theta=0] - The equator/azimuthal angle in radians around the y (up) axis.
	 */
	constructor( radius = 1, phi = 0, theta = 0 ) {

		/**
		 * The radius, or the Euclidean distance (straight-line distance) from the point to the origin.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.radius = radius;

		/**
		 * The polar angle in radians from the y (up) axis.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.phi = phi;

		/**
		 * The equator/azimuthal angle in radians around the y (up) axis.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.theta = theta;

	}

	/**
	 * Sets the spherical components by copying the given values.
	 *
	 * @param {number} radius - The radius.
	 * @param {number} phi - The polar angle.
	 * @param {number} theta - The azimuthal angle.
	 * @return {Spherical} A reference to this spherical.
	 */
	set( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	}

	/**
	 * Copies the values of the given spherical to this instance.
	 *
	 * @param {Spherical} other - The spherical to copy.
	 * @return {Spherical} A reference to this spherical.
	 */
	copy( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	}

	/**
	 * Restricts the polar angle [page:.phi phi] to be between `0.000001` and pi -
	 * `0.000001`.
	 *
	 * @return {Spherical} A reference to this spherical.
	 */
	makeSafe() {

		const EPS = 0.000001;
		this.phi = clamp( this.phi, EPS, Math.PI - EPS );

		return this;

	}

	/**
	 * Sets the spherical components from the given vector which is assumed to hold
	 * Cartesian coordinates.
	 *
	 * @param {Vector3} v - The vector to set.
	 * @return {Spherical} A reference to this spherical.
	 */
	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	/**
	 * Sets the spherical components from the given Cartesian coordinates.
	 *
	 * @param {number} x - The x value.
	 * @param {number} y - The y value.
	 * @param {number} z - The z value.
	 * @return {Spherical} A reference to this spherical.
	 */
	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + y * y + z * z );

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( x, z );
			this.phi = Math.acos( clamp( y / this.radius, -1, 1 ) );

		}

		return this;

	}

	/**
	 * Returns a new spherical with copied values from this instance.
	 *
	 * @return {Spherical} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

}

/**
 * Abstract base class for controls.
 *
 * @abstract
 * @augments EventDispatcher
 */
class Controls extends EventDispatcher {

	/**
	 * Constructs a new controls instance.
	 *
	 * @param {Object3D} object - The object that is managed by the controls.
	 * @param {?HTMLElement} domElement - The HTML element used for event listeners.
	 */
	constructor( object, domElement = null ) {

		super();

		/**
		 * The object that is managed by the controls.
		 *
		 * @type {Object3D}
		 */
		this.object = object;

		/**
		 * The HTML element used for event listeners.
		 *
		 * @type {?HTMLElement}
		 * @default null
		 */
		this.domElement = domElement;

		/**
		 * Whether the controls responds to user input or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.enabled = true;

		/**
		 * The internal state of the controls.
		 *
		 * @type {number}
		 * @default -1
		 */
		this.state = -1;

		/**
		 * This object defines the keyboard input of the controls.
		 *
		 * @type {Object}
		 */
		this.keys = {};

		/**
		 * This object defines what type of actions are assigned to the available mouse buttons.
		 * It depends on the control implementation what kind of mouse buttons and actions are supported.
		 *
		 * @type {{LEFT: ?number, MIDDLE: ?number, RIGHT: ?number}}
		 */
		this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };

		/**
		 * This object defines what type of actions are assigned to what kind of touch interaction.
		 * It depends on the control implementation what kind of touch interaction and actions are supported.
		 *
		 * @type {{ONE: ?number, TWO: ?number}}
		 */
		this.touches = { ONE: null, TWO: null };

	}

	/**
	 * Connects the controls to the DOM. This method has so called "side effects" since
	 * it adds the module's event listeners to the DOM.
	 *
	 * @param {HTMLElement} element - The DOM element to connect to.
	 */
	connect( element ) {

		if ( element === undefined ) {

			warn( 'Controls: connect() now requires an element.' ); // @deprecated, the warning can be removed with r185
			return;

		}

		if ( this.domElement !== null ) this.disconnect();

		this.domElement = element;

	}

	/**
	 * Disconnects the controls from the DOM.
	 */
	disconnect() {}

	/**
	 * Call this method if you no longer want use to the controls. It frees all internal
	 * resources and removes all event listeners.
	 */
	dispose() {}

	/**
	 * Controls should implement this method if they have to update their internal state
	 * per simulation step.
	 *
	 * @param {number} [delta] - The time delta in seconds.
	 */
	update( /* delta */ ) {}

}

/**
 * Determines how many bytes must be used to represent the texture.
 *
 * @param {number} width - The width of the texture.
 * @param {number} height - The height of the texture.
 * @param {number} format - The texture's format.
 * @param {number} type - The texture's type.
 * @return {number} The byte length.
 */
function getByteLength( width, height, format, type ) {

	const typeByteLength = getTextureTypeByteLength( type );

	switch ( format ) {

		// https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
		case AlphaFormat:
			return width * height;
		case RedFormat:
			return ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;
		case RedIntegerFormat:
			return ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;
		case RGFormat:
			return ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;
		case RGIntegerFormat:
			return ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;
		case RGBFormat:
			return ( ( width * height * 3 ) / typeByteLength.components ) * typeByteLength.byteLength;
		case RGBAFormat:
			return ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;
		case RGBAIntegerFormat:
			return ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;

		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
		case RGB_S3TC_DXT1_Format:
		case RGBA_S3TC_DXT1_Format:
			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;
		case RGBA_S3TC_DXT3_Format:
		case RGBA_S3TC_DXT5_Format:
			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;

		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
		case RGB_PVRTC_2BPPV1_Format:
		case RGBA_PVRTC_2BPPV1_Format:
			return ( Math.max( width, 16 ) * Math.max( height, 8 ) ) / 4;
		case RGB_PVRTC_4BPPV1_Format:
		case RGBA_PVRTC_4BPPV1_Format:
			return ( Math.max( width, 8 ) * Math.max( height, 8 ) ) / 2;

		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
		case RGB_ETC1_Format:
		case RGB_ETC2_Format:
			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;
		case RGBA_ETC2_EAC_Format:
			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;

		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
		case RGBA_ASTC_4x4_Format:
			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;
		case RGBA_ASTC_5x4_Format:
			return Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 3 ) / 4 ) * 16;
		case RGBA_ASTC_5x5_Format:
			return Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
		case RGBA_ASTC_6x5_Format:
			return Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
		case RGBA_ASTC_6x6_Format:
			return Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 5 ) / 6 ) * 16;
		case RGBA_ASTC_8x5_Format:
			return Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
		case RGBA_ASTC_8x6_Format:
			return Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 5 ) / 6 ) * 16;
		case RGBA_ASTC_8x8_Format:
			return Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 7 ) / 8 ) * 16;
		case RGBA_ASTC_10x5_Format:
			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
		case RGBA_ASTC_10x6_Format:
			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 5 ) / 6 ) * 16;
		case RGBA_ASTC_10x8_Format:
			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 7 ) / 8 ) * 16;
		case RGBA_ASTC_10x10_Format:
			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 9 ) / 10 ) * 16;
		case RGBA_ASTC_12x10_Format:
			return Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 9 ) / 10 ) * 16;
		case RGBA_ASTC_12x12_Format:
			return Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 11 ) / 12 ) * 16;

		// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
		case RGBA_BPTC_Format:
		case RGB_BPTC_SIGNED_Format:
		case RGB_BPTC_UNSIGNED_Format:
			return Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;

		// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
		case RED_RGTC1_Format:
		case SIGNED_RED_RGTC1_Format:
			return Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 8;
		case RED_GREEN_RGTC2_Format:
		case SIGNED_RED_GREEN_RGTC2_Format:
			return Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;

	}

	throw new Error(
		`Unable to determine texture byte length for ${format} format.`,
	);

}

function getTextureTypeByteLength( type ) {

	switch ( type ) {

		case UnsignedByteType:
		case ByteType:
			return { byteLength: 1, components: 1 };
		case UnsignedShortType:
		case ShortType:
		case HalfFloatType:
			return { byteLength: 2, components: 1 };
		case UnsignedShort4444Type:
		case UnsignedShort5551Type:
			return { byteLength: 2, components: 4 };
		case UnsignedIntType:
		case IntType:
		case FloatType:
			return { byteLength: 4, components: 1 };
		case UnsignedInt5999Type:
		case UnsignedInt101111Type:
			return { byteLength: 4, components: 3 };

	}

	throw new Error( `Unknown texture type ${type}.` );

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );

}

if ( typeof window !== 'undefined' ) {

	if ( window.__THREE__ ) {

		warn( 'WARNING: Multiple instances of Three.js being imported.' );

	} else {

		window.__THREE__ = REVISION;

	}

}

/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */

function WebGLAnimation() {

	let context = null;
	let isAnimating = false;
	let animationLoop = null;
	let requestId = null;

	function onAnimationFrame( time, frame ) {

		animationLoop( time, frame );

		requestId = context.requestAnimationFrame( onAnimationFrame );

	}

	return {

		start: function () {

			if ( isAnimating === true ) return;
			if ( animationLoop === null ) return;

			requestId = context.requestAnimationFrame( onAnimationFrame );

			isAnimating = true;

		},

		stop: function () {

			context.cancelAnimationFrame( requestId );

			isAnimating = false;

		},

		setAnimationLoop: function ( callback ) {

			animationLoop = callback;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

}

function WebGLAttributes( gl ) {

	const buffers = new WeakMap();

	function createBuffer( attribute, bufferType ) {

		const array = attribute.array;
		const usage = attribute.usage;
		const size = array.byteLength;

		const buffer = gl.createBuffer();

		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );

		attribute.onUploadCallback();

		let type;

		if ( array instanceof Float32Array ) {

			type = gl.FLOAT;

		} else if ( typeof Float16Array !== 'undefined' && array instanceof Float16Array ) {

			type = gl.HALF_FLOAT;

		} else if ( array instanceof Uint16Array ) {

			if ( attribute.isFloat16BufferAttribute ) {

				type = gl.HALF_FLOAT;

			} else {

				type = gl.UNSIGNED_SHORT;

			}

		} else if ( array instanceof Int16Array ) {

			type = gl.SHORT;

		} else if ( array instanceof Uint32Array ) {

			type = gl.UNSIGNED_INT;

		} else if ( array instanceof Int32Array ) {

			type = gl.INT;

		} else if ( array instanceof Int8Array ) {

			type = gl.BYTE;

		} else if ( array instanceof Uint8Array ) {

			type = gl.UNSIGNED_BYTE;

		} else if ( array instanceof Uint8ClampedArray ) {

			type = gl.UNSIGNED_BYTE;

		} else {

			throw new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );

		}

		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version,
			size: size
		};

	}

	function updateBuffer( buffer, attribute, bufferType ) {

		const array = attribute.array;
		const updateRanges = attribute.updateRanges;

		gl.bindBuffer( bufferType, buffer );

		if ( updateRanges.length === 0 ) {

			// Not using update ranges
			gl.bufferSubData( bufferType, 0, array );

		} else {

			// Before applying update ranges, we merge any adjacent / overlapping
			// ranges to reduce load on `gl.bufferSubData`. Empirically, this has led
			// to performance improvements for applications which make heavy use of
			// update ranges. Likely due to GPU command overhead.
			//
			// Note that to reduce garbage collection between frames, we merge the
			// update ranges in-place. This is safe because this method will clear the
			// update ranges once updated.

			updateRanges.sort( ( a, b ) => a.start - b.start );

			// To merge the update ranges in-place, we work from left to right in the
			// existing updateRanges array, merging ranges. This may result in a final
			// array which is smaller than the original. This index tracks the last
			// index representing a merged range, any data after this index can be
			// trimmed once the merge algorithm is completed.
			let mergeIndex = 0;

			for ( let i = 1; i < updateRanges.length; i ++ ) {

				const previousRange = updateRanges[ mergeIndex ];
				const range = updateRanges[ i ];

				// We add one here to merge adjacent ranges. This is safe because ranges
				// operate over positive integers.
				if ( range.start <= previousRange.start + previousRange.count + 1 ) {

					previousRange.count = Math.max(
						previousRange.count,
						range.start + range.count - previousRange.start
					);

				} else {

					++ mergeIndex;
					updateRanges[ mergeIndex ] = range;

				}

			}

			// Trim the array to only contain the merged ranges.
			updateRanges.length = mergeIndex + 1;

			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

				const range = updateRanges[ i ];

				gl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,
					array, range.start, range.count );

			}

			attribute.clearUpdateRanges();

		}

		attribute.onUploadCallback();

	}

	//

	function get( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return buffers.get( attribute );

	}

	function remove( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data ) {

			gl.deleteBuffer( data.buffer );

			buffers.delete( attribute );

		}

	}

	function update( attribute, bufferType ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		if ( attribute.isGLBufferAttribute ) {

			const cached = buffers.get( attribute );

			if ( ! cached || cached.version < attribute.version ) {

				buffers.set( attribute, {
					buffer: attribute.buffer,
					type: attribute.type,
					bytesPerElement: attribute.elementSize,
					version: attribute.version
				} );

			}

			return;

		}

		const data = buffers.get( attribute );

		if ( data === undefined ) {

			buffers.set( attribute, createBuffer( attribute, bufferType ) );

		} else if ( data.version < attribute.version ) {

			if ( data.size !== attribute.array.byteLength ) {

				throw new Error( 'THREE.WebGLAttributes: The size of the buffer attribute\'s array buffer does not match the original size. Resizing buffer attributes is not supported.' );

			}

			updateBuffer( data.buffer, attribute, bufferType );

			data.version = attribute.version;

		}

	}

	return {

		get: get,
		remove: remove,
		update: update

	};

}

var alphahash_fragment = "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";

var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif";

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment = "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif";

var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var batching_pars_vertex = "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif";

var batching_vertex = "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif";

var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif";

var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs = "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated";

var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif";

var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

var colorspace_pars_fragment = "vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n#endif";

var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";

var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";

var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif";

var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";

var lights_physical_pars_fragment = "uniform sampler2D dfgLUT;\nstruct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 uv = vec2( roughness, dotNV );\n\treturn texture2D( dfgLUT, uv ).rg;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nvec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 dfgV = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNV * dotNV), 0.0, dotNV), material.roughness );\n\tvec2 dfgL = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNL * dotNL), 0.0, dotNL), material.roughness );\n\tvec3 FssEss_V = material.specularColor * dfgV.x + material.specularF90 * dfgV.y;\n\tvec3 FssEss_L = material.specularColor * dfgL.x + material.specularF90 * dfgL.y;\n\tfloat Ess_V = dfgV.x + dfgV.y;\n\tfloat Ess_L = dfgL.x + dfgL.y;\n\tfloat Ems_V = 1.0 - Ess_V;\n\tfloat Ems_L = 1.0 - Ess_L;\n\tvec3 Favg = material.specularColor + ( 1.0 - material.specularColor ) * 0.047619;\n\tvec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg * Favg + EPSILON );\n\tfloat compensationFactor = Ems_V * Ems_L;\n\tvec3 multiScatter = Fms * compensationFactor;\n\treturn singleScatter + multiScatter;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";

var logdepthbuf_fragment = "#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";

var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif";

var morphcolor_vertex = "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";

var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;";

var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif";

var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif";

var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";

var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif";

var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";

var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\tfloat depth = unpackRGBAToDepth( texture2D( depths, uv ) );\n\t\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\t\treturn step( depth, compare );\n\t\t#else\n\t\t\treturn step( compare, depth );\n\t\t#endif\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow( sampler2D shadow, vec2 uv, float compare ) {\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\t\tfloat hard_shadow = step( distribution.x, compare );\n\t\t#else\n\t\t\tfloat hard_shadow = step( compare, distribution.x );\n\t\t#endif\n\t\tif ( hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif";

var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";

var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t#else\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif";

var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";

var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";

var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

const vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\tfloat fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];\n\t#else\n\t\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;\n\t#endif\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}";

const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";

const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";

const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";

const ShaderChunk = {
	alphahash_fragment: alphahash_fragment,
	alphahash_pars_fragment: alphahash_pars_fragment,
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	alphatest_pars_fragment: alphatest_pars_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	batching_pars_vertex: batching_pars_vertex,
	batching_vertex: batching_vertex,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	iridescence_fragment: iridescence_fragment,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	colorspace_fragment: colorspace_fragment,
	colorspace_pars_fragment: colorspace_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_common_pars_fragment: envmap_common_pars_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_fragment: lights_lambert_fragment,
	lights_lambert_pars_fragment: lights_lambert_pars_fragment,
	lights_pars_begin: lights_pars_begin,
	lights_toon_fragment: lights_toon_fragment,
	lights_toon_pars_fragment: lights_toon_pars_fragment,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphinstance_vertex: morphinstance_vertex,
	morphcolor_vertex: morphcolor_vertex,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normal_pars_fragment: normal_pars_fragment,
	normal_pars_vertex: normal_pars_vertex,
	normal_vertex: normal_vertex,
	normalmap_pars_fragment: normalmap_pars_fragment,
	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	clearcoat_pars_fragment: clearcoat_pars_fragment,
	iridescence_pars_fragment: iridescence_pars_fragment,
	opaque_fragment: opaque_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	transmission_fragment: transmission_fragment,
	transmission_pars_fragment: transmission_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	worldpos_vertex: worldpos_vertex,

	background_vert: vertex$h,
	background_frag: fragment$h,
	backgroundCube_vert: vertex$g,
	backgroundCube_frag: fragment$g,
	cube_vert: vertex$f,
	cube_frag: fragment$f,
	depth_vert: vertex$e,
	depth_frag: fragment$e,
	distanceRGBA_vert: vertex$d,
	distanceRGBA_frag: fragment$d,
	equirect_vert: vertex$c,
	equirect_frag: fragment$c,
	linedashed_vert: vertex$b,
	linedashed_frag: fragment$b,
	meshbasic_vert: vertex$a,
	meshbasic_frag: fragment$a,
	meshlambert_vert: vertex$9,
	meshlambert_frag: fragment$9,
	meshmatcap_vert: vertex$8,
	meshmatcap_frag: fragment$8,
	meshnormal_vert: vertex$7,
	meshnormal_frag: fragment$7,
	meshphong_vert: vertex$6,
	meshphong_frag: fragment$6,
	meshphysical_vert: vertex$5,
	meshphysical_frag: fragment$5,
	meshtoon_vert: vertex$4,
	meshtoon_frag: fragment$4,
	points_vert: vertex$3,
	points_frag: fragment$3,
	shadow_vert: vertex$2,
	shadow_frag: fragment$2,
	sprite_vert: vertex$1,
	sprite_frag: fragment$1
};

// Uniforms library for shared webgl shaders
const UniformsLib = {

	common: {

		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
		opacity: { value: 1.0 },

		map: { value: null },
		mapTransform: { value: /*@__PURE__*/ new Matrix3() },

		alphaMap: { value: null },
		alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },

		alphaTest: { value: 0 }

	},

	specularmap: {

		specularMap: { value: null },
		specularMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	envmap: {

		envMap: { value: null },
		envMapRotation: { value: /*@__PURE__*/ new Matrix3() },
		flipEnvMap: { value: -1 },
		reflectivity: { value: 1.0 }, // basic, lambert, phong
		ior: { value: 1.5 }, // physical
		refractionRatio: { value: 0.98 }, // basic, lambert, phong
		dfgLUT: { value: null } // DFG LUT for physically-based rendering

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 },
		aoMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 },
		lightMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		normalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	emissivemap: {

		emissiveMap: { value: null },
		emissiveMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	metalnessmap: {

		metalnessMap: { value: null },
		metalnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	roughnessmap: {

		roughnessMap: { value: null },
		roughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: /*@__PURE__*/ new Color( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		lightProbe: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {}
		} },

		directionalLightShadows: { value: [], properties: {
			shadowIntensity: 1,
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {}
		} },

		spotLightShadows: { value: [], properties: {
			shadowIntensity: 1,
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotLightMap: { value: [] },
		spotShadowMap: { value: [] },
		spotLightMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {}
		} },

		pointLightShadows: { value: [], properties: {
			shadowIntensity: 1,
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} },

		ltc_1: { value: null },
		ltc_2: { value: null }

	},

	points: {

		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		alphaMap: { value: null },
		alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		alphaTest: { value: 0 },
		uvTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	sprite: {

		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
		opacity: { value: 1.0 },
		center: { value: /*@__PURE__*/ new Vector2( 0.5, 0.5 ) },
		rotation: { value: 0.0 },
		map: { value: null },
		mapTransform: { value: /*@__PURE__*/ new Matrix3() },
		alphaMap: { value: null },
		alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		alphaTest: { value: 0 }

	}

};

const ShaderLib = {

	basic: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				specular: { value: /*@__PURE__*/ new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				roughness: { value: 1.0 },
				metalness: { value: 0.0 },
				envMapIntensity: { value: 1 }
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	toon: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag

	},

	matcap: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			{
				matcap: { value: null }
			}
		] ),

		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag

	},

	points: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.meshnormal_vert,
		fragmentShader: ShaderChunk.meshnormal_frag

	},

	sprite: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.sprite,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: /*@__PURE__*/ new Matrix3() },
			t2D: { value: null },
			backgroundIntensity: { value: 1 }
		},

		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag

	},

	backgroundCube: {

		uniforms: {
			envMap: { value: null },
			flipEnvMap: { value: -1 },
			backgroundBlurriness: { value: 0 },
			backgroundIntensity: { value: 1 },
			backgroundRotation: { value: /*@__PURE__*/ new Matrix3() }
		},

		vertexShader: ShaderChunk.backgroundCube_vert,
		fragmentShader: ShaderChunk.backgroundCube_frag

	},

	cube: {

		uniforms: {
			tCube: { value: null },
			tFlip: { value: -1 },
			opacity: { value: 1.0 }
		},

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: /*@__PURE__*/ new Vector3() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	},

	shadow: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: /*@__PURE__*/ new Color( 0x00000 ) },
				opacity: { value: 1.0 }
			},
		] ),

		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: /*@__PURE__*/ mergeUniforms( [
		ShaderLib.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			clearcoatNormalMap: { value: null },
			clearcoatNormalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			clearcoatNormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			dispersion: { value: 0 },
			iridescence: { value: 0 },
			iridescenceMap: { value: null },
			iridescenceMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			iridescenceIOR: { value: 1.3 },
			iridescenceThicknessMinimum: { value: 100 },
			iridescenceThicknessMaximum: { value: 400 },
			iridescenceThicknessMap: { value: null },
			iridescenceThicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			sheen: { value: 0 },
			sheenColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
			sheenColorMap: { value: null },
			sheenColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			sheenRoughness: { value: 1 },
			sheenRoughnessMap: { value: null },
			sheenRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			transmission: { value: 0 },
			transmissionMap: { value: null },
			transmissionMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			transmissionSamplerSize: { value: /*@__PURE__*/ new Vector2() },
			transmissionSamplerMap: { value: null },
			thickness: { value: 0 },
			thicknessMap: { value: null },
			thicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			attenuationDistance: { value: 0 },
			attenuationColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
			specularColor: { value: /*@__PURE__*/ new Color( 1, 1, 1 ) },
			specularColorMap: { value: null },
			specularColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			specularIntensity: { value: 1 },
			specularIntensityMap: { value: null },
			specularIntensityMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			anisotropyVector: { value: /*@__PURE__*/ new Vector2() },
			anisotropyMap: { value: null },
			anisotropyMapTransform: { value: /*@__PURE__*/ new Matrix3() },
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

const _rgb = { r: 0, b: 0, g: 0 };
const _e1$1 = /*@__PURE__*/ new Euler();
const _m1$1 = /*@__PURE__*/ new Matrix4();

function WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {

	const clearColor = new Color( 0x000000 );
	let clearAlpha = alpha === true ? 0 : 1;

	let planeMesh;
	let boxMesh;

	let currentBackground = null;
	let currentBackgroundVersion = 0;
	let currentTonemapping = null;

	function getBackground( scene ) {

		let background = scene.isScene === true ? scene.background : null;

		if ( background && background.isTexture ) {

			const usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background
			background = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );

		}

		return background;

	}

	function render( scene ) {

		let forceClear = false;
		const background = getBackground( scene );

		if ( background === null ) {

			setClear( clearColor, clearAlpha );

		} else if ( background && background.isColor ) {

			setClear( background, 1 );
			forceClear = true;

		}

		const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();

		if ( environmentBlendMode === 'additive' ) {

			state.buffers.color.setClear( 0, 0, 0, 1, premultipliedAlpha );

		} else if ( environmentBlendMode === 'alpha-blend' ) {

			state.buffers.color.setClear( 0, 0, 0, 0, premultipliedAlpha );

		}

		if ( renderer.autoClear || forceClear ) {

			// buffers might not be writable which is required to ensure a correct clear

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

	}

	function addToRenderList( renderList, scene ) {

		const background = getBackground( scene );

		if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

			if ( boxMesh === undefined ) {

				boxMesh = new Mesh(
					new BoxGeometry( 1, 1, 1 ),
					new ShaderMaterial( {
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms( ShaderLib.backgroundCube.uniforms ),
						vertexShader: ShaderLib.backgroundCube.vertexShader,
						fragmentShader: ShaderLib.backgroundCube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false,
						allowOverride: false
					} )
				);

				boxMesh.geometry.deleteAttribute( 'normal' );
				boxMesh.geometry.deleteAttribute( 'uv' );

				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

				// add "envMap" material property so the renderer can evaluate it like for built-in materials
				Object.defineProperty( boxMesh.material, 'envMap', {

					get: function () {

						return this.uniforms.envMap.value;

					}

				} );

				objects.update( boxMesh );

			}

			_e1$1.copy( scene.backgroundRotation );

			// accommodate left-handed frame
			_e1$1.x *= -1; _e1$1.y *= -1; _e1$1.z *= -1;

			if ( background.isCubeTexture && background.isRenderTargetTexture === false ) {

				// environment maps which are not cube render targets or PMREMs follow a different convention
				_e1$1.y *= -1;
				_e1$1.z *= -1;

			}

			boxMesh.material.uniforms.envMap.value = background;
			boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? -1 : 1;
			boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
			boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
			boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4( _m1$1.makeRotationFromEuler( _e1$1 ) );
			boxMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				boxMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			boxMesh.layers.enableAll();

			// push to the pre-sorted opaque render list
			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		} else if ( background && background.isTexture ) {

			if ( planeMesh === undefined ) {

				planeMesh = new Mesh(
					new PlaneGeometry( 2, 2 ),
					new ShaderMaterial( {
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false,
						allowOverride: false
					} )
				);

				planeMesh.geometry.deleteAttribute( 'normal' );

				// add "map" material property so the renderer can evaluate it like for built-in materials
				Object.defineProperty( planeMesh.material, 'map', {

					get: function () {

						return this.uniforms.t2D.value;

					}

				} );

				objects.update( planeMesh );

			}

			planeMesh.material.uniforms.t2D.value = background;
			planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
			planeMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;

			if ( background.matrixAutoUpdate === true ) {

				background.updateMatrix();

			}

			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				planeMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			planeMesh.layers.enableAll();

			// push to the pre-sorted opaque render list
			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		}

	}

	function setClear( color, alpha ) {

		color.getRGB( _rgb, getUnlitUniformColorSpace( renderer ) );

		state.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );

	}

	function dispose() {

		if ( boxMesh !== undefined ) {

			boxMesh.geometry.dispose();
			boxMesh.material.dispose();

			boxMesh = undefined;

		}

		if ( planeMesh !== undefined ) {

			planeMesh.geometry.dispose();
			planeMesh.material.dispose();

			planeMesh = undefined;

		}

	}

	return {

		getClearColor: function () {

			return clearColor;

		},
		setClearColor: function ( color, alpha = 1 ) {

			clearColor.set( color );
			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		getClearAlpha: function () {

			return clearAlpha;

		},
		setClearAlpha: function ( alpha ) {

			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		render: render,
		addToRenderList: addToRenderList,
		dispose: dispose

	};

}

function WebGLBindingStates( gl, attributes ) {

	const maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );

	const bindingStates = {};

	const defaultState = createBindingState( null );
	let currentState = defaultState;
	let forceUpdate = false;

	function setup( object, material, program, geometry, index ) {

		let updateBuffers = false;

		const state = getBindingState( geometry, program, material );

		if ( currentState !== state ) {

			currentState = state;
			bindVertexArrayObject( currentState.object );

		}

		updateBuffers = needsUpdate( object, geometry, program, index );

		if ( updateBuffers ) saveCache( object, geometry, program, index );

		if ( index !== null ) {

			attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

		}

		if ( updateBuffers || forceUpdate ) {

			forceUpdate = false;

			setupVertexAttributes( object, material, program, geometry );

			if ( index !== null ) {

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );

			}

		}

	}

	function createVertexArrayObject() {

		return gl.createVertexArray();

	}

	function bindVertexArrayObject( vao ) {

		return gl.bindVertexArray( vao );

	}

	function deleteVertexArrayObject( vao ) {

		return gl.deleteVertexArray( vao );

	}

	function getBindingState( geometry, program, material ) {

		const wireframe = ( material.wireframe === true );

		let programMap = bindingStates[ geometry.id ];

		if ( programMap === undefined ) {

			programMap = {};
			bindingStates[ geometry.id ] = programMap;

		}

		let stateMap = programMap[ program.id ];

		if ( stateMap === undefined ) {

			stateMap = {};
			programMap[ program.id ] = stateMap;

		}

		let state = stateMap[ wireframe ];

		if ( state === undefined ) {

			state = createBindingState( createVertexArrayObject() );
			stateMap[ wireframe ] = state;

		}

		return state;

	}

	function createBindingState( vao ) {

		const newAttributes = [];
		const enabledAttributes = [];
		const attributeDivisors = [];

		for ( let i = 0; i < maxVertexAttributes; i ++ ) {

			newAttributes[ i ] = 0;
			enabledAttributes[ i ] = 0;
			attributeDivisors[ i ] = 0;

		}

		return {

			// for backward compatibility on non-VAO support browser
			geometry: null,
			program: null,
			wireframe: false,

			newAttributes: newAttributes,
			enabledAttributes: enabledAttributes,
			attributeDivisors: attributeDivisors,
			object: vao,
			attributes: {},
			index: null

		};

	}

	function needsUpdate( object, geometry, program, index ) {

		const cachedAttributes = currentState.attributes;
		const geometryAttributes = geometry.attributes;

		let attributesNum = 0;

		const programAttributes = program.getAttributes();

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				const cachedAttribute = cachedAttributes[ name ];
				let geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

				}

				if ( cachedAttribute === undefined ) return true;

				if ( cachedAttribute.attribute !== geometryAttribute ) return true;

				if ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;

				attributesNum ++;

			}

		}

		if ( currentState.attributesNum !== attributesNum ) return true;

		if ( currentState.index !== index ) return true;

		return false;

	}

	function saveCache( object, geometry, program, index ) {

		const cache = {};
		const attributes = geometry.attributes;
		let attributesNum = 0;

		const programAttributes = program.getAttributes();

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				let attribute = attributes[ name ];

				if ( attribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;

				}

				const data = {};
				data.attribute = attribute;

				if ( attribute && attribute.data ) {

					data.data = attribute.data;

				}

				cache[ name ] = data;

				attributesNum ++;

			}

		}

		currentState.attributes = cache;
		currentState.attributesNum = attributesNum;

		currentState.index = index;

	}

	function initAttributes() {

		const newAttributes = currentState.newAttributes;

		for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		enableAttributeAndDivisor( attribute, 0 );

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		const attributeDivisors = currentState.attributeDivisors;

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			gl.vertexAttribDivisor( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;

		for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function vertexAttribPointer( index, size, type, normalized, stride, offset, integer ) {

		if ( integer === true ) {

			gl.vertexAttribIPointer( index, size, type, stride, offset );

		} else {

			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

		}

	}

	function setupVertexAttributes( object, material, program, geometry ) {

		initAttributes();

		const geometryAttributes = geometry.attributes;

		const programAttributes = program.getAttributes();

		const materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute.location >= 0 ) {

				let geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute === undefined ) {

					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

				}

				if ( geometryAttribute !== undefined ) {

					const normalized = geometryAttribute.normalized;
					const size = geometryAttribute.itemSize;

					const attribute = attributes.get( geometryAttribute );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;
					const bytesPerElement = attribute.bytesPerElement;

					// check for integer attributes

					const integer = ( type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType );

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						const data = geometryAttribute.data;
						const stride = data.stride;
						const offset = geometryAttribute.offset;

						if ( data.isInstancedInterleavedBuffer ) {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );

							}

							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

							}

						} else {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttribute( programAttribute.location + i );

							}

						}

						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

							vertexAttribPointer(
								programAttribute.location + i,
								size / programAttribute.locationSize,
								type,
								normalized,
								stride * bytesPerElement,
								( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement,
								integer
							);

						}

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );

							}

							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								enableAttribute( programAttribute.location + i );

							}

						}

						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

							vertexAttribPointer(
								programAttribute.location + i,
								size / programAttribute.locationSize,
								type,
								normalized,
								size * bytesPerElement,
								( size / programAttribute.locationSize ) * i * bytesPerElement,
								integer
							);

						}

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					const value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								gl.vertexAttrib2fv( programAttribute.location, value );
								break;

							case 3:
								gl.vertexAttrib3fv( programAttribute.location, value );
								break;

							case 4:
								gl.vertexAttrib4fv( programAttribute.location, value );
								break;

							default:
								gl.vertexAttrib1fv( programAttribute.location, value );

						}

					}

				}

			}

		}

		disableUnusedAttributes();

	}

	function dispose() {

		reset();

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometryId ];

		}

	}

	function releaseStatesOfGeometry( geometry ) {

		if ( bindingStates[ geometry.id ] === undefined ) return;

		const programMap = bindingStates[ geometry.id ];

		for ( const programId in programMap ) {

			const stateMap = programMap[ programId ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ programId ];

		}

		delete bindingStates[ geometry.id ];

	}

	function releaseStatesOfProgram( program ) {

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			if ( programMap[ program.id ] === undefined ) continue;

			const stateMap = programMap[ program.id ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ program.id ];

		}

	}

	function reset() {

		resetDefaultState();
		forceUpdate = true;

		if ( currentState === defaultState ) return;

		currentState = defaultState;
		bindVertexArrayObject( currentState.object );

	}

	// for backward-compatibility

	function resetDefaultState() {

		defaultState.geometry = null;
		defaultState.program = null;
		defaultState.wireframe = false;

	}

	return {

		setup: setup,
		reset: reset,
		resetDefaultState: resetDefaultState,
		dispose: dispose,
		releaseStatesOfGeometry: releaseStatesOfGeometry,
		releaseStatesOfProgram: releaseStatesOfProgram,

		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		disableUnusedAttributes: disableUnusedAttributes

	};

}

function WebGLBufferRenderer( gl, extensions, info ) {

	let mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		gl.drawArraysInstanced( mode, start, count, primcount );

		info.update( count, mode, primcount );

	}

	function renderMultiDraw( starts, counts, drawCount ) {

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );
		extension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );

		let elementCount = 0;
		for ( let i = 0; i < drawCount; i ++ ) {

			elementCount += counts[ i ];

		}

		info.update( elementCount, mode, 1 );

	}

	function renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < starts.length; i ++ ) {

				renderInstances( starts[ i ], counts[ i ], primcount[ i ] );

			}

		} else {

			extension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ] * primcount[ i ];

			}

			info.update( elementCount, mode, 1 );

		}

	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;
	this.renderMultiDraw = renderMultiDraw;
	this.renderMultiDrawInstances = renderMultiDrawInstances;

}

function WebGLCapabilities( gl, extensions, parameters, utils ) {

	let maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function textureFormatReadable( textureFormat ) {

		if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

			return false;

		}

		return true;

	}

	function textureTypeReadable( textureType ) {

		const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) );

		if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // Edge and Chrome Mac < 52 (#9513)
			textureType !== FloatType && ! halfFloatSupportedByExt ) {

			return false;

		}

		return true;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
				gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
				gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	const maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		warn( 'WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
	const reversedDepthBuffer = parameters.reversedDepthBuffer === true && extensions.has( 'EXT_clip_control' );

	const maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	const maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	const maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
	const maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	const maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	const maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
	const maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
	const maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

	const vertexTextures = maxVertexTextures > 0;

	const maxSamples = gl.getParameter( gl.MAX_SAMPLES );

	return {

		isWebGL2: true, // keeping this for backwards compatibility

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		textureFormatReadable: textureFormatReadable,
		textureTypeReadable: textureTypeReadable,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,
		reversedDepthBuffer: reversedDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,

		maxSamples: maxSamples

	};

}

function WebGLClipping( properties ) {

	const scope = this;

	let globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false;

	const plane = new Plane(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function ( planes, enableLocalClipping ) {

		const enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function () {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function () {

		renderingShadows = false;

	};

	this.setGlobalState = function ( planes, camera ) {

		globalState = projectPlanes( planes, camera, 0 );

	};

	this.setState = function ( material, camera, useCache ) {

		const planes = material.clippingPlanes,
			clipIntersection = material.clipIntersection,
			clipShadows = material.clipShadows;

		const materialProperties = properties.get( material );

		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			// there's no local clipping

			if ( renderingShadows ) {

				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();

			}

		} else {

			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4;

			let dstArray = materialProperties.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, useCache );

			for ( let i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			materialProperties.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		const nPlanes = planes !== null ? planes.length : 0;
		let dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				const flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;

		return dstArray;

	}

}

function WebGLCubeMaps( renderer ) {

	let cubemaps = new WeakMap();

	function mapTextureMapping( texture, mapping ) {

		if ( mapping === EquirectangularReflectionMapping ) {

			texture.mapping = CubeReflectionMapping;

		} else if ( mapping === EquirectangularRefractionMapping ) {

			texture.mapping = CubeRefractionMapping;

		}

		return texture;

	}

	function get( texture ) {

		if ( texture && texture.isTexture ) {

			const mapping = texture.mapping;

			if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

				if ( cubemaps.has( texture ) ) {

					const cubemap = cubemaps.get( texture ).texture;
					return mapTextureMapping( cubemap, texture.mapping );

				} else {

					const image = texture.image;

					if ( image && image.height > 0 ) {

						const renderTarget = new WebGLCubeRenderTarget( image.height );
						renderTarget.fromEquirectangularTexture( renderer, texture );
						cubemaps.set( texture, renderTarget );

						texture.addEventListener( 'dispose', onTextureDispose );

						return mapTextureMapping( renderTarget.texture, texture.mapping );

					} else {

						// image not yet ready. try the conversion next frame

						return null;

					}

				}

			}

		}

		return texture;

	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemap = cubemaps.get( texture );

		if ( cubemap !== undefined ) {

			cubemaps.delete( texture );
			cubemap.dispose();

		}

	}

	function dispose() {

		cubemaps = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

const LOD_MIN = 4;

// The standard deviations (radians) associated with the extra mips.
// Used for scene blur in fromScene() method.
const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
// Used for scene blur in fromScene() method.
const MAX_SAMPLES = 20;

// GGX VNDF importance sampling configuration
const GGX_SAMPLES = 512;

const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
const _clearColor = /*@__PURE__*/ new Color();
let _oldTarget = null;
let _oldActiveCubeFace = 0;
let _oldActiveMipmapLevel = 0;
let _oldXrEnabled = false;

const _origin = /*@__PURE__*/ new Vector3();

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * The prefiltering uses GGX VNDF (Visible Normal Distribution Function)
 * importance sampling based on "Sampling the GGX Distribution of Visible Normals"
 * (Heitz, 2018) to generate environment maps that accurately match the GGX BRDF
 * used in material rendering for physically-based image-based lighting.
 */
class PMREMGenerator {

	/**
	 * Constructs a new PMREM generator.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 */
	constructor( renderer ) {

		this._renderer = renderer;
		this._pingPongRenderTarget = null;

		this._lodMax = 0;
		this._cubeSize = 0;
		this._sizeLods = [];
		this._sigmas = [];
		this._lodMeshes = [];

		this._backgroundBox = null;

		this._cubemapMaterial = null;
		this._equirectMaterial = null;

		this._blurMaterial = null;
		this._ggxMaterial = null;

	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety.
	 *
	 * @param {Scene} scene - The scene to be captured.
	 * @param {number} [sigma=0] - The blur radius in radians.
	 * @param {number} [near=0.1] - The near plane distance.
	 * @param {number} [far=100] - The far plane distance.
	 * @param {Object} [options={}] - The configuration options.
	 * @param {number} [options.size=256] - The texture size of the PMREM.
	 * @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.
	 * @return {WebGLRenderTarget} The resulting PMREM.
	 */
	fromScene( scene, sigma = 0, near = 0.1, far = 100, options = {} ) {

		const {
			size = 256,
			position = _origin,
		} = options;

		_oldTarget = this._renderer.getRenderTarget();
		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
		_oldXrEnabled = this._renderer.xr.enabled;

		this._renderer.xr.enabled = false;

		this._setSize( size );

		const cubeUVRenderTarget = this._allocateTargets();
		cubeUVRenderTarget.depthBuffer = true;

		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget, position );

		if ( sigma > 0 ) {

			this._blur( cubeUVRenderTarget, 0, 0, sigma );

		}

		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * or HDR. The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 *
	 * @param {Texture} equirectangular - The equirectangular texture to be converted.
	 * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
	 * @return {WebGLRenderTarget} The resulting PMREM.
	 */
	fromEquirectangular( equirectangular, renderTarget = null ) {

		return this._fromTexture( equirectangular, renderTarget );

	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * or HDR. The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 *
	 * @param {Texture} cubemap - The cubemap texture to be converted.
	 * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
	 * @return {WebGLRenderTarget} The resulting PMREM.
	 */
	fromCubemap( cubemap, renderTarget = null ) {

		return this._fromTexture( cubemap, renderTarget );

	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader() {

		if ( this._cubemapMaterial === null ) {

			this._cubemapMaterial = _getCubemapMaterial();
			this._compileMaterial( this._cubemapMaterial );

		}

	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader() {

		if ( this._equirectMaterial === null ) {

			this._equirectMaterial = _getEquirectMaterial();
			this._compileMaterial( this._equirectMaterial );

		}

	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {

		this._dispose();

		if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
		if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();

		if ( this._backgroundBox !== null ) {

			this._backgroundBox.geometry.dispose();
			this._backgroundBox.material.dispose();

		}

	}

	// private interface

	_setSize( cubeSize ) {

		this._lodMax = Math.floor( Math.log2( cubeSize ) );
		this._cubeSize = Math.pow( 2, this._lodMax );

	}

	_dispose() {

		if ( this._blurMaterial !== null ) this._blurMaterial.dispose();
		if ( this._ggxMaterial !== null ) this._ggxMaterial.dispose();

		if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

		for ( let i = 0; i < this._lodMeshes.length; i ++ ) {

			this._lodMeshes[ i ].geometry.dispose();

		}

	}

	_cleanup( outputTarget ) {

		this._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );
		this._renderer.xr.enabled = _oldXrEnabled;

		outputTarget.scissorTest = false;
		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

	}

	_fromTexture( texture, renderTarget ) {

		if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

			this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

		} else { // Equirectangular

			this._setSize( texture.image.width / 4 );

		}

		_oldTarget = this._renderer.getRenderTarget();
		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
		_oldXrEnabled = this._renderer.xr.enabled;

		this._renderer.xr.enabled = false;

		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
		this._textureToCubeUV( texture, cubeUVRenderTarget );
		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	_allocateTargets() {

		const width = 3 * Math.max( this._cubeSize, 16 * 7 );
		const height = 4 * this._cubeSize;

		const params = {
			magFilter: LinearFilter,
			minFilter: LinearFilter,
			generateMipmaps: false,
			type: HalfFloatType,
			format: RGBAFormat,
			colorSpace: LinearSRGBColorSpace,
			depthBuffer: false
		};

		const cubeUVRenderTarget = _createRenderTarget( width, height, params );

		if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {

			if ( this._pingPongRenderTarget !== null ) {

				this._dispose();

			}

			this._pingPongRenderTarget = _createRenderTarget( width, height, params );

			const { _lodMax } = this;
			( { lodMeshes: this._lodMeshes, sizeLods: this._sizeLods, sigmas: this._sigmas } = _createPlanes( _lodMax ) );

			this._blurMaterial = _getBlurShader( _lodMax, width, height );

		}

		return cubeUVRenderTarget;

	}

	_compileMaterial( material ) {

		const mesh = new Mesh( new BufferGeometry(), material );
		this._renderer.compile( mesh, _flatCamera );

	}

	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget, position ) {

		const fov = 90;
		const aspect = 1;
		const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
		const upSign = [ 1, -1, 1, 1, 1, 1 ];
		const forwardSign = [ 1, 1, 1, -1, -1, -1 ];
		const renderer = this._renderer;

		const originalAutoClear = renderer.autoClear;
		const toneMapping = renderer.toneMapping;
		renderer.getClearColor( _clearColor );

		renderer.toneMapping = NoToneMapping;
		renderer.autoClear = false;

		// https://github.com/mrdoob/three.js/issues/31413#issuecomment-3095966812
		const reversedDepthBuffer = renderer.state.buffers.depth.getReversed();

		if ( reversedDepthBuffer ) {

			renderer.setRenderTarget( cubeUVRenderTarget );
			renderer.clearDepth();
			renderer.setRenderTarget( null );

		}

		if ( this._backgroundBox === null ) {

			this._backgroundBox = new Mesh(
				new BoxGeometry(),
				new MeshBasicMaterial( {
					name: 'PMREM.Background',
					side: BackSide,
					depthWrite: false,
					depthTest: false,
				} )
			);

		}

		const backgroundBox = this._backgroundBox;
		const backgroundMaterial = backgroundBox.material;

		let useSolidColor = false;

		const background = scene.background;

		if ( background ) {

			if ( background.isColor ) {

				backgroundMaterial.color.copy( background );
				scene.background = null;
				useSolidColor = true;

			}

		} else {

			backgroundMaterial.color.copy( _clearColor );
			useSolidColor = true;

		}

		for ( let i = 0; i < 6; i ++ ) {

			const col = i % 3;

			if ( col === 0 ) {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.position.set( position.x, position.y, position.z );
				cubeCamera.lookAt( position.x + forwardSign[ i ], position.y, position.z );

			} else if ( col === 1 ) {

				cubeCamera.up.set( 0, 0, upSign[ i ] );
				cubeCamera.position.set( position.x, position.y, position.z );
				cubeCamera.lookAt( position.x, position.y + forwardSign[ i ], position.z );


			} else {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.position.set( position.x, position.y, position.z );
				cubeCamera.lookAt( position.x, position.y, position.z + forwardSign[ i ] );

			}

			const size = this._cubeSize;

			_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

			renderer.setRenderTarget( cubeUVRenderTarget );

			if ( useSolidColor ) {

				renderer.render( backgroundBox, cubeCamera );

			}

			renderer.render( scene, cubeCamera );

		}

		renderer.toneMapping = toneMapping;
		renderer.autoClear = originalAutoClear;
		scene.background = background;

	}

	_textureToCubeUV( texture, cubeUVRenderTarget ) {

		const renderer = this._renderer;

		const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

		if ( isCubeTexture ) {

			if ( this._cubemapMaterial === null ) {

				this._cubemapMaterial = _getCubemapMaterial();

			}

			this._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? -1 : 1;

		} else {

			if ( this._equirectMaterial === null ) {

				this._equirectMaterial = _getEquirectMaterial();

			}

		}

		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;

		const mesh = this._lodMeshes[ 0 ];
		mesh.material = material;

		const uniforms = material.uniforms;

		uniforms[ 'envMap' ].value = texture;

		const size = this._cubeSize;

		_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( mesh, _flatCamera );

	}

	_applyPMREM( cubeUVRenderTarget ) {

		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;

		const n = this._lodMeshes.length;

		// Use GGX VNDF importance sampling
		for ( let i = 1; i < n; i ++ ) {

			this._applyGGXFilter( cubeUVRenderTarget, i - 1, i );

		}

		renderer.autoClear = autoClear;

	}

	/**
	 * Applies GGX VNDF importance sampling filter to generate a prefiltered environment map.
	 * Uses Monte Carlo integration with VNDF importance sampling to accurately represent the
	 * GGX BRDF for physically-based rendering. Reads from the previous LOD level and
	 * applies incremental roughness filtering to avoid over-blurring.
	 *
	 * @private
	 * @param {WebGLRenderTarget} cubeUVRenderTarget
	 * @param {number} lodIn - Source LOD level to read from
	 * @param {number} lodOut - Target LOD level to write to
	 */
	_applyGGXFilter( cubeUVRenderTarget, lodIn, lodOut ) {

		const renderer = this._renderer;
		const pingPongRenderTarget = this._pingPongRenderTarget;

		if ( this._ggxMaterial === null ) {

			const width = 3 * Math.max( this._cubeSize, 16 );
			const height = 4 * this._cubeSize;
			this._ggxMaterial = _getGGXShader( this._lodMax, width, height );

		}

		const ggxMaterial = this._ggxMaterial;
		const ggxMesh = this._lodMeshes[ lodOut ];
		ggxMesh.material = ggxMaterial;

		const ggxUniforms = ggxMaterial.uniforms;

		// Calculate incremental roughness between LOD levels
		const targetRoughness = lodOut / ( this._lodMeshes.length - 1 );
		const sourceRoughness = lodIn / ( this._lodMeshes.length - 1 );
		const incrementalRoughness = Math.sqrt( targetRoughness * targetRoughness - sourceRoughness * sourceRoughness );

		// Apply blur strength mapping for better quality across the roughness range
		const blurStrength = 0.05 + targetRoughness * 0.95;
		const adjustedRoughness = incrementalRoughness * blurStrength;

		// Calculate viewport position based on output LOD level
		const { _lodMax } = this;
		const outputSize = this._sizeLods[ lodOut ];
		const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
		const y = 4 * ( this._cubeSize - outputSize );

		// Read from previous LOD with incremental roughness
		ggxUniforms[ 'envMap' ].value = cubeUVRenderTarget.texture;
		ggxUniforms[ 'roughness' ].value = adjustedRoughness;
		ggxUniforms[ 'mipInt' ].value = _lodMax - lodIn; // Sample from input LOD

		_setViewport( pingPongRenderTarget, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( pingPongRenderTarget );
		renderer.render( ggxMesh, _flatCamera );

		// Copy from pingPong back to cubeUV (simple direct copy)
		ggxUniforms[ 'envMap' ].value = pingPongRenderTarget.texture;
		ggxUniforms[ 'roughness' ].value = 0.0; // Direct copy
		ggxUniforms[ 'mipInt' ].value = _lodMax - lodOut; // Read from the level we just wrote

		_setViewport( cubeUVRenderTarget, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( ggxMesh, _flatCamera );

	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 *
	 * Used for initial scene blur in fromScene() method when sigma > 0.
	 *
	 * @private
	 * @param {WebGLRenderTarget} cubeUVRenderTarget
	 * @param {number} lodIn
	 * @param {number} lodOut
	 * @param {number} sigma
	 * @param {Vector3} [poleAxis]
	 */
	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

		const pingPongRenderTarget = this._pingPongRenderTarget;

		this._halfBlur(
			cubeUVRenderTarget,
			pingPongRenderTarget,
			lodIn,
			lodOut,
			sigma,
			'latitudinal',
			poleAxis );

		this._halfBlur(
			pingPongRenderTarget,
			cubeUVRenderTarget,
			lodOut,
			lodOut,
			sigma,
			'longitudinal',
			poleAxis );

	}

	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;

		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

			error(
				'blur direction must be either latitudinal or longitudinal!' );

		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;

		const blurMesh = this._lodMeshes[ lodOut ];
		blurMesh.material = blurMaterial;

		const blurUniforms = blurMaterial.uniforms;

		const pixels = this._sizeLods[ lodIn ] - 1;
		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

		if ( samples > MAX_SAMPLES ) {

			warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

		}

		const weights = [];
		let sum = 0;

		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

			const x = i / sigmaPixels;
			const weight = Math.exp( - x * x / 2 );
			weights.push( weight );

			if ( i === 0 ) {

				sum += weight;

			} else if ( i < samples ) {

				sum += 2 * weight;

			}

		}

		for ( let i = 0; i < weights.length; i ++ ) {

			weights[ i ] = weights[ i ] / sum;

		}

		blurUniforms[ 'envMap' ].value = targetIn.texture;
		blurUniforms[ 'samples' ].value = samples;
		blurUniforms[ 'weights' ].value = weights;
		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

		if ( poleAxis ) {

			blurUniforms[ 'poleAxis' ].value = poleAxis;

		}

		const { _lodMax } = this;
		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
		blurUniforms[ 'mipInt' ].value = _lodMax - lodIn;

		const outputSize = this._sizeLods[ lodOut ];
		const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
		const y = 4 * ( this._cubeSize - outputSize );

		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( targetOut );
		renderer.render( blurMesh, _flatCamera );

	}

}



function _createPlanes( lodMax ) {

	const sizeLods = [];
	const sigmas = [];
	const lodMeshes = [];

	let lod = lodMax;

	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

	for ( let i = 0; i < totalLods; i ++ ) {

		const sizeLod = Math.pow( 2, lod );
		sizeLods.push( sizeLod );
		let sigma = 1.0 / sizeLod;

		if ( i > lodMax - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

		} else if ( i === 0 ) {

			sigma = 0;

		}

		sigmas.push( sigma );

		const texelSize = 1.0 / ( sizeLod - 2 );
		const min = - texelSize;
		const max = 1 + texelSize;
		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;

		const position = new Float32Array( positionSize * vertices * cubeFaces );
		const uv = new Float32Array( uvSize * vertices * cubeFaces );
		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( let face = 0; face < cubeFaces; face ++ ) {

			const x = ( face % 3 ) * 2 / 3 - 1;
			const y = face > 2 ? 0 : -1;
			const coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];
			position.set( coordinates, positionSize * vertices * face );
			uv.set( uv1, uvSize * vertices * face );
			const fill = [ face, face, face, face, face, face ];
			faceIndex.set( fill, faceIndexSize * vertices * face );

		}

		const planes = new BufferGeometry();
		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
		lodMeshes.push( new Mesh( planes, null ) );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}

	return { lodMeshes, sizeLods, sigmas };

}

function _createRenderTarget( width, height, params ) {

	const cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _getGGXShader( lodMax, width, height ) {

	const shaderMaterial = new ShaderMaterial( {

		name: 'PMREMGGXConvolution',

		defines: {
			'GGX_SAMPLES': GGX_SAMPLES,
			'CUBEUV_TEXEL_WIDTH': 1.0 / width,
			'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
			'CUBEUV_MAX_MIP': `${lodMax}.0`,
		},

		uniforms: {
			'envMap': { value: null },
			'roughness': { value: 0.0 },
			'mipInt': { value: 0 }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform float roughness;
			uniform float mipInt;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			#define PI 3.14159265359

			// Van der Corput radical inverse
			float radicalInverse_VdC(uint bits) {
				bits = (bits << 16u) | (bits >> 16u);
				bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
				bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
				bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
				bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
				return float(bits) * 2.3283064365386963e-10; // / 0x100000000
			}

			// Hammersley sequence
			vec2 hammersley(uint i, uint N) {
				return vec2(float(i) / float(N), radicalInverse_VdC(i));
			}

			// GGX VNDF importance sampling (Eric Heitz 2018)
			// "Sampling the GGX Distribution of Visible Normals"
			// https://jcgt.org/published/0007/04/01/
			vec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {
				float alpha = roughness * roughness;

				// Section 3.2: Transform view direction to hemisphere configuration
				vec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));

				// Section 4.1: Orthonormal basis
				float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
				vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);
				vec3 T2 = cross(Vh, T1);

				// Section 4.2: Parameterization of projected area
				float r = sqrt(Xi.x);
				float phi = 2.0 * PI * Xi.y;
				float t1 = r * cos(phi);
				float t2 = r * sin(phi);
				float s = 0.5 * (1.0 + Vh.z);
				t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

				// Section 4.3: Reprojection onto hemisphere
				vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;

				// Section 3.4: Transform back to ellipsoid configuration
				return normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));
			}

			void main() {
				vec3 N = normalize(vOutputDirection);
				vec3 V = N; // Assume view direction equals normal for pre-filtering

				vec3 prefilteredColor = vec3(0.0);
				float totalWeight = 0.0;

				// For very low roughness, just sample the environment directly
				if (roughness < 0.001) {
					gl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);
					return;
				}

				// Tangent space basis for VNDF sampling
				vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
				vec3 tangent = normalize(cross(up, N));
				vec3 bitangent = cross(N, tangent);

				for(uint i = 0u; i < uint(GGX_SAMPLES); i++) {
					vec2 Xi = hammersley(i, uint(GGX_SAMPLES));

					// For PMREM, V = N, so in tangent space V is always (0, 0, 1)
					vec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);

					// Transform H back to world space
					vec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
					vec3 L = normalize(2.0 * dot(V, H) * H - V);

					float NdotL = max(dot(N, L), 0.0);

					if(NdotL > 0.0) {
						// Sample environment at fixed mip level
						// VNDF importance sampling handles the distribution filtering
						vec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);

						// Weight by NdotL for the split-sum approximation
						// VNDF PDF naturally accounts for the visible microfacet distribution
						prefilteredColor += sampleColor * NdotL;
						totalWeight += NdotL;
					}
				}

				if (totalWeight > 0.0) {
					prefilteredColor = prefilteredColor / totalWeight;
				}

				gl_FragColor = vec4(prefilteredColor, 1.0);
			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getBlurShader( lodMax, width, height ) {

	const weights = new Float32Array( MAX_SAMPLES );
	const poleAxis = new Vector3( 0, 1, 0 );
	const shaderMaterial = new ShaderMaterial( {

		name: 'SphericalGaussianBlur',

		defines: {
			'n': MAX_SAMPLES,
			'CUBEUV_TEXEL_WIDTH': 1.0 / width,
			'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
			'CUBEUV_MAX_MIP': `${lodMax}.0`,
		},

		uniforms: {
			'envMap': { value: null },
			'samples': { value: 1 },
			'weights': { value: weights },
			'latitudinal': { value: false },
			'dTheta': { value: 0 },
			'mipInt': { value: 0 },
			'poleAxis': { value: poleAxis }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getEquirectMaterial() {

	return new ShaderMaterial( {

		name: 'EquirectangularToCubeUV',

		uniforms: {
			'envMap': { value: null }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

}

function _getCubemapMaterial() {

	return new ShaderMaterial( {

		name: 'CubemapToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'flipEnvMap': { value: -1 }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

}

function _getCommonVertexShader() {

	return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

}

function WebGLCubeUVMaps( renderer ) {

	let cubeUVmaps = new WeakMap();

	let pmremGenerator = null;

	function get( texture ) {

		if ( texture && texture.isTexture ) {

			const mapping = texture.mapping;

			const isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );
			const isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

			// equirect/cube map to cubeUV conversion

			if ( isEquirectMap || isCubeMap ) {

				let renderTarget = cubeUVmaps.get( texture );

				const currentPMREMVersion = renderTarget !== undefined ? renderTarget.texture.pmremVersion : 0;

				if ( texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion ) {

					if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

					renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );
					renderTarget.texture.pmremVersion = texture.pmremVersion;

					cubeUVmaps.set( texture, renderTarget );

					return renderTarget.texture;

				} else {

					if ( renderTarget !== undefined ) {

						return renderTarget.texture;

					} else {

						const image = texture.image;

						if ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {

							if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

							renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
							renderTarget.texture.pmremVersion = texture.pmremVersion;

							cubeUVmaps.set( texture, renderTarget );

							texture.addEventListener( 'dispose', onTextureDispose );

							return renderTarget.texture;

						} else {

							// image not yet ready. try the conversion next frame

							return null;

						}

					}

				}

			}

		}

		return texture;

	}

	function isCubeTextureComplete( image ) {

		let count = 0;
		const length = 6;

		for ( let i = 0; i < length; i ++ ) {

			if ( image[ i ] !== undefined ) count ++;

		}

		return count === length;


	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemapUV = cubeUVmaps.get( texture );

		if ( cubemapUV !== undefined ) {

			cubeUVmaps.delete( texture );
			cubemapUV.dispose();

		}

	}

	function dispose() {

		cubeUVmaps = new WeakMap();

		if ( pmremGenerator !== null ) {

			pmremGenerator.dispose();
			pmremGenerator = null;

		}

	}

	return {
		get: get,
		dispose: dispose
	};

}

function WebGLExtensions( gl ) {

	const extensions = {};

	function getExtension( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		const extension = gl.getExtension( name );

		extensions[ name ] = extension;

		return extension;

	}

	return {

		has: function ( name ) {

			return getExtension( name ) !== null;

		},

		init: function () {

			getExtension( 'EXT_color_buffer_float' );
			getExtension( 'WEBGL_clip_cull_distance' );
			getExtension( 'OES_texture_float_linear' );
			getExtension( 'EXT_color_buffer_half_float' );
			getExtension( 'WEBGL_multisampled_render_to_texture' );
			getExtension( 'WEBGL_render_shared_exponent' );

		},

		get: function ( name ) {

			const extension = getExtension( name );

			if ( extension === null ) {

				warnOnce( 'WebGLRenderer: ' + name + ' extension not supported.' );

			}

			return extension;

		}

	};

}

function WebGLGeometries( gl, attributes, info, bindingStates ) {

	const geometries = {};
	const wireframeAttributes = new WeakMap();

	function onGeometryDispose( event ) {

		const geometry = event.target;

		if ( geometry.index !== null ) {

			attributes.remove( geometry.index );

		}

		for ( const name in geometry.attributes ) {

			attributes.remove( geometry.attributes[ name ] );

		}

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		const attribute = wireframeAttributes.get( geometry );

		if ( attribute ) {

			attributes.remove( attribute );
			wireframeAttributes.delete( geometry );

		}

		bindingStates.releaseStatesOfGeometry( geometry );

		if ( geometry.isInstancedBufferGeometry === true ) {

			delete geometry._maxInstanceCount;

		}

		//

		info.memory.geometries --;

	}

	function get( object, geometry ) {

		if ( geometries[ geometry.id ] === true ) return geometry;

		geometry.addEventListener( 'dispose', onGeometryDispose );

		geometries[ geometry.id ] = true;

		info.memory.geometries ++;

		return geometry;

	}

	function update( geometry ) {

		const geometryAttributes = geometry.attributes;

		// Updating index buffer in VAO now. See WebGLBindingStates.

		for ( const name in geometryAttributes ) {

			attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

		}

	}

	function updateWireframeAttribute( geometry ) {

		const indices = [];

		const geometryIndex = geometry.index;
		const geometryPosition = geometry.attributes.position;
		let version = 0;

		if ( geometryIndex !== null ) {

			const array = geometryIndex.array;
			version = geometryIndex.version;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const a = array[ i + 0 ];
				const b = array[ i + 1 ];
				const c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else if ( geometryPosition !== undefined ) {

			const array = geometryPosition.array;
			version = geometryPosition.version;

			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				const a = i + 0;
				const b = i + 1;
				const c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		} else {

			return;

		}

		const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
		attribute.version = version;

		// Updating index buffer in VAO now. See WebGLBindingStates

		//

		const previousAttribute = wireframeAttributes.get( geometry );

		if ( previousAttribute ) attributes.remove( previousAttribute );

		//

		wireframeAttributes.set( geometry, attribute );

	}

	function getWireframeAttribute( geometry ) {

		const currentAttribute = wireframeAttributes.get( geometry );

		if ( currentAttribute ) {

			const geometryIndex = geometry.index;

			if ( geometryIndex !== null ) {

				// if the attribute is obsolete, create a new one

				if ( currentAttribute.version < geometryIndex.version ) {

					updateWireframeAttribute( geometry );

				}

			}

		} else {

			updateWireframeAttribute( geometry );

		}

		return wireframeAttributes.get( geometry );

	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};

}

function WebGLIndexedBufferRenderer( gl, extensions, info ) {

	let mode;

	function setMode( value ) {

		mode = value;

	}

	let type, bytesPerElement;

	function setIndex( value ) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * bytesPerElement );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		gl.drawElementsInstanced( mode, count, type, start * bytesPerElement, primcount );

		info.update( count, mode, primcount );

	}

	function renderMultiDraw( starts, counts, drawCount ) {

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );
		extension.multiDrawElementsWEBGL( mode, counts, 0, type, starts, 0, drawCount );

		let elementCount = 0;
		for ( let i = 0; i < drawCount; i ++ ) {

			elementCount += counts[ i ];

		}

		info.update( elementCount, mode, 1 );


	}

	function renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < starts.length; i ++ ) {

				renderInstances( starts[ i ] / bytesPerElement, counts[ i ], primcount[ i ] );

			}

		} else {

			extension.multiDrawElementsInstancedWEBGL( mode, counts, 0, type, starts, 0, primcount, 0, drawCount );

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ] * primcount[ i ];

			}

			info.update( elementCount, mode, 1 );

		}

	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;
	this.renderMultiDraw = renderMultiDraw;
	this.renderMultiDrawInstances = renderMultiDrawInstances;

}

function WebGLInfo( gl ) {

	const memory = {
		geometries: 0,
		textures: 0
	};

	const render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update( count, mode, instanceCount ) {

		render.calls ++;

		switch ( mode ) {

			case gl.TRIANGLES:
				render.triangles += instanceCount * ( count / 3 );
				break;

			case gl.LINES:
				render.lines += instanceCount * ( count / 2 );
				break;

			case gl.LINE_STRIP:
				render.lines += instanceCount * ( count - 1 );
				break;

			case gl.LINE_LOOP:
				render.lines += instanceCount * count;
				break;

			case gl.POINTS:
				render.points += instanceCount * count;
				break;

			default:
				error( 'WebGLInfo: Unknown draw mode:', mode );
				break;

		}

	}

	function reset() {

		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;

	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};

}

function WebGLMorphtargets( gl, capabilities, textures ) {

	const morphTextures = new WeakMap();
	const morph = new Vector4();

	function update( object, geometry, program ) {

		const objectInfluences = object.morphTargetInfluences;

		// the following encodes morph targets into an array of data textures. Each layer represents a single morph target.

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

		let entry = morphTextures.get( geometry );

		if ( entry === undefined || entry.count !== morphTargetsCount ) {

			if ( entry !== undefined ) entry.texture.dispose();

			const hasMorphPosition = geometry.morphAttributes.position !== undefined;
			const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
			const hasMorphColors = geometry.morphAttributes.color !== undefined;

			const morphTargets = geometry.morphAttributes.position || [];
			const morphNormals = geometry.morphAttributes.normal || [];
			const morphColors = geometry.morphAttributes.color || [];

			let vertexDataCount = 0;

			if ( hasMorphPosition === true ) vertexDataCount = 1;
			if ( hasMorphNormals === true ) vertexDataCount = 2;
			if ( hasMorphColors === true ) vertexDataCount = 3;

			let width = geometry.attributes.position.count * vertexDataCount;
			let height = 1;

			if ( width > capabilities.maxTextureSize ) {

				height = Math.ceil( width / capabilities.maxTextureSize );
				width = capabilities.maxTextureSize;

			}

			const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

			const texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
			texture.type = FloatType;
			texture.needsUpdate = true;

			// fill buffer

			const vertexDataStride = vertexDataCount * 4;

			for ( let i = 0; i < morphTargetsCount; i ++ ) {

				const morphTarget = morphTargets[ i ];
				const morphNormal = morphNormals[ i ];
				const morphColor = morphColors[ i ];

				const offset = width * height * 4 * i;

				for ( let j = 0; j < morphTarget.count; j ++ ) {

					const stride = j * vertexDataStride;

					if ( hasMorphPosition === true ) {

						morph.fromBufferAttribute( morphTarget, j );

						buffer[ offset + stride + 0 ] = morph.x;
						buffer[ offset + stride + 1 ] = morph.y;
						buffer[ offset + stride + 2 ] = morph.z;
						buffer[ offset + stride + 3 ] = 0;

					}

					if ( hasMorphNormals === true ) {

						morph.fromBufferAttribute( morphNormal, j );

						buffer[ offset + stride + 4 ] = morph.x;
						buffer[ offset + stride + 5 ] = morph.y;
						buffer[ offset + stride + 6 ] = morph.z;
						buffer[ offset + stride + 7 ] = 0;

					}

					if ( hasMorphColors === true ) {

						morph.fromBufferAttribute( morphColor, j );

						buffer[ offset + stride + 8 ] = morph.x;
						buffer[ offset + stride + 9 ] = morph.y;
						buffer[ offset + stride + 10 ] = morph.z;
						buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;

					}

				}

			}

			entry = {
				count: morphTargetsCount,
				texture: texture,
				size: new Vector2( width, height )
			};

			morphTextures.set( geometry, entry );

			function disposeTexture() {

				texture.dispose();

				morphTextures.delete( geometry );

				geometry.removeEventListener( 'dispose', disposeTexture );

			}

			geometry.addEventListener( 'dispose', disposeTexture );

		}

		//
		if ( object.isInstancedMesh === true && object.morphTexture !== null ) {

			program.getUniforms().setValue( gl, 'morphTexture', object.morphTexture, textures );

		} else {

			let morphInfluencesSum = 0;

			for ( let i = 0; i < objectInfluences.length; i ++ ) {

				morphInfluencesSum += objectInfluences[ i ];

			}

			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;


			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
			program.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );

		}

		program.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );
		program.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );

	}

	return {

		update: update

	};

}

function WebGLObjects( gl, geometries, attributes, info ) {

	let updateMap = new WeakMap();

	function update( object ) {

		const frame = info.render.frame;

		const geometry = object.geometry;
		const buffergeometry = geometries.get( object, geometry );

		// Update once per frame

		if ( updateMap.get( buffergeometry ) !== frame ) {

			geometries.update( buffergeometry );

			updateMap.set( buffergeometry, frame );

		}

		if ( object.isInstancedMesh ) {

			if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

				object.addEventListener( 'dispose', onInstancedMeshDispose );

			}

			if ( updateMap.get( object ) !== frame ) {

				attributes.update( object.instanceMatrix, gl.ARRAY_BUFFER );

				if ( object.instanceColor !== null ) {

					attributes.update( object.instanceColor, gl.ARRAY_BUFFER );

				}

				updateMap.set( object, frame );

			}

		}

		if ( object.isSkinnedMesh ) {

			const skeleton = object.skeleton;

			if ( updateMap.get( skeleton ) !== frame ) {

				skeleton.update();

				updateMap.set( skeleton, frame );

			}

		}

		return buffergeometry;

	}

	function dispose() {

		updateMap = new WeakMap();

	}

	function onInstancedMeshDispose( event ) {

		const instancedMesh = event.target;

		instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

		attributes.remove( instancedMesh.instanceMatrix );

		if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

	}

	return {

		update: update,
		dispose: dispose

	};

}

/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */


const emptyTexture = /*@__PURE__*/ new Texture();

const emptyShadowTexture = /*@__PURE__*/ new DepthTexture( 1, 1 );

const emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture();
const empty3dTexture = /*@__PURE__*/ new Data3DTexture();
const emptyCubeTexture = /*@__PURE__*/ new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array( 16 );
const mat3array = new Float32Array( 9 );
const mat2array = new Float32Array( 4 );

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	const firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	const n = nBlocks * blockSize;
	let r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

function arraysEqual( a, b ) {

	if ( a.length !== b.length ) return false;

	for ( let i = 0, l = a.length; i < l; i ++ ) {

		if ( a[ i ] !== b[ i ] ) return false;

	}

	return true;

}

function copyArray( a, b ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		a[ i ] = b[ i ];

	}

}

// Texture unit allocation

function allocTexUnits( textures, n ) {

	let r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( let i = 0; i !== n; ++ i ) {

		r[ i ] = textures.allocateTextureUnit();

	}

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1f( this.addr, v );

	cache[ 0 ] = v;

}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2f( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else if ( v.r !== undefined ) {

		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

			cache[ 0 ] = v.r;
			cache[ 1 ] = v.g;
			cache[ 2 ] = v.b;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4fv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single matrix (from flat array or THREE.MatrixN)

function setValueM2( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix2fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat2array.set( elements );

		gl.uniformMatrix2fv( this.addr, false, mat2array );

		copyArray( cache, elements );

	}

}

function setValueM3( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix3fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat3array.set( elements );

		gl.uniformMatrix3fv( this.addr, false, mat3array );

		copyArray( cache, elements );

	}

}

function setValueM4( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix4fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat4array.set( elements );

		gl.uniformMatrix4fv( this.addr, false, mat4array );

		copyArray( cache, elements );

	}

}

// Single integer / boolean

function setValueV1i( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1i( this.addr, v );

	cache[ 0 ] = v;

}

// Single integer / boolean vector (from flat array or THREE.VectorN)

function setValueV2i( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2i( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2iv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3i( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3i( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3iv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4i( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4i( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4iv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single unsigned integer

function setValueV1ui( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1ui( this.addr, v );

	cache[ 0 ] = v;

}

// Single unsigned integer vector (from flat array or THREE.VectorN)

function setValueV2ui( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2ui( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2uiv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3ui( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3ui( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3uiv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4ui( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4ui( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4uiv( this.addr, v );

		copyArray( cache, v );

	}

}


// Single texture (2D / Cube)

function setValueT1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	let emptyTexture2D;

	if ( this.type === gl.SAMPLER_2D_SHADOW ) {

		emptyShadowTexture.compareFunction = LessEqualCompare; // #28670
		emptyTexture2D = emptyShadowTexture;

	} else {

		emptyTexture2D = emptyTexture;

	}

	textures.setTexture2D( v || emptyTexture2D, unit );

}

function setValueT3D1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture3D( v || empty3dTexture, unit );

}

function setValueT6( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTextureCube( v || emptyCubeTexture, unit );

}

function setValueT2DArray1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2DArray( v || emptyArrayTexture, unit );

}

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1f; // FLOAT
		case 0x8b50: return setValueV2f; // _VEC2
		case 0x8b51: return setValueV3f; // _VEC3
		case 0x8b52: return setValueV4f; // _VEC4

		case 0x8b5a: return setValueM2; // _MAT2
		case 0x8b5b: return setValueM3; // _MAT3
		case 0x8b5c: return setValueM4; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

		case 0x1405: return setValueV1ui; // UINT
		case 0x8dc6: return setValueV2ui; // _VEC2
		case 0x8dc7: return setValueV3ui; // _VEC3
		case 0x8dc8: return setValueV4ui; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3D1;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArray1;

	}

}


// Array of scalars

function setValueV1fArray( gl, v ) {

	gl.uniform1fv( this.addr, v );

}

// Array of vectors (from flat array or array of THREE.VectorN)

function setValueV2fArray( gl, v ) {

	const data = flatten( v, this.size, 2 );

	gl.uniform2fv( this.addr, data );

}

function setValueV3fArray( gl, v ) {

	const data = flatten( v, this.size, 3 );

	gl.uniform3fv( this.addr, data );

}

function setValueV4fArray( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniform4fv( this.addr, data );

}

// Array of matrices (from flat array or array of THREE.MatrixN)

function setValueM2Array( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniformMatrix2fv( this.addr, false, data );

}

function setValueM3Array( gl, v ) {

	const data = flatten( v, this.size, 9 );

	gl.uniformMatrix3fv( this.addr, false, data );

}

function setValueM4Array( gl, v ) {

	const data = flatten( v, this.size, 16 );

	gl.uniformMatrix4fv( this.addr, false, data );

}

// Array of integer / boolean

function setValueV1iArray( gl, v ) {

	gl.uniform1iv( this.addr, v );

}

// Array of integer / boolean vectors (from flat array)

function setValueV2iArray( gl, v ) {

	gl.uniform2iv( this.addr, v );

}

function setValueV3iArray( gl, v ) {

	gl.uniform3iv( this.addr, v );

}

function setValueV4iArray( gl, v ) {

	gl.uniform4iv( this.addr, v );

}

// Array of unsigned integer

function setValueV1uiArray( gl, v ) {

	gl.uniform1uiv( this.addr, v );

}

// Array of unsigned integer vectors (from flat array)

function setValueV2uiArray( gl, v ) {

	gl.uniform2uiv( this.addr, v );

}

function setValueV3uiArray( gl, v ) {

	gl.uniform3uiv( this.addr, v );

}

function setValueV4uiArray( gl, v ) {

	gl.uniform4uiv( this.addr, v );

}


// Array of textures (2D / 3D / Cube / 2DArray)

function setValueT1Array( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT3DArray( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );

	}

}

function setValueT6Array( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

function setValueT2DArrayArray( gl, v, textures ) {

	const cache = this.cache;

	const n = v.length;

	const units = allocTexUnits( textures, n );

	if ( ! arraysEqual( cache, units ) ) {

		gl.uniform1iv( this.addr, units );

		copyArray( cache, units );

	}

	for ( let i = 0; i !== n; ++ i ) {

		textures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );

	}

}


// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1fArray; // FLOAT
		case 0x8b50: return setValueV2fArray; // _VEC2
		case 0x8b51: return setValueV3fArray; // _VEC3
		case 0x8b52: return setValueV4fArray; // _VEC4

		case 0x8b5a: return setValueM2Array; // _MAT2
		case 0x8b5b: return setValueM3Array; // _MAT3
		case 0x8b5c: return setValueM4Array; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

		case 0x1405: return setValueV1uiArray; // UINT
		case 0x8dc6: return setValueV2uiArray; // _VEC2
		case 0x8dc7: return setValueV3uiArray; // _VEC3
		case 0x8dc8: return setValueV4uiArray; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1Array;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3DArray;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6Array;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArrayArray;

	}

}

// --- Uniform Classes ---

class SingleUniform {

	constructor( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.type = activeInfo.type;
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

}

class PureArrayUniform {

	constructor( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.type = activeInfo.type;
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

}

class StructuredUniform {

	constructor( id ) {

		this.id = id;

		this.seq = [];
		this.map = {};

	}

	setValue( gl, value, textures ) {

		const seq = this.seq;

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			u.setValue( gl, value[ u.id ], textures );

		}

	}

}

// --- Top-level ---

// Parser - builds up the property tree from the path strings

const RePathPart = /(\w+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	const path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	while ( true ) {

		const match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex;

		let id = match[ 1 ];
		const idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
				new SingleUniform( id, activeInfo, addr ) :
				new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {

			// step into inner node / create it in case it doesn't exist

			const map = container.map;
			let next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

class WebGLUniforms {

	constructor( gl, program ) {

		this.seq = [];
		this.map = {};

		const n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

		for ( let i = 0; i < n; ++ i ) {

			const info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );

			parseUniform( info, addr, this );

		}

	}

	setValue( gl, name, value, textures ) {

		const u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, textures );

	}

	setOptional( gl, object, name ) {

		const v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	}

	static upload( gl, seq, values, textures ) {

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, textures );

			}

		}

	}

	static seqWithValue( seq, values ) {

		const r = [];

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	}

}

function WebGLShader( gl, type, string ) {

	const shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	return shader;

}

// From https://www.khronos.org/registry/webgl/extensions/KHR_parallel_shader_compile/
const COMPLETION_STATUS_KHR = 0x91B1;

let programIdCount = 0;

function handleSource( string, errorLine ) {

	const lines = string.split( '\n' );
	const lines2 = [];

	const from = Math.max( errorLine - 6, 0 );
	const to = Math.min( errorLine + 6, lines.length );

	for ( let i = from; i < to; i ++ ) {

		const line = i + 1;
		lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

	}

	return lines2.join( '\n' );

}

const _m0 = /*@__PURE__*/ new Matrix3();

function getEncodingComponents( colorSpace ) {

	ColorManagement._getMatrix( _m0, ColorManagement.workingColorSpace, colorSpace );

	const encodingMatrix = `mat3( ${ _m0.elements.map( ( v ) => v.toFixed( 4 ) ) } )`;

	switch ( ColorManagement.getTransfer( colorSpace ) ) {

		case LinearTransfer:
			return [ encodingMatrix, 'LinearTransferOETF' ];

		case SRGBTransfer:
			return [ encodingMatrix, 'sRGBTransferOETF' ];

		default:
			warn( 'WebGLProgram: Unsupported color space: ', colorSpace );
			return [ encodingMatrix, 'LinearTransferOETF' ];

	}

}

function getShaderErrors( gl, shader, type ) {

	const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );

	const shaderInfoLog = gl.getShaderInfoLog( shader ) || '';
	const errors = shaderInfoLog.trim();

	if ( status && errors === '' ) return '';

	const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
	if ( errorMatches ) {

		// --enable-privileged-webgl-extension
		// log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		const errorLine = parseInt( errorMatches[ 1 ] );
		return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource( gl.getShaderSource( shader ), errorLine );

	} else {

		return errors;

	}

}

function getTexelEncodingFunction( functionName, colorSpace ) {

	const components = getEncodingComponents( colorSpace );

	return [

		`vec4 ${functionName}( vec4 value ) {`,

		`	return ${components[ 1 ]}( vec4( value.rgb * ${components[ 0 ]}, value.a ) );`,

		'}',

	].join( '\n' );

}

function getToneMappingFunction( functionName, toneMapping ) {

	let toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;

		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;

		case CineonToneMapping:
			toneMappingName = 'Cineon';
			break;

		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;

		case AgXToneMapping:
			toneMappingName = 'AgX';
			break;

		case NeutralToneMapping:
			toneMappingName = 'Neutral';
			break;

		case CustomToneMapping:
			toneMappingName = 'Custom';
			break;

		default:
			warn( 'WebGLProgram: Unsupported toneMapping:', toneMapping );
			toneMappingName = 'Linear';

	}

	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

}

const _v0 = /*@__PURE__*/ new Vector3();

function getLuminanceFunction() {

	ColorManagement.getLuminanceCoefficients( _v0 );

	const r = _v0.x.toFixed( 4 );
	const g = _v0.y.toFixed( 4 );
	const b = _v0.z.toFixed( 4 );

	return [

		'float luminance( const in vec3 rgb ) {',

		`	const vec3 weights = vec3( ${ r }, ${ g }, ${ b } );`,

		'	return dot( weights, rgb );',

		'}'

	].join( '\n' );

}

function generateVertexExtensions( parameters ) {

	const chunks = [
		parameters.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '',
		parameters.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	const chunks = [];

	for ( const name in defines ) {

		const value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program ) {

	const attributes = {};

	const n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

	for ( let i = 0; i < n; i ++ ) {

		const info = gl.getActiveAttrib( program, i );
		const name = info.name;

		let locationSize = 1;
		if ( info.type === gl.FLOAT_MAT2 ) locationSize = 2;
		if ( info.type === gl.FLOAT_MAT3 ) locationSize = 3;
		if ( info.type === gl.FLOAT_MAT4 ) locationSize = 4;

		// log( 'WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[ name ] = {
			type: info.type,
			location: gl.getAttribLocation( program, name ),
			locationSize: locationSize
		};

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps )
		.replace( /NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
		.replace( /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps )
		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

}

function replaceClippingPlaneNums( string, parameters ) {

	return string
		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

}

// Resolve Includes

const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes( string ) {

	return string.replace( includePattern, includeReplacer );

}

const shaderChunkMap = new Map();

function includeReplacer( match, include ) {

	let string = ShaderChunk[ include ];

	if ( string === undefined ) {

		const newInclude = shaderChunkMap.get( include );

		if ( newInclude !== undefined ) {

			string = ShaderChunk[ newInclude ];
			warn( 'WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude );

		} else {

			throw new Error( 'Can not resolve #include <' + include + '>' );

		}

	}

	return resolveIncludes( string );

}

// Unroll Loops

const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops( string ) {

	return string.replace( unrollLoopPattern, loopReplacer );

}

function loopReplacer( match, start, end, snippet ) {

	let string = '';

	for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

		string += snippet
			.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
			.replace( /UNROLLED_LOOP_INDEX/g, i );

	}

	return string;

}

//

function generatePrecision( parameters ) {

	let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;

	if ( parameters.precision === 'highp' ) {

		precisionstring += '\n#define HIGH_PRECISION';

	} else if ( parameters.precision === 'mediump' ) {

		precisionstring += '\n#define MEDIUM_PRECISION';

	} else if ( parameters.precision === 'lowp' ) {

		precisionstring += '\n#define LOW_PRECISION';

	}

	return precisionstring;

}

function generateShadowMapTypeDefine( parameters ) {

	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	} else if ( parameters.shadowMapType === VSMShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

	}

	return shadowMapTypeDefine;

}

function generateEnvMapTypeDefine( parameters ) {

	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

		}

	}

	return envMapTypeDefine;

}

function generateEnvMapModeDefine( parameters ) {

	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeRefractionMapping:

				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

	}

	return envMapModeDefine;

}

function generateEnvMapBlendingDefine( parameters ) {

	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

	if ( parameters.envMap ) {

		switch ( parameters.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	return envMapBlendingDefine;

}

function generateCubeUVSize( parameters ) {

	const imageHeight = parameters.envMapCubeUVHeight;

	if ( imageHeight === null ) return null;

	const maxMip = Math.log2( imageHeight ) - 2;

	const texelHeight = 1.0 / imageHeight;

	const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

	return { texelWidth, texelHeight, maxMip };

}

function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

	// TODO Send this event to Three.js DevTools
	// log( 'WebGLProgram', cacheKey );

	const gl = renderer.getContext();

	const defines = parameters.defines;

	let vertexShader = parameters.vertexShader;
	let fragmentShader = parameters.fragmentShader;

	const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
	const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
	const envMapModeDefine = generateEnvMapModeDefine( parameters );
	const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
	const envMapCubeUVSize = generateCubeUVSize( parameters );

	const customVertexExtensions = generateVertexExtensions( parameters );

	const customDefines = generateDefines( defines );

	const program = gl.createProgram();

	let prefixVertex, prefixFragment;
	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

	if ( parameters.isRawShaderMaterial ) {

		prefixVertex = [

			'#define SHADER_TYPE ' + parameters.shaderType,
			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixVertex.length > 0 ) {

			prefixVertex += '\n';

		}

		prefixFragment = [

			'#define SHADER_TYPE ' + parameters.shaderType,
			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixFragment.length > 0 ) {

			prefixFragment += '\n';

		}

	} else {

		prefixVertex = [

			generatePrecision( parameters ),

			'#define SHADER_TYPE ' + parameters.shaderType,
			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
			parameters.batching ? '#define USE_BATCHING' : '',
			parameters.batchingColor ? '#define USE_BATCHING_COLOR' : '',
			parameters.instancing ? '#define USE_INSTANCING' : '',
			parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
			parameters.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',

			parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
			parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
			parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
			parameters.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

			parameters.anisotropy ? '#define USE_ANISOTROPY' : '',
			parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
			parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

			parameters.transmission ? '#define USE_TRANSMISSION' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
			parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

			//

			parameters.mapUv ? '#define MAP_UV ' + parameters.mapUv : '',
			parameters.alphaMapUv ? '#define ALPHAMAP_UV ' + parameters.alphaMapUv : '',
			parameters.lightMapUv ? '#define LIGHTMAP_UV ' + parameters.lightMapUv : '',
			parameters.aoMapUv ? '#define AOMAP_UV ' + parameters.aoMapUv : '',
			parameters.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + parameters.emissiveMapUv : '',
			parameters.bumpMapUv ? '#define BUMPMAP_UV ' + parameters.bumpMapUv : '',
			parameters.normalMapUv ? '#define NORMALMAP_UV ' + parameters.normalMapUv : '',
			parameters.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + parameters.displacementMapUv : '',

			parameters.metalnessMapUv ? '#define METALNESSMAP_UV ' + parameters.metalnessMapUv : '',
			parameters.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + parameters.roughnessMapUv : '',

			parameters.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + parameters.anisotropyMapUv : '',

			parameters.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + parameters.clearcoatMapUv : '',
			parameters.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + parameters.clearcoatNormalMapUv : '',
			parameters.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + parameters.clearcoatRoughnessMapUv : '',

			parameters.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + parameters.iridescenceMapUv : '',
			parameters.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + parameters.iridescenceThicknessMapUv : '',

			parameters.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + parameters.sheenColorMapUv : '',
			parameters.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + parameters.sheenRoughnessMapUv : '',

			parameters.specularMapUv ? '#define SPECULARMAP_UV ' + parameters.specularMapUv : '',
			parameters.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + parameters.specularColorMapUv : '',
			parameters.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + parameters.specularIntensityMapUv : '',

			parameters.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + parameters.transmissionMapUv : '',
			parameters.thicknessMapUv ? '#define THICKNESSMAP_UV ' + parameters.thicknessMapUv : '',

			//

			parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUv1s ? '#define USE_UV1' : '',
			parameters.vertexUv2s ? '#define USE_UV2' : '',
			parameters.vertexUv3s ? '#define USE_UV3' : '',

			parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			( parameters.morphColors ) ? '#define USE_MORPHCOLORS' : '',
			( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
			( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGARITHMIC_DEPTH_BUFFER' : '',
			parameters.reversedDepthBuffer ? '#define USE_REVERSED_DEPTH_BUFFER' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			'#ifdef USE_INSTANCING',

			'	attribute mat4 instanceMatrix;',

			'#endif',

			'#ifdef USE_INSTANCING_COLOR',

			'	attribute vec3 instanceColor;',

			'#endif',

			'#ifdef USE_INSTANCING_MORPH',

			'	uniform sampler2D morphTexture;',

			'#endif',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_UV1',

			'	attribute vec2 uv1;',

			'#endif',

			'#ifdef USE_UV2',

			'	attribute vec2 uv2;',

			'#endif',

			'#ifdef USE_UV3',

			'	attribute vec2 uv3;',

			'#endif',

			'#ifdef USE_TANGENT',

			'	attribute vec4 tangent;',

			'#endif',

			'#if defined( USE_COLOR_ALPHA )',

			'	attribute vec4 color;',

			'#elif defined( USE_COLOR )',

			'	attribute vec3 color;',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			generatePrecision( parameters ),

			'#define SHADER_TYPE ' + parameters.shaderType,
			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
			parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

			parameters.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
			parameters.map ? '#define USE_MAP' : '',
			parameters.matcap ? '#define USE_MATCAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
			envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
			envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
			parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

			parameters.anisotropy ? '#define USE_ANISOTROPY' : '',
			parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

			parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

			parameters.dispersion ? '#define USE_DISPERSION' : '',

			parameters.iridescence ? '#define USE_IRIDESCENCE' : '',
			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
			parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.alphaTest ? '#define USE_ALPHATEST' : '',
			parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

			parameters.sheen ? '#define USE_SHEEN' : '',
			parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
			parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

			parameters.transmission ? '#define USE_TRANSMISSION' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

			parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
			parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUv1s ? '#define USE_UV1' : '',
			parameters.vertexUv2s ? '#define USE_UV2' : '',
			parameters.vertexUv3s ? '#define USE_UV3' : '',

			parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',

			parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
			parameters.decodeVideoTextureEmissive ? '#define DECODE_VIDEO_TEXTURE_EMISSIVE' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGARITHMIC_DEPTH_BUFFER' : '',
			parameters.reversedDepthBuffer ? '#define USE_REVERSED_DEPTH_BUFFER' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

			parameters.dithering ? '#define DITHERING' : '',
			parameters.opaque ? '#define OPAQUE' : '',

			ShaderChunk[ 'colorspace_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
			getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputColorSpace ),
			getLuminanceFunction(),

			parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = resolveIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );
	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

	fragmentShader = resolveIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );
	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

	vertexShader = unrollLoops( vertexShader );
	fragmentShader = unrollLoops( fragmentShader );

	if ( parameters.isRawShaderMaterial !== true ) {

		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

		versionString = '#version 300 es\n';

		prefixVertex = [
			customVertexExtensions,
			'#define attribute in',
			'#define varying out',
			'#define texture2D texture'
		].join( '\n' ) + '\n' + prefixVertex;

		prefixFragment = [
			'#define varying in',
			( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
			( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
			'#define gl_FragDepthEXT gl_FragDepth',
			'#define texture2D texture',
			'#define textureCube texture',
			'#define texture2DProj textureProj',
			'#define texture2DLodEXT textureLod',
			'#define texture2DProjLodEXT textureProjLod',
			'#define textureCubeLodEXT textureLod',
			'#define texture2DGradEXT textureGrad',
			'#define texture2DProjGradEXT textureProjGrad',
			'#define textureCubeGradEXT textureGrad'
		].join( '\n' ) + '\n' + prefixFragment;

	}

	const vertexGlsl = versionString + prefixVertex + vertexShader;
	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

	// log( '*VERTEX*', vertexGlsl );
	// log( '*FRAGMENT*', fragmentGlsl );

	const glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
	const glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( parameters.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	function onFirstUse( self ) {

		// check for link errors
		if ( renderer.debug.checkShaderErrors ) {

			const programInfoLog = gl.getProgramInfoLog( program ) || '';
			const vertexShaderInfoLog = gl.getShaderInfoLog( glVertexShader ) || '';
			const fragmentShaderInfoLog = gl.getShaderInfoLog( glFragmentShader ) || '';

			const programLog = programInfoLog.trim();
			const vertexLog = vertexShaderInfoLog.trim();
			const fragmentLog = fragmentShaderInfoLog.trim();

			let runnable = true;
			let haveDiagnostics = true;

			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

				runnable = false;

				if ( typeof renderer.debug.onShaderError === 'function' ) {

					renderer.debug.onShaderError( gl, program, glVertexShader, glFragmentShader );

				} else {

					// default error reporting

					const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
					const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

					error(
						'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
						'VALIDATE_STATUS ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + '\n\n' +
						'Material Name: ' + self.name + '\n' +
						'Material Type: ' + self.type + '\n\n' +
						'Program Info Log: ' + programLog + '\n' +
						vertexErrors + '\n' +
						fragmentErrors
					);

				}

			} else if ( programLog !== '' ) {

				warn( 'WebGLProgram: Program Info Log:', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				self.diagnostics = {

					runnable: runnable,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

		}

		// Clean up

		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		cachedUniforms = new WebGLUniforms( gl, program );
		cachedAttributes = fetchAttributeLocations( gl, program );

	}

	// set up caching for uniform locations

	let cachedUniforms;

	this.getUniforms = function () {

		if ( cachedUniforms === undefined ) {

			// Populates cachedUniforms and cachedAttributes
			onFirstUse( this );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	let cachedAttributes;

	this.getAttributes = function () {

		if ( cachedAttributes === undefined ) {

			// Populates cachedAttributes and cachedUniforms
			onFirstUse( this );

		}

		return cachedAttributes;

	};

	// indicate when the program is ready to be used. if the KHR_parallel_shader_compile extension isn't supported,
	// flag the program as ready immediately. It may cause a stall when it's first used.

	let programReady = ( parameters.rendererExtensionParallelShaderCompile === false );

	this.isReady = function () {

		if ( programReady === false ) {

			programReady = gl.getProgramParameter( program, COMPLETION_STATUS_KHR );

		}

		return programReady;

	};

	// free resource

	this.destroy = function () {

		bindingStates.releaseStatesOfProgram( this );

		gl.deleteProgram( program );
		this.program = undefined;

	};

	//

	this.type = parameters.shaderType;
	this.name = parameters.shaderName;
	this.id = programIdCount ++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

let _id = 0;

class WebGLShaderCache {

	constructor() {

		this.shaderCache = new Map();
		this.materialCache = new Map();

	}

	update( material ) {

		const vertexShader = material.vertexShader;
		const fragmentShader = material.fragmentShader;

		const vertexShaderStage = this._getShaderStage( vertexShader );
		const fragmentShaderStage = this._getShaderStage( fragmentShader );

		const materialShaders = this._getShaderCacheForMaterial( material );

		if ( materialShaders.has( vertexShaderStage ) === false ) {

			materialShaders.add( vertexShaderStage );
			vertexShaderStage.usedTimes ++;

		}

		if ( materialShaders.has( fragmentShaderStage ) === false ) {

			materialShaders.add( fragmentShaderStage );
			fragmentShaderStage.usedTimes ++;

		}

		return this;

	}

	remove( material ) {

		const materialShaders = this.materialCache.get( material );

		for ( const shaderStage of materialShaders ) {

			shaderStage.usedTimes --;

			if ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );

		}

		this.materialCache.delete( material );

		return this;

	}

	getVertexShaderID( material ) {

		return this._getShaderStage( material.vertexShader ).id;

	}

	getFragmentShaderID( material ) {

		return this._getShaderStage( material.fragmentShader ).id;

	}

	dispose() {

		this.shaderCache.clear();
		this.materialCache.clear();

	}

	_getShaderCacheForMaterial( material ) {

		const cache = this.materialCache;
		let set = cache.get( material );

		if ( set === undefined ) {

			set = new Set();
			cache.set( material, set );

		}

		return set;

	}

	_getShaderStage( code ) {

		const cache = this.shaderCache;
		let stage = cache.get( code );

		if ( stage === undefined ) {

			stage = new WebGLShaderStage( code );
			cache.set( code, stage );

		}

		return stage;

	}

}

class WebGLShaderStage {

	constructor( code ) {

		this.id = _id ++;

		this.code = code;
		this.usedTimes = 0;

	}

}

function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {

	const _programLayers = new Layers();
	const _customShaders = new WebGLShaderCache();
	const _activeChannels = new Set();
	const programs = [];

	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;

	let precision = capabilities.precision;

	const shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};

	function getChannel( value ) {

		_activeChannels.add( value );

		if ( value === 0 ) return 'uv';

		return `uv${ value }`;

	}

	function getParameters( material, lights, shadows, scene, object ) {

		const fog = scene.fog;
		const geometry = object.geometry;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;

		const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
		const envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;

		const shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				warn( 'WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		//

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

		let morphTextureStride = 0;

		if ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;
		if ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;
		if ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;

		//

		let vertexShader, fragmentShader;
		let customVertexShaderID, customFragmentShaderID;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];

			vertexShader = shader.vertexShader;
			fragmentShader = shader.fragmentShader;

		} else {

			vertexShader = material.vertexShader;
			fragmentShader = material.fragmentShader;

			_customShaders.update( material );

			customVertexShaderID = _customShaders.getVertexShaderID( material );
			customFragmentShaderID = _customShaders.getFragmentShaderID( material );

		}

		const currentRenderTarget = renderer.getRenderTarget();
		const reversedDepthBuffer = renderer.state.buffers.depth.getReversed();

		const IS_INSTANCEDMESH = object.isInstancedMesh === true;
		const IS_BATCHEDMESH = object.isBatchedMesh === true;

		const HAS_MAP = !! material.map;
		const HAS_MATCAP = !! material.matcap;
		const HAS_ENVMAP = !! envMap;
		const HAS_AOMAP = !! material.aoMap;
		const HAS_LIGHTMAP = !! material.lightMap;
		const HAS_BUMPMAP = !! material.bumpMap;
		const HAS_NORMALMAP = !! material.normalMap;
		const HAS_DISPLACEMENTMAP = !! material.displacementMap;
		const HAS_EMISSIVEMAP = !! material.emissiveMap;

		const HAS_METALNESSMAP = !! material.metalnessMap;
		const HAS_ROUGHNESSMAP = !! material.roughnessMap;

		const HAS_ANISOTROPY = material.anisotropy > 0;
		const HAS_CLEARCOAT = material.clearcoat > 0;
		const HAS_DISPERSION = material.dispersion > 0;
		const HAS_IRIDESCENCE = material.iridescence > 0;
		const HAS_SHEEN = material.sheen > 0;
		const HAS_TRANSMISSION = material.transmission > 0;

		const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !! material.anisotropyMap;

		const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !! material.clearcoatMap;
		const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !! material.clearcoatNormalMap;
		const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !! material.clearcoatRoughnessMap;

		const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !! material.iridescenceMap;
		const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !! material.iridescenceThicknessMap;

		const HAS_SHEEN_COLORMAP = HAS_SHEEN && !! material.sheenColorMap;
		const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !! material.sheenRoughnessMap;

		const HAS_SPECULARMAP = !! material.specularMap;
		const HAS_SPECULAR_COLORMAP = !! material.specularColorMap;
		const HAS_SPECULAR_INTENSITYMAP = !! material.specularIntensityMap;

		const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !! material.transmissionMap;
		const HAS_THICKNESSMAP = HAS_TRANSMISSION && !! material.thicknessMap;

		const HAS_GRADIENTMAP = !! material.gradientMap;

		const HAS_ALPHAMAP = !! material.alphaMap;

		const HAS_ALPHATEST = material.alphaTest > 0;

		const HAS_ALPHAHASH = !! material.alphaHash;

		const HAS_EXTENSIONS = !! material.extensions;

		let toneMapping = NoToneMapping;

		if ( material.toneMapped ) {

			if ( currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true ) {

				toneMapping = renderer.toneMapping;

			}

		}

		const parameters = {

			shaderID: shaderID,
			shaderType: material.type,
			shaderName: material.name,

			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			defines: material.defines,

			customVertexShaderID: customVertexShaderID,
			customFragmentShaderID: customFragmentShaderID,

			isRawShaderMaterial: material.isRawShaderMaterial === true,
			glslVersion: material.glslVersion,

			precision: precision,

			batching: IS_BATCHEDMESH,
			batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
			instancing: IS_INSTANCEDMESH,
			instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
			instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,

			supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
			outputColorSpace: ( currentRenderTarget === null ) ? renderer.outputColorSpace : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace ),
			alphaToCoverage: !! material.alphaToCoverage,

			map: HAS_MAP,
			matcap: HAS_MATCAP,
			envMap: HAS_ENVMAP,
			envMapMode: HAS_ENVMAP && envMap.mapping,
			envMapCubeUVHeight: envMapCubeUVHeight,
			aoMap: HAS_AOMAP,
			lightMap: HAS_LIGHTMAP,
			bumpMap: HAS_BUMPMAP,
			normalMap: HAS_NORMALMAP,
			displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
			emissiveMap: HAS_EMISSIVEMAP,

			normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
			normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,

			metalnessMap: HAS_METALNESSMAP,
			roughnessMap: HAS_ROUGHNESSMAP,

			anisotropy: HAS_ANISOTROPY,
			anisotropyMap: HAS_ANISOTROPYMAP,

			clearcoat: HAS_CLEARCOAT,
			clearcoatMap: HAS_CLEARCOATMAP,
			clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
			clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,

			dispersion: HAS_DISPERSION,

			iridescence: HAS_IRIDESCENCE,
			iridescenceMap: HAS_IRIDESCENCEMAP,
			iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,

			sheen: HAS_SHEEN,
			sheenColorMap: HAS_SHEEN_COLORMAP,
			sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,

			specularMap: HAS_SPECULARMAP,
			specularColorMap: HAS_SPECULAR_COLORMAP,
			specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,

			transmission: HAS_TRANSMISSION,
			transmissionMap: HAS_TRANSMISSIONMAP,
			thicknessMap: HAS_THICKNESSMAP,

			gradientMap: HAS_GRADIENTMAP,

			opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,

			alphaMap: HAS_ALPHAMAP,
			alphaTest: HAS_ALPHATEST,
			alphaHash: HAS_ALPHAHASH,

			combine: material.combine,

			//

			mapUv: HAS_MAP && getChannel( material.map.channel ),
			aoMapUv: HAS_AOMAP && getChannel( material.aoMap.channel ),
			lightMapUv: HAS_LIGHTMAP && getChannel( material.lightMap.channel ),
			bumpMapUv: HAS_BUMPMAP && getChannel( material.bumpMap.channel ),
			normalMapUv: HAS_NORMALMAP && getChannel( material.normalMap.channel ),
			displacementMapUv: HAS_DISPLACEMENTMAP && getChannel( material.displacementMap.channel ),
			emissiveMapUv: HAS_EMISSIVEMAP && getChannel( material.emissiveMap.channel ),

			metalnessMapUv: HAS_METALNESSMAP && getChannel( material.metalnessMap.channel ),
			roughnessMapUv: HAS_ROUGHNESSMAP && getChannel( material.roughnessMap.channel ),

			anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel( material.anisotropyMap.channel ),

			clearcoatMapUv: HAS_CLEARCOATMAP && getChannel( material.clearcoatMap.channel ),
			clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel( material.clearcoatNormalMap.channel ),
			clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel( material.clearcoatRoughnessMap.channel ),

			iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel( material.iridescenceMap.channel ),
			iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel( material.iridescenceThicknessMap.channel ),

			sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel( material.sheenColorMap.channel ),
			sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel( material.sheenRoughnessMap.channel ),

			specularMapUv: HAS_SPECULARMAP && getChannel( material.specularMap.channel ),
			specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel( material.specularColorMap.channel ),
			specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel( material.specularIntensityMap.channel ),

			transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel( material.transmissionMap.channel ),
			thicknessMapUv: HAS_THICKNESSMAP && getChannel( material.thicknessMap.channel ),

			alphaMapUv: HAS_ALPHAMAP && getChannel( material.alphaMap.channel ),

			//

			vertexTangents: !! geometry.attributes.tangent && ( HAS_NORMALMAP || HAS_ANISOTROPY ),
			vertexColors: material.vertexColors,
			vertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,

			pointsUvs: object.isPoints === true && !! geometry.attributes.uv && ( HAS_MAP || HAS_ALPHAMAP ),

			fog: !! fog,
			useFog: material.fog === true,
			fogExp2: ( !! fog && fog.isFogExp2 ),

			flatShading: ( material.flatShading === true && material.wireframe === false ),

			sizeAttenuation: material.sizeAttenuation === true,
			logarithmicDepthBuffer: logarithmicDepthBuffer,
			reversedDepthBuffer: reversedDepthBuffer,

			skinning: object.isSkinnedMesh === true,

			morphTargets: geometry.morphAttributes.position !== undefined,
			morphNormals: geometry.morphAttributes.normal !== undefined,
			morphColors: geometry.morphAttributes.color !== undefined,
			morphTargetsCount: morphTargetsCount,
			morphTextureStride: morphTextureStride,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numSpotLightMaps: lights.spotLightMap.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numDirLightShadows: lights.directionalShadowMap.length,
			numPointLightShadows: lights.pointShadowMap.length,
			numSpotLightShadows: lights.spotShadowMap.length,
			numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,

			numLightProbes: lights.numLightProbes,

			numClippingPlanes: clipping.numPlanes,
			numClipIntersection: clipping.numIntersection,

			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: toneMapping,

			decodeVideoTexture: HAS_MAP && ( material.map.isVideoTexture === true ) && ( ColorManagement.getTransfer( material.map.colorSpace ) === SRGBTransfer ),
			decodeVideoTextureEmissive: HAS_EMISSIVEMAP && ( material.emissiveMap.isVideoTexture === true ) && ( ColorManagement.getTransfer( material.emissiveMap.colorSpace ) === SRGBTransfer ),

			premultipliedAlpha: material.premultipliedAlpha,

			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			useDepthPacking: material.depthPacking >= 0,
			depthPacking: material.depthPacking || 0,

			index0AttributeName: material.index0AttributeName,

			extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has( 'WEBGL_clip_cull_distance' ),
			extensionMultiDraw: ( HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH ) && extensions.has( 'WEBGL_multi_draw' ),

			rendererExtensionParallelShaderCompile: extensions.has( 'KHR_parallel_shader_compile' ),

			customProgramCacheKey: material.customProgramCacheKey()

		};

		// the usage of getChannel() determines the active texture channels for this shader

		parameters.vertexUv1s = _activeChannels.has( 1 );
		parameters.vertexUv2s = _activeChannels.has( 2 );
		parameters.vertexUv3s = _activeChannels.has( 3 );

		_activeChannels.clear();

		return parameters;

	}

	function getProgramCacheKey( parameters ) {

		const array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( parameters.customVertexShaderID );
			array.push( parameters.customFragmentShaderID );

		}

		if ( parameters.defines !== undefined ) {

			for ( const name in parameters.defines ) {

				array.push( name );
				array.push( parameters.defines[ name ] );

			}

		}

		if ( parameters.isRawShaderMaterial === false ) {

			getProgramCacheKeyParameters( array, parameters );
			getProgramCacheKeyBooleans( array, parameters );
			array.push( renderer.outputColorSpace );

		}

		array.push( parameters.customProgramCacheKey );

		return array.join();

	}

	function getProgramCacheKeyParameters( array, parameters ) {

		array.push( parameters.precision );
		array.push( parameters.outputColorSpace );
		array.push( parameters.envMapMode );
		array.push( parameters.envMapCubeUVHeight );
		array.push( parameters.mapUv );
		array.push( parameters.alphaMapUv );
		array.push( parameters.lightMapUv );
		array.push( parameters.aoMapUv );
		array.push( parameters.bumpMapUv );
		array.push( parameters.normalMapUv );
		array.push( parameters.displacementMapUv );
		array.push( parameters.emissiveMapUv );
		array.push( parameters.metalnessMapUv );
		array.push( parameters.roughnessMapUv );
		array.push( parameters.anisotropyMapUv );
		array.push( parameters.clearcoatMapUv );
		array.push( parameters.clearcoatNormalMapUv );
		array.push( parameters.clearcoatRoughnessMapUv );
		array.push( parameters.iridescenceMapUv );
		array.push( parameters.iridescenceThicknessMapUv );
		array.push( parameters.sheenColorMapUv );
		array.push( parameters.sheenRoughnessMapUv );
		array.push( parameters.specularMapUv );
		array.push( parameters.specularColorMapUv );
		array.push( parameters.specularIntensityMapUv );
		array.push( parameters.transmissionMapUv );
		array.push( parameters.thicknessMapUv );
		array.push( parameters.combine );
		array.push( parameters.fogExp2 );
		array.push( parameters.sizeAttenuation );
		array.push( parameters.morphTargetsCount );
		array.push( parameters.morphAttributeCount );
		array.push( parameters.numDirLights );
		array.push( parameters.numPointLights );
		array.push( parameters.numSpotLights );
		array.push( parameters.numSpotLightMaps );
		array.push( parameters.numHemiLights );
		array.push( parameters.numRectAreaLights );
		array.push( parameters.numDirLightShadows );
		array.push( parameters.numPointLightShadows );
		array.push( parameters.numSpotLightShadows );
		array.push( parameters.numSpotLightShadowsWithMaps );
		array.push( parameters.numLightProbes );
		array.push( parameters.shadowMapType );
		array.push( parameters.toneMapping );
		array.push( parameters.numClippingPlanes );
		array.push( parameters.numClipIntersection );
		array.push( parameters.depthPacking );

	}

	function getProgramCacheKeyBooleans( array, parameters ) {

		_programLayers.disableAll();

		if ( parameters.supportsVertexTextures )
			_programLayers.enable( 0 );
		if ( parameters.instancing )
			_programLayers.enable( 1 );
		if ( parameters.instancingColor )
			_programLayers.enable( 2 );
		if ( parameters.instancingMorph )
			_programLayers.enable( 3 );
		if ( parameters.matcap )
			_programLayers.enable( 4 );
		if ( parameters.envMap )
			_programLayers.enable( 5 );
		if ( parameters.normalMapObjectSpace )
			_programLayers.enable( 6 );
		if ( parameters.normalMapTangentSpace )
			_programLayers.enable( 7 );
		if ( parameters.clearcoat )
			_programLayers.enable( 8 );
		if ( parameters.iridescence )
			_programLayers.enable( 9 );
		if ( parameters.alphaTest )
			_programLayers.enable( 10 );
		if ( parameters.vertexColors )
			_programLayers.enable( 11 );
		if ( parameters.vertexAlphas )
			_programLayers.enable( 12 );
		if ( parameters.vertexUv1s )
			_programLayers.enable( 13 );
		if ( parameters.vertexUv2s )
			_programLayers.enable( 14 );
		if ( parameters.vertexUv3s )
			_programLayers.enable( 15 );
		if ( parameters.vertexTangents )
			_programLayers.enable( 16 );
		if ( parameters.anisotropy )
			_programLayers.enable( 17 );
		if ( parameters.alphaHash )
			_programLayers.enable( 18 );
		if ( parameters.batching )
			_programLayers.enable( 19 );
		if ( parameters.dispersion )
			_programLayers.enable( 20 );
		if ( parameters.batchingColor )
			_programLayers.enable( 21 );
		if ( parameters.gradientMap )
			_programLayers.enable( 22 );

		array.push( _programLayers.mask );
		_programLayers.disableAll();

		if ( parameters.fog )
			_programLayers.enable( 0 );
		if ( parameters.useFog )
			_programLayers.enable( 1 );
		if ( parameters.flatShading )
			_programLayers.enable( 2 );
		if ( parameters.logarithmicDepthBuffer )
			_programLayers.enable( 3 );
		if ( parameters.reversedDepthBuffer )
			_programLayers.enable( 4 );
		if ( parameters.skinning )
			_programLayers.enable( 5 );
		if ( parameters.morphTargets )
			_programLayers.enable( 6 );
		if ( parameters.morphNormals )
			_programLayers.enable( 7 );
		if ( parameters.morphColors )
			_programLayers.enable( 8 );
		if ( parameters.premultipliedAlpha )
			_programLayers.enable( 9 );
		if ( parameters.shadowMapEnabled )
			_programLayers.enable( 10 );
		if ( parameters.doubleSided )
			_programLayers.enable( 11 );
		if ( parameters.flipSided )
			_programLayers.enable( 12 );
		if ( parameters.useDepthPacking )
			_programLayers.enable( 13 );
		if ( parameters.dithering )
			_programLayers.enable( 14 );
		if ( parameters.transmission )
			_programLayers.enable( 15 );
		if ( parameters.sheen )
			_programLayers.enable( 16 );
		if ( parameters.opaque )
			_programLayers.enable( 17 );
		if ( parameters.pointsUvs )
			_programLayers.enable( 18 );
		if ( parameters.decodeVideoTexture )
			_programLayers.enable( 19 );
		if ( parameters.decodeVideoTextureEmissive )
			_programLayers.enable( 20 );
		if ( parameters.alphaToCoverage )
			_programLayers.enable( 21 );

		array.push( _programLayers.mask );

	}

	function getUniforms( material ) {

		const shaderID = shaderIDs[ material.type ];
		let uniforms;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];
			uniforms = UniformsUtils.clone( shader.uniforms );

		} else {

			uniforms = material.uniforms;

		}

		return uniforms;

	}

	function acquireProgram( parameters, cacheKey ) {

		let program;

		// Check if code has been already compiled
		for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

			const preexistingProgram = programs[ p ];

			if ( preexistingProgram.cacheKey === cacheKey ) {

				program = preexistingProgram;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
			programs.push( program );

		}

		return program;

	}

	function releaseProgram( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			const i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	}

	function releaseShaderCache( material ) {

		_customShaders.remove( material );

	}

	function dispose() {

		_customShaders.dispose();

	}

	return {
		getParameters: getParameters,
		getProgramCacheKey: getProgramCacheKey,
		getUniforms: getUniforms,
		acquireProgram: acquireProgram,
		releaseProgram: releaseProgram,
		releaseShaderCache: releaseShaderCache,
		// Exposed for resource monitoring & error feedback via renderer.info:
		programs: programs,
		dispose: dispose
	};

}

function WebGLProperties() {

	let properties = new WeakMap();

	function has( object ) {

		return properties.has( object );

	}

	function get( object ) {

		let map = properties.get( object );

		if ( map === undefined ) {

			map = {};
			properties.set( object, map );

		}

		return map;

	}

	function remove( object ) {

		properties.delete( object );

	}

	function update( object, key, value ) {

		properties.get( object )[ key ] = value;

	}

	function dispose() {

		properties = new WeakMap();

	}

	return {
		has: has,
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};

}

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}


function WebGLRenderList() {

	const renderItems = [];
	let renderItemsIndex = 0;

	const opaque = [];
	const transmissive = [];
	const transparent = [];

	function init() {

		renderItemsIndex = 0;

		opaque.length = 0;
		transmissive.length = 0;
		transparent.length = 0;

	}

	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		let renderItem = renderItems[ renderItemsIndex ];

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			renderItems[ renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;

		}

		renderItemsIndex ++;

		return renderItem;

	}

	function push( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		if ( material.transmission > 0.0 ) {

			transmissive.push( renderItem );

		} else if ( material.transparent === true ) {

			transparent.push( renderItem );

		} else {

			opaque.push( renderItem );

		}

	}

	function unshift( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		if ( material.transmission > 0.0 ) {

			transmissive.unshift( renderItem );

		} else if ( material.transparent === true ) {

			transparent.unshift( renderItem );

		} else {

			opaque.unshift( renderItem );

		}

	}

	function sort( customOpaqueSort, customTransparentSort ) {

		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
		if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	function finish() {

		// Clear references from inactive renderItems in the list

		for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

			const renderItem = renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.group = null;

		}

	}

	return {

		opaque: opaque,
		transmissive: transmissive,
		transparent: transparent,

		init: init,
		push: push,
		unshift: unshift,
		finish: finish,

		sort: sort
	};

}

function WebGLRenderLists() {

	let lists = new WeakMap();

	function get( scene, renderCallDepth ) {

		const listArray = lists.get( scene );
		let list;

		if ( listArray === undefined ) {

			list = new WebGLRenderList();
			lists.set( scene, [ list ] );

		} else {

			if ( renderCallDepth >= listArray.length ) {

				list = new WebGLRenderList();
				listArray.push( list );

			} else {

				list = listArray[ renderCallDepth ];

			}

		}

		return list;

	}

	function dispose() {

		lists = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

function UniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

function ShadowUniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						shadowIntensity: 1,
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						shadowIntensity: 1,
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						shadowIntensity: 1,
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				// TODO (abelnation): set RectAreaLight shadow uniforms

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}



let nextVersion = 0;

function shadowCastingAndTexturingLightsFirst( lightA, lightB ) {

	return ( lightB.castShadow ? 2 : 0 ) - ( lightA.castShadow ? 2 : 0 ) + ( lightB.map ? 1 : 0 ) - ( lightA.map ? 1 : 0 );

}

function WebGLLights( extensions ) {

	const cache = new UniformsCache();

	const shadowCache = ShadowUniformsCache();

	const state = {

		version: 0,

		hash: {
			directionalLength: -1,
			pointLength: -1,
			spotLength: -1,
			rectAreaLength: -1,
			hemiLength: -1,

			numDirectionalShadows: -1,
			numPointShadows: -1,
			numSpotShadows: -1,
			numSpotMaps: -1,

			numLightProbes: -1
		},

		ambient: [ 0, 0, 0 ],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotLightMap: [],
		spotShadow: [],
		spotShadowMap: [],
		spotLightMatrix: [],
		rectArea: [],
		rectAreaLTC1: null,
		rectAreaLTC2: null,
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: [],
		numSpotLightShadowsWithMaps: 0,
		numLightProbes: 0

	};

	for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

	const vector3 = new Vector3();
	const matrix4 = new Matrix4();
	const matrix42 = new Matrix4();

	function setup( lights ) {

		let r = 0, g = 0, b = 0;

		for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		let numDirectionalShadows = 0;
		let numPointShadows = 0;
		let numSpotShadows = 0;
		let numSpotMaps = 0;
		let numSpotShadowsWithMaps = 0;

		let numLightProbes = 0;

		// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
		lights.sort( shadowCastingAndTexturingLightsFirst );

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			const color = light.color;
			const intensity = light.intensity;
			const distance = light.distance;

			const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity;
				g += color.g * intensity;
				b += color.b * intensity;

			} else if ( light.isLightProbe ) {

				for ( let j = 0; j < 9; j ++ ) {

					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

				}

				numLightProbes ++;

			} else if ( light.isDirectionalLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowIntensity = shadow.intensity;
					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.directionalShadow[ directionalLength ] = shadowUniforms;
					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

					numDirectionalShadows ++;

				}

				state.directional[ directionalLength ] = uniforms;

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );

				uniforms.color.copy( color ).multiplyScalar( intensity );
				uniforms.distance = distance;

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = light.decay;

				state.spot[ spotLength ] = uniforms;

				const shadow = light.shadow;

				if ( light.map ) {

					state.spotLightMap[ numSpotMaps ] = light.map;
					numSpotMaps ++;

					// make sure the lightMatrix is up to date
					// TODO : do it if required only
					shadow.updateMatrices( light );

					if ( light.castShadow ) numSpotShadowsWithMaps ++;

				}

				state.spotLightMatrix[ spotLength ] = shadow.matrix;

				if ( light.castShadow ) {

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowIntensity = shadow.intensity;
					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.spotShadow[ spotLength ] = shadowUniforms;
					state.spotShadowMap[ spotLength ] = shadowMap;

					numSpotShadows ++;

				}

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				state.rectArea[ rectAreaLength ] = uniforms;

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowIntensity = shadow.intensity;
					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					shadowUniforms.shadowCameraNear = shadow.camera.near;
					shadowUniforms.shadowCameraFar = shadow.camera.far;

					state.pointShadow[ pointLength ] = shadowUniforms;
					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

					numPointShadows ++;

				}

				state.point[ pointLength ] = uniforms;

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = cache.get( light );

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

				state.hemi[ hemiLength ] = uniforms;

				hemiLength ++;

			}

		}

		if ( rectAreaLength > 0 ) {

			if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

			} else {

				state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
				state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

			}

		}

		state.ambient[ 0 ] = r;
		state.ambient[ 1 ] = g;
		state.ambient[ 2 ] = b;

		const hash = state.hash;

		if ( hash.directionalLength !== directionalLength ||
			hash.pointLength !== pointLength ||
			hash.spotLength !== spotLength ||
			hash.rectAreaLength !== rectAreaLength ||
			hash.hemiLength !== hemiLength ||
			hash.numDirectionalShadows !== numDirectionalShadows ||
			hash.numPointShadows !== numPointShadows ||
			hash.numSpotShadows !== numSpotShadows ||
			hash.numSpotMaps !== numSpotMaps ||
			hash.numLightProbes !== numLightProbes ) {

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
			state.spotLightMap.length = numSpotMaps;
			state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
			state.numLightProbes = numLightProbes;

			hash.directionalLength = directionalLength;
			hash.pointLength = pointLength;
			hash.spotLength = spotLength;
			hash.rectAreaLength = rectAreaLength;
			hash.hemiLength = hemiLength;

			hash.numDirectionalShadows = numDirectionalShadows;
			hash.numPointShadows = numPointShadows;
			hash.numSpotShadows = numSpotShadows;
			hash.numSpotMaps = numSpotMaps;

			hash.numLightProbes = numLightProbes;

			state.version = nextVersion ++;

		}

	}

	function setupView( lights, camera ) {

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		const viewMatrix = camera.matrixWorldInverse;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			if ( light.isDirectionalLight ) {

				const uniforms = state.directional[ directionalLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = state.spot[ spotLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = state.rectArea[ rectAreaLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy( light.matrixWorld );
				matrix4.premultiply( viewMatrix );
				matrix42.extractRotation( matrix4 );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( matrix42 );
				uniforms.halfHeight.applyMatrix4( matrix42 );

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = state.point[ pointLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = state.hemi[ hemiLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );

				hemiLength ++;

			}

		}

	}

	return {
		setup: setup,
		setupView: setupView,
		state: state
	};

}

function WebGLRenderState( extensions ) {

	const lights = new WebGLLights( extensions );

	const lightsArray = [];
	const shadowsArray = [];

	function init( camera ) {

		state.camera = camera;

		lightsArray.length = 0;
		shadowsArray.length = 0;

	}

	function pushLight( light ) {

		lightsArray.push( light );

	}

	function pushShadow( shadowLight ) {

		shadowsArray.push( shadowLight );

	}

	function setupLights() {

		lights.setup( lightsArray );

	}

	function setupLightsView( camera ) {

		lights.setupView( lightsArray, camera );

	}

	const state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,

		camera: null,

		lights: lights,

		transmissionRenderTarget: {}
	};

	return {
		init: init,
		state: state,
		setupLights: setupLights,
		setupLightsView: setupLightsView,

		pushLight: pushLight,
		pushShadow: pushShadow
	};

}

function WebGLRenderStates( extensions ) {

	let renderStates = new WeakMap();

	function get( scene, renderCallDepth = 0 ) {

		const renderStateArray = renderStates.get( scene );
		let renderState;

		if ( renderStateArray === undefined ) {

			renderState = new WebGLRenderState( extensions );
			renderStates.set( scene, [ renderState ] );

		} else {

			if ( renderCallDepth >= renderStateArray.length ) {

				renderState = new WebGLRenderState( extensions );
				renderStateArray.push( renderState );

			} else {

				renderState = renderStateArray[ renderCallDepth ];

			}

		}

		return renderState;

	}

	function dispose() {

		renderStates = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

function WebGLShadowMap( renderer, objects, capabilities ) {

	let _frustum = new Frustum();

	const _shadowMapSize = new Vector2(),
		_viewportSize = new Vector2(),

		_viewport = new Vector4(),

		_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),
		_distanceMaterial = new MeshDistanceMaterial(),

		_materialCache = {},

		_maxTextureSize = capabilities.maxTextureSize;

	const shadowSide = { [ FrontSide ]: BackSide, [ BackSide ]: FrontSide, [ DoubleSide ]: DoubleSide };

	const shadowMaterialVertical = new ShaderMaterial( {
		defines: {
			VSM_SAMPLES: 8
		},
		uniforms: {
			shadow_pass: { value: null },
			resolution: { value: new Vector2() },
			radius: { value: 4.0 }
		},

		vertexShader: vertex,
		fragmentShader: fragment

	} );

	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

	const fullScreenTri = new BufferGeometry();
	fullScreenTri.setAttribute(
		'position',
		new BufferAttribute(
			new Float32Array( [ -1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5 ] ),
			3
		)
	);

	const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

	const scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;
	let _previousType = this.type;

	this.render = function ( lights, scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( lights.length === 0 ) return;

		const currentRenderTarget = renderer.getRenderTarget();
		const activeCubeFace = renderer.getActiveCubeFace();
		const activeMipmapLevel = renderer.getActiveMipmapLevel();

		const _state = renderer.state;

		// Set GL state for depth map.
		_state.setBlending( NoBlending );

		if ( _state.buffers.depth.getReversed() === true ) {

			_state.buffers.color.setClear( 0, 0, 0, 0 );

		} else {

			_state.buffers.color.setClear( 1, 1, 1, 1 );

		}

		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );

		// check for shadow map type changes

		const toVSM = ( _previousType !== VSMShadowMap && this.type === VSMShadowMap );
		const fromVSM = ( _previousType === VSMShadowMap && this.type !== VSMShadowMap );

		// render depth map

		for ( let i = 0, il = lights.length; i < il; i ++ ) {

			const light = lights[ i ];
			const shadow = light.shadow;

			if ( shadow === undefined ) {

				warn( 'WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

			_shadowMapSize.copy( shadow.mapSize );

			const shadowFrameExtents = shadow.getFrameExtents();

			_shadowMapSize.multiply( shadowFrameExtents );

			_viewportSize.copy( shadow.mapSize );

			if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

				if ( _shadowMapSize.x > _maxTextureSize ) {

					_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;

				}

				if ( _shadowMapSize.y > _maxTextureSize ) {

					_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;

				}

			}

			if ( shadow.map === null || toVSM === true || fromVSM === true ) {

				const pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};

				if ( shadow.map !== null ) {

					shadow.map.dispose();

				}

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.camera.updateProjectionMatrix();

			}

			renderer.setRenderTarget( shadow.map );
			renderer.clear();

			const viewportCount = shadow.getViewportCount();

			for ( let vp = 0; vp < viewportCount; vp ++ ) {

				const viewport = shadow.getViewport( vp );

				_viewport.set(
					_viewportSize.x * viewport.x,
					_viewportSize.y * viewport.y,
					_viewportSize.x * viewport.z,
					_viewportSize.y * viewport.w
				);

				_state.viewport( _viewport );

				shadow.updateMatrices( light, vp );

				_frustum = shadow.getFrustum();

				renderObject( scene, camera, shadow.camera, light, this.type );

			}

			// do blur pass for VSM

			if ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {

				VSMPass( shadow, camera );

			}

			shadow.needsUpdate = false;

		}

		_previousType = this.type;

		scope.needsUpdate = false;

		renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

	};

	function VSMPass( shadow, camera ) {

		const geometry = objects.update( fullScreenMesh );

		if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {

			shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
			shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

			shadowMaterialVertical.needsUpdate = true;
			shadowMaterialHorizontal.needsUpdate = true;

		}

		if ( shadow.mapPass === null ) {

			shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );

		}

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		renderer.setRenderTarget( shadow.mapPass );
		renderer.clear();
		renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

		// horizontal pass

		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
		renderer.setRenderTarget( shadow.map );
		renderer.clear();
		renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

	}

	function getDepthMaterial( object, material, light, type ) {

		let result = null;

		const customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;

		if ( customMaterial !== undefined ) {

			result = customMaterial;

		} else {

			result = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;

			if ( ( renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||
				( material.displacementMap && material.displacementScale !== 0 ) ||
				( material.alphaMap && material.alphaTest > 0 ) ||
				( material.map && material.alphaTest > 0 ) ||
				( material.alphaToCoverage === true ) ) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				const keyA = result.uuid, keyB = material.uuid;

				let materialsForVariant = _materialCache[ keyA ];

				if ( materialsForVariant === undefined ) {

					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;

				}

				let cachedMaterial = materialsForVariant[ keyB ];

				if ( cachedMaterial === undefined ) {

					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;
					material.addEventListener( 'dispose', onMaterialDispose );

				}

				result = cachedMaterial;

			}

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		if ( type === VSMShadowMap ) {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

		} else {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

		}

		result.alphaMap = material.alphaMap;
		result.alphaTest = ( material.alphaToCoverage === true ) ? 0.5 : material.alphaTest; // approximate alphaToCoverage by using a fixed alphaTest value
		result.map = material.map;

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;

		result.displacementMap = material.displacementMap;
		result.displacementScale = material.displacementScale;
		result.displacementBias = material.displacementBias;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

			const materialProperties = renderer.properties.get( result );
			materialProperties.light = light;

		}

		return result;

	}

	function renderObject( object, camera, shadowCamera, light, type ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				const geometry = objects.update( object );
				const material = object.material;

				if ( Array.isArray( material ) ) {

					const groups = geometry.groups;

					for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

						const group = groups[ k ];
						const groupMaterial = material[ group.materialIndex ];

						if ( groupMaterial && groupMaterial.visible ) {

							const depthMaterial = getDepthMaterial( object, groupMaterial, light, type );

							object.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );

							renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							object.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );

						}

					}

				} else if ( material.visible ) {

					const depthMaterial = getDepthMaterial( object, material, light, type );

					object.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );

					renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					object.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			renderObject( children[ i ], camera, shadowCamera, light, type );

		}

	}

	function onMaterialDispose( event ) {

		const material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		// make sure to remove the unique distance/depth materials used for shadow map rendering

		for ( const id in _materialCache ) {

			const cache = _materialCache[ id ];

			const uuid = event.target.uuid;

			if ( uuid in cache ) {

				const shadowMaterial = cache[ uuid ];
				shadowMaterial.dispose();
				delete cache[ uuid ];

			}

		}

	}

}

const reversedFuncs = {
	[ NeverDepth ]: AlwaysDepth,
	[ LessDepth ]: GreaterDepth,
	[ EqualDepth ]: NotEqualDepth,
	[ LessEqualDepth ]: GreaterEqualDepth,

	[ AlwaysDepth ]: NeverDepth,
	[ GreaterDepth ]: LessDepth,
	[ NotEqualDepth ]: EqualDepth,
	[ GreaterEqualDepth ]: LessEqualDepth,
};

function WebGLState( gl, extensions ) {

	function ColorBuffer() {

		let locked = false;

		const color = new Vector4();
		let currentColorMask = null;
		const currentColorClear = new Vector4( 0, 0, 0, 0 );

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( -1, 0, 0, 0 ); // set to invalid state

			}

		};

	}

	function DepthBuffer() {

		let locked = false;

		let currentReversed = false;
		let currentDepthMask = null;
		let currentDepthFunc = null;
		let currentDepthClear = null;

		return {

			setReversed: function ( reversed ) {

				if ( currentReversed !== reversed ) {

					const ext = extensions.get( 'EXT_clip_control' );

					if ( reversed ) {

						ext.clipControlEXT( ext.LOWER_LEFT_EXT, ext.ZERO_TO_ONE_EXT );

					} else {

						ext.clipControlEXT( ext.LOWER_LEFT_EXT, ext.NEGATIVE_ONE_TO_ONE_EXT );

					}

					currentReversed = reversed;

					const oldDepth = currentDepthClear;
					currentDepthClear = null;
					this.setClear( oldDepth );

				}

			},

			getReversed: function () {

				return currentReversed;

			},

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( gl.DEPTH_TEST );

				} else {

					disable( gl.DEPTH_TEST );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentReversed ) depthFunc = reversedFuncs[ depthFunc ];

				if ( currentDepthFunc !== depthFunc ) {

					switch ( depthFunc ) {

						case NeverDepth:

							gl.depthFunc( gl.NEVER );
							break;

						case AlwaysDepth:

							gl.depthFunc( gl.ALWAYS );
							break;

						case LessDepth:

							gl.depthFunc( gl.LESS );
							break;

						case LessEqualDepth:

							gl.depthFunc( gl.LEQUAL );
							break;

						case EqualDepth:

							gl.depthFunc( gl.EQUAL );
							break;

						case GreaterEqualDepth:

							gl.depthFunc( gl.GEQUAL );
							break;

						case GreaterDepth:

							gl.depthFunc( gl.GREATER );
							break;

						case NotEqualDepth:

							gl.depthFunc( gl.NOTEQUAL );
							break;

						default:

							gl.depthFunc( gl.LEQUAL );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					if ( currentReversed ) {

						depth = 1 - depth;

					}

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;
				currentReversed = false;

			}

		};

	}

	function StencilBuffer() {

		let locked = false;

		let currentStencilMask = null;
		let currentStencilFunc = null;
		let currentStencilRef = null;
		let currentStencilFuncMask = null;
		let currentStencilFail = null;
		let currentStencilZFail = null;
		let currentStencilZPass = null;
		let currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( ! locked ) {

					if ( stencilTest ) {

						enable( gl.STENCIL_TEST );

					} else {

						disable( gl.STENCIL_TEST );

					}

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef !== stencilRef ||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail !== stencilFail ||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	const colorBuffer = new ColorBuffer();
	const depthBuffer = new DepthBuffer();
	const stencilBuffer = new StencilBuffer();

	const uboBindings = new WeakMap();
	const uboProgramMap = new WeakMap();

	let enabledCapabilities = {};

	let currentBoundFramebuffers = {};
	let currentDrawbuffers = new WeakMap();
	let defaultDrawbuffers = [];

	let currentProgram = null;

	let currentBlendingEnabled = false;
	let currentBlending = null;
	let currentBlendEquation = null;
	let currentBlendSrc = null;
	let currentBlendDst = null;
	let currentBlendEquationAlpha = null;
	let currentBlendSrcAlpha = null;
	let currentBlendDstAlpha = null;
	let currentBlendColor = new Color( 0, 0, 0 );
	let currentBlendAlpha = 0;
	let currentPremultipledAlpha = false;

	let currentFlipSided = null;
	let currentCullFace = null;

	let currentLineWidth = null;

	let currentPolygonOffsetFactor = null;
	let currentPolygonOffsetUnits = null;

	const maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

	let lineWidthAvailable = false;
	let version = 0;
	const glVersion = gl.getParameter( gl.VERSION );

	if ( glVersion.indexOf( 'WebGL' ) !== -1 ) {

		version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 1.0 );

	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== -1 ) {

		version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 2.0 );

	}

	let currentTextureSlot = null;
	let currentBoundTextures = {};

	const scissorParam = gl.getParameter( gl.SCISSOR_BOX );
	const viewportParam = gl.getParameter( gl.VIEWPORT );

	const currentScissor = new Vector4().fromArray( scissorParam );
	const currentViewport = new Vector4().fromArray( viewportParam );

	function createTexture( type, target, count, dimensions ) {

		const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		const texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

		for ( let i = 0; i < count; i ++ ) {

			if ( type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY ) {

				gl.texImage3D( target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

			} else {

				gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

			}

		}

		return texture;

	}

	const emptyTextures = {};
	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );
	emptyTextures[ gl.TEXTURE_2D_ARRAY ] = createTexture( gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1 );
	emptyTextures[ gl.TEXTURE_3D ] = createTexture( gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1 );

	// init

	colorBuffer.setClear( 0, 0, 0, 1 );
	depthBuffer.setClear( 1 );
	stencilBuffer.setClear( 0 );

	enable( gl.DEPTH_TEST );
	depthBuffer.setFunc( LessEqualDepth );

	setFlipSided( false );
	setCullFace( CullFaceBack );
	enable( gl.CULL_FACE );

	setBlending( NoBlending );

	//

	function enable( id ) {

		if ( enabledCapabilities[ id ] !== true ) {

			gl.enable( id );
			enabledCapabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( enabledCapabilities[ id ] !== false ) {

			gl.disable( id );
			enabledCapabilities[ id ] = false;

		}

	}

	function bindFramebuffer( target, framebuffer ) {

		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

			gl.bindFramebuffer( target, framebuffer );

			currentBoundFramebuffers[ target ] = framebuffer;

			// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

			if ( target === gl.DRAW_FRAMEBUFFER ) {

				currentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;

			}

			if ( target === gl.FRAMEBUFFER ) {

				currentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;

			}

			return true;

		}

		return false;

	}

	function drawBuffers( renderTarget, framebuffer ) {

		let drawBuffers = defaultDrawbuffers;

		let needsUpdate = false;

		if ( renderTarget ) {

			drawBuffers = currentDrawbuffers.get( framebuffer );

			if ( drawBuffers === undefined ) {

				drawBuffers = [];
				currentDrawbuffers.set( framebuffer, drawBuffers );

			}

			const textures = renderTarget.textures;

			if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {

				for ( let i = 0, il = textures.length; i < il; i ++ ) {

					drawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;

				}

				drawBuffers.length = textures.length;

				needsUpdate = true;

			}

		} else {

			if ( drawBuffers[ 0 ] !== gl.BACK ) {

				drawBuffers[ 0 ] = gl.BACK;

				needsUpdate = true;

			}

		}

		if ( needsUpdate ) {

			gl.drawBuffers( drawBuffers );

		}

	}

	function useProgram( program ) {

		if ( currentProgram !== program ) {

			gl.useProgram( program );

			currentProgram = program;

			return true;

		}

		return false;

	}

	const equationToGL = {
		[ AddEquation ]: gl.FUNC_ADD,
		[ SubtractEquation ]: gl.FUNC_SUBTRACT,
		[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT
	};

	equationToGL[ MinEquation ] = gl.MIN;
	equationToGL[ MaxEquation ] = gl.MAX;

	const factorToGL = {
		[ ZeroFactor ]: gl.ZERO,
		[ OneFactor ]: gl.ONE,
		[ SrcColorFactor ]: gl.SRC_COLOR,
		[ SrcAlphaFactor ]: gl.SRC_ALPHA,
		[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,
		[ DstColorFactor ]: gl.DST_COLOR,
		[ DstAlphaFactor ]: gl.DST_ALPHA,
		[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,
		[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,
		[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,
		[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA,
		[ ConstantColorFactor ]: gl.CONSTANT_COLOR,
		[ OneMinusConstantColorFactor ]: gl.ONE_MINUS_CONSTANT_COLOR,
		[ ConstantAlphaFactor ]: gl.CONSTANT_ALPHA,
		[ OneMinusConstantAlphaFactor ]: gl.ONE_MINUS_CONSTANT_ALPHA
	};

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha ) {

		if ( blending === NoBlending ) {

			if ( currentBlendingEnabled === true ) {

				disable( gl.BLEND );
				currentBlendingEnabled = false;

			}

			return;

		}

		if ( currentBlendingEnabled === false ) {

			enable( gl.BLEND );
			currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( gl.FUNC_ADD );

					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case AdditiveBlending:
							gl.blendFunc( gl.ONE, gl.ONE );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE );
							break;

						default:
							error( 'WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case AdditiveBlending:
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE );
							break;

						case SubtractiveBlending:
							error( 'WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true' );
							break;

						case MultiplyBlending:
							error( 'WebGLState: MultiplyBlending requires material.premultipliedAlpha = true' );
							break;

						default:
							error( 'WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;
				currentBlendColor.set( 0, 0, 0 );
				currentBlendAlpha = 0;

				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;

		}

		if ( blendColor.equals( currentBlendColor ) === false || blendAlpha !== currentBlendAlpha ) {

			gl.blendColor( blendColor.r, blendColor.g, blendColor.b, blendAlpha );

			currentBlendColor.copy( blendColor );
			currentBlendAlpha = blendAlpha;

		}

		currentBlending = blending;
		currentPremultipledAlpha = false;

	}

	function setMaterial( material, frontFaceCW ) {

		material.side === DoubleSide
			? disable( gl.CULL_FACE )
			: enable( gl.CULL_FACE );

		let flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) flipSided = ! flipSided;

		setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? setBlending( NoBlending )
			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha );

		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );

		const stencilWrite = material.stencilWrite;
		stencilBuffer.setTest( stencilWrite );
		if ( stencilWrite ) {

			stencilBuffer.setMask( material.stencilWriteMask );
			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		material.alphaToCoverage === true
			? enable( gl.SAMPLE_ALPHA_TO_COVERAGE )
			: disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( gl.CULL_FACE );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( gl.BACK );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( gl.FRONT );

				} else {

					gl.cullFace( gl.FRONT_AND_BACK );

				}

			}

		} else {

			disable( gl.CULL_FACE );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( gl.POLYGON_OFFSET_FILL );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( gl.POLYGON_OFFSET_FILL );

		}

	}

	function setScissorTest( scissorTest ) {

		if ( scissorTest ) {

			enable( gl.SCISSOR_TEST );

		} else {

			disable( gl.SCISSOR_TEST );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture, webglSlot ) {

		if ( webglSlot === undefined ) {

			if ( currentTextureSlot === null ) {

				webglSlot = gl.TEXTURE0 + maxTextures - 1;

			} else {

				webglSlot = currentTextureSlot;

			}

		}

		let boundTexture = currentBoundTextures[ webglSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ webglSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function unbindTexture() {

		const boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D( ...arguments );

		} catch ( error ) {

			error( 'WebGLState:', error );

		}

	}

	function compressedTexImage3D() {

		try {

			gl.compressedTexImage3D( ...arguments );

		} catch ( error ) {

			error( 'WebGLState:', error );

		}

	}

	function texSubImage2D() {

		try {

			gl.texSubImage2D( ...arguments );

		} catch ( error ) {

			error( 'WebGLState:', error );

		}

	}

	function texSubImage3D() {

		try {

			gl.texSubImage3D( ...arguments );

		} catch ( error ) {

			error( 'WebGLState:', error );

		}

	}

	function compressedTexSubImage2D() {

		try {

			gl.compressedTexSubImage2D( ...arguments );

		} catch ( error ) {

			error( 'WebGLState:', error );

		}

	}

	function compressedTexSubImage3D() {

		try {

			gl.compressedTexSubImage3D( ...arguments );

		} catch ( error ) {

			error( 'WebGLState:', error );

		}

	}

	function texStorage2D() {

		try {

			gl.texStorage2D( ...arguments );

		} catch ( error ) {

			error( 'WebGLState:', error );

		}

	}

	function texStorage3D() {

		try {

			gl.texStorage3D( ...arguments );

		} catch ( error ) {

			error( 'WebGLState:', error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D( ...arguments );

		} catch ( error ) {

			error( 'WebGLState:', error );

		}

	}

	function texImage3D() {

		try {

			gl.texImage3D( ...arguments );

		} catch ( error ) {

			error( 'WebGLState:', error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	function updateUBOMapping( uniformsGroup, program ) {

		let mapping = uboProgramMap.get( program );

		if ( mapping === undefined ) {

			mapping = new WeakMap();

			uboProgramMap.set( program, mapping );

		}

		let blockIndex = mapping.get( uniformsGroup );

		if ( blockIndex === undefined ) {

			blockIndex = gl.getUniformBlockIndex( program, uniformsGroup.name );

			mapping.set( uniformsGroup, blockIndex );

		}

	}

	function uniformBlockBinding( uniformsGroup, program ) {

		const mapping = uboProgramMap.get( program );
		const blockIndex = mapping.get( uniformsGroup );

		if ( uboBindings.get( program ) !== blockIndex ) {

			// bind shader specific block index to global block point
			gl.uniformBlockBinding( program, blockIndex, uniformsGroup.__bindingPointIndex );

			uboBindings.set( program, blockIndex );

		}

	}

	//

	function reset() {

		// reset state

		gl.disable( gl.BLEND );
		gl.disable( gl.CULL_FACE );
		gl.disable( gl.DEPTH_TEST );
		gl.disable( gl.POLYGON_OFFSET_FILL );
		gl.disable( gl.SCISSOR_TEST );
		gl.disable( gl.STENCIL_TEST );
		gl.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

		gl.blendEquation( gl.FUNC_ADD );
		gl.blendFunc( gl.ONE, gl.ZERO );
		gl.blendFuncSeparate( gl.ONE, gl.ZERO, gl.ONE, gl.ZERO );
		gl.blendColor( 0, 0, 0, 0 );

		gl.colorMask( true, true, true, true );
		gl.clearColor( 0, 0, 0, 0 );

		gl.depthMask( true );
		gl.depthFunc( gl.LESS );

		depthBuffer.setReversed( false );

		gl.clearDepth( 1 );

		gl.stencilMask( 0xffffffff );
		gl.stencilFunc( gl.ALWAYS, 0, 0xffffffff );
		gl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );
		gl.clearStencil( 0 );

		gl.cullFace( gl.BACK );
		gl.frontFace( gl.CCW );

		gl.polygonOffset( 0, 0 );

		gl.activeTexture( gl.TEXTURE0 );

		gl.bindFramebuffer( gl.FRAMEBUFFER, null );
		gl.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );
		gl.bindFramebuffer( gl.READ_FRAMEBUFFER, null );

		gl.useProgram( null );

		gl.lineWidth( 1 );

		gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
		gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

		// reset internals

		enabledCapabilities = {};

		currentTextureSlot = null;
		currentBoundTextures = {};

		currentBoundFramebuffers = {};
		currentDrawbuffers = new WeakMap();
		defaultDrawbuffers = [];

		currentProgram = null;

		currentBlendingEnabled = false;
		currentBlending = null;
		currentBlendEquation = null;
		currentBlendSrc = null;
		currentBlendDst = null;
		currentBlendEquationAlpha = null;
		currentBlendSrcAlpha = null;
		currentBlendDstAlpha = null;
		currentBlendColor = new Color( 0, 0, 0 );
		currentBlendAlpha = 0;
		currentPremultipledAlpha = false;

		currentFlipSided = null;
		currentCullFace = null;

		currentLineWidth = null;

		currentPolygonOffsetFactor = null;
		currentPolygonOffsetUnits = null;

		currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
		currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		enable: enable,
		disable: disable,

		bindFramebuffer: bindFramebuffer,
		drawBuffers: drawBuffers,

		useProgram: useProgram,

		setBlending: setBlending,
		setMaterial: setMaterial,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		unbindTexture: unbindTexture,
		compressedTexImage2D: compressedTexImage2D,
		compressedTexImage3D: compressedTexImage3D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,

		updateUBOMapping: updateUBOMapping,
		uniformBlockBinding: uniformBlockBinding,

		texStorage2D: texStorage2D,
		texStorage3D: texStorage3D,
		texSubImage2D: texSubImage2D,
		texSubImage3D: texSubImage3D,
		compressedTexSubImage2D: compressedTexSubImage2D,
		compressedTexSubImage3D: compressedTexSubImage3D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

	const multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;
	const supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );

	const _imageDimensions = new Vector2();
	const _videoTextures = new WeakMap();
	let _canvas;

	const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	let useOffscreenCanvas = false;

	try {

		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
			// eslint-disable-next-line compat/compat
			&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

	} catch ( err ) {

		// Ignore any errors

	}

	function createCanvas( width, height ) {

		// Use OffscreenCanvas when available. Specially needed in web workers

		return useOffscreenCanvas ?
			// eslint-disable-next-line compat/compat
			new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );

	}

	function resizeImage( image, needsNewCanvas, maxSize ) {

		let scale = 1;

		const dimensions = getDimensions( image );

		// handle case if texture exceeds max size

		if ( dimensions.width > maxSize || dimensions.height > maxSize ) {

			scale = maxSize / Math.max( dimensions.width, dimensions.height );

		}

		// only perform resize if necessary

		if ( scale < 1 ) {

			// only perform resize for certain image types

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||
				( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) ) {

				const width = Math.floor( scale * dimensions.width );
				const height = Math.floor( scale * dimensions.height );

				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

				// cube textures can't reuse the same canvas

				const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

				canvas.width = width;
				canvas.height = height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, width, height );

				warn( 'WebGLRenderer: Texture has been resized from (' + dimensions.width + 'x' + dimensions.height + ') to (' + width + 'x' + height + ').' );

				return canvas;

			} else {

				if ( 'data' in image ) {

					warn( 'WebGLRenderer: Image in DataTexture is too big (' + dimensions.width + 'x' + dimensions.height + ').' );

				}

				return image;

			}

		}

		return image;

	}

	function textureNeedsGenerateMipmaps( texture ) {

		return texture.generateMipmaps;

	}

	function generateMipmap( target ) {

		_gl.generateMipmap( target );

	}

	function getTargetType( texture ) {

		if ( texture.isWebGLCubeRenderTarget ) return _gl.TEXTURE_CUBE_MAP;
		if ( texture.isWebGL3DRenderTarget ) return _gl.TEXTURE_3D;
		if ( texture.isWebGLArrayRenderTarget || texture.isCompressedArrayTexture ) return _gl.TEXTURE_2D_ARRAY;
		return _gl.TEXTURE_2D;

	}

	function getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {

		if ( internalFormatName !== null ) {

			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			warn( 'WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		let internalFormat = glFormat;

		if ( glFormat === _gl.RED ) {

			if ( glType === _gl.FLOAT ) internalFormat = _gl.R32F;
			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.R16F;
			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8;

		}

		if ( glFormat === _gl.RED_INTEGER ) {

			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8UI;
			if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.R16UI;
			if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.R32UI;
			if ( glType === _gl.BYTE ) internalFormat = _gl.R8I;
			if ( glType === _gl.SHORT ) internalFormat = _gl.R16I;
			if ( glType === _gl.INT ) internalFormat = _gl.R32I;

		}

		if ( glFormat === _gl.RG ) {

			if ( glType === _gl.FLOAT ) internalFormat = _gl.RG32F;
			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RG16F;
			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8;

		}

		if ( glFormat === _gl.RG_INTEGER ) {

			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8UI;
			if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RG16UI;
			if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RG32UI;
			if ( glType === _gl.BYTE ) internalFormat = _gl.RG8I;
			if ( glType === _gl.SHORT ) internalFormat = _gl.RG16I;
			if ( glType === _gl.INT ) internalFormat = _gl.RG32I;

		}

		if ( glFormat === _gl.RGB_INTEGER ) {

			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RGB8UI;
			if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RGB16UI;
			if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RGB32UI;
			if ( glType === _gl.BYTE ) internalFormat = _gl.RGB8I;
			if ( glType === _gl.SHORT ) internalFormat = _gl.RGB16I;
			if ( glType === _gl.INT ) internalFormat = _gl.RGB32I;

		}

		if ( glFormat === _gl.RGBA_INTEGER ) {

			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RGBA8UI;
			if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RGBA16UI;
			if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RGBA32UI;
			if ( glType === _gl.BYTE ) internalFormat = _gl.RGBA8I;
			if ( glType === _gl.SHORT ) internalFormat = _gl.RGBA16I;
			if ( glType === _gl.INT ) internalFormat = _gl.RGBA32I;

		}

		if ( glFormat === _gl.RGB ) {

			if ( glType === _gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = _gl.RGB9_E5;
			if ( glType === _gl.UNSIGNED_INT_10F_11F_11F_REV ) internalFormat = _gl.R11F_G11F_B10F;

		}

		if ( glFormat === _gl.RGBA ) {

			const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer( colorSpace );

			if ( glType === _gl.FLOAT ) internalFormat = _gl.RGBA32F;
			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGBA16F;
			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = ( transfer === SRGBTransfer ) ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
			if ( glType === _gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = _gl.RGBA4;
			if ( glType === _gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = _gl.RGB5_A1;

		}

		if ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||
			internalFormat === _gl.RG16F || internalFormat === _gl.RG32F ||
			internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	function getInternalDepthFormat( useStencil, depthType ) {

		let glInternalFormat;
		if ( useStencil ) {

			if ( depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type ) {

				glInternalFormat = _gl.DEPTH24_STENCIL8;

			} else if ( depthType === FloatType ) {

				glInternalFormat = _gl.DEPTH32F_STENCIL8;

			} else if ( depthType === UnsignedShortType ) {

				glInternalFormat = _gl.DEPTH24_STENCIL8;
				warn( 'DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.' );

			}

		} else {

			if ( depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type ) {

				glInternalFormat = _gl.DEPTH_COMPONENT24;

			} else if ( depthType === FloatType ) {

				glInternalFormat = _gl.DEPTH_COMPONENT32F;

			} else if ( depthType === UnsignedShortType ) {

				glInternalFormat = _gl.DEPTH_COMPONENT16;

			}

		}

		return glInternalFormat;

	}

	function getMipLevels( texture, image ) {

		if ( textureNeedsGenerateMipmaps( texture ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {

			return Math.log2( Math.max( image.width, image.height ) ) + 1;

		} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {

			// user-defined mipmaps

			return texture.mipmaps.length;

		} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {

			return image.mipmaps.length;

		} else {

			// texture without mipmaps (only base level)

			return 1;

		}

	}

	//

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		if ( texture.isVideoTexture ) {

			_videoTextures.delete( texture );

		}

	}

	function onRenderTargetDispose( event ) {

		const renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

	}

	//

	function deallocateTexture( texture ) {

		const textureProperties = properties.get( texture );

		if ( textureProperties.__webglInit === undefined ) return;

		// check if it's necessary to remove the WebGLTexture object

		const source = texture.source;
		const webglTextures = _sources.get( source );

		if ( webglTextures ) {

			const webglTexture = webglTextures[ textureProperties.__cacheKey ];
			webglTexture.usedTimes --;

			// the WebGLTexture object is not used anymore, remove it

			if ( webglTexture.usedTimes === 0 ) {

				deleteTexture( texture );

			}

			// remove the weak map entry if no WebGLTexture uses the source anymore

			if ( Object.keys( webglTextures ).length === 0 ) {

				_sources.delete( source );

			}

		}

		properties.remove( texture );

	}

	function deleteTexture( texture ) {

		const textureProperties = properties.get( texture );
		_gl.deleteTexture( textureProperties.__webglTexture );

		const source = texture.source;
		const webglTextures = _sources.get( source );
		delete webglTextures[ textureProperties.__cacheKey ];

		info.memory.textures --;

	}

	function deallocateRenderTarget( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

			properties.remove( renderTarget.depthTexture );

		}

		if ( renderTarget.isWebGLCubeRenderTarget ) {

			for ( let i = 0; i < 6; i ++ ) {

				if ( Array.isArray( renderTargetProperties.__webglFramebuffer[ i ] ) ) {

					for ( let level = 0; level < renderTargetProperties.__webglFramebuffer[ i ].length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ][ level ] );

				} else {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );

				}

				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			if ( Array.isArray( renderTargetProperties.__webglFramebuffer ) ) {

				for ( let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ level ] );

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );

			}

			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );

			if ( renderTargetProperties.__webglColorRenderbuffer ) {

				for ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {

					if ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );

				}

			}

			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

		}

		const textures = renderTarget.textures;

		for ( let i = 0, il = textures.length; i < il; i ++ ) {

			const attachmentProperties = properties.get( textures[ i ] );

			if ( attachmentProperties.__webglTexture ) {

				_gl.deleteTexture( attachmentProperties.__webglTexture );

				info.memory.textures --;

			}

			properties.remove( textures[ i ] );

		}

		properties.remove( renderTarget );

	}

	//

	let textureUnits = 0;

	function resetTextureUnits() {

		textureUnits = 0;

	}

	function allocateTextureUnit() {

		const textureUnit = textureUnits;

		if ( textureUnit >= capabilities.maxTextures ) {

			warn( 'WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

		}

		textureUnits += 1;

		return textureUnit;

	}

	function getTextureCacheKey( texture ) {

		const array = [];

		array.push( texture.wrapS );
		array.push( texture.wrapT );
		array.push( texture.wrapR || 0 );
		array.push( texture.magFilter );
		array.push( texture.minFilter );
		array.push( texture.anisotropy );
		array.push( texture.internalFormat );
		array.push( texture.format );
		array.push( texture.type );
		array.push( texture.generateMipmaps );
		array.push( texture.premultiplyAlpha );
		array.push( texture.flipY );
		array.push( texture.unpackAlignment );
		array.push( texture.colorSpace );

		return array.join();

	}

	//

	function setTexture2D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.isVideoTexture ) updateVideoTexture( texture );

		if ( texture.isRenderTargetTexture === false && texture.isExternalTexture !== true && texture.version > 0 && textureProperties.__version !== texture.version ) {

			const image = texture.image;

			if ( image === null ) {

				warn( 'WebGLRenderer: Texture marked for update but no image data found.' );

			} else if ( image.complete === false ) {

				warn( 'WebGLRenderer: Texture marked for update but image is incomplete' );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		} else if ( texture.isExternalTexture ) {

			textureProperties.__webglTexture = texture.sourceTexture ? texture.sourceTexture : null;

		}

		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

	}

	function setTexture2DArray( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		} else if ( texture.isExternalTexture ) {

			textureProperties.__webglTexture = texture.sourceTexture ? texture.sourceTexture : null;

		}

		state.bindTexture( _gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

	}

	function setTexture3D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

	}

	function setTextureCube( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadCubeTexture( textureProperties, texture, slot );
			return;

		}

		state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

	}

	const wrappingToGL = {
		[ RepeatWrapping ]: _gl.REPEAT,
		[ ClampToEdgeWrapping ]: _gl.CLAMP_TO_EDGE,
		[ MirroredRepeatWrapping ]: _gl.MIRRORED_REPEAT
	};

	const filterToGL = {
		[ NearestFilter ]: _gl.NEAREST,
		[ NearestMipmapNearestFilter ]: _gl.NEAREST_MIPMAP_NEAREST,
		[ NearestMipmapLinearFilter ]: _gl.NEAREST_MIPMAP_LINEAR,

		[ LinearFilter ]: _gl.LINEAR,
		[ LinearMipmapNearestFilter ]: _gl.LINEAR_MIPMAP_NEAREST,
		[ LinearMipmapLinearFilter ]: _gl.LINEAR_MIPMAP_LINEAR
	};

	const compareToGL = {
		[ NeverCompare ]: _gl.NEVER,
		[ AlwaysCompare ]: _gl.ALWAYS,
		[ LessCompare ]: _gl.LESS,
		[ LessEqualCompare ]: _gl.LEQUAL,
		[ EqualCompare ]: _gl.EQUAL,
		[ GreaterEqualCompare ]: _gl.GEQUAL,
		[ GreaterCompare ]: _gl.GREATER,
		[ NotEqualCompare ]: _gl.NOTEQUAL
	};

	function setTextureParameters( textureType, texture ) {

		if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false &&
			( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||
			texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter ) ) {

			warn( 'WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.' );

		}

		_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
		_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

		if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

		}

		_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );
		_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[ texture.minFilter ] );

		if ( texture.compareFunction ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE );
			_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );

		}

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			if ( texture.magFilter === NearestFilter ) return;
			if ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;
			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );
				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function initTexture( textureProperties, texture ) {

		let forceUpload = false;

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

		}

		// create Source <-> WebGLTextures mapping if necessary

		const source = texture.source;
		let webglTextures = _sources.get( source );

		if ( webglTextures === undefined ) {

			webglTextures = {};
			_sources.set( source, webglTextures );

		}

		// check if there is already a WebGLTexture object for the given texture parameters

		const textureCacheKey = getTextureCacheKey( texture );

		if ( textureCacheKey !== textureProperties.__cacheKey ) {

			// if not, create a new instance of WebGLTexture

			if ( webglTextures[ textureCacheKey ] === undefined ) {

				// create new entry

				webglTextures[ textureCacheKey ] = {
					texture: _gl.createTexture(),
					usedTimes: 0
				};

				info.memory.textures ++;

				// when a new instance of WebGLTexture was created, a texture upload is required
				// even if the image contents are identical

				forceUpload = true;

			}

			webglTextures[ textureCacheKey ].usedTimes ++;

			// every time the texture cache key changes, it's necessary to check if an instance of
			// WebGLTexture can be deleted in order to avoid a memory leak.

			const webglTexture = webglTextures[ textureProperties.__cacheKey ];

			if ( webglTexture !== undefined ) {

				webglTextures[ textureProperties.__cacheKey ].usedTimes --;

				if ( webglTexture.usedTimes === 0 ) {

					deleteTexture( texture );

				}

			}

			// store references to cache key and WebGLTexture object

			textureProperties.__cacheKey = textureCacheKey;
			textureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;

		}

		return forceUpload;

	}

	function getRow( index, rowLength, componentStride ) {

		return Math.floor( Math.floor( index / componentStride ) / rowLength );

	}

	function updateTexture( texture, image, glFormat, glType ) {

		const componentStride = 4; // only RGBA supported

		const updateRanges = texture.updateRanges;

		if ( updateRanges.length === 0 ) {

			state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );

		} else {

			// Before applying update ranges, we merge any adjacent / overlapping
			// ranges to reduce load on `gl.texSubImage2D`. Empirically, this has led
			// to performance improvements for applications which make heavy use of
			// update ranges. Likely due to GPU command overhead.
			//
			// Note that to reduce garbage collection between frames, we merge the
			// update ranges in-place. This is safe because this method will clear the
			// update ranges once updated.

			updateRanges.sort( ( a, b ) => a.start - b.start );

			// To merge the update ranges in-place, we work from left to right in the
			// existing updateRanges array, merging ranges. This may result in a final
			// array which is smaller than the original. This index tracks the last
			// index representing a merged range, any data after this index can be
			// trimmed once the merge algorithm is completed.
			let mergeIndex = 0;

			for ( let i = 1; i < updateRanges.length; i ++ ) {

				const previousRange = updateRanges[ mergeIndex ];
				const range = updateRanges[ i ];

				// Only merge if in the same row and overlapping/adjacent
				const previousEnd = previousRange.start + previousRange.count;
				const currentRow = getRow( range.start, image.width, componentStride );
				const previousRow = getRow( previousRange.start, image.width, componentStride );

				// We add one here to merge adjacent ranges. This is safe because ranges
				// operate over positive integers.
				if (
					range.start <= previousEnd + 1 &&
					currentRow === previousRow &&
					getRow( range.start + range.count - 1, image.width, componentStride ) === currentRow // ensure range doesn't spill
				) {

					previousRange.count = Math.max(
						previousRange.count,
						range.start + range.count - previousRange.start
					);

				} else {

					++ mergeIndex;
					updateRanges[ mergeIndex ] = range;

				}


			}

			// Trim the array to only contain the merged ranges.
			updateRanges.length = mergeIndex + 1;

			const currentUnpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );
			const currentUnpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );
			const currentUnpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );

			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );

			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

				const range = updateRanges[ i ];

				const pixelStart = Math.floor( range.start / componentStride );
				const pixelCount = Math.ceil( range.count / componentStride );

				const x = pixelStart % image.width;
				const y = Math.floor( pixelStart / image.width );

				// Assumes update ranges refer to contiguous memory
				const width = pixelCount;
				const height = 1;

				_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, x );
				_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, y );

				state.texSubImage2D( _gl.TEXTURE_2D, 0, x, y, width, height, glFormat, glType, image.data );

			}

			texture.clearUpdateRanges();

			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );
			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );
			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		let textureType = _gl.TEXTURE_2D;

		if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) textureType = _gl.TEXTURE_2D_ARRAY;
		if ( texture.isData3DTexture ) textureType = _gl.TEXTURE_3D;

		const forceUpload = initTexture( textureProperties, texture );
		const source = texture.source;

		state.bindTexture( textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		const sourceProperties = properties.get( source );

		if ( source.version !== sourceProperties.__version || forceUpload === true ) {

			state.activeTexture( _gl.TEXTURE0 + slot );

			const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
			const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );
			const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
			_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );

			let image = resizeImage( texture.image, false, capabilities.maxTextureSize );
			image = verifyColorSpace( texture, image );

			const glFormat = utils.convert( texture.format, texture.colorSpace );

			const glType = utils.convert( texture.type );
			let glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );

			setTextureParameters( textureType, texture );

			let mipmap;
			const mipmaps = texture.mipmaps;

			const useTexStorage = ( texture.isVideoTexture !== true );
			const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
			const dataReady = source.dataReady;
			const levels = getMipLevels( texture, image );

			if ( texture.isDepthTexture ) {

				glInternalFormat = getInternalDepthFormat( texture.format === DepthStencilFormat, texture.type );

				//

				if ( allocateMemory ) {

					if ( useTexStorage ) {

						state.texStorage2D( _gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height );

					} else {

						state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

					}

				}

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( useTexStorage ) {

							if ( dataReady ) {

								state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

					texture.generateMipmaps = false;

				} else {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

						}

						if ( dataReady ) {

							updateTexture( texture, image, glFormat, glType );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );

					}

				}

			} else if ( texture.isCompressedTexture ) {

				if ( texture.isCompressedArrayTexture ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height, image.depth );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									if ( dataReady ) {

										if ( texture.layerUpdates.size > 0 ) {

											const layerByteLength = getByteLength( mipmap.width, mipmap.height, texture.format, texture.type );

											for ( const layerIndex of texture.layerUpdates ) {

												const layerData = mipmap.data.subarray(
													layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT,
													( layerIndex + 1 ) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT
												);
												state.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData );

											}

											texture.clearLayerUpdates();

										} else {

											state.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data );

										}

									}

								} else {

									state.compressedTexImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0 );

								}

							} else {

								warn( 'WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

							}

						} else {

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );

								}

							} else {

								state.texImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				} else {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									if ( dataReady ) {

										state.compressedTexSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

									}

								} else {

									state.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								}

							} else {

								warn( 'WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

							}

						} else {

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

			} else if ( texture.isDataArrayTexture ) {

				if ( useTexStorage ) {

					if ( allocateMemory ) {

						state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth );

					}

					if ( dataReady ) {

						if ( texture.layerUpdates.size > 0 ) {

							const layerByteLength = getByteLength( image.width, image.height, texture.format, texture.type );

							for ( const layerIndex of texture.layerUpdates ) {

								const layerData = image.data.subarray(
									layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT,
									( layerIndex + 1 ) * layerByteLength / image.data.BYTES_PER_ELEMENT
								);
								state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData );

							}

							texture.clearLayerUpdates();

						} else {

							state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

						}

					}

				} else {

					state.texImage3D( _gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

				}

			} else if ( texture.isData3DTexture ) {

				if ( useTexStorage ) {

					if ( allocateMemory ) {

						state.texStorage3D( _gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth );

					}

					if ( dataReady ) {

						state.texSubImage3D( _gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

					}

				} else {

					state.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

				}

			} else if ( texture.isFramebufferTexture ) {

				if ( allocateMemory ) {

					if ( useTexStorage ) {

						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

					} else {

						let width = image.width, height = image.height;

						for ( let i = 0; i < levels; i ++ ) {

							state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null );

							width >>= 1;
							height >>= 1;

						}

					}

				}

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 ) {

					if ( useTexStorage && allocateMemory ) {

						const dimensions = getDimensions( mipmaps[ 0 ] );

						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( useTexStorage ) {

							if ( dataReady ) {

								state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );

						}

					}

					texture.generateMipmaps = false;

				} else {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							const dimensions = getDimensions( image );

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );

						}

						if ( dataReady ) {

							state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );

					}

				}

			}

			if ( textureNeedsGenerateMipmaps( texture ) ) {

				generateMipmap( textureType );

			}

			sourceProperties.__version = source.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		textureProperties.__version = texture.version;

	}

	function uploadCubeTexture( textureProperties, texture, slot ) {

		if ( texture.image.length !== 6 ) return;

		const forceUpload = initTexture( textureProperties, texture );
		const source = texture.source;

		state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		const sourceProperties = properties.get( source );

		if ( source.version !== sourceProperties.__version || forceUpload === true ) {

			state.activeTexture( _gl.TEXTURE0 + slot );

			const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
			const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );
			const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
			_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );

			const isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );
			const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

			const cubeImage = [];

			for ( let i = 0; i < 6; i ++ ) {

				if ( ! isCompressed && ! isDataTexture ) {

					cubeImage[ i ] = resizeImage( texture.image[ i ], true, capabilities.maxCubemapSize );

				} else {

					cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

				}

				cubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );

			}

			const image = cubeImage[ 0 ],
				glFormat = utils.convert( texture.format, texture.colorSpace ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );

			const useTexStorage = ( texture.isVideoTexture !== true );
			const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
			const dataReady = source.dataReady;
			let levels = getMipLevels( texture, image );

			setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );

			let mipmaps;

			if ( isCompressed ) {

				if ( useTexStorage && allocateMemory ) {

					state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height );

				}

				for ( let i = 0; i < 6; i ++ ) {

					mipmaps = cubeImage[ i ].mipmaps;

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									if ( dataReady ) {

										state.compressedTexSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

									}

								} else {

									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								}

							} else {

								warn( 'WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

							}

						} else {

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

			} else {

				mipmaps = texture.mipmaps;

				if ( useTexStorage && allocateMemory ) {

					// TODO: Uniformly handle mipmap definitions
					// Normal textures and compressed cube textures define base level + mips with their mipmap array
					// Uncompressed cube textures use their mipmap array only for mips (no base level)

					if ( mipmaps.length > 0 ) levels ++;

					const dimensions = getDimensions( cubeImage[ 0 ] );

					state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height );

				}

				for ( let i = 0; i < 6; i ++ ) {

					if ( isDataTexture ) {

						if ( useTexStorage ) {

							if ( dataReady ) {

								state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						}

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];
							const mipmapImage = mipmap.image[ i ].image;

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

							}

						}

					} else {

						if ( useTexStorage ) {

							if ( dataReady ) {

								state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

						}

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];

							if ( useTexStorage ) {

								if ( dataReady ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

							}

						}

					}

				}

			}

			if ( textureNeedsGenerateMipmaps( texture ) ) {

				// We assume images for cube map have the same size.
				generateMipmap( _gl.TEXTURE_CUBE_MAP );

			}

			sourceProperties.__version = source.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		textureProperties.__version = texture.version;

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget, level ) {

		const glFormat = utils.convert( texture.format, texture.colorSpace );
		const glType = utils.convert( texture.type );
		const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		textureProperties.__renderTarget = renderTarget;

		if ( ! renderTargetProperties.__hasExternalTextures ) {

			const width = Math.max( 1, renderTarget.width >> level );
			const height = Math.max( 1, renderTarget.height >> level );

			if ( textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ) {

				state.texImage3D( textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null );

			} else {

				state.texImage2D( textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null );

			}

		}

		state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

		if ( useMultisampledRTT( renderTarget ) ) {

			multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, 0, getRenderTargetSamples( renderTarget ) );

		} else if ( textureTarget === _gl.TEXTURE_2D || ( textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z ) ) { // see #24753

			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, level );

		}

		state.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer ) {

			// retrieve the depth attachment types
			const depthTexture = renderTarget.depthTexture;
			const depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
			const glInternalFormat = getInternalDepthFormat( renderTarget.stencilBuffer, depthType );
			const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;

			// set up the attachment
			const samples = getRenderTargetSamples( renderTarget );
			const isUseMultisampledRTT = useMultisampledRTT( renderTarget );
			if ( isUseMultisampledRTT ) {

				multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else if ( isMultisample ) {

				_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

			}

			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer );

		} else {

			const textures = renderTarget.textures;

			for ( let i = 0; i < textures.length; i ++ ) {

				const texture = textures[ i ];

				const glFormat = utils.convert( texture.format, texture.colorSpace );
				const glType = utils.convert( texture.type );
				const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
				const samples = getRenderTargetSamples( renderTarget );

				if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			}

		}

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

		state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		}

		const textureProperties = properties.get( renderTarget.depthTexture );
		textureProperties.__renderTarget = renderTarget;

		// upload an empty depth texture with framebuffer size
		if ( ! textureProperties.__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {

			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;

		}

		setTexture2D( renderTarget.depthTexture, 0 );

		const webglDepthTexture = textureProperties.__webglTexture;
		const samples = getRenderTargetSamples( renderTarget );

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

			} else {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			}

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

			} else {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			}

		} else {

			throw new Error( 'Unknown depthTexture format' );

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );
		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

		// if the bound depth texture has changed
		if ( renderTargetProperties.__boundDepthTexture !== renderTarget.depthTexture ) {

			// fire the dispose event to get rid of stored state associated with the previously bound depth buffer
			const depthTexture = renderTarget.depthTexture;
			if ( renderTargetProperties.__depthDisposeCallback ) {

				renderTargetProperties.__depthDisposeCallback();

			}

			// set up dispose listeners to track when the currently attached buffer is implicitly unbound
			if ( depthTexture ) {

				const disposeEvent = () => {

					delete renderTargetProperties.__boundDepthTexture;
					delete renderTargetProperties.__depthDisposeCallback;
					depthTexture.removeEventListener( 'dispose', disposeEvent );

				};

				depthTexture.addEventListener( 'dispose', disposeEvent );
				renderTargetProperties.__depthDisposeCallback = disposeEvent;

			}

			renderTargetProperties.__boundDepthTexture = depthTexture;

		}

		if ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {

			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

			const mipmaps = renderTarget.texture.mipmaps;

			if ( mipmaps && mipmaps.length > 0 ) {

				setupDepthTexture( renderTargetProperties.__webglFramebuffer[ 0 ], renderTarget );

			} else {

				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

			}

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );

					if ( renderTargetProperties.__webglDepthbuffer[ i ] === undefined ) {

						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

					} else {

						// attach buffer if it's been created already
						const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
						const renderbuffer = renderTargetProperties.__webglDepthbuffer[ i ];
						_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer );

					}

				}

			} else {

				const mipmaps = renderTarget.texture.mipmaps;

				if ( mipmaps && mipmaps.length > 0 ) {

					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ 0 ] );

				} else {

					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

				}

				if ( renderTargetProperties.__webglDepthbuffer === undefined ) {

					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

				} else {

					// attach buffer if it's been created already
					const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
					const renderbuffer = renderTargetProperties.__webglDepthbuffer;
					_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer );

				}

			}

		}

		state.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// rebind framebuffer with external textures
	function rebindTextures( renderTarget, colorTexture, depthTexture ) {

		const renderTargetProperties = properties.get( renderTarget );

		if ( colorTexture !== undefined ) {

			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0 );

		}

		if ( depthTexture !== undefined ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		const textures = renderTarget.textures;

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
		const isMultipleRenderTargets = ( textures.length > 1 );

		if ( ! isMultipleRenderTargets ) {

			if ( textureProperties.__webglTexture === undefined ) {

				textureProperties.__webglTexture = _gl.createTexture();

			}

			textureProperties.__version = texture.version;
			info.memory.textures ++;

		}

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( let i = 0; i < 6; i ++ ) {

				if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

					renderTargetProperties.__webglFramebuffer[ i ] = [];

					for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

						renderTargetProperties.__webglFramebuffer[ i ][ level ] = _gl.createFramebuffer();

					}

				} else {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

				}

			}

		} else {

			if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

					renderTargetProperties.__webglFramebuffer[ level ] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			}

			if ( isMultipleRenderTargets ) {

				for ( let i = 0, il = textures.length; i < il; i ++ ) {

					const attachmentProperties = properties.get( textures[ i ] );

					if ( attachmentProperties.__webglTexture === undefined ) {

						attachmentProperties.__webglTexture = _gl.createTexture();

						info.memory.textures ++;

					}

				}

			}

			if ( ( renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

				renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
				renderTargetProperties.__webglColorRenderbuffer = [];

				state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

				for ( let i = 0; i < textures.length; i ++ ) {

					const texture = textures[ i ];
					renderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

					const glFormat = utils.convert( texture.format, texture.colorSpace );
					const glType = utils.convert( texture.type );
					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, renderTarget.isXRRenderTarget === true );
					const samples = getRenderTargetSamples( renderTarget );
					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

				}

				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

				if ( renderTarget.depthBuffer ) {

					renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

				}

				state.bindFramebuffer( _gl.FRAMEBUFFER, null );

			}

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );

			for ( let i = 0; i < 6; i ++ ) {

				if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

					for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ][ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level );

					}

				} else {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0 );

				}

			}

			if ( textureNeedsGenerateMipmaps( texture ) ) {

				generateMipmap( _gl.TEXTURE_CUBE_MAP );

			}

			state.unbindTexture();

		} else if ( isMultipleRenderTargets ) {

			for ( let i = 0, il = textures.length; i < il; i ++ ) {

				const attachment = textures[ i ];
				const attachmentProperties = properties.get( attachment );

				let glTextureType = _gl.TEXTURE_2D;

				if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

					glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;

				}

				state.bindTexture( glTextureType, attachmentProperties.__webglTexture );
				setTextureParameters( glTextureType, attachment );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, glTextureType, 0 );

				if ( textureNeedsGenerateMipmaps( attachment ) ) {

					generateMipmap( glTextureType );

				}

			}

			state.unbindTexture();

		} else {

			let glTextureType = _gl.TEXTURE_2D;

			if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

				glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;

			}

			state.bindTexture( glTextureType, textureProperties.__webglTexture );
			setTextureParameters( glTextureType, texture );

			if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

				for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level );

				}

			} else {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0 );

			}

			if ( textureNeedsGenerateMipmaps( texture ) ) {

				generateMipmap( glTextureType );

			}

			state.unbindTexture();

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		const textures = renderTarget.textures;

		for ( let i = 0, il = textures.length; i < il; i ++ ) {

			const texture = textures[ i ];

			if ( textureNeedsGenerateMipmaps( texture ) ) {

				const targetType = getTargetType( renderTarget );
				const webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( targetType, webglTexture );
				generateMipmap( targetType );
				state.unbindTexture();

			}

		}

	}

	const invalidationArrayRead = [];
	const invalidationArrayDraw = [];

	function updateMultisampleRenderTarget( renderTarget ) {

		if ( renderTarget.samples > 0 ) {

			if ( useMultisampledRTT( renderTarget ) === false ) {

				const textures = renderTarget.textures;
				const width = renderTarget.width;
				const height = renderTarget.height;
				let mask = _gl.COLOR_BUFFER_BIT;
				const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
				const renderTargetProperties = properties.get( renderTarget );
				const isMultipleRenderTargets = ( textures.length > 1 );

				// If MRT we need to remove FBO attachments
				if ( isMultipleRenderTargets ) {

					for ( let i = 0; i < textures.length; i ++ ) {

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null );

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0 );

					}

				}

				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

				const mipmaps = renderTarget.texture.mipmaps;

				if ( mipmaps && mipmaps.length > 0 ) {

					state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ 0 ] );

				} else {

					state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

				}

				for ( let i = 0; i < textures.length; i ++ ) {

					if ( renderTarget.resolveDepthBuffer ) {

						if ( renderTarget.depthBuffer ) mask |= _gl.DEPTH_BUFFER_BIT;

						// resolving stencil is slow with a D3D backend. disable it for all transmission render targets (see #27799)

						if ( renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer ) mask |= _gl.STENCIL_BUFFER_BIT;

					}

					if ( isMultipleRenderTargets ) {

						_gl.framebufferRenderbuffer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

						const webglTexture = properties.get( textures[ i ] ).__webglTexture;
						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0 );

					}

					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );

					if ( supportsInvalidateFramebuffer === true ) {

						invalidationArrayRead.length = 0;
						invalidationArrayDraw.length = 0;

						invalidationArrayRead.push( _gl.COLOR_ATTACHMENT0 + i );

						if ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false ) {

							invalidationArrayRead.push( depthStyle );
							invalidationArrayDraw.push( depthStyle );

							_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, invalidationArrayDraw );

						}

						_gl.invalidateFramebuffer( _gl.READ_FRAMEBUFFER, invalidationArrayRead );

					}

				}

				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );
				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );

				// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
				if ( isMultipleRenderTargets ) {

					for ( let i = 0; i < textures.length; i ++ ) {

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

						const webglTexture = properties.get( textures[ i ] ).__webglTexture;

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0 );

					}

				}

				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

			} else {

				if ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer ) {

					const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;

					_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, [ depthStyle ] );

				}

			}

		}

	}

	function getRenderTargetSamples( renderTarget ) {

		return Math.min( capabilities.maxSamples, renderTarget.samples );

	}

	function useMultisampledRTT( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );

		return renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;

	}

	function updateVideoTexture( texture ) {

		const frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if ( _videoTextures.get( texture ) !== frame ) {

			_videoTextures.set( texture, frame );
			texture.update();

		}

	}

	function verifyColorSpace( texture, image ) {

		const colorSpace = texture.colorSpace;
		const format = texture.format;
		const type = texture.type;

		if ( texture.isCompressedTexture === true || texture.isVideoTexture === true ) return image;

		if ( colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace ) {

			// sRGB

			if ( ColorManagement.getTransfer( colorSpace ) === SRGBTransfer ) {

				// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

				if ( format !== RGBAFormat || type !== UnsignedByteType ) {

					warn( 'WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );

				}

			} else {

				error( 'WebGLTextures: Unsupported texture color space:', colorSpace );

			}

		}

		return image;

	}

	function getDimensions( image ) {

		if ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) {

			// if intrinsic data are not available, fallback to width/height

			_imageDimensions.width = image.naturalWidth || image.width;
			_imageDimensions.height = image.naturalHeight || image.height;

		} else if ( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) {

			_imageDimensions.width = image.displayWidth;
			_imageDimensions.height = image.displayHeight;

		} else {

			_imageDimensions.width = image.width;
			_imageDimensions.height = image.height;

		}

		return _imageDimensions;

	}

	//

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;

	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.rebindTextures = rebindTextures;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
	this.setupDepthRenderbuffer = setupDepthRenderbuffer;
	this.setupFrameBufferTexture = setupFrameBufferTexture;
	this.useMultisampledRTT = useMultisampledRTT;

}

function WebGLUtils( gl, extensions ) {

	function convert( p, colorSpace = NoColorSpace ) {

		let extension;

		const transfer = ColorManagement.getTransfer( colorSpace );

		if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
		if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;
		if ( p === UnsignedInt101111Type ) return gl.UNSIGNED_INT_10F_11F_11F_REV;

		if ( p === ByteType ) return gl.BYTE;
		if ( p === ShortType ) return gl.SHORT;
		if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
		if ( p === IntType ) return gl.INT;
		if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
		if ( p === FloatType ) return gl.FLOAT;
		if ( p === HalfFloatType ) return gl.HALF_FLOAT;

		if ( p === AlphaFormat ) return gl.ALPHA;
		if ( p === RGBFormat ) return gl.RGB;
		if ( p === RGBAFormat ) return gl.RGBA;
		if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
		if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

		// WebGL2 formats.

		if ( p === RedFormat ) return gl.RED;
		if ( p === RedIntegerFormat ) return gl.RED_INTEGER;
		if ( p === RGFormat ) return gl.RG;
		if ( p === RGIntegerFormat ) return gl.RG_INTEGER;
		if ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;

		// S3TC

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			if ( transfer === SRGBTransfer ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			} else {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			}

		}

		// PVRTC

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		// ETC

		if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
				if ( p === RGBA_ETC2_EAC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

			} else {

				return null;

			}

		}

		// ASTC

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				if ( p === RGBA_ASTC_4x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if ( p === RGBA_ASTC_5x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if ( p === RGBA_ASTC_5x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if ( p === RGBA_ASTC_6x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if ( p === RGBA_ASTC_6x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if ( p === RGBA_ASTC_8x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if ( p === RGBA_ASTC_8x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if ( p === RGBA_ASTC_8x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if ( p === RGBA_ASTC_10x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if ( p === RGBA_ASTC_10x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if ( p === RGBA_ASTC_10x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if ( p === RGBA_ASTC_10x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if ( p === RGBA_ASTC_12x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if ( p === RGBA_ASTC_12x12_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

			} else {

				return null;

			}

		}

		// BPTC

		if ( p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				if ( p === RGBA_BPTC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
				if ( p === RGB_BPTC_SIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
				if ( p === RGB_BPTC_UNSIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;

			} else {

				return null;

			}

		}

		// RGTC

		if ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {

			extension = extensions.get( 'EXT_texture_compression_rgtc' );

			if ( extension !== null ) {

				if ( p === RED_RGTC1_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;
				if ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
				if ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
				if ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;

			} else {

				return null;

			}

		}

		//

		if ( p === UnsignedInt248Type ) return gl.UNSIGNED_INT_24_8;

		// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

		return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

	}

	return { convert: convert };

}

const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;

const _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;

/**
 * A XR module that manages the access to the Depth Sensing API.
 */
class WebXRDepthSensing {

	/**
	 * Constructs a new depth sensing module.
	 */
	constructor() {

		/**
		 * An opaque texture representing the depth of the user's environment.
		 *
		 * @type {?ExternalTexture}
		 */
		this.texture = null;

		/**
		 * A plane mesh for visualizing the depth texture.
		 *
		 * @type {?Mesh}
		 */
		this.mesh = null;

		/**
		 * The depth near value.
		 *
		 * @type {number}
		 */
		this.depthNear = 0;

		/**
		 * The depth near far.
		 *
		 * @type {number}
		 */
		this.depthFar = 0;

	}

	/**
	 * Inits the depth sensing module
	 *
	 * @param {XRWebGLDepthInformation} depthData - The XR depth data.
	 * @param {XRRenderState} renderState - The XR render state.
	 */
	init( depthData, renderState ) {

		if ( this.texture === null ) {

			const texture = new ExternalTexture( depthData.texture );

			if ( ( depthData.depthNear !== renderState.depthNear ) || ( depthData.depthFar !== renderState.depthFar ) ) {

				this.depthNear = depthData.depthNear;
				this.depthFar = depthData.depthFar;

			}

			this.texture = texture;

		}

	}

	/**
	 * Returns a plane mesh that visualizes the depth texture.
	 *
	 * @param {ArrayCamera} cameraXR - The XR camera.
	 * @return {?Mesh} The plane mesh.
	 */
	getMesh( cameraXR ) {

		if ( this.texture !== null ) {

			if ( this.mesh === null ) {

				const viewport = cameraXR.cameras[ 0 ].viewport;
				const material = new ShaderMaterial( {
					vertexShader: _occlusion_vertex,
					fragmentShader: _occlusion_fragment,
					uniforms: {
						depthColor: { value: this.texture },
						depthWidth: { value: viewport.z },
						depthHeight: { value: viewport.w }
					}
				} );

				this.mesh = new Mesh( new PlaneGeometry( 20, 20 ), material );

			}

		}

		return this.mesh;

	}

	/**
	 * Resets the module
	 */
	reset() {

		this.texture = null;
		this.mesh = null;

	}

	/**
	 * Returns a texture representing the depth of the user's environment.
	 *
	 * @return {?ExternalTexture} The depth texture.
	 */
	getDepthTexture() {

		return this.texture;

	}

}

/**
 * This class represents an abstraction of the WebXR Device API and is
 * internally used by {@link WebGLRenderer}. `WebXRManager` also provides a public
 * interface that allows users to enable/disable XR and perform XR related
 * tasks like for instance retrieving controllers.
 *
 * @augments EventDispatcher
 * @hideconstructor
 */
class WebXRManager extends EventDispatcher {

	/**
	 * Constructs a new WebGL renderer.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {WebGL2RenderingContext} gl - The rendering context.
	 */
	constructor( renderer, gl ) {

		super();

		const scope = this;

		let session = null;

		let framebufferScaleFactor = 1.0;

		let referenceSpace = null;
		let referenceSpaceType = 'local-floor';
		// Set default foveation to maximum.
		let foveation = 1.0;
		let customReferenceSpace = null;

		let pose = null;
		let glBinding = null;
		let glProjLayer = null;
		let glBaseLayer = null;
		let xrFrame = null;

		const supportsGlBinding = typeof XRWebGLBinding !== 'undefined';

		const depthSensing = new WebXRDepthSensing();
		const cameraAccessTextures = {};
		const attributes = gl.getContextAttributes();

		let initialRenderTarget = null;
		let newRenderTarget = null;

		const controllers = [];
		const controllerInputSources = [];

		const currentSize = new Vector2();
		let currentPixelRatio = null;

		//

		const cameraL = new PerspectiveCamera();
		cameraL.viewport = new Vector4();

		const cameraR = new PerspectiveCamera();
		cameraR.viewport = new Vector4();

		const cameras = [ cameraL, cameraR ];

		const cameraXR = new ArrayCamera();

		let _currentDepthNear = null;
		let _currentDepthFar = null;

		//

		/**
		 * Whether the manager's XR camera should be automatically updated or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.cameraAutoUpdate = true;

		/**
		 * This flag notifies the renderer to be ready for XR rendering. Set it to `true`
		 * if you are going to use XR in your app.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.enabled = false;

		/**
		 * Whether XR presentation is active or not.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default false
		 */
		this.isPresenting = false;

		/**
		 * Returns a group representing the `target ray` space of the XR controller.
		 * Use this space for visualizing 3D objects that support the user in pointing
		 * tasks like UI interaction.
		 *
		 * @param {number} index - The index of the controller.
		 * @return {Group} A group representing the `target ray` space.
		 */
		this.getController = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getTargetRaySpace();

		};

		/**
		 * Returns a group representing the `grip` space of the XR controller.
		 * Use this space for visualizing 3D objects that support the user in pointing
		 * tasks like UI interaction.
		 *
		 * Note: If you want to show something in the user's hand AND offer a
		 * pointing ray at the same time, you'll want to attached the handheld object
		 * to the group returned by `getControllerGrip()` and the ray to the
		 * group returned by `getController()`. The idea is to have two
		 * different groups in two different coordinate spaces for the same WebXR
		 * controller.
		 *
		 * @param {number} index - The index of the controller.
		 * @return {Group} A group representing the `grip` space.
		 */
		this.getControllerGrip = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getGripSpace();

		};

		/**
		 * Returns a group representing the `hand` space of the XR controller.
		 * Use this space for visualizing 3D objects that support the user in pointing
		 * tasks like UI interaction.
		 *
		 * @param {number} index - The index of the controller.
		 * @return {Group} A group representing the `hand` space.
		 */
		this.getHand = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getHandSpace();

		};

		//

		function onSessionEvent( event ) {

			const controllerIndex = controllerInputSources.indexOf( event.inputSource );

			if ( controllerIndex === -1 ) {

				return;

			}

			const controller = controllers[ controllerIndex ];

			if ( controller !== undefined ) {

				controller.update( event.inputSource, event.frame, customReferenceSpace || referenceSpace );
				controller.dispatchEvent( { type: event.type, data: event.inputSource } );

			}

		}

		function onSessionEnd() {

			session.removeEventListener( 'select', onSessionEvent );
			session.removeEventListener( 'selectstart', onSessionEvent );
			session.removeEventListener( 'selectend', onSessionEvent );
			session.removeEventListener( 'squeeze', onSessionEvent );
			session.removeEventListener( 'squeezestart', onSessionEvent );
			session.removeEventListener( 'squeezeend', onSessionEvent );
			session.removeEventListener( 'end', onSessionEnd );
			session.removeEventListener( 'inputsourceschange', onInputSourcesChange );

			for ( let i = 0; i < controllers.length; i ++ ) {

				const inputSource = controllerInputSources[ i ];

				if ( inputSource === null ) continue;

				controllerInputSources[ i ] = null;

				controllers[ i ].disconnect( inputSource );

			}

			_currentDepthNear = null;
			_currentDepthFar = null;

			depthSensing.reset();
			for ( const key in cameraAccessTextures ) {

				delete cameraAccessTextures[ key ];

			}

			// restore framebuffer/rendering state

			renderer.setRenderTarget( initialRenderTarget );

			glBaseLayer = null;
			glProjLayer = null;
			glBinding = null;
			session = null;
			newRenderTarget = null;

			//

			animation.stop();

			scope.isPresenting = false;

			renderer.setPixelRatio( currentPixelRatio );
			renderer.setSize( currentSize.width, currentSize.height, false );

			scope.dispatchEvent( { type: 'sessionend' } );

		}

		/**
		 * Sets the framebuffer scale factor.
		 *
		 * This method can not be used during a XR session.
		 *
		 * @param {number} value - The framebuffer scale factor.
		 */
		this.setFramebufferScaleFactor = function ( value ) {

			framebufferScaleFactor = value;

			if ( scope.isPresenting === true ) {

				warn( 'WebXRManager: Cannot change framebuffer scale while presenting.' );

			}

		};

		/**
		 * Sets the reference space type. Can be used to configure a spatial relationship with the user's physical
		 * environment. Depending on how the user moves in 3D space, setting an appropriate reference space can
		 * improve tracking. Default is `local-floor`. Valid values can be found here
		 * https://developer.mozilla.org/en-US/docs/Web/API/XRReferenceSpace#reference_space_types.
		 *
		 * This method can not be used during a XR session.
		 *
		 * @param {string} value - The reference space type.
		 */
		this.setReferenceSpaceType = function ( value ) {

			referenceSpaceType = value;

			if ( scope.isPresenting === true ) {

				warn( 'WebXRManager: Cannot change reference space type while presenting.' );

			}

		};

		/**
		 * Returns the XR reference space.
		 *
		 * @return {XRReferenceSpace} The XR reference space.
		 */
		this.getReferenceSpace = function () {

			return customReferenceSpace || referenceSpace;

		};

		/**
		 * Sets a custom XR reference space.
		 *
		 * @param {XRReferenceSpace} space - The XR reference space.
		 */
		this.setReferenceSpace = function ( space ) {

			customReferenceSpace = space;

		};

		/**
		 * Returns the current base layer.
		 *
		 * This is an `XRProjectionLayer` when the targeted XR device supports the
		 * WebXR Layers API, or an `XRWebGLLayer` otherwise.
		 *
		 * @return {?(XRWebGLLayer|XRProjectionLayer)} The XR base layer.
		 */
		this.getBaseLayer = function () {

			return glProjLayer !== null ? glProjLayer : glBaseLayer;

		};

		/**
		 * Returns the current XR binding.
		 *
		 * Creates a new binding if needed and the browser is
		 * capable of doing so.
		 *
		 * @return {?XRWebGLBinding} The XR binding. Returns `null` if one cannot be created.
		 */
		this.getBinding = function () {

			if ( glBinding === null && supportsGlBinding ) {

				glBinding = new XRWebGLBinding( session, gl );

			}

			return glBinding;

		};

		/**
		 * Returns the current XR frame.
		 *
		 * @return {?XRFrame} The XR frame. Returns `null` when used outside a XR session.
		 */
		this.getFrame = function () {

			return xrFrame;

		};

		/**
		 * Returns the current XR session.
		 *
		 * @return {?XRSession} The XR session. Returns `null` when used outside a XR session.
		 */
		this.getSession = function () {

			return session;

		};

		/**
		 * After a XR session has been requested usually with one of the `*Button` modules, it
		 * is injected into the renderer with this method. This method triggers the start of
		 * the actual XR rendering.
		 *
		 * @async
		 * @param {XRSession} value - The XR session to set.
		 * @return {Promise} A Promise that resolves when the session has been set.
		 */
		this.setSession = async function ( value ) {

			session = value;

			if ( session !== null ) {

				initialRenderTarget = renderer.getRenderTarget();

				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'squeeze', onSessionEvent );
				session.addEventListener( 'squeezestart', onSessionEvent );
				session.addEventListener( 'squeezeend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );
				session.addEventListener( 'inputsourceschange', onInputSourcesChange );

				if ( attributes.xrCompatible !== true ) {

					await gl.makeXRCompatible();

				}

				currentPixelRatio = renderer.getPixelRatio();
				renderer.getSize( currentSize );


				// Check that the browser implements the necessary APIs to use an
				// XRProjectionLayer rather than an XRWebGLLayer
				const supportsLayers = supportsGlBinding && 'createProjectionLayer' in XRWebGLBinding.prototype;

				if ( ! supportsLayers ) {

					const layerInit = {
						antialias: attributes.antialias,
						alpha: true,
						depth: attributes.depth,
						stencil: attributes.stencil,
						framebufferScaleFactor: framebufferScaleFactor
					};

					glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

					session.updateRenderState( { baseLayer: glBaseLayer } );

					renderer.setPixelRatio( 1 );
					renderer.setSize( glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false );

					newRenderTarget = new WebGLRenderTarget(
						glBaseLayer.framebufferWidth,
						glBaseLayer.framebufferHeight,
						{
							format: RGBAFormat,
							type: UnsignedByteType,
							colorSpace: renderer.outputColorSpace,
							stencilBuffer: attributes.stencil,
							resolveDepthBuffer: ( glBaseLayer.ignoreDepthValues === false ),
							resolveStencilBuffer: ( glBaseLayer.ignoreDepthValues === false )

						}
					);

				} else {

					let depthFormat = null;
					let depthType = null;
					let glDepthFormat = null;

					if ( attributes.depth ) {

						glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
						depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
						depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;

					}

					const projectionlayerInit = {
						colorFormat: gl.RGBA8,
						depthFormat: glDepthFormat,
						scaleFactor: framebufferScaleFactor
					};

					glBinding = this.getBinding();

					glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

					session.updateRenderState( { layers: [ glProjLayer ] } );

					renderer.setPixelRatio( 1 );
					renderer.setSize( glProjLayer.textureWidth, glProjLayer.textureHeight, false );

					newRenderTarget = new WebGLRenderTarget(
						glProjLayer.textureWidth,
						glProjLayer.textureHeight,
						{
							format: RGBAFormat,
							type: UnsignedByteType,
							depthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),
							stencilBuffer: attributes.stencil,
							colorSpace: renderer.outputColorSpace,
							samples: attributes.antialias ? 4 : 0,
							resolveDepthBuffer: ( glProjLayer.ignoreDepthValues === false ),
							resolveStencilBuffer: ( glProjLayer.ignoreDepthValues === false )
						} );

				}

				newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

				this.setFoveation( foveation );

				customReferenceSpace = null;
				referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

				animation.setContext( session );
				animation.start();

				scope.isPresenting = true;

				scope.dispatchEvent( { type: 'sessionstart' } );

			}

		};

		/**
		 * Returns the environment blend mode from the current XR session.
		 *
		 * @return {'opaque'|'additive'|'alpha-blend'|undefined} The environment blend mode. Returns `undefined` when used outside of a XR session.
		 */
		this.getEnvironmentBlendMode = function () {

			if ( session !== null ) {

				return session.environmentBlendMode;

			}

		};

		/**
		 * Returns the current depth texture computed via depth sensing.
		 *
		 * See {@link WebXRDepthSensing#getDepthTexture}.
		 *
		 * @return {?Texture} The depth texture.
		 */
		this.getDepthTexture = function () {

			return depthSensing.getDepthTexture();

		};

		function onInputSourcesChange( event ) {

			// Notify disconnected

			for ( let i = 0; i < event.removed.length; i ++ ) {

				const inputSource = event.removed[ i ];
				const index = controllerInputSources.indexOf( inputSource );

				if ( index >= 0 ) {

					controllerInputSources[ index ] = null;
					controllers[ index ].disconnect( inputSource );

				}

			}

			// Notify connected

			for ( let i = 0; i < event.added.length; i ++ ) {

				const inputSource = event.added[ i ];

				let controllerIndex = controllerInputSources.indexOf( inputSource );

				if ( controllerIndex === -1 ) {

					// Assign input source a controller that currently has no input source

					for ( let i = 0; i < controllers.length; i ++ ) {

						if ( i >= controllerInputSources.length ) {

							controllerInputSources.push( inputSource );
							controllerIndex = i;
							break;

						} else if ( controllerInputSources[ i ] === null ) {

							controllerInputSources[ i ] = inputSource;
							controllerIndex = i;
							break;

						}

					}

					// If all controllers do currently receive input we ignore new ones

					if ( controllerIndex === -1 ) break;

				}

				const controller = controllers[ controllerIndex ];

				if ( controller ) {

					controller.connect( inputSource );

				}

			}

		}

		//

		const cameraLPos = new Vector3();
		const cameraRPos = new Vector3();

		/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 *
		 * @param {ArrayCamera} camera - The camera to update.
		 * @param {PerspectiveCamera} cameraL - The left camera.
		 * @param {PerspectiveCamera} cameraR - The right camera.
		 */
		function setProjectionFromUnion( camera, cameraL, cameraR ) {

			cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
			cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

			const ipd = cameraLPos.distanceTo( cameraRPos );

			const projL = cameraL.projectionMatrix.elements;
			const projR = cameraR.projectionMatrix.elements;

			// VR systems will have identical far and near planes, and
			// most likely identical top and bottom frustum extents.
			// Use the left camera for these values.
			const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
			const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
			const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
			const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

			const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
			const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
			const left = near * leftFov;
			const right = near * rightFov;

			// Calculate the new camera's position offset from the
			// left camera. xOffset should be roughly half `ipd`.
			const zOffset = ipd / ( - leftFov + rightFov );
			const xOffset = zOffset * - leftFov;

			// TODO: Better way to apply this offset?
			cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
			camera.translateX( xOffset );
			camera.translateZ( zOffset );
			camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			// Check if the projection uses an infinite far plane.
			if ( projL[ 10 ] === -1 ) {

				// Use the projection matrix from the left eye.
				// The camera offset is sufficient to include the view volumes
				// of both eyes (assuming symmetric projections).
				camera.projectionMatrix.copy( cameraL.projectionMatrix );
				camera.projectionMatrixInverse.copy( cameraL.projectionMatrixInverse );

			} else {

				// Find the union of the frustum values of the cameras and scale
				// the values so that the near plane's position does not change in world space,
				// although must now be relative to the new union camera.
				const near2 = near + zOffset;
				const far2 = far + zOffset;
				const left2 = left - xOffset;
				const right2 = right + ( ipd - xOffset );
				const top2 = topFov * far / far2 * near2;
				const bottom2 = bottomFov * far / far2 * near2;

				camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );
				camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();

			}

		}

		function updateCamera( camera, parent ) {

			if ( parent === null ) {

				camera.matrixWorld.copy( camera.matrix );

			} else {

				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			}

			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		}

		/**
		 * Updates the state of the XR camera. Use this method on app level if you
		 * set `cameraAutoUpdate` to `false`. The method requires the non-XR
		 * camera of the scene as a parameter. The passed in camera's transformation
		 * is automatically adjusted to the position of the XR camera when calling
		 * this method.
		 *
		 * @param {Camera} camera - The camera.
		 */
		this.updateCamera = function ( camera ) {

			if ( session === null ) return;

			let depthNear = camera.near;
			let depthFar = camera.far;

			if ( depthSensing.texture !== null ) {

				if ( depthSensing.depthNear > 0 ) depthNear = depthSensing.depthNear;
				if ( depthSensing.depthFar > 0 ) depthFar = depthSensing.depthFar;

			}

			cameraXR.near = cameraR.near = cameraL.near = depthNear;
			cameraXR.far = cameraR.far = cameraL.far = depthFar;

			if ( _currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far ) {

				// Note that the new renderState won't apply until the next frame. See #18320

				session.updateRenderState( {
					depthNear: cameraXR.near,
					depthFar: cameraXR.far
				} );

				_currentDepthNear = cameraXR.near;
				_currentDepthFar = cameraXR.far;

			}

			// inherit camera layers and enable eye layers (1 = left, 2 = right)
			cameraXR.layers.mask = camera.layers.mask | 0b110;
			cameraL.layers.mask = cameraXR.layers.mask & 0b011;
			cameraR.layers.mask = cameraXR.layers.mask & 0b101;

			const parent = camera.parent;
			const cameras = cameraXR.cameras;

			updateCamera( cameraXR, parent );

			for ( let i = 0; i < cameras.length; i ++ ) {

				updateCamera( cameras[ i ], parent );

			}

			// update projection matrix for proper view frustum culling

			if ( cameras.length === 2 ) {

				setProjectionFromUnion( cameraXR, cameraL, cameraR );

			} else {

				// assume single camera setup (AR)

				cameraXR.projectionMatrix.copy( cameraL.projectionMatrix );

			}

			// update user camera and its children

			updateUserCamera( camera, cameraXR, parent );

		};

		function updateUserCamera( camera, cameraXR, parent ) {

			if ( parent === null ) {

				camera.matrix.copy( cameraXR.matrixWorld );

			} else {

				camera.matrix.copy( parent.matrixWorld );
				camera.matrix.invert();
				camera.matrix.multiply( cameraXR.matrixWorld );

			}

			camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
			camera.updateMatrixWorld( true );

			camera.projectionMatrix.copy( cameraXR.projectionMatrix );
			camera.projectionMatrixInverse.copy( cameraXR.projectionMatrixInverse );

			if ( camera.isPerspectiveCamera ) {

				camera.fov = RAD2DEG * 2 * Math.atan( 1 / camera.projectionMatrix.elements[ 5 ] );
				camera.zoom = 1;

			}

		}

		/**
		 * Returns an instance of {@link ArrayCamera} which represents the XR camera
		 * of the active XR session. For each view it holds a separate camera object.
		 *
		 * The camera's `fov` is currently not used and does not reflect the fov of
		 * the XR camera. If you need the fov on app level, you have to compute in
		 * manually from the XR camera's projection matrices.
		 *
		 * @return {ArrayCamera} The XR camera.
		 */
		this.getCamera = function () {

			return cameraXR;

		};

		/**
		 * Returns the amount of foveation used by the XR compositor for the projection layer.
		 *
		 * @return {number|undefined} The amount of foveation.
		 */
		this.getFoveation = function () {

			if ( glProjLayer === null && glBaseLayer === null ) {

				return undefined;

			}

			return foveation;

		};

		/**
		 * Sets the foveation value.
		 *
		 * @param {number} value - A number in the range `[0,1]` where `0` means no foveation (full resolution)
		 * and `1` means maximum foveation (the edges render at lower resolution).
		 */
		this.setFoveation = function ( value ) {

			// 0 = no foveation = full resolution
			// 1 = maximum foveation = the edges render at lower resolution

			foveation = value;

			if ( glProjLayer !== null ) {

				glProjLayer.fixedFoveation = value;

			}

			if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {

				glBaseLayer.fixedFoveation = value;

			}

		};

		/**
		 * Returns `true` if depth sensing is supported.
		 *
		 * @return {boolean} Whether depth sensing is supported or not.
		 */
		this.hasDepthSensing = function () {

			return depthSensing.texture !== null;

		};

		/**
		 * Returns the depth sensing mesh.
		 *
		 * See {@link WebXRDepthSensing#getMesh}.
		 *
		 * @return {Mesh} The depth sensing mesh.
		 */
		this.getDepthSensingMesh = function () {

			return depthSensing.getMesh( cameraXR );

		};

		/**
		 * Retrieves an opaque texture from the view-aligned {@link XRCamera}.
		 * Only available during the current animation loop.
		 *
		 * @param {XRCamera} xrCamera - The camera to query.
		 * @return {?Texture} An opaque texture representing the current raw camera frame.
		 */
		this.getCameraTexture = function ( xrCamera ) {

			return cameraAccessTextures[ xrCamera ];

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time, frame ) {

			pose = frame.getViewerPose( customReferenceSpace || referenceSpace );
			xrFrame = frame;

			if ( pose !== null ) {

				const views = pose.views;

				if ( glBaseLayer !== null ) {

					renderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );
					renderer.setRenderTarget( newRenderTarget );

				}

				let cameraXRNeedsUpdate = false;

				// check if it's necessary to rebuild cameraXR's camera list

				if ( views.length !== cameraXR.cameras.length ) {

					cameraXR.cameras.length = 0;
					cameraXRNeedsUpdate = true;

				}

				for ( let i = 0; i < views.length; i ++ ) {

					const view = views[ i ];

					let viewport = null;

					if ( glBaseLayer !== null ) {

						viewport = glBaseLayer.getViewport( view );

					} else {

						const glSubImage = glBinding.getViewSubImage( glProjLayer, view );
						viewport = glSubImage.viewport;

						// For side-by-side projection, we only produce a single texture for both eyes.
						if ( i === 0 ) {

							renderer.setRenderTargetTextures(
								newRenderTarget,
								glSubImage.colorTexture,
								glSubImage.depthStencilTexture );

							renderer.setRenderTarget( newRenderTarget );

						}

					}

					let camera = cameras[ i ];

					if ( camera === undefined ) {

						camera = new PerspectiveCamera();
						camera.layers.enable( i );
						camera.viewport = new Vector4();
						cameras[ i ] = camera;

					}

					camera.matrix.fromArray( view.transform.matrix );
					camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					if ( i === 0 ) {

						cameraXR.matrix.copy( camera.matrix );
						cameraXR.matrix.decompose( cameraXR.position, cameraXR.quaternion, cameraXR.scale );

					}

					if ( cameraXRNeedsUpdate === true ) {

						cameraXR.cameras.push( camera );

					}

				}

				//

				const enabledFeatures = session.enabledFeatures;
				const gpuDepthSensingEnabled = enabledFeatures &&
					enabledFeatures.includes( 'depth-sensing' ) &&
					session.depthUsage == 'gpu-optimized';

				if ( gpuDepthSensingEnabled && supportsGlBinding ) {

					glBinding = scope.getBinding();

					const depthData = glBinding.getDepthInformation( views[ 0 ] );

					if ( depthData && depthData.isValid && depthData.texture ) {

						depthSensing.init( depthData, session.renderState );

					}

				}

				const cameraAccessEnabled = enabledFeatures &&
				    enabledFeatures.includes( 'camera-access' );

				if ( cameraAccessEnabled && supportsGlBinding ) {

					renderer.state.unbindTexture();

					glBinding = scope.getBinding();

					for ( let i = 0; i < views.length; i ++ ) {

						const camera = views[ i ].camera;

						if ( camera ) {

							let cameraTex = cameraAccessTextures[ camera ];

							if ( ! cameraTex ) {

								cameraTex = new ExternalTexture();
								cameraAccessTextures[ camera ] = cameraTex;

							}

							const glTexture = glBinding.getCameraImage( camera );
							cameraTex.sourceTexture = glTexture;

						}

					}

				}

			}

			//

			for ( let i = 0; i < controllers.length; i ++ ) {

				const inputSource = controllerInputSources[ i ];
				const controller = controllers[ i ];

				if ( inputSource !== null && controller !== undefined ) {

					controller.update( inputSource, frame, customReferenceSpace || referenceSpace );

				}

			}

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

			if ( frame.detectedPlanes ) {

				scope.dispatchEvent( { type: 'planesdetected', data: frame } );

			}

			xrFrame = null;

		}

		const animation = new WebGLAnimation();

		animation.setAnimationLoop( onAnimationFrame );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;

		};

		this.dispose = function () {};

	}

}

const _e1 = /*@__PURE__*/ new Euler();
const _m1 = /*@__PURE__*/ new Matrix4();

function WebGLMaterials( renderer, properties ) {

	function refreshTransformUniform( map, uniform ) {

		if ( map.matrixAutoUpdate === true ) {

			map.updateMatrix();

		}

		uniform.value.copy( map.matrix );

	}

	function refreshFogUniforms( uniforms, fog ) {

		fog.color.getRGB( uniforms.fogColor.value, getUnlitUniformColorSpace( renderer ) );

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

		if ( material.isMeshBasicMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshLambertMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshToonMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsToon( uniforms, material );

		} else if ( material.isMeshPhongMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsPhong( uniforms, material );

		} else if ( material.isMeshStandardMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsStandard( uniforms, material );

			if ( material.isMeshPhysicalMaterial ) {

				refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

			}

		} else if ( material.isMeshMatcapMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsMatcap( uniforms, material );

		} else if ( material.isMeshDepthMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshDistanceMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDistance( uniforms, material );

		} else if ( material.isMeshNormalMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isLineBasicMaterial ) {

			refreshUniformsLine( uniforms, material );

			if ( material.isLineDashedMaterial ) {

				refreshUniformsDash( uniforms, material );

			}

		} else if ( material.isPointsMaterial ) {

			refreshUniformsPoints( uniforms, material, pixelRatio, height );

		} else if ( material.isSpriteMaterial ) {

			refreshUniformsSprites( uniforms, material );

		} else if ( material.isShadowMaterial ) {

			uniforms.color.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		} else if ( material.isShaderMaterial ) {

			material.uniformsNeedUpdate = false; // #15581

		}

	}

	function refreshUniformsCommon( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( material.color ) {

			uniforms.diffuse.value.copy( material.color );

		}

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		if ( material.map ) {

			uniforms.map.value = material.map;

			refreshTransformUniform( material.map, uniforms.mapTransform );

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

			refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;

			refreshTransformUniform( material.bumpMap, uniforms.bumpMapTransform );

			uniforms.bumpScale.value = material.bumpScale;

			if ( material.side === BackSide ) {

				uniforms.bumpScale.value *= -1;

			}

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;

			refreshTransformUniform( material.normalMap, uniforms.normalMapTransform );

			uniforms.normalScale.value.copy( material.normalScale );

			if ( material.side === BackSide ) {

				uniforms.normalScale.value.negate();

			}

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;

			refreshTransformUniform( material.displacementMap, uniforms.displacementMapTransform );

			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

			refreshTransformUniform( material.emissiveMap, uniforms.emissiveMapTransform );

		}

		if ( material.specularMap ) {

			uniforms.specularMap.value = material.specularMap;

			refreshTransformUniform( material.specularMap, uniforms.specularMapTransform );

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

		const materialProperties = properties.get( material );

		const envMap = materialProperties.envMap;
		const envMapRotation = materialProperties.envMapRotation;

		if ( envMap ) {

			uniforms.envMap.value = envMap;

			_e1.copy( envMapRotation );

			// accommodate left-handed frame
			_e1.x *= -1; _e1.y *= -1; _e1.z *= -1;

			if ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) {

				// environment maps which are not cube render targets or PMREMs follow a different convention
				_e1.y *= -1;
				_e1.z *= -1;

			}

			uniforms.envMapRotation.value.setFromMatrix4( _m1.makeRotationFromEuler( _e1 ) );

			uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? -1 : 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.ior.value = material.ior;
			uniforms.refractionRatio.value = material.refractionRatio;

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

			refreshTransformUniform( material.lightMap, uniforms.lightMapTransform );

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

			refreshTransformUniform( material.aoMap, uniforms.aoMapTransform );

		}

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;

		if ( material.map ) {

			uniforms.map.value = material.map;

			refreshTransformUniform( material.map, uniforms.mapTransform );

		}

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * pixelRatio;
		uniforms.scale.value = height * 0.5;

		if ( material.map ) {

			uniforms.map.value = material.map;

			refreshTransformUniform( material.map, uniforms.uvTransform );

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

			refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

	}

	function refreshUniformsSprites( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;

		if ( material.map ) {

			uniforms.map.value = material.map;

			refreshTransformUniform( material.map, uniforms.mapTransform );

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

			refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

		}

		if ( material.alphaTest > 0 ) {

			uniforms.alphaTest.value = material.alphaTest;

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value.copy( material.specular );
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

	}

	function refreshUniformsToon( uniforms, material ) {

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

	}

	function refreshUniformsStandard( uniforms, material ) {

		uniforms.metalness.value = material.metalness;

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

			refreshTransformUniform( material.metalnessMap, uniforms.metalnessMapTransform );

		}

		uniforms.roughness.value = material.roughness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

			refreshTransformUniform( material.roughnessMap, uniforms.roughnessMapTransform );

		}

		if ( material.envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common

			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

		uniforms.ior.value = material.ior; // also part of uniforms common

		if ( material.sheen > 0 ) {

			uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );

			uniforms.sheenRoughness.value = material.sheenRoughness;

			if ( material.sheenColorMap ) {

				uniforms.sheenColorMap.value = material.sheenColorMap;

				refreshTransformUniform( material.sheenColorMap, uniforms.sheenColorMapTransform );

			}

			if ( material.sheenRoughnessMap ) {

				uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;

				refreshTransformUniform( material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform );

			}

		}

		if ( material.clearcoat > 0 ) {

			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

			if ( material.clearcoatMap ) {

				uniforms.clearcoatMap.value = material.clearcoatMap;

				refreshTransformUniform( material.clearcoatMap, uniforms.clearcoatMapTransform );

			}

			if ( material.clearcoatRoughnessMap ) {

				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

				refreshTransformUniform( material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform );

			}

			if ( material.clearcoatNormalMap ) {

				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

				refreshTransformUniform( material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform );

				uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );

				if ( material.side === BackSide ) {

					uniforms.clearcoatNormalScale.value.negate();

				}

			}

		}

		if ( material.dispersion > 0 ) {

			uniforms.dispersion.value = material.dispersion;

		}

		if ( material.iridescence > 0 ) {

			uniforms.iridescence.value = material.iridescence;
			uniforms.iridescenceIOR.value = material.iridescenceIOR;
			uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];
			uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];

			if ( material.iridescenceMap ) {

				uniforms.iridescenceMap.value = material.iridescenceMap;

				refreshTransformUniform( material.iridescenceMap, uniforms.iridescenceMapTransform );

			}

			if ( material.iridescenceThicknessMap ) {

				uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;

				refreshTransformUniform( material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform );

			}

		}

		if ( material.transmission > 0 ) {

			uniforms.transmission.value = material.transmission;
			uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
			uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

			if ( material.transmissionMap ) {

				uniforms.transmissionMap.value = material.transmissionMap;

				refreshTransformUniform( material.transmissionMap, uniforms.transmissionMapTransform );

			}

			uniforms.thickness.value = material.thickness;

			if ( material.thicknessMap ) {

				uniforms.thicknessMap.value = material.thicknessMap;

				refreshTransformUniform( material.thicknessMap, uniforms.thicknessMapTransform );

			}

			uniforms.attenuationDistance.value = material.attenuationDistance;
			uniforms.attenuationColor.value.copy( material.attenuationColor );

		}

		if ( material.anisotropy > 0 ) {

			uniforms.anisotropyVector.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );

			if ( material.anisotropyMap ) {

				uniforms.anisotropyMap.value = material.anisotropyMap;

				refreshTransformUniform( material.anisotropyMap, uniforms.anisotropyMapTransform );

			}

		}

		uniforms.specularIntensity.value = material.specularIntensity;
		uniforms.specularColor.value.copy( material.specularColor );

		if ( material.specularColorMap ) {

			uniforms.specularColorMap.value = material.specularColorMap;

			refreshTransformUniform( material.specularColorMap, uniforms.specularColorMapTransform );

		}

		if ( material.specularIntensityMap ) {

			uniforms.specularIntensityMap.value = material.specularIntensityMap;

			refreshTransformUniform( material.specularIntensityMap, uniforms.specularIntensityMapTransform );

		}

	}

	function refreshUniformsMatcap( uniforms, material ) {

		if ( material.matcap ) {

			uniforms.matcap.value = material.matcap;

		}

	}

	function refreshUniformsDistance( uniforms, material ) {

		const light = properties.get( material ).light;

		uniforms.referencePosition.value.setFromMatrixPosition( light.matrixWorld );
		uniforms.nearDistance.value = light.shadow.camera.near;
		uniforms.farDistance.value = light.shadow.camera.far;

	}

	return {
		refreshFogUniforms: refreshFogUniforms,
		refreshMaterialUniforms: refreshMaterialUniforms
	};

}

function WebGLUniformsGroups( gl, info, capabilities, state ) {

	let buffers = {};
	let updateList = {};
	let allocatedBindingPoints = [];

	const maxBindingPoints = gl.getParameter( gl.MAX_UNIFORM_BUFFER_BINDINGS ); // binding points are global whereas block indices are per shader program

	function bind( uniformsGroup, program ) {

		const webglProgram = program.program;
		state.uniformBlockBinding( uniformsGroup, webglProgram );

	}

	function update( uniformsGroup, program ) {

		let buffer = buffers[ uniformsGroup.id ];

		if ( buffer === undefined ) {

			prepareUniformsGroup( uniformsGroup );

			buffer = createBuffer( uniformsGroup );
			buffers[ uniformsGroup.id ] = buffer;

			uniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );

		}

		// ensure to update the binding points/block indices mapping for this program

		const webglProgram = program.program;
		state.updateUBOMapping( uniformsGroup, webglProgram );

		// update UBO once per frame

		const frame = info.render.frame;

		if ( updateList[ uniformsGroup.id ] !== frame ) {

			updateBufferData( uniformsGroup );

			updateList[ uniformsGroup.id ] = frame;

		}

	}

	function createBuffer( uniformsGroup ) {

		// the setup of an UBO is independent of a particular shader program but global

		const bindingPointIndex = allocateBindingPointIndex();
		uniformsGroup.__bindingPointIndex = bindingPointIndex;

		const buffer = gl.createBuffer();
		const size = uniformsGroup.__size;
		const usage = uniformsGroup.usage;

		gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );
		gl.bufferData( gl.UNIFORM_BUFFER, size, usage );
		gl.bindBuffer( gl.UNIFORM_BUFFER, null );
		gl.bindBufferBase( gl.UNIFORM_BUFFER, bindingPointIndex, buffer );

		return buffer;

	}

	function allocateBindingPointIndex() {

		for ( let i = 0; i < maxBindingPoints; i ++ ) {

			if ( allocatedBindingPoints.indexOf( i ) === -1 ) {

				allocatedBindingPoints.push( i );
				return i;

			}

		}

		error( 'WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );

		return 0;

	}

	function updateBufferData( uniformsGroup ) {

		const buffer = buffers[ uniformsGroup.id ];
		const uniforms = uniformsGroup.uniforms;
		const cache = uniformsGroup.__cache;

		gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );

		for ( let i = 0, il = uniforms.length; i < il; i ++ ) {

			const uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];

			for ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {

				const uniform = uniformArray[ j ];

				if ( hasUniformChanged( uniform, i, j, cache ) === true ) {

					const offset = uniform.__offset;

					const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

					let arrayOffset = 0;

					for ( let k = 0; k < values.length; k ++ ) {

						const value = values[ k ];

						const info = getUniformSize( value );

						// TODO add integer and struct support
						if ( typeof value === 'number' || typeof value === 'boolean' ) {

							uniform.__data[ 0 ] = value;
							gl.bufferSubData( gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data );

						} else if ( value.isMatrix3 ) {

							// manually converting 3x3 to 3x4

							uniform.__data[ 0 ] = value.elements[ 0 ];
							uniform.__data[ 1 ] = value.elements[ 1 ];
							uniform.__data[ 2 ] = value.elements[ 2 ];
							uniform.__data[ 3 ] = 0;
							uniform.__data[ 4 ] = value.elements[ 3 ];
							uniform.__data[ 5 ] = value.elements[ 4 ];
							uniform.__data[ 6 ] = value.elements[ 5 ];
							uniform.__data[ 7 ] = 0;
							uniform.__data[ 8 ] = value.elements[ 6 ];
							uniform.__data[ 9 ] = value.elements[ 7 ];
							uniform.__data[ 10 ] = value.elements[ 8 ];
							uniform.__data[ 11 ] = 0;

						} else {

							value.toArray( uniform.__data, arrayOffset );

							arrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT;

						}

					}

					gl.bufferSubData( gl.UNIFORM_BUFFER, offset, uniform.__data );

				}

			}

		}

		gl.bindBuffer( gl.UNIFORM_BUFFER, null );

	}

	function hasUniformChanged( uniform, index, indexArray, cache ) {

		const value = uniform.value;
		const indexString = index + '_' + indexArray;

		if ( cache[ indexString ] === undefined ) {

			// cache entry does not exist so far

			if ( typeof value === 'number' || typeof value === 'boolean' ) {

				cache[ indexString ] = value;

			} else {

				cache[ indexString ] = value.clone();

			}

			return true;

		} else {

			const cachedObject = cache[ indexString ];

			// compare current value with cached entry

			if ( typeof value === 'number' || typeof value === 'boolean' ) {

				if ( cachedObject !== value ) {

					cache[ indexString ] = value;
					return true;

				}

			} else {

				if ( cachedObject.equals( value ) === false ) {

					cachedObject.copy( value );
					return true;

				}

			}

		}

		return false;

	}

	function prepareUniformsGroup( uniformsGroup ) {

		// determine total buffer size according to the STD140 layout
		// Hint: STD140 is the only supported layout in WebGL 2

		const uniforms = uniformsGroup.uniforms;

		let offset = 0; // global buffer offset in bytes
		const chunkSize = 16; // size of a chunk in bytes

		for ( let i = 0, l = uniforms.length; i < l; i ++ ) {

			const uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];

			for ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {

				const uniform = uniformArray[ j ];

				const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

				for ( let k = 0, kl = values.length; k < kl; k ++ ) {

					const value = values[ k ];

					const info = getUniformSize( value );

					const chunkOffset = offset % chunkSize; // offset in the current chunk
					const chunkPadding = chunkOffset % info.boundary; // required padding to match boundary
					const chunkStart = chunkOffset + chunkPadding; // the start position in the current chunk for the data

					offset += chunkPadding;

					// Check for chunk overflow
					if ( chunkStart !== 0 && ( chunkSize - chunkStart ) < info.storage ) {

						// Add padding and adjust offset
						offset += ( chunkSize - chunkStart );

					}

					// the following two properties will be used for partial buffer updates
					uniform.__data = new Float32Array( info.storage / Float32Array.BYTES_PER_ELEMENT );
					uniform.__offset = offset;

					// Update the global offset
					offset += info.storage;

				}

			}

		}

		// ensure correct final padding

		const chunkOffset = offset % chunkSize;

		if ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );

		//

		uniformsGroup.__size = offset;
		uniformsGroup.__cache = {};

		return this;

	}

	function getUniformSize( value ) {

		const info = {
			boundary: 0, // bytes
			storage: 0 // bytes
		};

		// determine sizes according to STD140

		if ( typeof value === 'number' || typeof value === 'boolean' ) {

			// float/int/bool

			info.boundary = 4;
			info.storage = 4;

		} else if ( value.isVector2 ) {

			// vec2

			info.boundary = 8;
			info.storage = 8;

		} else if ( value.isVector3 || value.isColor ) {

			// vec3

			info.boundary = 16;
			info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes

		} else if ( value.isVector4 ) {

			// vec4

			info.boundary = 16;
			info.storage = 16;

		} else if ( value.isMatrix3 ) {

			// mat3 (in STD140 a 3x3 matrix is represented as 3x4)

			info.boundary = 48;
			info.storage = 48;

		} else if ( value.isMatrix4 ) {

			// mat4

			info.boundary = 64;
			info.storage = 64;

		} else if ( value.isTexture ) {

			warn( 'WebGLRenderer: Texture samplers can not be part of an uniforms group.' );

		} else {

			warn( 'WebGLRenderer: Unsupported uniform value type.', value );

		}

		return info;

	}

	function onUniformsGroupsDispose( event ) {

		const uniformsGroup = event.target;

		uniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );

		const index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );
		allocatedBindingPoints.splice( index, 1 );

		gl.deleteBuffer( buffers[ uniformsGroup.id ] );

		delete buffers[ uniformsGroup.id ];
		delete updateList[ uniformsGroup.id ];

	}

	function dispose() {

		for ( const id in buffers ) {

			gl.deleteBuffer( buffers[ id ] );

		}

		allocatedBindingPoints = [];
		buffers = {};
		updateList = {};

	}

	return {

		bind: bind,
		update: update,

		dispose: dispose

	};

}

/**
 * Precomputed DFG LUT for Image-Based Lighting
 * Resolution: 32x32
 * Samples: 4096 per texel
 * Format: RG16F (2 half floats per texel: scale, bias)
 */


const DATA = new Uint16Array( [
	0x2cd9, 0x3b64, 0x2d0e, 0x3b43, 0x2e20, 0x3aa7, 0x3061, 0x39fb, 0x325e, 0x397c, 0x3454, 0x3908, 0x357d, 0x3893, 0x3698, 0x381e, 0x379d, 0x375b, 0x3845, 0x3689, 0x38af, 0x35ca, 0x390d, 0x351e, 0x395f, 0x3484, 0x39a8, 0x33f9, 0x39e6, 0x330a, 0x3a1c, 0x3239, 0x3a4b, 0x3183, 0x3a73, 0x30e5, 0x3a95, 0x305b, 0x3ab1, 0x2fc6, 0x3ac9, 0x2ef7, 0x3ade, 0x2e43, 0x3aee, 0x2da7, 0x3afc, 0x2d1f, 0x3b07, 0x2ca9, 0x3b10, 0x2c42, 0x3b17, 0x2bd1, 0x3b1c, 0x2b34, 0x3b1f, 0x2aaa, 0x3b22, 0x2a31, 0x3b23, 0x29c7, 0x3b23, 0x2968,
	0x32d4, 0x3a4b, 0x32dc, 0x3a45, 0x3308, 0x3a26, 0x3378, 0x39d0, 0x3425, 0x394a, 0x34c9, 0x38be, 0x359c, 0x383e, 0x3688, 0x3796, 0x3778, 0x36c4, 0x382f, 0x3603, 0x3898, 0x3553, 0x38f7, 0x34b3, 0x394b, 0x3424, 0x3994, 0x334c, 0x39d3, 0x326c, 0x3a08, 0x31a9, 0x3a35, 0x30fe, 0x3a5a, 0x306a, 0x3a78, 0x2fd1, 0x3a90, 0x2ef1, 0x3aa2, 0x2e2e, 0x3ab0, 0x2d86, 0x3aba, 0x2cf3, 0x3ac1, 0x2c74, 0x3ac4, 0x2c05, 0x3ac4, 0x2b49, 0x3ac2, 0x2aa1, 0x3abd, 0x2a0c, 0x3ab7, 0x298b, 0x3aaf, 0x2918, 0x3aa6, 0x28b3, 0x3a9b, 0x285a,
	0x3559, 0x3954, 0x355a, 0x3951, 0x3566, 0x3944, 0x3582, 0x391e, 0x35b6, 0x38d3, 0x360a, 0x386a, 0x3684, 0x37ed, 0x3720, 0x370d, 0x37d3, 0x3641, 0x3847, 0x3588, 0x38a3, 0x34e2, 0x38fa, 0x344d, 0x3948, 0x3391, 0x398d, 0x32a6, 0x39c8, 0x31d6, 0x39fa, 0x3121, 0x3a22, 0x3082, 0x3a43, 0x2ff0, 0x3a5c, 0x2f01, 0x3a6f, 0x2e32, 0x3a7c, 0x2d7e, 0x3a84, 0x2ce2, 0x3a87, 0x2c5b, 0x3a87, 0x2bcc, 0x3a83, 0x2b00, 0x3a7b, 0x2a4e, 0x3a71, 0x29b3, 0x3a66, 0x292c, 0x3a58, 0x28b4, 0x3a4b, 0x284b, 0x3a3d, 0x27dc, 0x3a2e, 0x2739,
	0x3709, 0x387c, 0x370a, 0x387b, 0x3710, 0x3874, 0x3720, 0x385f, 0x373d, 0x3834, 0x376a, 0x37e1, 0x37ac, 0x3732, 0x3805, 0x3675, 0x383f, 0x35bc, 0x3883, 0x3511, 0x38cb, 0x3476, 0x3912, 0x33d8, 0x3955, 0x32e2, 0x3991, 0x3208, 0x39c6, 0x3149, 0x39f1, 0x30a1, 0x3a15, 0x300f, 0x3a30, 0x2f21, 0x3a44, 0x2e45, 0x3a51, 0x2d87, 0x3a59, 0x2ce2, 0x3a5b, 0x2c53, 0x3a58, 0x2bb0, 0x3a52, 0x2ada, 0x3a49, 0x2a1f, 0x3a40, 0x297d, 0x3a34, 0x28f0, 0x3a25, 0x2874, 0x3a13, 0x2807, 0x3a00, 0x274e, 0x39eb, 0x26a6, 0x39d5, 0x2611,
	0x3840, 0x3780, 0x3840, 0x377e, 0x3842, 0x3776, 0x3846, 0x375e, 0x384f, 0x372a, 0x385b, 0x36d3, 0x386c, 0x3659, 0x3885, 0x35c7, 0x38a8, 0x352d, 0x38d4, 0x3497, 0x3906, 0x340c, 0x393b, 0x331a, 0x3970, 0x323a, 0x39a0, 0x3172, 0x39cb, 0x30c3, 0x39ef, 0x302a, 0x3a0c, 0x2f4a, 0x3a21, 0x2e63, 0x3a2f, 0x2d9b, 0x3a37, 0x2ced, 0x3a39, 0x2c57, 0x3a37, 0x2baa, 0x3a34, 0x2ac9, 0x3a2c, 0x2a05, 0x3a20, 0x295d, 0x3a11, 0x28ca, 0x39ff, 0x2849, 0x39eb, 0x27b2, 0x39d5, 0x26ed, 0x39be, 0x2640, 0x39a5, 0x25aa, 0x398b, 0x2523,
	0x38e2, 0x363b, 0x38e2, 0x363b, 0x38e3, 0x3635, 0x38e6, 0x3626, 0x38ea, 0x3606, 0x38f0, 0x35cd, 0x38f8, 0x3579, 0x3903, 0x350e, 0x3915, 0x3495, 0x392d, 0x3418, 0x394c, 0x3340, 0x3970, 0x3261, 0x3995, 0x3197, 0x39b8, 0x30e4, 0x39d8, 0x3046, 0x39f3, 0x2f76, 0x3a08, 0x2e86, 0x3a16, 0x2db5, 0x3a1e, 0x2cff, 0x3a22, 0x2c61, 0x3a24, 0x2bb3, 0x3a20, 0x2ac7, 0x3a17, 0x29fc, 0x3a0a, 0x294c, 0x39fa, 0x28b2, 0x39e7, 0x282e, 0x39d1, 0x2773, 0x39b9, 0x26a9, 0x399f, 0x25fa, 0x3985, 0x255f, 0x3968, 0x24d6, 0x394a, 0x245d,
	0x396e, 0x3524, 0x396e, 0x3524, 0x396e, 0x3520, 0x396f, 0x3517, 0x3971, 0x3502, 0x3973, 0x34dd, 0x3975, 0x34a5, 0x3978, 0x3458, 0x397e, 0x33f9, 0x3987, 0x3332, 0x3997, 0x326b, 0x39aa, 0x31ac, 0x39c0, 0x30fb, 0x39d7, 0x305c, 0x39eb, 0x2f9e, 0x39fc, 0x2ea7, 0x3a07, 0x2dcf, 0x3a0f, 0x2d13, 0x3a16, 0x2c70, 0x3a17, 0x2bc4, 0x3a14, 0x2ad0, 0x3a0a, 0x29fc, 0x39fd, 0x2945, 0x39ed, 0x28a6, 0x39d9, 0x281d, 0x39c2, 0x274a, 0x39a9, 0x267c, 0x398e, 0x25c7, 0x3971, 0x2528, 0x3952, 0x249e, 0x3931, 0x2425, 0x3910, 0x2374,
	0x39e5, 0x3436, 0x39e5, 0x3435, 0x39e5, 0x3434, 0x39e5, 0x342e, 0x39e5, 0x3420, 0x39e5, 0x3408, 0x39e3, 0x33c4, 0x39e1, 0x3359, 0x39df, 0x32d3, 0x39de, 0x323a, 0x39e1, 0x319a, 0x39e7, 0x30fb, 0x39f0, 0x3065, 0x39f9, 0x2fb6, 0x3a02, 0x2ec0, 0x3a08, 0x2de6, 0x3a0d, 0x2d26, 0x3a12, 0x2c7e, 0x3a13, 0x2bda, 0x3a0e, 0x2adc, 0x3a05, 0x2a02, 0x39f8, 0x2945, 0x39e7, 0x28a1, 0x39d3, 0x2813, 0x39bc, 0x2730, 0x39a2, 0x265c, 0x3985, 0x25a3, 0x3966, 0x2501, 0x3945, 0x2475, 0x3923, 0x23f3, 0x3901, 0x231c, 0x38dd, 0x225e,
	0x3a4b, 0x32d6, 0x3a4a, 0x32d6, 0x3a4a, 0x32d4, 0x3a4a, 0x32cc, 0x3a48, 0x32bb, 0x3a47, 0x329d, 0x3a43, 0x326b, 0x3a3d, 0x3222, 0x3a36, 0x31c2, 0x3a2e, 0x314f, 0x3a28, 0x30d2, 0x3a23, 0x3052, 0x3a20, 0x2fab, 0x3a1e, 0x2ec2, 0x3a1b, 0x2def, 0x3a19, 0x2d31, 0x3a1a, 0x2c89, 0x3a18, 0x2beb, 0x3a11, 0x2aea, 0x3a07, 0x2a0a, 0x39fa, 0x2948, 0x39e9, 0x28a1, 0x39d4, 0x280f, 0x39bd, 0x2721, 0x39a2, 0x2647, 0x3985, 0x258b, 0x3964, 0x24e5, 0x3942, 0x2455, 0x391f, 0x23b3, 0x38fb, 0x22d8, 0x38d4, 0x2219, 0x38ad, 0x2172,
	0x3aa0, 0x3180, 0x3aa0, 0x3180, 0x3aa0, 0x317f, 0x3a9f, 0x317b, 0x3a9d, 0x3170, 0x3a99, 0x315d, 0x3a95, 0x313d, 0x3a8d, 0x310c, 0x3a82, 0x30ca, 0x3a76, 0x3077, 0x3a69, 0x3019, 0x3a5c, 0x2f68, 0x3a4f, 0x2e9e, 0x3a42, 0x2dde, 0x3a37, 0x2d2b, 0x3a30, 0x2c89, 0x3a29, 0x2bef, 0x3a1f, 0x2af0, 0x3a12, 0x2a0f, 0x3a03, 0x294a, 0x39f1, 0x28a0, 0x39dc, 0x280c, 0x39c5, 0x2717, 0x39a9, 0x2638, 0x398b, 0x2578, 0x396a, 0x24d0, 0x3947, 0x243f, 0x3923, 0x2380, 0x38fc, 0x22a4, 0x38d4, 0x21e4, 0x38ac, 0x213c, 0x3883, 0x20a8,
	0x3ae8, 0x3062, 0x3ae8, 0x3062, 0x3ae7, 0x3061, 0x3ae6, 0x305f, 0x3ae4, 0x305a, 0x3ae0, 0x304f, 0x3ada, 0x303b, 0x3ad1, 0x301b, 0x3ac5, 0x2fdd, 0x3ab6, 0x2f6a, 0x3aa4, 0x2ede, 0x3a91, 0x2e45, 0x3a7c, 0x2da5, 0x3a67, 0x2d0a, 0x3a57, 0x2c77, 0x3a48, 0x2bdc, 0x3a38, 0x2ae5, 0x3a27, 0x2a0a, 0x3a16, 0x2947, 0x3a02, 0x289d, 0x39eb, 0x2808, 0x39d3, 0x270d, 0x39b6, 0x262b, 0x3997, 0x256a, 0x3976, 0x24bf, 0x3952, 0x242b, 0x392d, 0x2358, 0x3904, 0x227a, 0x38db, 0x21b8, 0x38b2, 0x2110, 0x3887, 0x207d, 0x385b, 0x1ff6,
	0x3b23, 0x2ee8, 0x3b23, 0x2ee8, 0x3b22, 0x2ee8, 0x3b21, 0x2ee7, 0x3b1f, 0x2ee3, 0x3b1a, 0x2ed6, 0x3b14, 0x2ec1, 0x3b0b, 0x2e99, 0x3afe, 0x2e60, 0x3aee, 0x2e12, 0x3ad8, 0x2dad, 0x3ac1, 0x2d3d, 0x3aa5, 0x2cc3, 0x3a8b, 0x2c48, 0x3a76, 0x2ba2, 0x3a60, 0x2ac0, 0x3a49, 0x29f2, 0x3a32, 0x2938, 0x3a1b, 0x2893, 0x3a02, 0x27ff, 0x39e8, 0x26ff, 0x39ca, 0x261e, 0x39aa, 0x255b, 0x3988, 0x24b0, 0x3964, 0x241c, 0x393d, 0x2336, 0x3913, 0x2257, 0x38e9, 0x2195, 0x38be, 0x20eb, 0x3891, 0x2059, 0x3864, 0x1fae, 0x3837, 0x1ecd,
	0x3b54, 0x2d61, 0x3b54, 0x2d61, 0x3b53, 0x2d61, 0x3b52, 0x2d62, 0x3b4f, 0x2d61, 0x3b4b, 0x2d5c, 0x3b45, 0x2d51, 0x3b3b, 0x2d3d, 0x3b2e, 0x2d1a, 0x3b1d, 0x2ce7, 0x3b06, 0x2ca3, 0x3aeb, 0x2c52, 0x3acb, 0x2bee, 0x3ab0, 0x2b31, 0x3a94, 0x2a74, 0x3a77, 0x29bf, 0x3a5a, 0x2915, 0x3a3f, 0x287a, 0x3a22, 0x27de, 0x3a05, 0x26e4, 0x39e5, 0x2609, 0x39c3, 0x2547, 0x39a0, 0x249f, 0x397b, 0x240c, 0x3953, 0x2314, 0x3928, 0x2238, 0x38fd, 0x2175, 0x38d0, 0x20cb, 0x38a2, 0x2038, 0x3873, 0x1f71, 0x3844, 0x1e90, 0x3815, 0x1dce,
	0x3b7c, 0x2c22, 0x3b7c, 0x2c22, 0x3b7b, 0x2c23, 0x3b7a, 0x2c25, 0x3b77, 0x2c27, 0x3b73, 0x2c26, 0x3b6d, 0x2c23, 0x3b64, 0x2c1a, 0x3b57, 0x2c07, 0x3b46, 0x2bd1, 0x3b2e, 0x2b79, 0x3b0f, 0x2b07, 0x3aef, 0x2a86, 0x3ad1, 0x29f8, 0x3ab0, 0x2967, 0x3a8e, 0x28d7, 0x3a6d, 0x284e, 0x3a4c, 0x279f, 0x3a2b, 0x26b7, 0x3a08, 0x25e5, 0x39e4, 0x252c, 0x39be, 0x2488, 0x3998, 0x23f0, 0x396f, 0x22f2, 0x3943, 0x2215, 0x3917, 0x2155, 0x38e8, 0x20ae, 0x38b9, 0x201c, 0x3888, 0x1f38, 0x3857, 0x1e5a, 0x3826, 0x1d9a, 0x37eb, 0x1cf0,
	0x3b9c, 0x2a43, 0x3b9c, 0x2a43, 0x3b9b, 0x2a46, 0x3b9a, 0x2a4a, 0x3b98, 0x2a50, 0x3b93, 0x2a54, 0x3b8e, 0x2a59, 0x3b85, 0x2a56, 0x3b79, 0x2a45, 0x3b67, 0x2a24, 0x3b4f, 0x29ee, 0x3b2f, 0x29a4, 0x3b10, 0x294b, 0x3aef, 0x28e5, 0x3ac9, 0x2877, 0x3aa4, 0x2809, 0x3a7e, 0x2739, 0x3a59, 0x266d, 0x3a34, 0x25af, 0x3a0c, 0x2503, 0x39e4, 0x2468, 0x39bb, 0x23bb, 0x3990, 0x22c6, 0x3963, 0x21f0, 0x3936, 0x2133, 0x3906, 0x208f, 0x38d5, 0x1ffd, 0x38a3, 0x1f04, 0x3870, 0x1e28, 0x383d, 0x1d69, 0x380b, 0x1cc3, 0x37b0, 0x1c32,
	0x3bb5, 0x28aa, 0x3bb5, 0x28ab, 0x3bb5, 0x28ad, 0x3bb4, 0x28b2, 0x3bb2, 0x28b9, 0x3bae, 0x28c2, 0x3ba8, 0x28ca, 0x3ba0, 0x28d1, 0x3b94, 0x28cd, 0x3b83, 0x28c1, 0x3b6a, 0x28a3, 0x3b4b, 0x2876, 0x3b2d, 0x283d, 0x3b09, 0x27ea, 0x3ae1, 0x274b, 0x3ab9, 0x26a6, 0x3a8f, 0x25fe, 0x3a67, 0x255d, 0x3a3d, 0x24c5, 0x3a11, 0x2439, 0x39e6, 0x2371, 0x39b9, 0x228d, 0x398a, 0x21c1, 0x395a, 0x210b, 0x3929, 0x206c, 0x38f7, 0x1fc1, 0x38c3, 0x1ecb, 0x388f, 0x1df6, 0x385a, 0x1d3a, 0x3825, 0x1c99, 0x37e1, 0x1c08, 0x3779, 0x1b1b,
	0x3bc9, 0x26d3, 0x3bc9, 0x26d4, 0x3bc9, 0x26d9, 0x3bc8, 0x26e3, 0x3bc6, 0x26ef, 0x3bc2, 0x2705, 0x3bbd, 0x271a, 0x3bb6, 0x2731, 0x3baa, 0x273c, 0x3b9a, 0x273d, 0x3b81, 0x2726, 0x3b65, 0x26f7, 0x3b46, 0x26af, 0x3b20, 0x2650, 0x3af7, 0x25e1, 0x3acd, 0x256a, 0x3aa1, 0x24eb, 0x3a75, 0x246f, 0x3a46, 0x23ee, 0x3a17, 0x230d, 0x39e9, 0x223e, 0x39b7, 0x2183, 0x3985, 0x20d8, 0x3953, 0x2043, 0x391e, 0x1f7a, 0x38e9, 0x1e8d, 0x38b3, 0x1dbf, 0x387c, 0x1d0b, 0x3845, 0x1c6c, 0x380e, 0x1bc4, 0x37b0, 0x1ad2, 0x3745, 0x19fd,
	0x3bd9, 0x24e4, 0x3bd9, 0x24e5, 0x3bd9, 0x24e8, 0x3bd8, 0x24f2, 0x3bd5, 0x24fe, 0x3bd2, 0x2512, 0x3bce, 0x252b, 0x3bc6, 0x2544, 0x3bbc, 0x255a, 0x3bac, 0x256b, 0x3b93, 0x2569, 0x3b7a, 0x2557, 0x3b5b, 0x252f, 0x3b34, 0x24f7, 0x3b0c, 0x24ad, 0x3adf, 0x2458, 0x3ab1, 0x23f8, 0x3a82, 0x233f, 0x3a4f, 0x2286, 0x3a1e, 0x21d5, 0x39eb, 0x2130, 0x39b6, 0x2098, 0x3982, 0x200e, 0x394b, 0x1f25, 0x3914, 0x1e45, 0x38dc, 0x1d83, 0x38a3, 0x1cd6, 0x386b, 0x1c3d, 0x3831, 0x1b71, 0x37f2, 0x1a87, 0x3782, 0x19bc, 0x3714, 0x1909,
	0x3be5, 0x22d8, 0x3be5, 0x22d9, 0x3be4, 0x22df, 0x3be4, 0x22ef, 0x3be1, 0x2305, 0x3bde, 0x232a, 0x3bda, 0x2358, 0x3bd4, 0x2392, 0x3bcb, 0x23ca, 0x3bbb, 0x23f4, 0x3ba3, 0x2405, 0x3b8c, 0x2405, 0x3b6c, 0x23ec, 0x3b47, 0x23ae, 0x3b1d, 0x2353, 0x3af0, 0x22e2, 0x3ac0, 0x2261, 0x3a8e, 0x21d9, 0x3a5a, 0x214e, 0x3a26, 0x20c7, 0x39ee, 0x2045, 0x39b7, 0x1f97, 0x397f, 0x1eba, 0x3945, 0x1df0, 0x390b, 0x1d3a, 0x38d0, 0x1c9a, 0x3895, 0x1c0a, 0x385a, 0x1b18, 0x381f, 0x1a39, 0x37c9, 0x1975, 0x3756, 0x18cc, 0x36e6, 0x1836,
	0x3bed, 0x20a8, 0x3bed, 0x20a9, 0x3bed, 0x20ae, 0x3bed, 0x20bb, 0x3beb, 0x20cf, 0x3be8, 0x20ef, 0x3be4, 0x2119, 0x3bde, 0x214f, 0x3bd6, 0x2189, 0x3bc6, 0x21b8, 0x3bb1, 0x21de, 0x3b9a, 0x21f2, 0x3b7b, 0x21f2, 0x3b57, 0x21d8, 0x3b2d, 0x21a4, 0x3b00, 0x215f, 0x3acf, 0x2108, 0x3a99, 0x20a8, 0x3a64, 0x2043, 0x3a2c, 0x1fba, 0x39f2, 0x1ef3, 0x39b8, 0x1e36, 0x397c, 0x1d86, 0x3940, 0x1ce5, 0x3903, 0x1c52, 0x38c6, 0x1b9e, 0x3888, 0x1ab3, 0x384a, 0x19e4, 0x380e, 0x192b, 0x37a3, 0x188b, 0x372d, 0x17f7, 0x36ba, 0x1701,
	0x3bf4, 0x1e23, 0x3bf4, 0x1e25, 0x3bf4, 0x1e2d, 0x3bf3, 0x1e41, 0x3bf1, 0x1e64, 0x3bef, 0x1e9c, 0x3beb, 0x1ee1, 0x3be6, 0x1f40, 0x3bde, 0x1fa7, 0x3bce, 0x2001, 0x3bbd, 0x202f, 0x3ba6, 0x204e, 0x3b88, 0x205f, 0x3b64, 0x205b, 0x3b3b, 0x2044, 0x3b0e, 0x201f, 0x3adb, 0x1fcf, 0x3aa6, 0x1f4e, 0x3a6e, 0x1ec1, 0x3a33, 0x1e2b, 0x39f7, 0x1d95, 0x39ba, 0x1d06, 0x397b, 0x1c7d, 0x393c, 0x1bfc, 0x38fc, 0x1b13, 0x38bc, 0x1a40, 0x387c, 0x1983, 0x383c, 0x18da, 0x37fa, 0x1842, 0x377f, 0x177f, 0x3706, 0x1695, 0x3691, 0x15c8,
	0x3bf8, 0x1bca, 0x3bf8, 0x1bcc, 0x3bf8, 0x1bd8, 0x3bf8, 0x1bf7, 0x3bf6, 0x1c1b, 0x3bf4, 0x1c45, 0x3bf1, 0x1c83, 0x3bec, 0x1cce, 0x3be4, 0x1d21, 0x3bd5, 0x1d78, 0x3bc5, 0x1dd1, 0x3bb0, 0x1e17, 0x3b93, 0x1e4a, 0x3b70, 0x1e5f, 0x3b48, 0x1e57, 0x3b1b, 0x1e35, 0x3ae7, 0x1df6, 0x3ab2, 0x1da4, 0x3a77, 0x1d44, 0x3a3a, 0x1cdb, 0x39fc, 0x1c6e, 0x39bb, 0x1c03, 0x397a, 0x1b35, 0x3938, 0x1a72, 0x38f5, 0x19bb, 0x38b3, 0x1914, 0x3870, 0x187d, 0x382e, 0x17eb, 0x37db, 0x16f9, 0x375c, 0x1621, 0x36e1, 0x1565, 0x3669, 0x14be,
	0x3bfb, 0x18b9, 0x3bfb, 0x18ba, 0x3bfb, 0x18c3, 0x3bfb, 0x18da, 0x3bf9, 0x190a, 0x3bf7, 0x1948, 0x3bf5, 0x19ac, 0x3bf0, 0x1a20, 0x3be9, 0x1ab3, 0x3bdb, 0x1b49, 0x3bcd, 0x1be6, 0x3bb7, 0x1c34, 0x3b9c, 0x1c6d, 0x3b7a, 0x1c8e, 0x3b54, 0x1c9e, 0x3b26, 0x1c96, 0x3af2, 0x1c75, 0x3abc, 0x1c47, 0x3a80, 0x1c09, 0x3a42, 0x1b85, 0x3a01, 0x1aec, 0x39be, 0x1a50, 0x397a, 0x19b5, 0x3935, 0x1921, 0x38f0, 0x1895, 0x38aa, 0x1814, 0x3866, 0x173a, 0x3821, 0x1665, 0x37be, 0x15a4, 0x373c, 0x14f9, 0x36be, 0x1460, 0x3644, 0x13b3,
	0x3bfd, 0x156b, 0x3bfd, 0x156c, 0x3bfd, 0x1578, 0x3bfd, 0x1598, 0x3bfc, 0x15dd, 0x3bfa, 0x163c, 0x3bf7, 0x16cb, 0x3bf3, 0x177b, 0x3beb, 0x1833, 0x3be0, 0x18ad, 0x3bd2, 0x192e, 0x3bbd, 0x19a6, 0x3ba4, 0x1a0c, 0x3b83, 0x1a5a, 0x3b5d, 0x1a8c, 0x3b30, 0x1a9b, 0x3afd, 0x1a86, 0x3ac6, 0x1a5c, 0x3a89, 0x1a11, 0x3a49, 0x19b7, 0x3a06, 0x194f, 0x39c1, 0x18e3, 0x397a, 0x1873, 0x3933, 0x1805, 0x38eb, 0x173a, 0x38a3, 0x1676, 0x385c, 0x15bf, 0x3816, 0x1519, 0x37a2, 0x1482, 0x371d, 0x13f7, 0x369c, 0x1306, 0x3620, 0x1231,
	0x3bff, 0x11cb, 0x3bff, 0x11cd, 0x3bfe, 0x11dd, 0x3bfe, 0x1219, 0x3bfd, 0x126b, 0x3bfb, 0x12e9, 0x3bf9, 0x13c5, 0x3bf5, 0x1460, 0x3bee, 0x150f, 0x3be3, 0x15c9, 0x3bd6, 0x168a, 0x3bc3, 0x174f, 0x3baa, 0x1806, 0x3b8b, 0x184f, 0x3b66, 0x1888, 0x3b39, 0x18a6, 0x3b07, 0x18ad, 0x3acf, 0x189c, 0x3a92, 0x1876, 0x3a50, 0x1840, 0x3a0c, 0x17fd, 0x39c4, 0x176a, 0x397b, 0x16ce, 0x3931, 0x1634, 0x38e6, 0x1599, 0x389c, 0x1508, 0x3852, 0x147f, 0x380a, 0x1401, 0x3788, 0x131c, 0x36ff, 0x124a, 0x367c, 0x1190, 0x35fe, 0x10ea,
	0x3bff, 0x0daa, 0x3bff, 0x0dad, 0x3bff, 0x0dc0, 0x3bff, 0x0e0e, 0x3bfe, 0x0e87, 0x3bfc, 0x0f14, 0x3bfb, 0x1029, 0x3bf7, 0x10d1, 0x3bf0, 0x11d3, 0x3be6, 0x12c9, 0x3bd9, 0x13fc, 0x3bc7, 0x1499, 0x3bb0, 0x152a, 0x3b92, 0x15ab, 0x3b6e, 0x1615, 0x3b42, 0x165a, 0x3b10, 0x1681, 0x3ad8, 0x1683, 0x3a9a, 0x1665, 0x3a57, 0x1629, 0x3a11, 0x15dd, 0x39c8, 0x1580, 0x397c, 0x1518, 0x3930, 0x14ae, 0x38e3, 0x1441, 0x3896, 0x13b1, 0x384a, 0x12e9, 0x37ff, 0x122f, 0x376f, 0x1182, 0x36e3, 0x10e5, 0x365e, 0x1057, 0x35de, 0x0fac,
	0x3c00, 0x08ea, 0x3c00, 0x08ed, 0x3c00, 0x0902, 0x3c00, 0x0961, 0x3bff, 0x09f3, 0x3bfd, 0x0abc, 0x3bfb, 0x0c1f, 0x3bf8, 0x0d15, 0x3bf1, 0x0e5b, 0x3be8, 0x0fb4, 0x3bdc, 0x10b0, 0x3bcb, 0x1190, 0x3bb5, 0x126c, 0x3b97, 0x132c, 0x3b74, 0x13de, 0x3b4a, 0x1432, 0x3b18, 0x145e, 0x3ae0, 0x1472, 0x3aa2, 0x146f, 0x3a5f, 0x1456, 0x3a17, 0x142e, 0x39cc, 0x13ee, 0x397e, 0x136b, 0x392f, 0x12e1, 0x38df, 0x124f, 0x3890, 0x11bd, 0x3842, 0x1131, 0x37eb, 0x10ac, 0x3757, 0x102e, 0x36c9, 0x0f76, 0x3640, 0x0ea3, 0x35bf, 0x0de4,
	0x3c00, 0x039b, 0x3c00, 0x039d, 0x3c00, 0x03b2, 0x3c00, 0x041c, 0x3bff, 0x04be, 0x3bfd, 0x05d6, 0x3bfc, 0x0764, 0x3bf8, 0x08e2, 0x3bf2, 0x0a67, 0x3bea, 0x0c1b, 0x3bde, 0x0d41, 0x3bcd, 0x0e5f, 0x3bb8, 0x0f8c, 0x3b9c, 0x1057, 0x3b7a, 0x10e5, 0x3b51, 0x1155, 0x3b20, 0x11a5, 0x3ae8, 0x11da, 0x3aaa, 0x11ef, 0x3a66, 0x11e5, 0x3a1d, 0x11c1, 0x39d0, 0x1185, 0x3980, 0x113b, 0x392e, 0x10e5, 0x38dc, 0x1087, 0x388b, 0x1028, 0x383b, 0x0f94, 0x37d9, 0x0edb, 0x3741, 0x0e2c, 0x36af, 0x0d89, 0x3625, 0x0cf2, 0x35a1, 0x0c69,
	0x3c00, 0x0107, 0x3c00, 0x0108, 0x3c00, 0x0110, 0x3c00, 0x0145, 0x3bff, 0x0197, 0x3bfe, 0x0224, 0x3bfc, 0x030c, 0x3bf8, 0x0478, 0x3bf3, 0x062c, 0x3beb, 0x0833, 0x3be0, 0x0979, 0x3bd0, 0x0aeb, 0x3bbc, 0x0c3d, 0x3ba0, 0x0d01, 0x3b80, 0x0dbd, 0x3b57, 0x0e69, 0x3b27, 0x0eeb, 0x3af0, 0x0f53, 0x3ab1, 0x0f8a, 0x3a6c, 0x0f9f, 0x3a22, 0x0f8b, 0x39d4, 0x0f5b, 0x3982, 0x0f0f, 0x392f, 0x0eac, 0x38da, 0x0e3d, 0x3886, 0x0dc9, 0x3834, 0x0d51, 0x37c7, 0x0cd9, 0x372c, 0x0c65, 0x3697, 0x0bef, 0x360a, 0x0b20, 0x3585, 0x0a62,
	0x3c00, 0x0031, 0x3c00, 0x0031, 0x3c00, 0x0034, 0x3c00, 0x004b, 0x3bff, 0x006f, 0x3bfe, 0x00c9, 0x3bfc, 0x011b, 0x3bf9, 0x0207, 0x3bf4, 0x02d6, 0x3bec, 0x0415, 0x3be1, 0x0587, 0x3bd2, 0x0703, 0x3bbf, 0x087d, 0x3ba5, 0x096a, 0x3b85, 0x0a59, 0x3b5d, 0x0b32, 0x3b2e, 0x0bee, 0x3af7, 0x0c44, 0x3ab8, 0x0c7c, 0x3a73, 0x0c9c, 0x3a28, 0x0ca4, 0x39d8, 0x0c98, 0x3985, 0x0c77, 0x392f, 0x0c4a, 0x38d9, 0x0c10, 0x3882, 0x0ba0, 0x382e, 0x0b14, 0x37b6, 0x0a84, 0x3717, 0x09f5, 0x3680, 0x0969, 0x35f0, 0x08e6, 0x356a, 0x086a,
	0x3c00, 0x0004, 0x3c00, 0x0004, 0x3c00, 0x0004, 0x3c00, 0x000d, 0x3bff, 0x0021, 0x3bfe, 0x003b, 0x3bfd, 0x0070, 0x3bf9, 0x00c7, 0x3bf4, 0x012e, 0x3bed, 0x01c8, 0x3be3, 0x0274, 0x3bd4, 0x033b, 0x3bc1, 0x043a, 0x3ba8, 0x0534, 0x3b89, 0x0641, 0x3b62, 0x073b, 0x3b34, 0x0815, 0x3afd, 0x087c, 0x3abf, 0x08d0, 0x3a7a, 0x090a, 0x3a2e, 0x092c, 0x39dd, 0x0936, 0x3988, 0x0928, 0x3930, 0x0907, 0x38d7, 0x08d7, 0x387f, 0x089b, 0x3828, 0x0855, 0x37a7, 0x080b, 0x3704, 0x077b, 0x366a, 0x06e1, 0x35d8, 0x0649, 0x3550, 0x05b8,
	0x3c00, 0x0000, 0x3c00, 0x0000, 0x3c00, 0x0000, 0x3c00, 0x0003, 0x3bff, 0x0012, 0x3bfe, 0x001a, 0x3bfd, 0x0035, 0x3bfa, 0x0050, 0x3bf4, 0x0061, 0x3bed, 0x00a5, 0x3be4, 0x00ee, 0x3bd6, 0x0146, 0x3bc3, 0x01ab, 0x3bab, 0x0211, 0x3b8d, 0x028e, 0x3b67, 0x0303, 0x3b39, 0x0375, 0x3b04, 0x03e2, 0x3ac6, 0x0441, 0x3a80, 0x0492, 0x3a34, 0x04cd, 0x39e1, 0x04f2, 0x398b, 0x0504, 0x3931, 0x0502, 0x38d6, 0x04ec, 0x387c, 0x04c7, 0x3822, 0x0496, 0x3798, 0x045c, 0x36f2, 0x041a, 0x3655, 0x03d5, 0x35c1, 0x038e, 0x3537, 0x0347
] );

let lut = null;

function getDFGLUT() {

	if ( lut === null ) {

		lut = new DataTexture( DATA, 32, 32, RGFormat, HalfFloatType );
		lut.minFilter = LinearFilter;
		lut.magFilter = LinearFilter;
		lut.wrapS = ClampToEdgeWrapping;
		lut.wrapT = ClampToEdgeWrapping;
		lut.generateMipmaps = false;
		lut.needsUpdate = true;

	}

	return lut;

}

/**
 * This renderer uses WebGL 2 to display scenes.
 *
 * WebGL 1 is not supported since `r163`.
 */
class WebGLRenderer {

	/**
	 * Constructs a new WebGL renderer.
	 *
	 * @param {WebGLRenderer~Options} [parameters] - The configuration parameter.
	 */
	constructor( parameters = {} ) {

		const {
			canvas = createCanvasElement(),
			context = null,
			depth = true,
			stencil = false,
			alpha = false,
			antialias = false,
			premultipliedAlpha = true,
			preserveDrawingBuffer = false,
			powerPreference = 'default',
			failIfMajorPerformanceCaveat = false,
			reversedDepthBuffer = false,
		} = parameters;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isWebGLRenderer = true;

		let _alpha;

		if ( context !== null ) {

			if ( typeof WebGLRenderingContext !== 'undefined' && context instanceof WebGLRenderingContext ) {

				throw new Error( 'THREE.WebGLRenderer: WebGL 1 is not supported since r163.' );

			}

			_alpha = context.getContextAttributes().alpha;

		} else {

			_alpha = alpha;

		}

		const INTEGER_FORMATS = new Set( [
			RGBAIntegerFormat,
			RGIntegerFormat,
			RedIntegerFormat
		] );

		const UNSIGNED_TYPES = new Set( [
			UnsignedByteType,
			UnsignedIntType,
			UnsignedShortType,
			UnsignedInt248Type,
			UnsignedShort4444Type,
			UnsignedShort5551Type
		] );

		const uintClearColor = new Uint32Array( 4 );
		const intClearColor = new Int32Array( 4 );

		let currentRenderList = null;
		let currentRenderState = null;

		// render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its list and state isolated from the parent render call.

		const renderListStack = [];
		const renderStateStack = [];

		// public properties

		/**
		 * A canvas where the renderer draws its output.This is automatically created by the renderer
		 * in the constructor (if not provided already); you just need to add it to your page like so:
		 * ```js
		 * document.body.appendChild( renderer.domElement );
		 * ```
		 *
		 * @type {HTMLCanvasElement|OffscreenCanvas}
		 */
		this.domElement = canvas;

		/**
		 * A object with debug configuration settings.
		 *
		 * - `checkShaderErrors`: If it is `true`, defines whether material shader programs are
		 * checked for errors during compilation and linkage process. It may be useful to disable
		 * this check in production for performance gain. It is strongly recommended to keep these
		 * checks enabled during development. If the shader does not compile and link - it will not
		 * work and associated material will not render.
		 * - `onShaderError(gl, program, glVertexShader,glFragmentShader)`: A callback function that
		 * can be used for custom error reporting. The callback receives the WebGL context, an instance
		 * of WebGLProgram as well two instances of WebGLShader representing the vertex and fragment shader.
		 * Assigning a custom function disables the default error reporting.
		 *
		 * @type {Object}
		 */
		this.debug = {

			/**
			 * Enables error checking and reporting when shader programs are being compiled.
			 * @type {boolean}
			 */
			checkShaderErrors: true,
			/**
			 * Callback for custom error reporting.
			 * @type {?Function}
			 */
			onShaderError: null
		};

		// clearing

		/**
		 * Whether the renderer should automatically clear its output before rendering a frame or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.autoClear = true;

		/**
		 * If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear
		 * the color buffer or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.autoClearColor = true;

		/**
		 * If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear
		 * the depth buffer or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.autoClearDepth = true;

		/**
		 * If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear
		 * the stencil buffer or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.autoClearStencil = true;

		// scene graph

		/**
		 * Whether the renderer should sort objects or not.
		 *
		 * Note: Sorting is used to attempt to properly render objects that have some
		 * degree of transparency. By definition, sorting objects may not work in all
		 * cases. Depending on the needs of application, it may be necessary to turn
		 * off sorting and use other methods to deal with transparency rendering e.g.
		 * manually determining each object's rendering order.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.sortObjects = true;

		// user-defined clipping

		/**
		 * User-defined clipping planes specified in world space. These planes apply globally.
		 * Points in space whose dot product with the plane is negative are cut away.
		 *
		 * @type {Array<Plane>}
		 */
		this.clippingPlanes = [];

		/**
		 * Whether the renderer respects object-level clipping planes or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.localClippingEnabled = false;

		// tone mapping

		/**
		 * The tone mapping technique of the renderer.
		 *
		 * @type {(NoToneMapping|LinearToneMapping|ReinhardToneMapping|CineonToneMapping|ACESFilmicToneMapping|CustomToneMapping|AgXToneMapping|NeutralToneMapping)}
		 * @default NoToneMapping
		 */
		this.toneMapping = NoToneMapping;

		/**
		 * Exposure level of tone mapping.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.toneMappingExposure = 1.0;

		// transmission

		/**
		 * The normalized resolution scale for the transmission render target, measured in percentage
		 * of viewport dimensions. Lowering this value can result in significant performance improvements
		 * when using {@link MeshPhysicalMaterial#transmission}.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.transmissionResolutionScale = 1.0;

		// internal properties

		const _this = this;

		let _isContextLost = false;

		// internal state cache

		this._outputColorSpace = SRGBColorSpace;

		let _currentActiveCubeFace = 0;
		let _currentActiveMipmapLevel = 0;
		let _currentRenderTarget = null;
		let _currentMaterialId = -1;

		let _currentCamera = null;

		const _currentViewport = new Vector4();
		const _currentScissor = new Vector4();
		let _currentScissorTest = null;

		const _currentClearColor = new Color( 0x000000 );
		let _currentClearAlpha = 0;

		//

		let _width = canvas.width;
		let _height = canvas.height;

		let _pixelRatio = 1;
		let _opaqueSort = null;
		let _transparentSort = null;

		const _viewport = new Vector4( 0, 0, _width, _height );
		const _scissor = new Vector4( 0, 0, _width, _height );
		let _scissorTest = false;

		// frustum

		const _frustum = new Frustum();

		// clipping

		let _clippingEnabled = false;
		let _localClippingEnabled = false;

		// camera matrices cache

		const _projScreenMatrix = new Matrix4();

		const _vector3 = new Vector3();

		const _vector4 = new Vector4();

		const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

		let _renderBackground = false;

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		// initialize

		let _gl = context;

		function getContext( contextName, contextAttributes ) {

			return canvas.getContext( contextName, contextAttributes );

		}

		try {

			const contextAttributes = {
				alpha: true,
				depth,
				stencil,
				antialias,
				premultipliedAlpha,
				preserveDrawingBuffer,
				powerPreference,
				failIfMajorPerformanceCaveat,
			};

			// OffscreenCanvas does not have setAttribute, see #22811
			if ( 'setAttribute' in canvas ) canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );

			// event listeners must be registered before WebGL context is created, see #12753
			canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
			canvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );

			if ( _gl === null ) {

				const contextName = 'webgl2';

				_gl = getContext( contextName, contextAttributes );

				if ( _gl === null ) {

					if ( getContext( contextName ) ) {

						throw new Error( 'Error creating WebGL context with your selected attributes.' );

					} else {

						throw new Error( 'Error creating WebGL context.' );

					}

				}

			}

		} catch ( error ) {

			error( 'WebGLRenderer: ' + error.message );
			throw error;

		}

		let extensions, capabilities, state, info;
		let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
		let programCache, materials, renderLists, renderStates, clipping, shadowMap;

		let background, morphtargets, bufferRenderer, indexedBufferRenderer;

		let utils, bindingStates, uniformsGroups;

		function initGLContext() {

			extensions = new WebGLExtensions( _gl );
			extensions.init();

			utils = new WebGLUtils( _gl, extensions );

			capabilities = new WebGLCapabilities( _gl, extensions, parameters, utils );

			state = new WebGLState( _gl, extensions );

			if ( capabilities.reversedDepthBuffer && reversedDepthBuffer ) {

				state.buffers.depth.setReversed( true );

			}

			info = new WebGLInfo( _gl );
			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
			cubemaps = new WebGLCubeMaps( _this );
			cubeuvmaps = new WebGLCubeUVMaps( _this );
			attributes = new WebGLAttributes( _gl );
			bindingStates = new WebGLBindingStates( _gl, attributes );
			geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
			objects = new WebGLObjects( _gl, geometries, attributes, info );
			morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
			clipping = new WebGLClipping( properties );
			programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
			materials = new WebGLMaterials( _this, properties );
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates( extensions );
			background = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha );
			shadowMap = new WebGLShadowMap( _this, objects, capabilities );
			uniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );

			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info );

			info.programs = programCache.programs;

			/**
			 * Holds details about the capabilities of the current rendering context.
			 *
			 * @name WebGLRenderer#capabilities
			 * @type {WebGLRenderer~Capabilities}
			 */
			_this.capabilities = capabilities;

			/**
			 * Provides methods for retrieving and testing WebGL extensions.
			 *
			 * - `get(extensionName:string)`: Used to check whether a WebGL extension is supported
			 * and return the extension object if available.
			 * - `has(extensionName:string)`: returns `true` if the extension is supported.
			 *
			 * @name WebGLRenderer#extensions
			 * @type {Object}
			 */
			_this.extensions = extensions;

			/**
			 * Used to track properties of other objects like native WebGL objects.
			 *
			 * @name WebGLRenderer#properties
			 * @type {Object}
			 */
			_this.properties = properties;

			/**
			 * Manages the render lists of the renderer.
			 *
			 * @name WebGLRenderer#renderLists
			 * @type {Object}
			 */
			_this.renderLists = renderLists;



			/**
			 * Interface for managing shadows.
			 *
			 * @name WebGLRenderer#shadowMap
			 * @type {WebGLRenderer~ShadowMap}
			 */
			_this.shadowMap = shadowMap;

			/**
			 * Interface for managing the WebGL state.
			 *
			 * @name WebGLRenderer#state
			 * @type {Object}
			 */
			_this.state = state;

			/**
			 * Holds a series of statistical information about the GPU memory
			 * and the rendering process. Useful for debugging and monitoring.
			 *
			 * By default these data are reset at each render call but when having
			 * multiple render passes per frame (e.g. when using post processing) it can
			 * be preferred to reset with a custom pattern. First, set `autoReset` to
			 * `false`.
			 * ```js
			 * renderer.info.autoReset = false;
			 * ```
			 * Call `reset()` whenever you have finished to render a single frame.
			 * ```js
			 * renderer.info.reset();
			 * ```
			 *
			 * @name WebGLRenderer#info
			 * @type {WebGLRenderer~Info}
			 */
			_this.info = info;

		}

		initGLContext();

		// xr

		const xr = new WebXRManager( _this, _gl );

		/**
		 * A reference to the XR manager.
		 *
		 * @type {WebXRManager}
		 */
		this.xr = xr;

		/**
		 * Returns the rendering context.
		 *
		 * @return {WebGL2RenderingContext} The rendering context.
		 */
		this.getContext = function () {

			return _gl;

		};

		/**
		 * Returns the rendering context attributes.
		 *
		 * @return {WebGLContextAttributes} The rendering context attributes.
		 */
		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		/**
		 * Simulates a loss of the WebGL context. This requires support for the `WEBGL_lose_context` extension.
		 */
		this.forceContextLoss = function () {

			const extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();

		};

		/**
		 * Simulates a restore of the WebGL context. This requires support for the `WEBGL_lose_context` extension.
		 */
		this.forceContextRestore = function () {

			const extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();

		};

		/**
		 * Returns the pixel ratio.
		 *
		 * @return {number} The pixel ratio.
		 */
		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		/**
		 * Sets the given pixel ratio and resizes the canvas if necessary.
		 *
		 * @param {number} value - The pixel ratio.
		 */
		this.setPixelRatio = function ( value ) {

			if ( value === undefined ) return;

			_pixelRatio = value;

			this.setSize( _width, _height, false );

		};

		/**
		 * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
		 *
		 * @param {Vector2} target - The method writes the result in this target object.
		 * @return {Vector2} The renderer's size in logical pixels.
		 */
		this.getSize = function ( target ) {

			return target.set( _width, _height );

		};

		/**
		 * Resizes the output canvas to (width, height) with device pixel ratio taken
		 * into account, and also sets the viewport to fit that size, starting in (0,
		 * 0). Setting `updateStyle` to false prevents any style changes to the output canvas.
		 *
		 * @param {number} width - The width in logical pixels.
		 * @param {number} height - The height in logical pixels.
		 * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
		 */
		this.setSize = function ( width, height, updateStyle = true ) {

			if ( xr.isPresenting ) {

				warn( 'WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;

			}

			_width = width;
			_height = height;

			canvas.width = Math.floor( width * _pixelRatio );
			canvas.height = Math.floor( height * _pixelRatio );

			if ( updateStyle === true ) {

				canvas.style.width = width + 'px';
				canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		/**
		 * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
		 *
		 * @param {Vector2} target - The method writes the result in this target object.
		 * @return {Vector2} The drawing buffer size.
		 */
		this.getDrawingBufferSize = function ( target ) {

			return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

		};

		/**
		 * This method allows to define the drawing buffer size by specifying
		 * width, height and pixel ratio all at once. The size of the drawing
		 * buffer is computed with this formula:
		 * ```js
		 * size.x = width * pixelRatio;
		 * size.y = height * pixelRatio;
		 * ```
		 *
		 * @param {number} width - The width in logical pixels.
		 * @param {number} height - The height in logical pixels.
		 * @param {number} pixelRatio - The pixel ratio.
		 */
		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			canvas.width = Math.floor( width * pixelRatio );
			canvas.height = Math.floor( height * pixelRatio );

			this.setViewport( 0, 0, width, height );

		};

		/**
		 * Returns the current viewport definition.
		 *
		 * @param {Vector2} target - The method writes the result in this target object.
		 * @return {Vector2} The current viewport definition.
		 */
		this.getCurrentViewport = function ( target ) {

			return target.copy( _currentViewport );

		};

		/**
		 * Returns the viewport definition.
		 *
		 * @param {Vector4} target - The method writes the result in this target object.
		 * @return {Vector4} The viewport definition.
		 */
		this.getViewport = function ( target ) {

			return target.copy( _viewport );

		};

		/**
		 * Sets the viewport to render from `(x, y)` to `(x + width, y + height)`.
		 *
		 * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
		 * Or alternatively a four-component vector specifying all the parameters of the viewport.
		 * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
		 * @param {number} width - The width of the viewport in logical pixel unit.
		 * @param {number} height - The height of the viewport in logical pixel unit.
		 */
		this.setViewport = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_viewport.set( x.x, x.y, x.z, x.w );

			} else {

				_viewport.set( x, y, width, height );

			}

			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).round() );

		};

		/**
		 * Returns the scissor region.
		 *
		 * @param {Vector4} target - The method writes the result in this target object.
		 * @return {Vector4} The scissor region.
		 */
		this.getScissor = function ( target ) {

			return target.copy( _scissor );

		};

		/**
		 * Sets the scissor region to render from `(x, y)` to `(x + width, y + height)`.
		 *
		 * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the scissor region origin in logical pixel unit.
		 * Or alternatively a four-component vector specifying all the parameters of the scissor region.
		 * @param {number} y - The vertical coordinate for the lower left corner of the scissor region origin  in logical pixel unit.
		 * @param {number} width - The width of the scissor region in logical pixel unit.
		 * @param {number} height - The height of the scissor region in logical pixel unit.
		 */
		this.setScissor = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_scissor.set( x.x, x.y, x.z, x.w );

			} else {

				_scissor.set( x, y, width, height );

			}

			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).round() );

		};

		/**
		 * Returns `true` if the scissor test is enabled.
		 *
		 * @return {boolean} Whether the scissor test is enabled or not.
		 */
		this.getScissorTest = function () {

			return _scissorTest;

		};

		/**
		 * Enable or disable the scissor test. When this is enabled, only the pixels
		 * within the defined scissor area will be affected by further renderer
		 * actions.
		 *
		 * @param {boolean} boolean - Whether the scissor test is enabled or not.
		 */
		this.setScissorTest = function ( boolean ) {

			state.setScissorTest( _scissorTest = boolean );

		};

		/**
		 * Sets a custom opaque sort function for the render lists. Pass `null`
		 * to use the default `painterSortStable` function.
		 *
		 * @param {?Function} method - The opaque sort function.
		 */
		this.setOpaqueSort = function ( method ) {

			_opaqueSort = method;

		};

		/**
		 * Sets a custom transparent sort function for the render lists. Pass `null`
		 * to use the default `reversePainterSortStable` function.
		 *
		 * @param {?Function} method - The opaque sort function.
		 */
		this.setTransparentSort = function ( method ) {

			_transparentSort = method;

		};

		// Clearing

		/**
		 * Returns the clear color.
		 *
		 * @param {Color} target - The method writes the result in this target object.
		 * @return {Color} The clear color.
		 */
		this.getClearColor = function ( target ) {

			return target.copy( background.getClearColor() );

		};

		/**
		 * Sets the clear color and alpha.
		 *
		 * @param {Color} color - The clear color.
		 * @param {number} [alpha=1] - The clear alpha.
		 */
		this.setClearColor = function () {

			background.setClearColor( ...arguments );

		};

		/**
		 * Returns the clear alpha. Ranges within `[0,1]`.
		 *
		 * @return {number} The clear alpha.
		 */
		this.getClearAlpha = function () {

			return background.getClearAlpha();

		};

		/**
		 * Sets the clear alpha.
		 *
		 * @param {number} alpha - The clear alpha.
		 */
		this.setClearAlpha = function () {

			background.setClearAlpha( ...arguments );

		};

		/**
		 * Tells the renderer to clear its color, depth or stencil drawing buffer(s).
		 * This method initializes the buffers to the current clear color values.
		 *
		 * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
		 * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
		 * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
		 */
		this.clear = function ( color = true, depth = true, stencil = true ) {

			let bits = 0;

			if ( color ) {

				// check if we're trying to clear an integer target
				let isIntegerFormat = false;
				if ( _currentRenderTarget !== null ) {

					const targetFormat = _currentRenderTarget.texture.format;
					isIntegerFormat = INTEGER_FORMATS.has( targetFormat );

				}

				// use the appropriate clear functions to clear the target if it's a signed
				// or unsigned integer target
				if ( isIntegerFormat ) {

					const targetType = _currentRenderTarget.texture.type;
					const isUnsignedType = UNSIGNED_TYPES.has( targetType );

					const clearColor = background.getClearColor();
					const a = background.getClearAlpha();
					const r = clearColor.r;
					const g = clearColor.g;
					const b = clearColor.b;

					if ( isUnsignedType ) {

						uintClearColor[ 0 ] = r;
						uintClearColor[ 1 ] = g;
						uintClearColor[ 2 ] = b;
						uintClearColor[ 3 ] = a;
						_gl.clearBufferuiv( _gl.COLOR, 0, uintClearColor );

					} else {

						intClearColor[ 0 ] = r;
						intClearColor[ 1 ] = g;
						intClearColor[ 2 ] = b;
						intClearColor[ 3 ] = a;
						_gl.clearBufferiv( _gl.COLOR, 0, intClearColor );

					}

				} else {

					bits |= _gl.COLOR_BUFFER_BIT;

				}

			}

			if ( depth ) {

				bits |= _gl.DEPTH_BUFFER_BIT;

			}

			if ( stencil ) {

				bits |= _gl.STENCIL_BUFFER_BIT;
				this.state.buffers.stencil.setMask( 0xffffffff );

			}

			_gl.clear( bits );

		};

		/**
		 * Clears the color buffer. Equivalent to calling `renderer.clear( true, false, false )`.
		 */
		this.clearColor = function () {

			this.clear( true, false, false );

		};

		/**
		 * Clears the depth buffer. Equivalent to calling `renderer.clear( false, true, false )`.
		 */
		this.clearDepth = function () {

			this.clear( false, true, false );

		};

		/**
		 * Clears the stencil buffer. Equivalent to calling `renderer.clear( false, false, true )`.
		 */
		this.clearStencil = function () {

			this.clear( false, false, true );

		};

		/**
		 * Frees the GPU-related resources allocated by this instance. Call this
		 * method whenever this instance is no longer used in your app.
		 */
		this.dispose = function () {

			canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
			canvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );

			background.dispose();
			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			cubeuvmaps.dispose();
			objects.dispose();
			bindingStates.dispose();
			uniformsGroups.dispose();
			programCache.dispose();

			xr.dispose();

			xr.removeEventListener( 'sessionstart', onXRSessionStart );
			xr.removeEventListener( 'sessionend', onXRSessionEnd );

			animation.stop();

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			log( 'WebGLRenderer: Context Lost.' );

			_isContextLost = true;

		}

		function onContextRestore( /* event */ ) {

			log( 'WebGLRenderer: Context Restored.' );

			_isContextLost = false;

			const infoAutoReset = info.autoReset;
			const shadowMapEnabled = shadowMap.enabled;
			const shadowMapAutoUpdate = shadowMap.autoUpdate;
			const shadowMapNeedsUpdate = shadowMap.needsUpdate;
			const shadowMapType = shadowMap.type;

			initGLContext();

			info.autoReset = infoAutoReset;
			shadowMap.enabled = shadowMapEnabled;
			shadowMap.autoUpdate = shadowMapAutoUpdate;
			shadowMap.needsUpdate = shadowMapNeedsUpdate;
			shadowMap.type = shadowMapType;

		}

		function onContextCreationError( event ) {

			error( 'WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );

		}

		function onMaterialDispose( event ) {

			const material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateMaterial( material ) {

			releaseMaterialProgramReferences( material );

			properties.remove( material );

		}


		function releaseMaterialProgramReferences( material ) {

			const programs = properties.get( material ).programs;

			if ( programs !== undefined ) {

				programs.forEach( function ( program ) {

					programCache.releaseProgram( program );

				} );

				if ( material.isShaderMaterial ) {

					programCache.releaseShaderCache( material );

				}

			}

		}

		// Buffer rendering

		this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

			if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

			const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

			const program = setProgram( camera, scene, geometry, material, object );

			state.setMaterial( material, frontFaceCW );

			//

			let index = geometry.index;
			let rangeFactor = 1;

			if ( material.wireframe === true ) {

				index = geometries.getWireframeAttribute( geometry );

				if ( index === undefined ) return;

				rangeFactor = 2;

			}

			//

			const drawRange = geometry.drawRange;
			const position = geometry.attributes.position;

			let drawStart = drawRange.start * rangeFactor;
			let drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;

			if ( group !== null ) {

				drawStart = Math.max( drawStart, group.start * rangeFactor );
				drawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );

			}

			if ( index !== null ) {

				drawStart = Math.max( drawStart, 0 );
				drawEnd = Math.min( drawEnd, index.count );

			} else if ( position !== undefined && position !== null ) {

				drawStart = Math.max( drawStart, 0 );
				drawEnd = Math.min( drawEnd, position.count );

			}

			const drawCount = drawEnd - drawStart;

			if ( drawCount < 0 || drawCount === Infinity ) return;

			//

			bindingStates.setup( object, material, program, geometry, index );

			let attribute;
			let renderer = bufferRenderer;

			if ( index !== null ) {

				attribute = attributes.get( index );

				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );

			}

			//

			if ( object.isMesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( _gl.LINES );

				} else {

					renderer.setMode( _gl.TRIANGLES );

				}

			} else if ( object.isLine ) {

				let lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * getTargetPixelRatio() );

				if ( object.isLineSegments ) {

					renderer.setMode( _gl.LINES );

				} else if ( object.isLineLoop ) {

					renderer.setMode( _gl.LINE_LOOP );

				} else {

					renderer.setMode( _gl.LINE_STRIP );

				}

			} else if ( object.isPoints ) {

				renderer.setMode( _gl.POINTS );

			} else if ( object.isSprite ) {

				renderer.setMode( _gl.TRIANGLES );

			}

			if ( object.isBatchedMesh ) {

				if ( object._multiDrawInstances !== null ) {

					// @deprecated, r174
					warnOnce( 'WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.' );
					renderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );

				} else {

					if ( ! extensions.get( 'WEBGL_multi_draw' ) ) {

						const starts = object._multiDrawStarts;
						const counts = object._multiDrawCounts;
						const drawCount = object._multiDrawCount;
						const bytesPerElement = index ? attributes.get( index ).bytesPerElement : 1;
						const uniforms = properties.get( material ).currentProgram.getUniforms();
						for ( let i = 0; i < drawCount; i ++ ) {

							uniforms.setValue( _gl, '_gl_DrawID', i );
							renderer.render( starts[ i ] / bytesPerElement, counts[ i ] );

						}

					} else {

						renderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );

					}

				}

			} else if ( object.isInstancedMesh ) {

				renderer.renderInstances( drawStart, drawCount, object.count );

			} else if ( geometry.isInstancedBufferGeometry ) {

				const maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;
				const instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );

				renderer.renderInstances( drawStart, drawCount, instanceCount );

			} else {

				renderer.render( drawStart, drawCount );

			}

		};

		// Compile

		function prepareMaterial( material, scene, object ) {

			if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

				material.side = BackSide;
				material.needsUpdate = true;
				getProgram( material, scene, object );

				material.side = FrontSide;
				material.needsUpdate = true;
				getProgram( material, scene, object );

				material.side = DoubleSide;

			} else {

				getProgram( material, scene, object );

			}

		}

		/**
		 * Compiles all materials in the scene with the camera. This is useful to precompile shaders
		 * before the first rendering. If you want to add a 3D object to an existing scene, use the third
		 * optional parameter for applying the target scene.
		 *
		 * Note that the (target) scene's lighting and environment must be configured before calling this method.
		 *
		 * @param {Object3D} scene - The scene or another type of 3D object to precompile.
		 * @param {Camera} camera - The camera.
		 * @param {?Scene} [targetScene=null] - The target scene.
		 * @return {Set<Material>} The precompiled materials.
		 */
		this.compile = function ( scene, camera, targetScene = null ) {

			if ( targetScene === null ) targetScene = scene;

			currentRenderState = renderStates.get( targetScene );
			currentRenderState.init( camera );

			renderStateStack.push( currentRenderState );

			// gather lights from both the target scene and the new object that will be added to the scene.

			targetScene.traverseVisible( function ( object ) {

				if ( object.isLight && object.layers.test( camera.layers ) ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				}

			} );

			if ( scene !== targetScene ) {

				scene.traverseVisible( function ( object ) {

					if ( object.isLight && object.layers.test( camera.layers ) ) {

						currentRenderState.pushLight( object );

						if ( object.castShadow ) {

							currentRenderState.pushShadow( object );

						}

					}

				} );

			}

			currentRenderState.setupLights();

			// Only initialize materials in the new scene, not the targetScene.

			const materials = new Set();

			scene.traverse( function ( object ) {

				if ( ! ( object.isMesh || object.isPoints || object.isLine || object.isSprite ) ) {

					return;

				}

				const material = object.material;

				if ( material ) {

					if ( Array.isArray( material ) ) {

						for ( let i = 0; i < material.length; i ++ ) {

							const material2 = material[ i ];

							prepareMaterial( material2, targetScene, object );
							materials.add( material2 );

						}

					} else {

						prepareMaterial( material, targetScene, object );
						materials.add( material );

					}

				}

			} );

			currentRenderState = renderStateStack.pop();

			return materials;

		};

		// compileAsync

		/**
		 * Asynchronous version of {@link WebGLRenderer#compile}.
		 *
		 * This method makes use of the `KHR_parallel_shader_compile` WebGL extension. Hence,
		 * it is recommended to use this version of `compile()` whenever possible.
		 *
		 * @async
		 * @param {Object3D} scene - The scene or another type of 3D object to precompile.
		 * @param {Camera} camera - The camera.
		 * @param {?Scene} [targetScene=null] - The target scene.
		 * @return {Promise} A Promise that resolves when the given scene can be rendered without unnecessary stalling due to shader compilation.
		 */
		this.compileAsync = function ( scene, camera, targetScene = null ) {

			const materials = this.compile( scene, camera, targetScene );

			// Wait for all the materials in the new object to indicate that they're
			// ready to be used before resolving the promise.

			return new Promise( ( resolve ) => {

				function checkMaterialsReady() {

					materials.forEach( function ( material ) {

						const materialProperties = properties.get( material );
						const program = materialProperties.currentProgram;

						if ( program.isReady() ) {

							// remove any programs that report they're ready to use from the list
							materials.delete( material );

						}

					} );

					// once the list of compiling materials is empty, call the callback

					if ( materials.size === 0 ) {

						resolve( scene );
						return;

					}

					// if some materials are still not ready, wait a bit and check again

					setTimeout( checkMaterialsReady, 10 );

				}

				if ( extensions.get( 'KHR_parallel_shader_compile' ) !== null ) {

					// If we can check the compilation status of the materials without
					// blocking then do so right away.

					checkMaterialsReady();

				} else {

					// Otherwise start by waiting a bit to give the materials we just
					// initialized a chance to finish.

					setTimeout( checkMaterialsReady, 10 );

				}

			} );

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time ) {

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		function onXRSessionStart() {

			animation.stop();

		}

		function onXRSessionEnd() {

			animation.start();

		}

		const animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		if ( typeof self !== 'undefined' ) animation.setContext( self );

		/**
		 * Applications are advised to always define the animation loop
		 * with this method and not manually with `requestAnimationFrame()`
		 * for best compatibility.
		 *
		 * @param {?onAnimationCallback} callback - The application's animation loop.
		 */
		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;
			xr.setAnimationLoop( callback );

			( callback === null ) ? animation.stop() : animation.start();

		};

		xr.addEventListener( 'sessionstart', onXRSessionStart );
		xr.addEventListener( 'sessionend', onXRSessionEnd );

		// Rendering

		/**
		 * Renders the given scene (or other type of 3D object) using the given camera.
		 *
		 * The render is done to a previously specified render target set by calling {@link WebGLRenderer#setRenderTarget}
		 * or to the canvas as usual.
		 *
		 * By default render buffers are cleared before rendering but you can prevent
		 * this by setting the property `autoClear` to `false`. If you want to prevent
		 * only certain buffers being cleared you can `autoClearColor`, `autoClearDepth`
		 * or `autoClearStencil` to `false`. To force a clear, use {@link WebGLRenderer#clear}.
		 *
		 * @param {Object3D} scene - The scene to render.
		 * @param {Camera} camera - The camera.
		 */
		this.render = function ( scene, camera ) {

			if ( camera !== undefined && camera.isCamera !== true ) {

				error( 'WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			if ( _isContextLost === true ) return;

			// update scene graph

			if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

			if ( xr.enabled === true && xr.isPresenting === true ) {

				if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

				camera = xr.getCamera(); // use XR camera for rendering

			}

			//
			if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

			currentRenderState = renderStates.get( scene, renderStateStack.length );
			currentRenderState.init( camera );

			renderStateStack.push( currentRenderState );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromProjectionMatrix( _projScreenMatrix, WebGLCoordinateSystem, camera.reversedDepth );

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled );

			currentRenderList = renderLists.get( scene, renderListStack.length );
			currentRenderList.init();

			renderListStack.push( currentRenderList );

			if ( xr.enabled === true && xr.isPresenting === true ) {

				const depthSensingMesh = _this.xr.getDepthSensingMesh();

				if ( depthSensingMesh !== null ) {

					projectObject( depthSensingMesh, camera, - Infinity, _this.sortObjects );

				}

			}

			projectObject( scene, camera, 0, _this.sortObjects );

			currentRenderList.finish();

			if ( _this.sortObjects === true ) {

				currentRenderList.sort( _opaqueSort, _transparentSort );

			}

			_renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
			if ( _renderBackground ) {

				background.addToRenderList( currentRenderList, scene );

			}

			//

			this.info.render.frame ++;

			if ( _clippingEnabled === true ) clipping.beginShadows();

			const shadowsArray = currentRenderState.state.shadowsArray;

			shadowMap.render( shadowsArray, scene, camera );

			if ( _clippingEnabled === true ) clipping.endShadows();

			//

			if ( this.info.autoReset === true ) this.info.reset();

			// render scene

			const opaqueObjects = currentRenderList.opaque;
			const transmissiveObjects = currentRenderList.transmissive;

			currentRenderState.setupLights();

			if ( camera.isArrayCamera ) {

				const cameras = camera.cameras;

				if ( transmissiveObjects.length > 0 ) {

					for ( let i = 0, l = cameras.length; i < l; i ++ ) {

						const camera2 = cameras[ i ];

						renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera2 );

					}

				}

				if ( _renderBackground ) background.render( scene );

				for ( let i = 0, l = cameras.length; i < l; i ++ ) {

					const camera2 = cameras[ i ];

					renderScene( currentRenderList, scene, camera2, camera2.viewport );

				}

			} else {

				if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera );

				if ( _renderBackground ) background.render( scene );

				renderScene( currentRenderList, scene, camera );

			}

			//

			if ( _currentRenderTarget !== null && _currentActiveMipmapLevel === 0 ) {

				// resolve multisample renderbuffers to a single-sample texture if necessary

				textures.updateMultisampleRenderTarget( _currentRenderTarget );

				// Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap( _currentRenderTarget );

			}

			//

			if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

			// _gl.finish();

			bindingStates.resetDefaultState();
			_currentMaterialId = -1;
			_currentCamera = null;

			renderStateStack.pop();

			if ( renderStateStack.length > 0 ) {

				currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

				if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, currentRenderState.state.camera );

			} else {

				currentRenderState = null;

			}

			renderListStack.pop();

			if ( renderListStack.length > 0 ) {

				currentRenderList = renderListStack[ renderListStack.length - 1 ];

			} else {

				currentRenderList = null;

			}

		};

		function projectObject( object, camera, groupOrder, sortObjects ) {

			if ( object.visible === false ) return;

			const visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isGroup ) {

					groupOrder = object.renderOrder;

				} else if ( object.isLOD ) {

					if ( object.autoUpdate === true ) object.update( camera );

				} else if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						if ( sortObjects ) {

							_vector4.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						const geometry = objects.update( object );
						const material = object.material;

						if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector4.z, null );

						}

					}

				} else if ( object.isMesh || object.isLine || object.isPoints ) {

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						const geometry = objects.update( object );
						const material = object.material;

						if ( sortObjects ) {

							if ( object.boundingSphere !== undefined ) {

								if ( object.boundingSphere === null ) object.computeBoundingSphere();
								_vector4.copy( object.boundingSphere.center );

							} else {

								if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
								_vector4.copy( geometry.boundingSphere.center );

							}

							_vector4
								.applyMatrix4( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						if ( Array.isArray( material ) ) {

							const groups = geometry.groups;

							for ( let i = 0, l = groups.length; i < l; i ++ ) {

								const group = groups[ i ];
								const groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group );

								}

							}

						} else if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector4.z, null );

						}

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera, groupOrder, sortObjects );

			}

		}

		function renderScene( currentRenderList, scene, camera, viewport ) {

			const { opaque: opaqueObjects, transmissive: transmissiveObjects, transparent: transparentObjects } = currentRenderList;

			currentRenderState.setupLightsView( camera );

			if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );

			if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );

			if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
			if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
			if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			state.setPolygonOffset( false );

		}

		function renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera ) {

			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			if ( overrideMaterial !== null ) {

				return;

			}

			if ( currentRenderState.state.transmissionRenderTarget[ camera.id ] === undefined ) {

				currentRenderState.state.transmissionRenderTarget[ camera.id ] = new WebGLRenderTarget( 1, 1, {
					generateMipmaps: true,
					type: ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) ) ? HalfFloatType : UnsignedByteType,
					minFilter: LinearMipmapLinearFilter,
					samples: 4,
					stencilBuffer: stencil,
					resolveDepthBuffer: false,
					resolveStencilBuffer: false,
					colorSpace: ColorManagement.workingColorSpace,
				} );

				// debug

				/*
				const geometry = new PlaneGeometry();
				const material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );

				const mesh = new Mesh( geometry, material );
				scene.add( mesh );
				*/

			}

			const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[ camera.id ];

			const activeViewport = camera.viewport || _currentViewport;
			transmissionRenderTarget.setSize( activeViewport.z * _this.transmissionResolutionScale, activeViewport.w * _this.transmissionResolutionScale );

			//

			const currentRenderTarget = _this.getRenderTarget();
			const currentActiveCubeFace = _this.getActiveCubeFace();
			const currentActiveMipmapLevel = _this.getActiveMipmapLevel();

			_this.setRenderTarget( transmissionRenderTarget );

			_this.getClearColor( _currentClearColor );
			_currentClearAlpha = _this.getClearAlpha();
			if ( _currentClearAlpha < 1 ) _this.setClearColor( 0xffffff, 0.5 );

			_this.clear();

			if ( _renderBackground ) background.render( scene );

			// Turn off the features which can affect the frag color for opaque objects pass.
			// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
			const currentToneMapping = _this.toneMapping;
			_this.toneMapping = NoToneMapping;

			// Remove viewport from camera to avoid nested render calls resetting viewport to it (e.g Reflector).
			// Transmission render pass requires viewport to match the transmissionRenderTarget.
			const currentCameraViewport = camera.viewport;
			if ( camera.viewport !== undefined ) camera.viewport = undefined;

			currentRenderState.setupLightsView( camera );

			if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );

			renderObjects( opaqueObjects, scene, camera );

			textures.updateMultisampleRenderTarget( transmissionRenderTarget );
			textures.updateRenderTargetMipmap( transmissionRenderTarget );

			if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === false ) { // see #28131

				let renderTargetNeedsUpdate = false;

				for ( let i = 0, l = transmissiveObjects.length; i < l; i ++ ) {

					const renderItem = transmissiveObjects[ i ];

					const { object, geometry, material, group } = renderItem;

					if ( material.side === DoubleSide && object.layers.test( camera.layers ) ) {

						const currentSide = material.side;

						material.side = BackSide;
						material.needsUpdate = true;

						renderObject( object, scene, camera, geometry, material, group );

						material.side = currentSide;
						material.needsUpdate = true;

						renderTargetNeedsUpdate = true;

					}

				}

				if ( renderTargetNeedsUpdate === true ) {

					textures.updateMultisampleRenderTarget( transmissionRenderTarget );
					textures.updateRenderTargetMipmap( transmissionRenderTarget );

				}

			}

			_this.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );

			_this.setClearColor( _currentClearColor, _currentClearAlpha );

			if ( currentCameraViewport !== undefined ) camera.viewport = currentCameraViewport;

			_this.toneMapping = currentToneMapping;

		}

		function renderObjects( renderList, scene, camera ) {

			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			for ( let i = 0, l = renderList.length; i < l; i ++ ) {

				const renderItem = renderList[ i ];

				const { object, geometry, group } = renderItem;
				let material = renderItem.material;

				if ( material.allowOverride === true && overrideMaterial !== null ) {

					material = overrideMaterial;

				}

				if ( object.layers.test( camera.layers ) ) {

					renderObject( object, scene, camera, geometry, material, group );

				}

			}

		}

		function renderObject( object, scene, camera, geometry, material, group ) {

			object.onBeforeRender( _this, scene, camera, geometry, material, group );

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			material.onBeforeRender( _this, scene, camera, geometry, object, group );

			if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

				material.side = BackSide;
				material.needsUpdate = true;
				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

				material.side = FrontSide;
				material.needsUpdate = true;
				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

				material.side = DoubleSide;

			} else {

				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );

		}

		function getProgram( material, scene, object ) {

			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			const materialProperties = properties.get( material );

			const lights = currentRenderState.state.lights;
			const shadowsArray = currentRenderState.state.shadowsArray;

			const lightsStateVersion = lights.state.version;

			const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
			const programCacheKey = programCache.getProgramCacheKey( parameters );

			let programs = materialProperties.programs;

			// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );
			materialProperties.envMapRotation = ( materialProperties.environment !== null && material.envMap === null ) ? scene.environmentRotation : material.envMapRotation;

			if ( programs === undefined ) {

				// new material

				material.addEventListener( 'dispose', onMaterialDispose );

				programs = new Map();
				materialProperties.programs = programs;

			}

			let program = programs.get( programCacheKey );

			if ( program !== undefined ) {

				// early out if program and light state is identical

				if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

					updateCommonMaterialProperties( material, parameters );

					return program;

				}

			} else {

				parameters.uniforms = programCache.getUniforms( material );

				material.onBeforeCompile( parameters, _this );

				program = programCache.acquireProgram( parameters, programCacheKey );
				programs.set( programCacheKey, program );

				materialProperties.uniforms = parameters.uniforms;

			}

			const uniforms = materialProperties.uniforms;

			if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

				uniforms.clippingPlanes = clipping.uniform;

			}

			updateCommonMaterialProperties( material, parameters );

			// store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights( material );
			materialProperties.lightsStateVersion = lightsStateVersion;

			if ( materialProperties.needsLights ) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
				uniforms.spotLightMap.value = lights.state.spotLightMap;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			materialProperties.currentProgram = program;
			materialProperties.uniformsList = null;

			return program;

		}

		function getUniformList( materialProperties ) {

			if ( materialProperties.uniformsList === null ) {

				const progUniforms = materialProperties.currentProgram.getUniforms();
				materialProperties.uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, materialProperties.uniforms );

			}

			return materialProperties.uniformsList;

		}

		function updateCommonMaterialProperties( material, parameters ) {

			const materialProperties = properties.get( material );

			materialProperties.outputColorSpace = parameters.outputColorSpace;
			materialProperties.batching = parameters.batching;
			materialProperties.batchingColor = parameters.batchingColor;
			materialProperties.instancing = parameters.instancing;
			materialProperties.instancingColor = parameters.instancingColor;
			materialProperties.instancingMorph = parameters.instancingMorph;
			materialProperties.skinning = parameters.skinning;
			materialProperties.morphTargets = parameters.morphTargets;
			materialProperties.morphNormals = parameters.morphNormals;
			materialProperties.morphColors = parameters.morphColors;
			materialProperties.morphTargetsCount = parameters.morphTargetsCount;
			materialProperties.numClippingPlanes = parameters.numClippingPlanes;
			materialProperties.numIntersection = parameters.numClipIntersection;
			materialProperties.vertexAlphas = parameters.vertexAlphas;
			materialProperties.vertexTangents = parameters.vertexTangents;
			materialProperties.toneMapping = parameters.toneMapping;

		}

		function setProgram( camera, scene, geometry, material, object ) {

			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits();

			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const colorSpace = ( _currentRenderTarget === null ) ? _this.outputColorSpace : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace );
			const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
			const vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;
			const vertexTangents = !! geometry.attributes.tangent && ( !! material.normalMap || material.anisotropy > 0 );
			const morphTargets = !! geometry.morphAttributes.position;
			const morphNormals = !! geometry.morphAttributes.normal;
			const morphColors = !! geometry.morphAttributes.color;

			let toneMapping = NoToneMapping;

			if ( material.toneMapped ) {

				if ( _currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true ) {

					toneMapping = _this.toneMapping;

				}

			}

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

			const materialProperties = properties.get( material );
			const lights = currentRenderState.state.lights;

			if ( _clippingEnabled === true ) {

				if ( _localClippingEnabled === true || camera !== _currentCamera ) {

					const useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					clipping.setState( material, camera, useCache );

				}

			}

			//

			let needsProgramChange = false;

			if ( material.version === materialProperties.__version ) {

				if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

					needsProgramChange = true;

				} else if ( materialProperties.outputColorSpace !== colorSpace ) {

					needsProgramChange = true;

				} else if ( object.isBatchedMesh && materialProperties.batching === false ) {

					needsProgramChange = true;

				} else if ( ! object.isBatchedMesh && materialProperties.batching === true ) {

					needsProgramChange = true;

				} else if ( object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null ) {

					needsProgramChange = true;

				} else if ( object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

					needsProgramChange = true;

				} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

					needsProgramChange = true;

				} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

					needsProgramChange = true;

				} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null ) {

					needsProgramChange = true;

				} else if ( materialProperties.envMap !== envMap ) {

					needsProgramChange = true;

				} else if ( material.fog === true && materialProperties.fog !== fog ) {

					needsProgramChange = true;

				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== clipping.numPlanes ||
					materialProperties.numIntersection !== clipping.numIntersection ) ) {

					needsProgramChange = true;

				} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

					needsProgramChange = true;

				} else if ( materialProperties.vertexTangents !== vertexTangents ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphTargets !== morphTargets ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphNormals !== morphNormals ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphColors !== morphColors ) {

					needsProgramChange = true;

				} else if ( materialProperties.toneMapping !== toneMapping ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphTargetsCount !== morphTargetsCount ) {

					needsProgramChange = true;

				}

			} else {

				needsProgramChange = true;
				materialProperties.__version = material.version;

			}

			//

			let program = materialProperties.currentProgram;

			if ( needsProgramChange === true ) {

				program = getProgram( material, scene, object );

			}

			let refreshProgram = false;
			let refreshMaterial = false;
			let refreshLights = false;

			const p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.uniforms;

			if ( state.useProgram( program.program ) ) {

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || _currentCamera !== camera ) {

				// common camera uniforms

				const reversedDepthBuffer = state.buffers.depth.getReversed();

				if ( reversedDepthBuffer && camera.reversedDepth !== true ) {

					camera._reversedDepth = true;
					camera.updateProjectionMatrix();

				}

				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

				const uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl, _vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

				if ( capabilities.logarithmicDepthBuffer ) {

					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}

				// consider moving isOrthographic to UniformLib and WebGLMaterials, see https://github.com/mrdoob/three.js/pull/26467#issuecomment-1645185067

				if ( material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ) {

					p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

				}

				if ( _currentCamera !== camera ) {

					_currentCamera = camera;

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

			}

			// skinning and morph target uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone and morph texture must go before other textures
			// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

			if ( object.isSkinnedMesh ) {

				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

				const skeleton = object.skeleton;

				if ( skeleton ) {

					if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );

				}

			}

			if ( object.isBatchedMesh ) {

				p_uniforms.setOptional( _gl, object, 'batchingTexture' );
				p_uniforms.setValue( _gl, 'batchingTexture', object._matricesTexture, textures );

				p_uniforms.setOptional( _gl, object, 'batchingIdTexture' );
				p_uniforms.setValue( _gl, 'batchingIdTexture', object._indirectTexture, textures );

				p_uniforms.setOptional( _gl, object, 'batchingColorTexture' );
				if ( object._colorsTexture !== null ) {

					p_uniforms.setValue( _gl, 'batchingColorTexture', object._colorsTexture, textures );

				}

			}

			const morphAttributes = geometry.morphAttributes;

			if ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined ) ) {

				morphtargets.update( object, geometry, program );

			}

			if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

			}

			// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512

			if ( material.isMeshGouraudMaterial && material.envMap !== null ) {

				m_uniforms.envMap.value = envMap;

				m_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? -1 : 1;

			}

			if ( material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null ) {

				m_uniforms.envMapIntensity.value = scene.environmentIntensity;

			}

			// Set DFG LUT for physically-based materials
			if ( m_uniforms.dfgLUT !== undefined ) {

				m_uniforms.dfgLUT.value = getDFGLUT();

			}

			if ( refreshMaterial ) {

				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

				if ( materialProperties.needsLights ) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

				}

				// refresh uniforms common to several materials

				if ( fog && material.fog === true ) {

					materials.refreshFogUniforms( m_uniforms, fog );

				}

				materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[ camera.id ] );

				WebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );

			}

			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

				WebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );
				material.uniformsNeedUpdate = false;

			}

			if ( material.isSpriteMaterial ) {

				p_uniforms.setValue( _gl, 'center', object.center );

			}

			// common matrices

			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

			// UBOs

			if ( material.isShaderMaterial || material.isRawShaderMaterial ) {

				const groups = material.uniformsGroups;

				for ( let i = 0, l = groups.length; i < l; i ++ ) {

					const group = groups[ i ];

					uniformsGroups.update( group, program );
					uniformsGroups.bind( group, program );

				}

			}

			return program;

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		function materialNeedsLights( material ) {

			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial || material.isShadowMaterial ||
				( material.isShaderMaterial && material.lights === true );

		}

		/**
		 * Returns the active cube face.
		 *
		 * @return {number} The active cube face.
		 */
		this.getActiveCubeFace = function () {

			return _currentActiveCubeFace;

		};

		/**
		 * Returns the active mipmap level.
		 *
		 * @return {number} The active mipmap level.
		 */
		this.getActiveMipmapLevel = function () {

			return _currentActiveMipmapLevel;

		};

		/**
		 * Returns the active render target.
		 *
		 * @return {?WebGLRenderTarget} The active render target. Returns `null` if no render target
		 * is currently set.
		 */
		this.getRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {

			const renderTargetProperties = properties.get( renderTarget );

			renderTargetProperties.__autoAllocateDepthBuffer = renderTarget.resolveDepthBuffer === false;
			if ( renderTargetProperties.__autoAllocateDepthBuffer === false ) {

				// The multisample_render_to_texture extension doesn't work properly if there
				// are midframe flushes and an external depth buffer. Disable use of the extension.
				renderTargetProperties.__useRenderToTexture = false;

			}

			properties.get( renderTarget.texture ).__webglTexture = colorTexture;
			properties.get( renderTarget.depthTexture ).__webglTexture = renderTargetProperties.__autoAllocateDepthBuffer ? undefined : depthTexture;

			renderTargetProperties.__hasExternalTextures = true;

		};

		this.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {

			const renderTargetProperties = properties.get( renderTarget );
			renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
			renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;

		};

		const _scratchFrameBuffer = _gl.createFramebuffer();

		/**
		 * Sets the active rendertarget.
		 *
		 * @param {?WebGLRenderTarget} renderTarget - The render target to set. When `null` is given,
		 * the canvas is set as the active render target instead.
		 * @param {number} [activeCubeFace=0] - The active cube face when using a cube render target.
		 * Indicates the z layer to render in to when using 3D or array render targets.
		 * @param {number} [activeMipmapLevel=0] - The active mipmap level.
		 */
		this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;

			let useDefaultFramebuffer = true;
			let framebuffer = null;
			let isCube = false;
			let isRenderTarget3D = false;

			if ( renderTarget ) {

				const renderTargetProperties = properties.get( renderTarget );

				if ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {

					// We need to make sure to rebind the framebuffer.
					state.bindFramebuffer( _gl.FRAMEBUFFER, null );
					useDefaultFramebuffer = false;

				} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {

					textures.setupRenderTarget( renderTarget );

				} else if ( renderTargetProperties.__hasExternalTextures ) {

					// Color and depth texture must be rebound in order for the swapchain to update.
					textures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );

				} else if ( renderTarget.depthBuffer ) {

					// check if the depth texture is already bound to the frame buffer and that it's been initialized
					const depthTexture = renderTarget.depthTexture;
					if ( renderTargetProperties.__boundDepthTexture !== depthTexture ) {

						// check if the depth texture is compatible
						if (
							depthTexture !== null &&
							properties.has( depthTexture ) &&
							( renderTarget.width !== depthTexture.image.width || renderTarget.height !== depthTexture.image.height )
						) {

							throw new Error( 'WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.' );

						}

						// Swap the depth buffer to the currently attached one
						textures.setupDepthRenderbuffer( renderTarget );

					}

				}

				const texture = renderTarget.texture;

				if ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

					isRenderTarget3D = true;

				}

				const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLCubeRenderTarget ) {

					if ( Array.isArray( __webglFramebuffer[ activeCubeFace ] ) ) {

						framebuffer = __webglFramebuffer[ activeCubeFace ][ activeMipmapLevel ];

					} else {

						framebuffer = __webglFramebuffer[ activeCubeFace ];

					}

					isCube = true;

				} else if ( ( renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {

					framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

				} else {

					if ( Array.isArray( __webglFramebuffer ) ) {

						framebuffer = __webglFramebuffer[ activeMipmapLevel ];

					} else {

						framebuffer = __webglFramebuffer;

					}

				}

				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;

			} else {

				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
				_currentScissorTest = _scissorTest;

			}

			// Use a scratch frame buffer if rendering to a mip level to avoid depth buffers
			// being bound that are different sizes.
			if ( activeMipmapLevel !== 0 ) {

				framebuffer = _scratchFrameBuffer;

			}

			const framebufferBound = state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			if ( framebufferBound && useDefaultFramebuffer ) {

				state.drawBuffers( renderTarget, framebuffer );

			}

			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );

			if ( isCube ) {

				const textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

			} else if ( isRenderTarget3D ) {

				const layer = activeCubeFace;

				for ( let i = 0; i < renderTarget.textures.length; i ++ ) {

					const textureProperties = properties.get( renderTarget.textures[ i ] );

					_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, textureProperties.__webglTexture, activeMipmapLevel, layer );

				}

			} else if ( renderTarget !== null && activeMipmapLevel !== 0 ) {

				// Only bind the frame buffer if we are using a scratch frame buffer to render to a mipmap.
				// If we rebind the texture when using a multi sample buffer then an error about inconsistent samples will be thrown.
				const textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, textureProperties.__webglTexture, activeMipmapLevel );

			}

			_currentMaterialId = -1; // reset current material to ensure correct uniform bindings

		};

		/**
		 * Reads the pixel data from the given render target into the given buffer.
		 *
		 * @param {WebGLRenderTarget} renderTarget - The render target to read from.
		 * @param {number} x - The `x` coordinate of the copy region's origin.
		 * @param {number} y - The `y` coordinate of the copy region's origin.
		 * @param {number} width - The width of the copy region.
		 * @param {number} height - The height of the copy region.
		 * @param {TypedArray} buffer - The result buffer.
		 * @param {number} [activeCubeFaceIndex] - The active cube face index.
		 * @param {number} [textureIndex=0] - The texture index of an MRT render target.
		 */
		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex, textureIndex = 0 ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				error( 'WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

				framebuffer = framebuffer[ activeCubeFaceIndex ];

			}

			if ( framebuffer ) {

				state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				try {

					const texture = renderTarget.textures[ textureIndex ];
					const textureFormat = texture.format;
					const textureType = texture.type;

					if ( ! capabilities.textureFormatReadable( textureFormat ) ) {

						error( 'WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					if ( ! capabilities.textureTypeReadable( textureType ) ) {

						error( 'WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						// when using MRT, select the correct color buffer for the subsequent read command

						if ( renderTarget.textures.length > 1 ) _gl.readBuffer( _gl.COLOR_ATTACHMENT0 + textureIndex );

						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

					}

				} finally {

					// restore framebuffer of current render target if necessary

					const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
					state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				}

			}

		};

		/**
		 * Asynchronous, non-blocking version of {@link WebGLRenderer#readRenderTargetPixels}.
		 *
		 * It is recommended to use this version of `readRenderTargetPixels()` whenever possible.
		 *
		 * @async
		 * @param {WebGLRenderTarget} renderTarget - The render target to read from.
		 * @param {number} x - The `x` coordinate of the copy region's origin.
		 * @param {number} y - The `y` coordinate of the copy region's origin.
		 * @param {number} width - The width of the copy region.
		 * @param {number} height - The height of the copy region.
		 * @param {TypedArray} buffer - The result buffer.
		 * @param {number} [activeCubeFaceIndex] - The active cube face index.
		 * @param {number} [textureIndex=0] - The texture index of an MRT render target.
		 * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
		 */
		this.readRenderTargetPixelsAsync = async function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex, textureIndex = 0 ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				throw new Error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );

			}

			let framebuffer = properties.get( renderTarget ).__webglFramebuffer;
			if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

				framebuffer = framebuffer[ activeCubeFaceIndex ];

			}

			if ( framebuffer ) {

				// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
				if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

					// set the active frame buffer to the one we want to read
					state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

					const texture = renderTarget.textures[ textureIndex ];
					const textureFormat = texture.format;
					const textureType = texture.type;

					if ( ! capabilities.textureFormatReadable( textureFormat ) ) {

						throw new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.' );

					}

					if ( ! capabilities.textureTypeReadable( textureType ) ) {

						throw new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.' );

					}

					const glBuffer = _gl.createBuffer();
					_gl.bindBuffer( _gl.PIXEL_PACK_BUFFER, glBuffer );
					_gl.bufferData( _gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ );

					// when using MRT, select the correct color buffer for the subsequent read command

					if ( renderTarget.textures.length > 1 ) _gl.readBuffer( _gl.COLOR_ATTACHMENT0 + textureIndex );

					_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), 0 );

					// reset the frame buffer to the currently set buffer before waiting
					const currFramebuffer = _currentRenderTarget !== null ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
					state.bindFramebuffer( _gl.FRAMEBUFFER, currFramebuffer );

					// check if the commands have finished every 8 ms
					const sync = _gl.fenceSync( _gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );

					_gl.flush();

					await probeAsync( _gl, sync, 4 );

					// read the data and delete the buffer
					_gl.bindBuffer( _gl.PIXEL_PACK_BUFFER, glBuffer );
					_gl.getBufferSubData( _gl.PIXEL_PACK_BUFFER, 0, buffer );
					_gl.deleteBuffer( glBuffer );
					_gl.deleteSync( sync );

					return buffer;

				} else {

					throw new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.' );

				}

			}

		};

		/**
		 * Copies pixels from the current bound framebuffer into the given texture.
		 *
		 * @param {FramebufferTexture} texture - The texture.
		 * @param {?Vector2} [position=null] - The start position of the copy operation.
		 * @param {number} [level=0] - The mip level. The default represents the base mip.
		 */
		this.copyFramebufferToTexture = function ( texture, position = null, level = 0 ) {

			const levelScale = Math.pow( 2, - level );
			const width = Math.floor( texture.image.width * levelScale );
			const height = Math.floor( texture.image.height * levelScale );

			const x = position !== null ? position.x : 0;
			const y = position !== null ? position.y : 0;

			textures.setTexture2D( texture, 0 );

			_gl.copyTexSubImage2D( _gl.TEXTURE_2D, level, 0, 0, x, y, width, height );

			state.unbindTexture();

		};

		const _srcFramebuffer = _gl.createFramebuffer();
		const _dstFramebuffer = _gl.createFramebuffer();

		/**
		 * Copies data of the given source texture into a destination texture.
		 *
		 * When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are initialized
		 * {@link WebGLRenderer#initRenderTarget}.
		 *
		 * @param {Texture} srcTexture - The source texture.
		 * @param {Texture} dstTexture - The destination texture.
		 * @param {?(Box2|Box3)} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
		 * @param {?(Vector2|Vector3)} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
		 * @param {number} [srcLevel=0] - The source mipmap level to copy.
		 * @param {?number} [dstLevel=null] - The destination mipmap level.
		 */
		this.copyTextureToTexture = function ( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = null ) {

			// support the previous signature with just a single dst mipmap level
			if ( dstLevel === null ) {

				if ( srcLevel !== 0 ) {

					// @deprecated, r171
					warnOnce( 'WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.' );
					dstLevel = srcLevel;
					srcLevel = 0;

				} else {

					dstLevel = 0;

				}

			}

			// gather the necessary dimensions to copy
			let width, height, depth, minX, minY, minZ;
			let dstX, dstY, dstZ;
			const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ dstLevel ] : srcTexture.image;
			if ( srcRegion !== null ) {

				width = srcRegion.max.x - srcRegion.min.x;
				height = srcRegion.max.y - srcRegion.min.y;
				depth = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;
				minX = srcRegion.min.x;
				minY = srcRegion.min.y;
				minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;

			} else {

				const levelScale = Math.pow( 2, - srcLevel );
				width = Math.floor( image.width * levelScale );
				height = Math.floor( image.height * levelScale );
				if ( srcTexture.isDataArrayTexture ) {

					depth = image.depth;

				} else if ( srcTexture.isData3DTexture ) {

					depth = Math.floor( image.depth * levelScale );

				} else {

					depth = 1;

				}

				minX = 0;
				minY = 0;
				minZ = 0;

			}

			if ( dstPosition !== null ) {

				dstX = dstPosition.x;
				dstY = dstPosition.y;
				dstZ = dstPosition.z;

			} else {

				dstX = 0;
				dstY = 0;
				dstZ = 0;

			}

			// Set up the destination target
			const glFormat = utils.convert( dstTexture.format );
			const glType = utils.convert( dstTexture.type );
			let glTarget;

			if ( dstTexture.isData3DTexture ) {

				textures.setTexture3D( dstTexture, 0 );
				glTarget = _gl.TEXTURE_3D;

			} else if ( dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture ) {

				textures.setTexture2DArray( dstTexture, 0 );
				glTarget = _gl.TEXTURE_2D_ARRAY;

			} else {

				textures.setTexture2D( dstTexture, 0 );
				glTarget = _gl.TEXTURE_2D;

			}

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

			// used for copying data from cpu
			const currentUnpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );
			const currentUnpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );
			const currentUnpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );
			const currentUnpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );
			const currentUnpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );

			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );
			_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );
			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, minX );
			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, minY );
			_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, minZ );

			// set up the src texture
			const isSrc3D = srcTexture.isDataArrayTexture || srcTexture.isData3DTexture;
			const isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture;
			if ( srcTexture.isDepthTexture ) {

				const srcTextureProperties = properties.get( srcTexture );
				const dstTextureProperties = properties.get( dstTexture );
				const srcRenderTargetProperties = properties.get( srcTextureProperties.__renderTarget );
				const dstRenderTargetProperties = properties.get( dstTextureProperties.__renderTarget );
				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, srcRenderTargetProperties.__webglFramebuffer );
				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, dstRenderTargetProperties.__webglFramebuffer );

				for ( let i = 0; i < depth; i ++ ) {

					// if the source or destination are a 3d target then a layer needs to be bound
					if ( isSrc3D ) {

						_gl.framebufferTextureLayer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get( srcTexture ).__webglTexture, srcLevel, minZ + i );
						_gl.framebufferTextureLayer( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get( dstTexture ).__webglTexture, dstLevel, dstZ + i );

					}

					_gl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, _gl.DEPTH_BUFFER_BIT, _gl.NEAREST );

				}

				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );
				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );

			} else if ( srcLevel !== 0 || srcTexture.isRenderTargetTexture || properties.has( srcTexture ) ) {

				// get the appropriate frame buffers
				const srcTextureProperties = properties.get( srcTexture );
				const dstTextureProperties = properties.get( dstTexture );

				// bind the frame buffer targets
				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, _srcFramebuffer );
				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, _dstFramebuffer );

				for ( let i = 0; i < depth; i ++ ) {

					// assign the correct layers and mip maps to the frame buffers
					if ( isSrc3D ) {

						_gl.framebufferTextureLayer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, srcTextureProperties.__webglTexture, srcLevel, minZ + i );

					} else {

						_gl.framebufferTexture2D( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, srcTextureProperties.__webglTexture, srcLevel );

					}

					if ( isDst3D ) {

						_gl.framebufferTextureLayer( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, dstTextureProperties.__webglTexture, dstLevel, dstZ + i );

					} else {

						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, dstTextureProperties.__webglTexture, dstLevel );

					}

					// copy the data using the fastest function that can achieve the copy
					if ( srcLevel !== 0 ) {

						_gl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, _gl.COLOR_BUFFER_BIT, _gl.NEAREST );

					} else if ( isDst3D ) {

						_gl.copyTexSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ + i, minX, minY, width, height );

					} else {

						_gl.copyTexSubImage2D( glTarget, dstLevel, dstX, dstY, minX, minY, width, height );

					}

				}

				// unbind read, draw buffers
				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );
				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );

			} else {

				if ( isDst3D ) {

					// copy data into the 3d texture
					if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {

						_gl.texSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image.data );

					} else if ( dstTexture.isCompressedArrayTexture ) {

						_gl.compressedTexSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, image.data );

					} else {

						_gl.texSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image );

					}

				} else {

					// copy data into the 2d texture
					if ( srcTexture.isDataTexture ) {

						_gl.texSubImage2D( _gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image.data );

					} else if ( srcTexture.isCompressedTexture ) {

						_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, dstLevel, dstX, dstY, image.width, image.height, glFormat, image.data );

					} else {

						_gl.texSubImage2D( _gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image );

					}

				}

			}

			// reset values
			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );
			_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );
			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );
			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );
			_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );

			// Generate mipmaps only when copying level 0
			if ( dstLevel === 0 && dstTexture.generateMipmaps ) {

				_gl.generateMipmap( glTarget );

			}

			state.unbindTexture();

		};

		/**
		 * Initializes the given WebGLRenderTarget memory. Useful for initializing a render target so data
		 * can be copied into it using {@link WebGLRenderer#copyTextureToTexture} before it has been
		 * rendered to.
		 *
		 * @param {WebGLRenderTarget} target - The render target.
		 */
		this.initRenderTarget = function ( target ) {

			if ( properties.get( target ).__webglFramebuffer === undefined ) {

				textures.setupRenderTarget( target );

			}

		};

		/**
		 * Initializes the given texture. Useful for preloading a texture rather than waiting until first
		 * render (which can cause noticeable lags due to decode and GPU upload overhead).
		 *
		 * @param {Texture} texture - The texture.
		 */
		this.initTexture = function ( texture ) {

			if ( texture.isCubeTexture ) {

				textures.setTextureCube( texture, 0 );

			} else if ( texture.isData3DTexture ) {

				textures.setTexture3D( texture, 0 );

			} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

				textures.setTexture2DArray( texture, 0 );

			} else {

				textures.setTexture2D( texture, 0 );

			}

			state.unbindTexture();

		};

		/**
		 * Can be used to reset the internal WebGL state. This method is mostly
		 * relevant for applications which share a single WebGL context across
		 * multiple WebGL libraries.
		 */
		this.resetState = function () {

			_currentActiveCubeFace = 0;
			_currentActiveMipmapLevel = 0;
			_currentRenderTarget = null;

			state.reset();
			bindingStates.reset();

		};

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

		}

	}

	/**
	 * Defines the coordinate system of the renderer.
	 *
	 * In `WebGLRenderer`, the value is always `WebGLCoordinateSystem`.
	 *
	 * @type {WebGLCoordinateSystem|WebGPUCoordinateSystem}
	 * @default WebGLCoordinateSystem
	 * @readonly
	 */
	get coordinateSystem() {

		return WebGLCoordinateSystem;

	}

	/**
	 * Defines the output color space of the renderer.
	 *
	 * @type {SRGBColorSpace|LinearSRGBColorSpace}
	 * @default SRGBColorSpace
	 */
	get outputColorSpace() {

		return this._outputColorSpace;

	}

	set outputColorSpace( colorSpace ) {

		this._outputColorSpace = colorSpace;

		const gl = this.getContext();
		gl.drawingBufferColorSpace = ColorManagement._getDrawingBufferColorSpace( colorSpace );
		gl.unpackColorSpace = ColorManagement._getUnpackColorSpace();

	}

}

/**
 * @module CopyShader
 * @three_import import { CopyShader } from 'three/addons/shaders/CopyShader.js';
 */

/**
 * Full-screen copy shader pass.
 *
 * @constant
 * @type {ShaderMaterial~Shader}
 */
const CopyShader = {

	name: 'CopyShader',

	uniforms: {

		'tDiffuse': { value: null },
		'opacity': { value: 1.0 }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`

};

/**
 * Abstract base class for all post processing passes.
 *
 * This module is only relevant for post processing with {@link WebGLRenderer}.
 *
 * @abstract
 * @three_import import { Pass } from 'three/addons/postprocessing/Pass.js';
 */
class Pass {

	/**
	 * Constructs a new pass.
	 */
	constructor() {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {boolean}
		 * @readonly
		 * @default true
		 */
		this.isPass = true;

		/**
		 * If set to `true`, the pass is processed by the composer.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.enabled = true;

		/**
		 * If set to `true`, the pass indicates to swap read and write buffer after rendering.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.needsSwap = true;

		/**
		 * If set to `true`, the pass clears its buffer before rendering
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.clear = false;

		/**
		 * If set to `true`, the result of the pass is rendered to screen. The last pass in the composers
		 * pass chain gets automatically rendered to screen, no matter how this property is configured.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.renderToScreen = false;

	}

	/**
	 * Sets the size of the pass.
	 *
	 * @abstract
	 * @param {number} width - The width to set.
	 * @param {number} height - The height to set.
	 */
	setSize( /* width, height */ ) {}

	/**
	 * This method holds the render logic of a pass. It must be implemented in all derived classes.
	 *
	 * @abstract
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
	 * destination for the pass.
	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
	 * previous pass from this buffer.
	 * @param {number} deltaTime - The delta time in seconds.
	 * @param {boolean} maskActive - Whether masking is active or not.
	 */
	render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

		console.error( 'THREE.Pass: .render() must be implemented in derived pass.' );

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever the pass is no longer used in your app.
	 *
	 * @abstract
	 */
	dispose() {}

}

// Helper for passes that need to fill the viewport with a single quad.

const _camera = new OrthographicCamera( -1, 1, 1, -1, 0, 1 );

// https://github.com/mrdoob/three.js/pull/21358

class FullscreenTriangleGeometry extends BufferGeometry {

	constructor() {

		super();

		this.setAttribute( 'position', new Float32BufferAttribute( [ -1, 3, 0, -1, -1, 0, 3, -1, 0 ], 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

	}

}

const _geometry = new FullscreenTriangleGeometry();


/**
 * This module is a helper for passes which need to render a full
 * screen effect which is quite common in context of post processing.
 *
 * The intended usage is to reuse a single full screen quad for rendering
 * subsequent passes by just reassigning the `material` reference.
 *
 * This module can only be used with {@link WebGLRenderer}.
 *
 * @augments Mesh
 * @three_import import { FullScreenQuad } from 'three/addons/postprocessing/Pass.js';
 */
class FullScreenQuad {

	/**
	 * Constructs a new full screen quad.
	 *
	 * @param {?Material} material - The material to render te full screen quad with.
	 */
	constructor( material ) {

		this._mesh = new Mesh( _geometry, material );

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever the instance is no longer used in your app.
	 */
	dispose() {

		this._mesh.geometry.dispose();

	}

	/**
	 * Renders the full screen quad.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 */
	render( renderer ) {

		renderer.render( this._mesh, _camera );

	}

	/**
	 * The quad's material.
	 *
	 * @type {?Material}
	 */
	get material() {

		return this._mesh.material;

	}

	set material( value ) {

		this._mesh.material = value;

	}

}

/**
 * This pass can be used to create a post processing effect
 * with a raw GLSL shader object. Useful for implementing custom
 * effects.
 *
 * ```js
 * const fxaaPass = new ShaderPass( FXAAShader );
 * composer.addPass( fxaaPass );
 * ```
 *
 * @augments Pass
 * @three_import import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
 */
class ShaderPass extends Pass {

	/**
	 * Constructs a new shader pass.
	 *
	 * @param {Object|ShaderMaterial} [shader] - A shader object holding vertex and fragment shader as well as
	 * defines and uniforms. It's also valid to pass a custom shader material.
	 * @param {string} [textureID='tDiffuse'] - The name of the texture uniform that should sample
	 * the read buffer.
	 */
	constructor( shader, textureID = 'tDiffuse' ) {

		super();

		/**
		 * The name of the texture uniform that should sample the read buffer.
		 *
		 * @type {string}
		 * @default 'tDiffuse'
		 */
		this.textureID = textureID;

		/**
		 * The pass uniforms.
		 *
		 * @type {?Object}
		 */
		this.uniforms = null;

		/**
		 * The pass material.
		 *
		 * @type {?ShaderMaterial}
		 */
		this.material = null;

		if ( shader instanceof ShaderMaterial ) {

			this.uniforms = shader.uniforms;

			this.material = shader;

		} else if ( shader ) {

			this.uniforms = UniformsUtils.clone( shader.uniforms );

			this.material = new ShaderMaterial( {

				name: ( shader.name !== undefined ) ? shader.name : 'unspecified',
				defines: Object.assign( {}, shader.defines ),
				uniforms: this.uniforms,
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader

			} );

		}

		// internals

		this._fsQuad = new FullScreenQuad( this.material );

	}

	/**
	 * Performs the shader pass.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
	 * destination for the pass.
	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
	 * previous pass from this buffer.
	 * @param {number} deltaTime - The delta time in seconds.
	 * @param {boolean} maskActive - Whether masking is active or not.
	 */
	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer.texture;

		}

		this._fsQuad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.setRenderTarget( null );
			this._fsQuad.render( renderer );

		} else {

			renderer.setRenderTarget( writeBuffer );
			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
			if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
			this._fsQuad.render( renderer );

		}

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever the pass is no longer used in your app.
	 */
	dispose() {

		this.material.dispose();

		this._fsQuad.dispose();

	}

}

/**
 * This pass can be used to define a mask during post processing.
 * Meaning only areas of subsequent post processing are affected
 * which lie in the masking area of this pass. Internally, the masking
 * is implemented with the stencil buffer.
 *
 * ```js
 * const maskPass = new MaskPass( scene, camera );
 * composer.addPass( maskPass );
 * ```
 *
 * @augments Pass
 * @three_import import { MaskPass } from 'three/addons/postprocessing/MaskPass.js';
 */
class MaskPass extends Pass {

	/**
	 * Constructs a new mask pass.
	 *
	 * @param {Scene} scene - The 3D objects in this scene will define the mask.
	 * @param {Camera} camera - The camera.
	 */
	constructor( scene, camera ) {

		super();

		/**
		 * The scene that defines the mask.
		 *
		 * @type {Scene}
		 */
		this.scene = scene;

		/**
		 * The camera.
		 *
		 * @type {Camera}
		 */
		this.camera = camera;

		/**
		 * Overwritten to perform a clear operation by default.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.clear = true;

		/**
		 * Overwritten to disable the swap.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.needsSwap = false;

		/**
		 * Whether to inverse the mask or not.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.inverse = false;

	}

	/**
	 * Performs a mask pass with the configured scene and camera.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
	 * destination for the pass.
	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
	 * previous pass from this buffer.
	 * @param {number} deltaTime - The delta time in seconds.
	 * @param {boolean} maskActive - Whether masking is active or not.
	 */
	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		const context = renderer.getContext();
		const state = renderer.state;

		// don't update color or depth

		state.buffers.color.setMask( false );
		state.buffers.depth.setMask( false );

		// lock buffers

		state.buffers.color.setLocked( true );
		state.buffers.depth.setLocked( true );

		// set up stencil

		let writeValue, clearValue;

		if ( this.inverse ) {

			writeValue = 0;
			clearValue = 1;

		} else {

			writeValue = 1;
			clearValue = 0;

		}

		state.buffers.stencil.setTest( true );
		state.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );
		state.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );
		state.buffers.stencil.setClear( clearValue );
		state.buffers.stencil.setLocked( true );

		// draw into the stencil buffer

		renderer.setRenderTarget( readBuffer );
		if ( this.clear ) renderer.clear();
		renderer.render( this.scene, this.camera );

		renderer.setRenderTarget( writeBuffer );
		if ( this.clear ) renderer.clear();
		renderer.render( this.scene, this.camera );

		// unlock color and depth buffer and make them writable for subsequent rendering/clearing

		state.buffers.color.setLocked( false );
		state.buffers.depth.setLocked( false );

		state.buffers.color.setMask( true );
		state.buffers.depth.setMask( true );

		// only render where stencil is set to 1

		state.buffers.stencil.setLocked( false );
		state.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1
		state.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );
		state.buffers.stencil.setLocked( true );

	}

}

/**
 * This pass can be used to clear a mask previously defined with {@link MaskPass}.
 *
 * ```js
 * const clearPass = new ClearMaskPass();
 * composer.addPass( clearPass );
 * ```
 *
 * @augments Pass
 */
class ClearMaskPass extends Pass {

	/**
	 * Constructs a new clear mask pass.
	 */
	constructor() {

		super();

		/**
		 * Overwritten to disable the swap.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.needsSwap = false;

	}

	/**
	 * Performs the clear of the currently defined mask.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
	 * destination for the pass.
	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
	 * previous pass from this buffer.
	 * @param {number} deltaTime - The delta time in seconds.
	 * @param {boolean} maskActive - Whether masking is active or not.
	 */
	render( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

		renderer.state.buffers.stencil.setLocked( false );
		renderer.state.buffers.stencil.setTest( false );

	}

}

/**
 * Used to implement post-processing effects in three.js.
 * The class manages a chain of post-processing passes to produce the final visual result.
 * Post-processing passes are executed in order of their addition/insertion.
 * The last pass is automatically rendered to screen.
 *
 * This module can only be used with {@link WebGLRenderer}.
 *
 * ```js
 * const composer = new EffectComposer( renderer );
 *
 * // adding some passes
 * const renderPass = new RenderPass( scene, camera );
 * composer.addPass( renderPass );
 *
 * const glitchPass = new GlitchPass();
 * composer.addPass( glitchPass );
 *
 * const outputPass = new OutputPass()
 * composer.addPass( outputPass );
 *
 * function animate() {
 *
 * 	composer.render(); // instead of renderer.render()
 *
 * }
 * ```
 *
 * @three_import import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
 */
class EffectComposer {

	/**
	 * Constructs a new effect composer.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {WebGLRenderTarget} [renderTarget] - This render target and a clone will
	 * be used as the internal read and write buffers. If not given, the composer creates
	 * the buffers automatically.
	 */
	constructor( renderer, renderTarget ) {

		/**
		 * The renderer.
		 *
		 * @type {WebGLRenderer}
		 */
		this.renderer = renderer;

		this._pixelRatio = renderer.getPixelRatio();

		if ( renderTarget === undefined ) {

			const size = renderer.getSize( new Vector2() );
			this._width = size.width;
			this._height = size.height;

			renderTarget = new WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType } );
			renderTarget.texture.name = 'EffectComposer.rt1';

		} else {

			this._width = renderTarget.width;
			this._height = renderTarget.height;

		}

		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();
		this.renderTarget2.texture.name = 'EffectComposer.rt2';

		/**
		 * A reference to the internal write buffer. Passes usually write
		 * their result into this buffer.
		 *
		 * @type {WebGLRenderTarget}
		 */
		this.writeBuffer = this.renderTarget1;

		/**
		 * A reference to the internal read buffer. Passes usually read
		 * the previous render result from this buffer.
		 *
		 * @type {WebGLRenderTarget}
		 */
		this.readBuffer = this.renderTarget2;

		/**
		 * Whether the final pass is rendered to the screen (default framebuffer) or not.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.renderToScreen = true;

		/**
		 * An array representing the (ordered) chain of post-processing passes.
		 *
		 * @type {Array<Pass>}
		 */
		this.passes = [];

		/**
		 * A copy pass used for internal swap operations.
		 *
		 * @private
		 * @type {ShaderPass}
		 */
		this.copyPass = new ShaderPass( CopyShader );
		this.copyPass.material.blending = NoBlending;

		/**
		 * The internal clock for managing time data.
		 *
		 * @private
		 * @type {Clock}
		 */
		this.clock = new Clock();

	}

	/**
	 * Swaps the internal read/write buffers.
	 */
	swapBuffers() {

		const tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;

	}

	/**
	 * Adds the given pass to the pass chain.
	 *
	 * @param {Pass} pass - The pass to add.
	 */
	addPass( pass ) {

		this.passes.push( pass );
		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

	}

	/**
	 * Inserts the given pass at a given index.
	 *
	 * @param {Pass} pass - The pass to insert.
	 * @param {number} index - The index into the pass chain.
	 */
	insertPass( pass, index ) {

		this.passes.splice( index, 0, pass );
		pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

	}

	/**
	 * Removes the given pass from the pass chain.
	 *
	 * @param {Pass} pass - The pass to remove.
	 */
	removePass( pass ) {

		const index = this.passes.indexOf( pass );

		if ( index !== -1 ) {

			this.passes.splice( index, 1 );

		}

	}

	/**
	 * Returns `true` if the pass for the given index is the last enabled pass in the pass chain.
	 *
	 * @param {number} passIndex - The pass index.
	 * @return {boolean} Whether the pass for the given index is the last pass in the pass chain.
	 */
	isLastEnabledPass( passIndex ) {

		for ( let i = passIndex + 1; i < this.passes.length; i ++ ) {

			if ( this.passes[ i ].enabled ) {

				return false;

			}

		}

		return true;

	}

	/**
	 * Executes all enabled post-processing passes in order to produce the final frame.
	 *
	 * @param {number} deltaTime - The delta time in seconds. If not given, the composer computes
	 * its own time delta value.
	 */
	render( deltaTime ) {

		// deltaTime value is in seconds

		if ( deltaTime === undefined ) {

			deltaTime = this.clock.getDelta();

		}

		const currentRenderTarget = this.renderer.getRenderTarget();

		let maskActive = false;

		for ( let i = 0, il = this.passes.length; i < il; i ++ ) {

			const pass = this.passes[ i ];

			if ( pass.enabled === false ) continue;

			pass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );
			pass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );

			if ( pass.needsSwap ) {

				if ( maskActive ) {

					const context = this.renderer.getContext();
					const stencil = this.renderer.state.buffers.stencil;

					//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
					stencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );

					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );

					//context.stencilFunc( context.EQUAL, 1, 0xffffffff );
					stencil.setFunc( context.EQUAL, 1, 0xffffffff );

				}

				this.swapBuffers();

			}

			if ( MaskPass !== undefined ) {

				if ( pass instanceof MaskPass ) {

					maskActive = true;

				} else if ( pass instanceof ClearMaskPass ) {

					maskActive = false;

				}

			}

		}

		this.renderer.setRenderTarget( currentRenderTarget );

	}

	/**
	 * Resets the internal state of the EffectComposer.
	 *
	 * @param {WebGLRenderTarget} [renderTarget] - This render target has the same purpose like
	 * the one from the constructor. If set, it is used to setup the read and write buffers.
	 */
	reset( renderTarget ) {

		if ( renderTarget === undefined ) {

			const size = this.renderer.getSize( new Vector2() );
			this._pixelRatio = this.renderer.getPixelRatio();
			this._width = size.width;
			this._height = size.height;

			renderTarget = this.renderTarget1.clone();
			renderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

		}

		this.renderTarget1.dispose();
		this.renderTarget2.dispose();
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

	}

	/**
	 * Resizes the internal read and write buffers as well as all passes. Similar to {@link WebGLRenderer#setSize},
	 * this method honors the current pixel ration.
	 *
	 * @param {number} width - The width in logical pixels.
	 * @param {number} height - The height in logical pixels.
	 */
	setSize( width, height ) {

		this._width = width;
		this._height = height;

		const effectiveWidth = this._width * this._pixelRatio;
		const effectiveHeight = this._height * this._pixelRatio;

		this.renderTarget1.setSize( effectiveWidth, effectiveHeight );
		this.renderTarget2.setSize( effectiveWidth, effectiveHeight );

		for ( let i = 0; i < this.passes.length; i ++ ) {

			this.passes[ i ].setSize( effectiveWidth, effectiveHeight );

		}

	}

	/**
	 * Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.
	 * Setting the pixel ratio will automatically resize the composer.
	 *
	 * @param {number} pixelRatio - The pixel ratio to set.
	 */
	setPixelRatio( pixelRatio ) {

		this._pixelRatio = pixelRatio;

		this.setSize( this._width, this._height );

	}

	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever the composer is no longer used in your app.
	 */
	dispose() {

		this.renderTarget1.dispose();
		this.renderTarget2.dispose();

		this.copyPass.dispose();

	}

}

/**
 * This class represents a render pass. It takes a camera and a scene and produces
 * a beauty pass for subsequent post processing effects.
 *
 * ```js
 * const renderPass = new RenderPass( scene, camera );
 * composer.addPass( renderPass );
 * ```
 *
 * @augments Pass
 * @three_import import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 */
class RenderPass extends Pass {

	/**
	 * Constructs a new render pass.
	 *
	 * @param {Scene} scene - The scene to render.
	 * @param {Camera} camera - The camera.
	 * @param {?Material} [overrideMaterial=null] - The override material. If set, this material is used
	 * for all objects in the scene.
	 * @param {?(number|Color|string)} [clearColor=null] - The clear color of the render pass.
	 * @param {?number} [clearAlpha=null] - The clear alpha of the render pass.
	 */
	constructor( scene, camera, overrideMaterial = null, clearColor = null, clearAlpha = null ) {

		super();

		/**
		 * The scene to render.
		 *
		 * @type {Scene}
		 */
		this.scene = scene;

		/**
		 * The camera.
		 *
		 * @type {Camera}
		 */
		this.camera = camera;

		/**
		 * The override material. If set, this material is used
		 * for all objects in the scene.
		 *
		 * @type {?Material}
		 * @default null
		 */
		this.overrideMaterial = overrideMaterial;

		/**
		 * The clear color of the render pass.
		 *
		 * @type {?(number|Color|string)}
		 * @default null
		 */
		this.clearColor = clearColor;

		/**
		 * The clear alpha of the render pass.
		 *
		 * @type {?number}
		 * @default null
		 */
		this.clearAlpha = clearAlpha;

		/**
		 * Overwritten to perform a clear operation by default.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.clear = true;

		/**
		 * If set to `true`, only the depth can be cleared when `clear` is to `false`.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.clearDepth = false;

		/**
		 * Overwritten to disable the swap.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.needsSwap = false;
		this._oldClearColor = new Color();

	}

	/**
	 * Performs a beauty pass with the configured scene and camera.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
	 * destination for the pass.
	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
	 * previous pass from this buffer.
	 * @param {number} deltaTime - The delta time in seconds.
	 * @param {boolean} maskActive - Whether masking is active or not.
	 */
	render( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

		const oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		let oldClearAlpha, oldOverrideMaterial;

		if ( this.overrideMaterial !== null ) {

			oldOverrideMaterial = this.scene.overrideMaterial;

			this.scene.overrideMaterial = this.overrideMaterial;

		}

		if ( this.clearColor !== null ) {

			renderer.getClearColor( this._oldClearColor );
			renderer.setClearColor( this.clearColor, renderer.getClearAlpha() );

		}

		if ( this.clearAlpha !== null ) {

			oldClearAlpha = renderer.getClearAlpha();
			renderer.setClearAlpha( this.clearAlpha );

		}

		if ( this.clearDepth == true ) {

			renderer.clearDepth();

		}

		renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );

		if ( this.clear === true ) {

			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

		renderer.render( this.scene, this.camera );

		// restore

		if ( this.clearColor !== null ) {

			renderer.setClearColor( this._oldClearColor );

		}

		if ( this.clearAlpha !== null ) {

			renderer.setClearAlpha( oldClearAlpha );

		}

		if ( this.overrideMaterial !== null ) {

			this.scene.overrideMaterial = oldOverrideMaterial;

		}

		renderer.autoClear = oldAutoClear;

	}

}

/**
 * UnrealBloomPassAlpha - Modified UnrealBloomPass that preserves alpha channel
 *
 * Based on Three.js UnrealBloomPass with shader modifications to prevent
 * alpha channel destruction during Gaussian blur operations.
 *
 * Issue: Standard UnrealBloomPass sets fragment alpha to 1.0, destroying transparency
 * Solution: Accumulate alpha values during blur using same Gaussian weights as RGB
 *
 * References:
 * - https://github.com/mrdoob/three.js/issues/14104
 * - https://gist.github.com/DOSputin/3bcb7355cbb2aef87013dbacb33ec2e1
 */


/**
 * Modified separable Gaussian blur shader that preserves alpha channel
 */
({
    uniforms: {
        'texSize': { value: new Vector2(0.5, 0.5) },
        'direction': { value: new Vector2(0.5, 0.5) }}});

/**
 * UnrealBloomPassAlpha - preserves alpha channel transparency
 */
class UnrealBloomPassAlpha extends Pass {
    constructor(resolution, strength, radius, threshold) {
        super();

        this.strength = (strength !== undefined) ? strength : 1;
        this.radius = radius;
        this.threshold = threshold;
        this.resolution = (resolution !== undefined) ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);

        // Render targets with RGBA format for alpha preservation + HDR
        const pars = {
            minFilter: LinearFilter,
            magFilter: LinearFilter,
            format: RGBAFormat,      // CRITICAL: Use RGBA not RGB
            type: HalfFloatType      // HDR: Allow values > 1.0 for proper bloom
        };

        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;

        // 75% resolution for sharp bloom with good performance
        let resx = Math.round(this.resolution.x * 0.75);
        let resy = Math.round(this.resolution.y * 0.75);

        this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);
        this.renderTargetBright.texture.name = 'UnrealBloomPassAlpha.bright';
        this.renderTargetBright.texture.generateMipmaps = false;

        for (let i = 0; i < this.nMips; i++) {
            const renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);
            renderTargetHorizonal.texture.name = `UnrealBloomPassAlpha.h${i}`;
            renderTargetHorizonal.texture.generateMipmaps = false;

            this.renderTargetsHorizontal.push(renderTargetHorizonal);

            const renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);
            renderTargetVertical.texture.name = `UnrealBloomPassAlpha.v${i}`;
            renderTargetVertical.texture.generateMipmaps = false;

            this.renderTargetsVertical.push(renderTargetVertical);

            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }

        // Custom luminosity high pass material that PRESERVES ALPHA
        this.highPassUniforms = {
            tDiffuse: { value: null },
            luminosityThreshold: { value: threshold },
            smoothWidth: { value: 0.01 }
        };

        this.materialHighPassFilter = new ShaderMaterial({
            uniforms: this.highPassUniforms,
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float luminosityThreshold;
                uniform float smoothWidth;
                varying vec2 vUv;

                void main() {
                    vec4 texel = texture2D(tDiffuse, vUv);
                    vec3 luma = vec3(0.299, 0.587, 0.114);
                    float v = dot(texel.xyz, luma);
                    float alpha = smoothstep(luminosityThreshold, luminosityThreshold + smoothWidth, v);

                    // CRITICAL: Preserve original alpha, only filter by luminosity
                    gl_FragColor = vec4(texel.rgb * alpha, texel.a);
                }`
        });

        // Gaussian blur materials with alpha preservation
        this.separableBlurMaterials = [];
        const kernelSizeArray = [3, 5, 7, 9, 11];
        // 75% resolution for sharp bloom with good performance
        resx = Math.round(this.resolution.x * 0.75);
        resy = Math.round(this.resolution.y * 0.75);

        for (let i = 0; i < this.nMips; i++) {
            this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));
            this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);

            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }

        // Composite material
        this.compositeMaterial = this.getCompositeMaterial(this.nMips);
        this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;
        this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;
        this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;
        this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;
        this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;
        this.compositeMaterial.uniforms['bloomStrength'].value = strength;
        this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;

        const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];
        this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;
        this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];
        this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;

        // Copy material with additive blending (like working implementation)
        this.materialCopy = new ShaderMaterial({
            uniforms: {
                'tDiffuse': { value: null }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                varying vec2 vUv;
                void main() {
                    gl_FragColor = texture2D(tDiffuse, vUv);
                }`,
            blending: AdditiveBlending,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });

        this.enabled = true;
        this.needsSwap = false; // No swap - we modify readBuffer in place with additive blending

        this._oldClearColor = new Color();
        this.oldClearAlpha = 1;
        this.clearColor = new Color(0, 0, 0); // CRITICAL: Initialize clear color

        this.basic = new MeshBasicMaterial({
            transparent: true,
            depthTest: false,
            depthWrite: false
        });

        this.fsQuad = new FullScreenQuad(null);
    }

    dispose() {
        // Safely dispose render targets
        if (this.renderTargetsHorizontal) {
            for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {
                this.renderTargetsHorizontal[i]?.dispose();
            }
        }

        if (this.renderTargetsVertical) {
            for (let i = 0; i < this.renderTargetsVertical.length; i++) {
                this.renderTargetsVertical[i]?.dispose();
            }
        }

        this.renderTargetBright?.dispose();

        if (this.separableBlurMaterials) {
            for (let i = 0; i < this.separableBlurMaterials.length; i++) {
                this.separableBlurMaterials[i]?.dispose();
            }
        }

        this.compositeMaterial?.dispose();
        this.blendMaterial?.dispose();
        this.basic?.dispose();

        this.fsQuad?.dispose();
    }

    /**
     * Clear all bloom render targets to remove residual glow
     * Call this during geometry swaps to prevent bloom bleeding between shapes
     * @param {WebGLRenderer} renderer - Three.js renderer
     */
    clearBloomBuffers(renderer) {
        const currentRenderTarget = renderer.getRenderTarget();
        const currentClearColor = renderer.getClearColor(this._oldClearColor);
        const currentClearAlpha = renderer.getClearAlpha();

        renderer.setClearColor(0x000000, 0);

        // Clear bright pass target
        renderer.setRenderTarget(this.renderTargetBright);
        renderer.clear();

        // Clear all horizontal blur targets
        for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {
            renderer.setRenderTarget(this.renderTargetsHorizontal[i]);
            renderer.clear();
        }

        // Clear all vertical blur targets
        for (let i = 0; i < this.renderTargetsVertical.length; i++) {
            renderer.setRenderTarget(this.renderTargetsVertical[i]);
            renderer.clear();
        }

        // Restore previous state
        renderer.setRenderTarget(currentRenderTarget);
        renderer.setClearColor(currentClearColor, currentClearAlpha);
    }

    setSize(width, height) {
        // 75% resolution for sharp bloom with good performance
        let resx = Math.round(width * 0.75);
        let resy = Math.round(height * 0.75);

        this.renderTargetBright.setSize(resx, resy);

        for (let i = 0; i < this.nMips; i++) {
            this.renderTargetsHorizontal[i].setSize(resx, resy);
            this.renderTargetsVertical[i].setSize(resx, resy);

            this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);

            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
    }

    render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
        renderer.getClearColor(this._oldClearColor);
        this.oldClearAlpha = renderer.getClearAlpha();
        const oldAutoClear = renderer.autoClear;
        renderer.autoClear = false;

        renderer.setClearColor(this.clearColor, 0);

        if (maskActive) renderer.state.buffers.stencil.setTest(false);

        // Render input to screen (skip if we're doing overlay-only bloom like particles)
        if (this.renderToScreen && !this.skipBaseCopy) {
            this.fsQuad.material = this.basic;
            this.basic.map = readBuffer.texture;

            renderer.setRenderTarget(null);
            // CRITICAL: Do NOT clear when rendering to screen - this preserves CSS background transparency
            // The scene is already rendered to readBuffer with proper transparency
            // Clearing here would fill with black, destroying the alpha channel
            this.fsQuad.render(renderer);
        }

        // 1. Extract bright areas
        this.highPassUniforms['tDiffuse'].value = readBuffer.texture;
        this.highPassUniforms['luminosityThreshold'].value = this.threshold;
        this.fsQuad.material = this.materialHighPassFilter;

        renderer.setRenderTarget(this.renderTargetBright);
        renderer.clear();
        this.fsQuad.render(renderer);

        // 2. Blur bright areas with separable blur
        let inputRenderTarget = this.renderTargetBright;

        for (let i = 0; i < this.nMips; i++) {
            this.fsQuad.material = this.separableBlurMaterials[i];

            this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;
            this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPassAlpha.BlurDirectionX;
            renderer.setRenderTarget(this.renderTargetsHorizontal[i]);
            renderer.clear();
            this.fsQuad.render(renderer);

            this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;
            this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPassAlpha.BlurDirectionY;
            renderer.setRenderTarget(this.renderTargetsVertical[i]);
            renderer.clear();
            this.fsQuad.render(renderer);

            inputRenderTarget = this.renderTargetsVertical[i];
        }

        // Composite all the mips
        this.fsQuad.material = this.compositeMaterial;
        this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;
        this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;
        this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;

        renderer.setRenderTarget(this.renderTargetsHorizontal[0]);
        renderer.clear();
        this.fsQuad.render(renderer);

        // Blend bloom additively (like working implementation)
        this.fsQuad.material = this.materialCopy;
        this.materialCopy.uniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;

        if (maskActive) renderer.state.buffers.stencil.setTest(true);

        // Render to readBuffer with additive blending (working implementation approach)
        if (this.renderToScreen) {
            renderer.setRenderTarget(null);
            this.fsQuad.render(renderer);
        } else {
            renderer.setRenderTarget(readBuffer);
            this.fsQuad.render(renderer);
        }

        // Restore renderer settings
        renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
        renderer.autoClear = oldAutoClear;
    }

    getSeperableBlurMaterial(kernelRadius) {
        const defines = {
            MAX_RADIUS: kernelRadius
        };

        return new ShaderMaterial({
            defines,
            uniforms: {
                'colorTexture': { value: null },
                'texSize': { value: new Vector2(0.5, 0.5) },
                'direction': { value: new Vector2(0.5, 0.5) },
                'kernelRadius': { value: 1.0 }
            },

            vertexShader: `
                varying vec2 vUv;

                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }`,

            fragmentShader: `
                #include <common>
                varying vec2 vUv;
                uniform sampler2D colorTexture;
                uniform vec2 texSize;
                uniform vec2 direction;
                uniform float kernelRadius;

                float gaussianPdf(in float x, in float sigma) {
                    return 0.39894 * exp( -0.5 * x * x / ( sigma * sigma ) ) / sigma;
                }

                void main() {
                    vec2 invSize = 1.0 / texSize;
                    float sigma = kernelRadius / 2.0;
                    float weightSum = gaussianPdf(0.0, sigma);

                    // CRITICAL: Accumulate RGB and alpha SEPARATELY
                    // Include center pixel for BOTH RGB and alpha
                    vec4 centerPixel = texture2D(colorTexture, vUv);
                    vec3 diffuseSum = centerPixel.rgb * weightSum;
                    float alphaSum = centerPixel.a * weightSum;

                    vec2 delta = direction * invSize * kernelRadius / float(MAX_RADIUS);

                    for( int i = 1; i < MAX_RADIUS; i ++ ) {
                        float x = kernelRadius * float(i) / float(MAX_RADIUS);
                        float w = gaussianPdf(x, sigma);

                        vec2 uvOffset = delta * float(i);
                        vec4 sample1 = texture2D(colorTexture, vUv + uvOffset);
                        vec4 sample2 = texture2D(colorTexture, vUv - uvOffset);

                        // Accumulate RGB and alpha separately
                        diffuseSum += (sample1.rgb + sample2.rgb) * w;
                        alphaSum += (sample1.a + sample2.a) * w;
                        weightSum += 2.0 * w;
                    }

                    // Output with separately normalized alpha
                    gl_FragColor = vec4(diffuseSum / weightSum, alphaSum / weightSum);
                }`
        });
    }

    getCompositeMaterial(nMips) {
        return new ShaderMaterial({
            uniforms: {
                'blurTexture1': { value: null },
                'blurTexture2': { value: null },
                'blurTexture3': { value: null },
                'blurTexture4': { value: null },
                'blurTexture5': { value: null },
                'bloomStrength': { value: 1.0 },
                'bloomFactors': { value: null },
                'bloomTintColors': { value: null },
                'bloomRadius': { value: 0.0 }
            },

            vertexShader: `
                varying vec2 vUv;

                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }`,

            fragmentShader: `
                varying vec2 vUv;
                uniform sampler2D blurTexture1;
                uniform sampler2D blurTexture2;
                uniform sampler2D blurTexture3;
                uniform sampler2D blurTexture4;
                uniform sampler2D blurTexture5;
                uniform float bloomStrength;
                uniform float bloomRadius;
                uniform float bloomFactors[5];
                uniform vec3 bloomTintColors[5];

                float lerpBloomFactor(const in float factor) {
                    float mirrorFactor = 1.2 - factor;
                    return mix(factor, mirrorFactor, bloomRadius);
                }

                void main() {
                    // ALPHA PRESERVATION: Sample all textures and preserve their alpha
                    vec4 sample1 = texture2D(blurTexture1, vUv);
                    vec4 sample2 = texture2D(blurTexture2, vUv);
                    vec4 sample3 = texture2D(blurTexture3, vUv);
                    vec4 sample4 = texture2D(blurTexture4, vUv);
                    vec4 sample5 = texture2D(blurTexture5, vUv);

                    // Apply tint to RGB only, preserve alpha from samples
                    vec4 color = bloomStrength * (
                        lerpBloomFactor(bloomFactors[0]) * vec4(sample1.rgb * bloomTintColors[0], sample1.a) +
                        lerpBloomFactor(bloomFactors[1]) * vec4(sample2.rgb * bloomTintColors[1], sample2.a) +
                        lerpBloomFactor(bloomFactors[2]) * vec4(sample3.rgb * bloomTintColors[2], sample3.a) +
                        lerpBloomFactor(bloomFactors[3]) * vec4(sample4.rgb * bloomTintColors[3], sample4.a) +
                        lerpBloomFactor(bloomFactors[4]) * vec4(sample5.rgb * bloomTintColors[4], sample5.a)
                    );

                    gl_FragColor = color;
                }`
        });
    }
}

UnrealBloomPassAlpha.BlurDirectionX = new Vector2(1.0, 0.0);
UnrealBloomPassAlpha.BlurDirectionY = new Vector2(0.0, 1.0);

/**
 * Fires when the camera has been transformed by the controls.
 *
 * @event OrbitControls#change
 * @type {Object}
 */
const _changeEvent = { type: 'change' };

/**
 * Fires when an interaction was initiated.
 *
 * @event OrbitControls#start
 * @type {Object}
 */
const _startEvent = { type: 'start' };

/**
 * Fires when an interaction has finished.
 *
 * @event OrbitControls#end
 * @type {Object}
 */
const _endEvent = { type: 'end' };

const _ray = new Ray();
const _plane = new Plane();
const _TILT_LIMIT = Math.cos( 70 * MathUtils.DEG2RAD );

const _v = new Vector3();
const _twoPI = 2 * Math.PI;

const _STATE = {
	NONE: -1,
	ROTATE: 0,
	DOLLY: 1,
	PAN: 2,
	TOUCH_ROTATE: 3,
	TOUCH_PAN: 4,
	TOUCH_DOLLY_PAN: 5,
	TOUCH_DOLLY_ROTATE: 6
};
const _EPS = 0.000001;


/**
 * Orbit controls allow the camera to orbit around a target.
 *
 * OrbitControls performs orbiting, dollying (zooming), and panning. Unlike {@link TrackballControls},
 * it maintains the "up" direction `object.up` (+Y by default).
 *
 * - Orbit: Left mouse / touch: one-finger move.
 * - Zoom: Middle mouse, or mousewheel / touch: two-finger spread or squish.
 * - Pan: Right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move.
 *
 * ```js
 * const controls = new OrbitControls( camera, renderer.domElement );
 *
 * // controls.update() must be called after any manual changes to the camera's transform
 * camera.position.set( 0, 20, 100 );
 * controls.update();
 *
 * function animate() {
 *
 * 	// required if controls.enableDamping or controls.autoRotate are set to true
 * 	controls.update();
 *
 * 	renderer.render( scene, camera );
 *
 * }
 * ```
 *
 * @augments Controls
 * @three_import import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 */
class OrbitControls extends Controls {

	/**
	 * Constructs a new controls instance.
	 *
	 * @param {Object3D} object - The object that is managed by the controls.
	 * @param {?HTMLElement} domElement - The HTML element used for event listeners.
	 */
	constructor( object, domElement = null ) {

		super( object, domElement );

		this.state = _STATE.NONE;

		/**
		 * The focus point of the controls, the `object` orbits around this.
		 * It can be updated manually at any point to change the focus of the controls.
		 *
		 * @type {Vector3}
		 */
		this.target = new Vector3();

		/**
		 * The focus point of the `minTargetRadius` and `maxTargetRadius` limits.
		 * It can be updated manually at any point to change the center of interest
		 * for the `target`.
		 *
		 * @type {Vector3}
		 */
		this.cursor = new Vector3();

		/**
		 * How far you can dolly in (perspective camera only).
		 *
		 * @type {number}
		 * @default 0
		 */
		this.minDistance = 0;

		/**
		 * How far you can dolly out (perspective camera only).
		 *
		 * @type {number}
		 * @default Infinity
		 */
		this.maxDistance = Infinity;

		/**
		 * How far you can zoom in (orthographic camera only).
		 *
		 * @type {number}
		 * @default 0
		 */
		this.minZoom = 0;

		/**
		 * How far you can zoom out (orthographic camera only).
		 *
		 * @type {number}
		 * @default Infinity
		 */
		this.maxZoom = Infinity;

		/**
		 * How close you can get the target to the 3D `cursor`.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.minTargetRadius = 0;

		/**
		 * How far you can move the target from the 3D `cursor`.
		 *
		 * @type {number}
		 * @default Infinity
		 */
		this.maxTargetRadius = Infinity;

		/**
		 * How far you can orbit vertically, lower limit. Range is `[0, Math.PI]` radians.
		 *
		 * @type {number}
		 * @default 0
		 */
		this.minPolarAngle = 0;

		/**
		 * How far you can orbit vertically, upper limit. Range is `[0, Math.PI]` radians.
		 *
		 * @type {number}
		 * @default Math.PI
		 */
		this.maxPolarAngle = Math.PI;

		/**
		 * How far you can orbit horizontally, lower limit. If set, the interval `[ min, max ]`
		 * must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.
		 *
		 * @type {number}
		 * @default -Infinity
		 */
		this.minAzimuthAngle = - Infinity;

		/**
		 * How far you can orbit horizontally, upper limit. If set, the interval `[ min, max ]`
		 * must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.
		 *
		 * @type {number}
		 * @default -Infinity
		 */
		this.maxAzimuthAngle = Infinity;

		/**
		 * Set to `true` to enable damping (inertia), which can be used to give a sense of weight
		 * to the controls. Note that if this is enabled, you must call `update()` in your animation
		 * loop.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.enableDamping = false;

		/**
		 * The damping inertia used if `enableDamping` is set to `true`.
		 *
		 * Note that for this to work, you must call `update()` in your animation loop.
		 *
		 * @type {number}
		 * @default 0.05
		 */
		this.dampingFactor = 0.05;

		/**
		 * Enable or disable zooming (dollying) of the camera.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.enableZoom = true;

		/**
		 * Speed of zooming / dollying.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.zoomSpeed = 1.0;

		/**
		 * Enable or disable horizontal and vertical rotation of the camera.
		 *
		 * Note that it is possible to disable a single axis by setting the min and max of the
		 * `minPolarAngle` or `minAzimuthAngle` to the same value, which will cause the vertical
		 * or horizontal rotation to be fixed at that value.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.enableRotate = true;

		/**
		 * Speed of rotation.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.rotateSpeed = 1.0;

		/**
		 * How fast to rotate the camera when the keyboard is used.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.keyRotateSpeed = 1.0;

		/**
		 * Enable or disable camera panning.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.enablePan = true;

		/**
		 * Speed of panning.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.panSpeed = 1.0;

		/**
		 * Defines how the camera's position is translated when panning. If `true`, the camera pans
		 * in screen space. Otherwise, the camera pans in the plane orthogonal to the camera's up
		 * direction.
		 *
		 * @type {boolean}
		 * @default true
		 */
		this.screenSpacePanning = true;

		/**
		 * How fast to pan the camera when the keyboard is used in
		 * pixels per keypress.
		 *
		 * @type {number}
		 * @default 7
		 */
		this.keyPanSpeed = 7.0;

		/**
		 * Setting this property to `true` allows to zoom to the cursor's position.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.zoomToCursor = false;

		/**
		 * Set to true to automatically rotate around the target
		 *
		 * Note that if this is enabled, you must call `update()` in your animation loop.
		 * If you want the auto-rotate speed to be independent of the frame rate (the refresh
		 * rate of the display), you must pass the time `deltaTime`, in seconds, to `update()`.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.autoRotate = false;

		/**
		 * How fast to rotate around the target if `autoRotate` is `true`. The default  equates to 30 seconds
		 * per orbit at 60fps.
		 *
		 * Note that if `autoRotate` is enabled, you must call `update()` in your animation loop.
		 *
		 * @type {number}
		 * @default 2
		 */
		this.autoRotateSpeed = 2.0;

		/**
		 * This object contains references to the keycodes for controlling camera panning.
		 *
		 * ```js
		 * controls.keys = {
		 * 	LEFT: 'ArrowLeft', //left arrow
		 * 	UP: 'ArrowUp', // up arrow
		 * 	RIGHT: 'ArrowRight', // right arrow
		 * 	BOTTOM: 'ArrowDown' // down arrow
		 * }
		 * ```
		 * @type {Object}
		 */
		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

		/**
		 * This object contains references to the mouse actions used by the controls.
		 *
		 * ```js
		 * controls.mouseButtons = {
		 * 	LEFT: THREE.MOUSE.ROTATE,
		 * 	MIDDLE: THREE.MOUSE.DOLLY,
		 * 	RIGHT: THREE.MOUSE.PAN
		 * }
		 * ```
		 * @type {Object}
		 */
		this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };

		/**
		 * This object contains references to the touch actions used by the controls.
		 *
		 * ```js
		 * controls.mouseButtons = {
		 * 	ONE: THREE.TOUCH.ROTATE,
		 * 	TWO: THREE.TOUCH.DOLLY_PAN
		 * }
		 * ```
		 * @type {Object}
		 */
		this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };

		/**
		 * Used internally by `saveState()` and `reset()`.
		 *
		 * @type {Vector3}
		 */
		this.target0 = this.target.clone();

		/**
		 * Used internally by `saveState()` and `reset()`.
		 *
		 * @type {Vector3}
		 */
		this.position0 = this.object.position.clone();

		/**
		 * Used internally by `saveState()` and `reset()`.
		 *
		 * @type {number}
		 */
		this.zoom0 = this.object.zoom;

		// the target DOM element for key events
		this._domElementKeyEvents = null;

		// internals

		this._lastPosition = new Vector3();
		this._lastQuaternion = new Quaternion();
		this._lastTargetPosition = new Vector3();

		// so camera.up is the orbit axis
		this._quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );
		this._quatInverse = this._quat.clone().invert();

		// current position in spherical coordinates
		this._spherical = new Spherical();
		this._sphericalDelta = new Spherical();

		this._scale = 1;
		this._panOffset = new Vector3();

		this._rotateStart = new Vector2();
		this._rotateEnd = new Vector2();
		this._rotateDelta = new Vector2();

		this._panStart = new Vector2();
		this._panEnd = new Vector2();
		this._panDelta = new Vector2();

		this._dollyStart = new Vector2();
		this._dollyEnd = new Vector2();
		this._dollyDelta = new Vector2();

		this._dollyDirection = new Vector3();
		this._mouse = new Vector2();
		this._performCursorZoom = false;

		this._pointers = [];
		this._pointerPositions = {};

		this._controlActive = false;

		// event listeners

		this._onPointerMove = onPointerMove.bind( this );
		this._onPointerDown = onPointerDown.bind( this );
		this._onPointerUp = onPointerUp.bind( this );
		this._onContextMenu = onContextMenu.bind( this );
		this._onMouseWheel = onMouseWheel.bind( this );
		this._onKeyDown = onKeyDown.bind( this );

		this._onTouchStart = onTouchStart.bind( this );
		this._onTouchMove = onTouchMove.bind( this );

		this._onMouseDown = onMouseDown.bind( this );
		this._onMouseMove = onMouseMove.bind( this );

		this._interceptControlDown = interceptControlDown.bind( this );
		this._interceptControlUp = interceptControlUp.bind( this );

		//

		if ( this.domElement !== null ) {

			this.connect( this.domElement );

		}

		this.update();

	}

	connect( element ) {

		super.connect( element );

		this.domElement.addEventListener( 'pointerdown', this._onPointerDown );
		this.domElement.addEventListener( 'pointercancel', this._onPointerUp );

		this.domElement.addEventListener( 'contextmenu', this._onContextMenu );
		this.domElement.addEventListener( 'wheel', this._onMouseWheel, { passive: false } );

		const document = this.domElement.getRootNode(); // offscreen canvas compatibility
		document.addEventListener( 'keydown', this._interceptControlDown, { passive: true, capture: true } );

		this.domElement.style.touchAction = 'none'; // disable touch scroll

	}

	disconnect() {

		this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );
		this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
		this.domElement.removeEventListener( 'pointerup', this._onPointerUp );
		this.domElement.removeEventListener( 'pointercancel', this._onPointerUp );

		this.domElement.removeEventListener( 'wheel', this._onMouseWheel );
		this.domElement.removeEventListener( 'contextmenu', this._onContextMenu );

		this.stopListenToKeyEvents();

		const document = this.domElement.getRootNode(); // offscreen canvas compatibility
		document.removeEventListener( 'keydown', this._interceptControlDown, { capture: true } );

		this.domElement.style.touchAction = 'auto';

	}

	dispose() {

		this.disconnect();

	}

	/**
	 * Get the current vertical rotation, in radians.
	 *
	 * @return {number} The current vertical rotation, in radians.
	 */
	getPolarAngle() {

		return this._spherical.phi;

	}

	/**
	 * Get the current horizontal rotation, in radians.
	 *
	 * @return {number} The current horizontal rotation, in radians.
	 */
	getAzimuthalAngle() {

		return this._spherical.theta;

	}

	/**
	 * Returns the distance from the camera to the target.
	 *
	 * @return {number} The distance from the camera to the target.
	 */
	getDistance() {

		return this.object.position.distanceTo( this.target );

	}

	/**
	 * Adds key event listeners to the given DOM element.
	 * `window` is a recommended argument for using this method.
	 *
	 * @param {HTMLElement} domElement - The DOM element
	 */
	listenToKeyEvents( domElement ) {

		domElement.addEventListener( 'keydown', this._onKeyDown );
		this._domElementKeyEvents = domElement;

	}

	/**
	 * Removes the key event listener previously defined with `listenToKeyEvents()`.
	 */
	stopListenToKeyEvents() {

		if ( this._domElementKeyEvents !== null ) {

			this._domElementKeyEvents.removeEventListener( 'keydown', this._onKeyDown );
			this._domElementKeyEvents = null;

		}

	}

	/**
	 * Save the current state of the controls. This can later be recovered with `reset()`.
	 */
	saveState() {

		this.target0.copy( this.target );
		this.position0.copy( this.object.position );
		this.zoom0 = this.object.zoom;

	}

	/**
	 * Reset the controls to their state from either the last time the `saveState()`
	 * was called, or the initial state.
	 */
	reset() {

		this.target.copy( this.target0 );
		this.object.position.copy( this.position0 );
		this.object.zoom = this.zoom0;

		this.object.updateProjectionMatrix();
		this.dispatchEvent( _changeEvent );

		this.update();

		this.state = _STATE.NONE;

	}

	update( deltaTime = null ) {

		const position = this.object.position;

		_v.copy( position ).sub( this.target );

		// rotate offset to "y-axis-is-up" space
		_v.applyQuaternion( this._quat );

		// angle from z-axis around y-axis
		this._spherical.setFromVector3( _v );

		if ( this.autoRotate && this.state === _STATE.NONE ) {

			this._rotateLeft( this._getAutoRotationAngle( deltaTime ) );

		}

		if ( this.enableDamping ) {

			this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;
			this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;

		} else {

			this._spherical.theta += this._sphericalDelta.theta;
			this._spherical.phi += this._sphericalDelta.phi;

		}

		// restrict theta to be between desired limits

		let min = this.minAzimuthAngle;
		let max = this.maxAzimuthAngle;

		if ( isFinite( min ) && isFinite( max ) ) {

			if ( min < - Math.PI ) min += _twoPI; else if ( min > Math.PI ) min -= _twoPI;

			if ( max < - Math.PI ) max += _twoPI; else if ( max > Math.PI ) max -= _twoPI;

			if ( min <= max ) {

				this._spherical.theta = Math.max( min, Math.min( max, this._spherical.theta ) );

			} else {

				this._spherical.theta = ( this._spherical.theta > ( min + max ) / 2 ) ?
					Math.max( min, this._spherical.theta ) :
					Math.min( max, this._spherical.theta );

			}

		}

		// restrict phi to be between desired limits
		this._spherical.phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, this._spherical.phi ) );

		this._spherical.makeSafe();


		// move target to panned location

		if ( this.enableDamping === true ) {

			this.target.addScaledVector( this._panOffset, this.dampingFactor );

		} else {

			this.target.add( this._panOffset );

		}

		// Limit the target distance from the cursor to create a sphere around the center of interest
		this.target.sub( this.cursor );
		this.target.clampLength( this.minTargetRadius, this.maxTargetRadius );
		this.target.add( this.cursor );

		let zoomChanged = false;
		// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera
		// we adjust zoom later in these cases
		if ( this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera ) {

			this._spherical.radius = this._clampDistance( this._spherical.radius );

		} else {

			const prevRadius = this._spherical.radius;
			this._spherical.radius = this._clampDistance( this._spherical.radius * this._scale );
			zoomChanged = prevRadius != this._spherical.radius;

		}

		_v.setFromSpherical( this._spherical );

		// rotate offset back to "camera-up-vector-is-up" space
		_v.applyQuaternion( this._quatInverse );

		position.copy( this.target ).add( _v );

		this.object.lookAt( this.target );

		if ( this.enableDamping === true ) {

			this._sphericalDelta.theta *= ( 1 - this.dampingFactor );
			this._sphericalDelta.phi *= ( 1 - this.dampingFactor );

			this._panOffset.multiplyScalar( 1 - this.dampingFactor );

		} else {

			this._sphericalDelta.set( 0, 0, 0 );

			this._panOffset.set( 0, 0, 0 );

		}

		// adjust camera position
		if ( this.zoomToCursor && this._performCursorZoom ) {

			let newRadius = null;
			if ( this.object.isPerspectiveCamera ) {

				// move the camera down the pointer ray
				// this method avoids floating point error
				const prevRadius = _v.length();
				newRadius = this._clampDistance( prevRadius * this._scale );

				const radiusDelta = prevRadius - newRadius;
				this.object.position.addScaledVector( this._dollyDirection, radiusDelta );
				this.object.updateMatrixWorld();

				zoomChanged = !! radiusDelta;

			} else if ( this.object.isOrthographicCamera ) {

				// adjust the ortho camera position based on zoom changes
				const mouseBefore = new Vector3( this._mouse.x, this._mouse.y, 0 );
				mouseBefore.unproject( this.object );

				const prevZoom = this.object.zoom;
				this.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / this._scale ) );
				this.object.updateProjectionMatrix();

				zoomChanged = prevZoom !== this.object.zoom;

				const mouseAfter = new Vector3( this._mouse.x, this._mouse.y, 0 );
				mouseAfter.unproject( this.object );

				this.object.position.sub( mouseAfter ).add( mouseBefore );
				this.object.updateMatrixWorld();

				newRadius = _v.length();

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );
				this.zoomToCursor = false;

			}

			// handle the placement of the target
			if ( newRadius !== null ) {

				if ( this.screenSpacePanning ) {

					// position the orbit target in front of the new camera position
					this.target.set( 0, 0, -1 )
						.transformDirection( this.object.matrix )
						.multiplyScalar( newRadius )
						.add( this.object.position );

				} else {

					// get the ray and translation plane to compute target
					_ray.origin.copy( this.object.position );
					_ray.direction.set( 0, 0, -1 ).transformDirection( this.object.matrix );

					// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid
					// extremely large values
					if ( Math.abs( this.object.up.dot( _ray.direction ) ) < _TILT_LIMIT ) {

						this.object.lookAt( this.target );

					} else {

						_plane.setFromNormalAndCoplanarPoint( this.object.up, this.target );
						_ray.intersectPlane( _plane, this.target );

					}

				}

			}

		} else if ( this.object.isOrthographicCamera ) {

			const prevZoom = this.object.zoom;
			this.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / this._scale ) );

			if ( prevZoom !== this.object.zoom ) {

				this.object.updateProjectionMatrix();
				zoomChanged = true;

			}

		}

		this._scale = 1;
		this._performCursorZoom = false;

		// update condition is:
		// min(camera displacement, camera rotation in radians)^2 > EPS
		// using small-angle approximation cos(x/2) = 1 - x^2 / 8

		if ( zoomChanged ||
			this._lastPosition.distanceToSquared( this.object.position ) > _EPS ||
			8 * ( 1 - this._lastQuaternion.dot( this.object.quaternion ) ) > _EPS ||
			this._lastTargetPosition.distanceToSquared( this.target ) > _EPS ) {

			this.dispatchEvent( _changeEvent );

			this._lastPosition.copy( this.object.position );
			this._lastQuaternion.copy( this.object.quaternion );
			this._lastTargetPosition.copy( this.target );

			return true;

		}

		return false;

	}

	_getAutoRotationAngle( deltaTime ) {

		if ( deltaTime !== null ) {

			return ( _twoPI / 60 * this.autoRotateSpeed ) * deltaTime;

		} else {

			return _twoPI / 60 / 60 * this.autoRotateSpeed;

		}

	}

	_getZoomScale( delta ) {

		const normalizedDelta = Math.abs( delta * 0.01 );
		return Math.pow( 0.95, this.zoomSpeed * normalizedDelta );

	}

	_rotateLeft( angle ) {

		this._sphericalDelta.theta -= angle;

	}

	_rotateUp( angle ) {

		this._sphericalDelta.phi -= angle;

	}

	_panLeft( distance, objectMatrix ) {

		_v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
		_v.multiplyScalar( - distance );

		this._panOffset.add( _v );

	}

	_panUp( distance, objectMatrix ) {

		if ( this.screenSpacePanning === true ) {

			_v.setFromMatrixColumn( objectMatrix, 1 );

		} else {

			_v.setFromMatrixColumn( objectMatrix, 0 );
			_v.crossVectors( this.object.up, _v );

		}

		_v.multiplyScalar( distance );

		this._panOffset.add( _v );

	}

	// deltaX and deltaY are in pixels; right and down are positive
	_pan( deltaX, deltaY ) {

		const element = this.domElement;

		if ( this.object.isPerspectiveCamera ) {

			// perspective
			const position = this.object.position;
			_v.copy( position ).sub( this.target );
			let targetDistance = _v.length();

			// half of the fov is center to top of screen
			targetDistance *= Math.tan( ( this.object.fov / 2 ) * Math.PI / 180.0 );

			// we use only clientHeight here so aspect ratio does not distort speed
			this._panLeft( 2 * deltaX * targetDistance / element.clientHeight, this.object.matrix );
			this._panUp( 2 * deltaY * targetDistance / element.clientHeight, this.object.matrix );

		} else if ( this.object.isOrthographicCamera ) {

			// orthographic
			this._panLeft( deltaX * ( this.object.right - this.object.left ) / this.object.zoom / element.clientWidth, this.object.matrix );
			this._panUp( deltaY * ( this.object.top - this.object.bottom ) / this.object.zoom / element.clientHeight, this.object.matrix );

		} else {

			// camera neither orthographic nor perspective
			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
			this.enablePan = false;

		}

	}

	_dollyOut( dollyScale ) {

		if ( this.object.isPerspectiveCamera || this.object.isOrthographicCamera ) {

			this._scale /= dollyScale;

		} else {

			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
			this.enableZoom = false;

		}

	}

	_dollyIn( dollyScale ) {

		if ( this.object.isPerspectiveCamera || this.object.isOrthographicCamera ) {

			this._scale *= dollyScale;

		} else {

			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
			this.enableZoom = false;

		}

	}

	_updateZoomParameters( x, y ) {

		if ( ! this.zoomToCursor ) {

			return;

		}

		this._performCursorZoom = true;

		const rect = this.domElement.getBoundingClientRect();
		const dx = x - rect.left;
		const dy = y - rect.top;
		const w = rect.width;
		const h = rect.height;

		this._mouse.x = ( dx / w ) * 2 - 1;
		this._mouse.y = - ( dy / h ) * 2 + 1;

		this._dollyDirection.set( this._mouse.x, this._mouse.y, 1 ).unproject( this.object ).sub( this.object.position ).normalize();

	}

	_clampDistance( dist ) {

		return Math.max( this.minDistance, Math.min( this.maxDistance, dist ) );

	}

	//
	// event callbacks - update the object state
	//

	_handleMouseDownRotate( event ) {

		this._rotateStart.set( event.clientX, event.clientY );

	}

	_handleMouseDownDolly( event ) {

		this._updateZoomParameters( event.clientX, event.clientX );
		this._dollyStart.set( event.clientX, event.clientY );

	}

	_handleMouseDownPan( event ) {

		this._panStart.set( event.clientX, event.clientY );

	}

	_handleMouseMoveRotate( event ) {

		this._rotateEnd.set( event.clientX, event.clientY );

		this._rotateDelta.subVectors( this._rotateEnd, this._rotateStart ).multiplyScalar( this.rotateSpeed );

		const element = this.domElement;

		this._rotateLeft( _twoPI * this._rotateDelta.x / element.clientHeight ); // yes, height

		this._rotateUp( _twoPI * this._rotateDelta.y / element.clientHeight );

		this._rotateStart.copy( this._rotateEnd );

		this.update();

	}

	_handleMouseMoveDolly( event ) {

		this._dollyEnd.set( event.clientX, event.clientY );

		this._dollyDelta.subVectors( this._dollyEnd, this._dollyStart );

		if ( this._dollyDelta.y > 0 ) {

			this._dollyOut( this._getZoomScale( this._dollyDelta.y ) );

		} else if ( this._dollyDelta.y < 0 ) {

			this._dollyIn( this._getZoomScale( this._dollyDelta.y ) );

		}

		this._dollyStart.copy( this._dollyEnd );

		this.update();

	}

	_handleMouseMovePan( event ) {

		this._panEnd.set( event.clientX, event.clientY );

		this._panDelta.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.panSpeed );

		this._pan( this._panDelta.x, this._panDelta.y );

		this._panStart.copy( this._panEnd );

		this.update();

	}

	_handleMouseWheel( event ) {

		this._updateZoomParameters( event.clientX, event.clientY );

		if ( event.deltaY < 0 ) {

			this._dollyIn( this._getZoomScale( event.deltaY ) );

		} else if ( event.deltaY > 0 ) {

			this._dollyOut( this._getZoomScale( event.deltaY ) );

		}

		this.update();

	}

	_handleKeyDown( event ) {

		let needsUpdate = false;

		switch ( event.code ) {

			case this.keys.UP:

				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

					if ( this.enableRotate ) {

						this._rotateUp( _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );

					}

				} else {

					if ( this.enablePan ) {

						this._pan( 0, this.keyPanSpeed );

					}

				}

				needsUpdate = true;
				break;

			case this.keys.BOTTOM:

				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

					if ( this.enableRotate ) {

						this._rotateUp( - _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );

					}

				} else {

					if ( this.enablePan ) {

						this._pan( 0, - this.keyPanSpeed );

					}

				}

				needsUpdate = true;
				break;

			case this.keys.LEFT:

				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

					if ( this.enableRotate ) {

						this._rotateLeft( _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );

					}

				} else {

					if ( this.enablePan ) {

						this._pan( this.keyPanSpeed, 0 );

					}

				}

				needsUpdate = true;
				break;

			case this.keys.RIGHT:

				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

					if ( this.enableRotate ) {

						this._rotateLeft( - _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );

					}

				} else {

					if ( this.enablePan ) {

						this._pan( - this.keyPanSpeed, 0 );

					}

				}

				needsUpdate = true;
				break;

		}

		if ( needsUpdate ) {

			// prevent the browser from scrolling on cursor keys
			event.preventDefault();

			this.update();

		}


	}

	_handleTouchStartRotate( event ) {

		if ( this._pointers.length === 1 ) {

			this._rotateStart.set( event.pageX, event.pageY );

		} else {

			const position = this._getSecondPointerPosition( event );

			const x = 0.5 * ( event.pageX + position.x );
			const y = 0.5 * ( event.pageY + position.y );

			this._rotateStart.set( x, y );

		}

	}

	_handleTouchStartPan( event ) {

		if ( this._pointers.length === 1 ) {

			this._panStart.set( event.pageX, event.pageY );

		} else {

			const position = this._getSecondPointerPosition( event );

			const x = 0.5 * ( event.pageX + position.x );
			const y = 0.5 * ( event.pageY + position.y );

			this._panStart.set( x, y );

		}

	}

	_handleTouchStartDolly( event ) {

		const position = this._getSecondPointerPosition( event );

		const dx = event.pageX - position.x;
		const dy = event.pageY - position.y;

		const distance = Math.sqrt( dx * dx + dy * dy );

		this._dollyStart.set( 0, distance );

	}

	_handleTouchStartDollyPan( event ) {

		if ( this.enableZoom ) this._handleTouchStartDolly( event );

		if ( this.enablePan ) this._handleTouchStartPan( event );

	}

	_handleTouchStartDollyRotate( event ) {

		if ( this.enableZoom ) this._handleTouchStartDolly( event );

		if ( this.enableRotate ) this._handleTouchStartRotate( event );

	}

	_handleTouchMoveRotate( event ) {

		if ( this._pointers.length == 1 ) {

			this._rotateEnd.set( event.pageX, event.pageY );

		} else {

			const position = this._getSecondPointerPosition( event );

			const x = 0.5 * ( event.pageX + position.x );
			const y = 0.5 * ( event.pageY + position.y );

			this._rotateEnd.set( x, y );

		}

		this._rotateDelta.subVectors( this._rotateEnd, this._rotateStart ).multiplyScalar( this.rotateSpeed );

		const element = this.domElement;

		this._rotateLeft( _twoPI * this._rotateDelta.x / element.clientHeight ); // yes, height

		this._rotateUp( _twoPI * this._rotateDelta.y / element.clientHeight );

		this._rotateStart.copy( this._rotateEnd );

	}

	_handleTouchMovePan( event ) {

		if ( this._pointers.length === 1 ) {

			this._panEnd.set( event.pageX, event.pageY );

		} else {

			const position = this._getSecondPointerPosition( event );

			const x = 0.5 * ( event.pageX + position.x );
			const y = 0.5 * ( event.pageY + position.y );

			this._panEnd.set( x, y );

		}

		this._panDelta.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.panSpeed );

		this._pan( this._panDelta.x, this._panDelta.y );

		this._panStart.copy( this._panEnd );

	}

	_handleTouchMoveDolly( event ) {

		const position = this._getSecondPointerPosition( event );

		const dx = event.pageX - position.x;
		const dy = event.pageY - position.y;

		const distance = Math.sqrt( dx * dx + dy * dy );

		this._dollyEnd.set( 0, distance );

		this._dollyDelta.set( 0, Math.pow( this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed ) );

		this._dollyOut( this._dollyDelta.y );

		this._dollyStart.copy( this._dollyEnd );

		const centerX = ( event.pageX + position.x ) * 0.5;
		const centerY = ( event.pageY + position.y ) * 0.5;

		this._updateZoomParameters( centerX, centerY );

	}

	_handleTouchMoveDollyPan( event ) {

		if ( this.enableZoom ) this._handleTouchMoveDolly( event );

		if ( this.enablePan ) this._handleTouchMovePan( event );

	}

	_handleTouchMoveDollyRotate( event ) {

		if ( this.enableZoom ) this._handleTouchMoveDolly( event );

		if ( this.enableRotate ) this._handleTouchMoveRotate( event );

	}

	// pointers

	_addPointer( event ) {

		this._pointers.push( event.pointerId );

	}

	_removePointer( event ) {

		delete this._pointerPositions[ event.pointerId ];

		for ( let i = 0; i < this._pointers.length; i ++ ) {

			if ( this._pointers[ i ] == event.pointerId ) {

				this._pointers.splice( i, 1 );
				return;

			}

		}

	}

	_isTrackingPointer( event ) {

		for ( let i = 0; i < this._pointers.length; i ++ ) {

			if ( this._pointers[ i ] == event.pointerId ) return true;

		}

		return false;

	}

	_trackPointer( event ) {

		let position = this._pointerPositions[ event.pointerId ];

		if ( position === undefined ) {

			position = new Vector2();
			this._pointerPositions[ event.pointerId ] = position;

		}

		position.set( event.pageX, event.pageY );

	}

	_getSecondPointerPosition( event ) {

		const pointerId = ( event.pointerId === this._pointers[ 0 ] ) ? this._pointers[ 1 ] : this._pointers[ 0 ];

		return this._pointerPositions[ pointerId ];

	}

	//

	_customWheelEvent( event ) {

		const mode = event.deltaMode;

		// minimal wheel event altered to meet delta-zoom demand
		const newEvent = {
			clientX: event.clientX,
			clientY: event.clientY,
			deltaY: event.deltaY,
		};

		switch ( mode ) {

			case 1: // LINE_MODE
				newEvent.deltaY *= 16;
				break;

			case 2: // PAGE_MODE
				newEvent.deltaY *= 100;
				break;

		}

		// detect if event was triggered by pinching
		if ( event.ctrlKey && ! this._controlActive ) {

			newEvent.deltaY *= 10;

		}

		return newEvent;

	}

}

function onPointerDown( event ) {

	if ( this.enabled === false ) return;

	if ( this._pointers.length === 0 ) {

		this.domElement.setPointerCapture( event.pointerId );

		this.domElement.addEventListener( 'pointermove', this._onPointerMove );
		this.domElement.addEventListener( 'pointerup', this._onPointerUp );

	}

	//

	if ( this._isTrackingPointer( event ) ) return;

	//

	this._addPointer( event );

	if ( event.pointerType === 'touch' ) {

		this._onTouchStart( event );

	} else {

		this._onMouseDown( event );

	}

}

function onPointerMove( event ) {

	if ( this.enabled === false ) return;

	if ( event.pointerType === 'touch' ) {

		this._onTouchMove( event );

	} else {

		this._onMouseMove( event );

	}

}

function onPointerUp( event ) {

	this._removePointer( event );

	switch ( this._pointers.length ) {

		case 0:

			this.domElement.releasePointerCapture( event.pointerId );

			this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
			this.domElement.removeEventListener( 'pointerup', this._onPointerUp );

			this.dispatchEvent( _endEvent );

			this.state = _STATE.NONE;

			break;

		case 1:

			const pointerId = this._pointers[ 0 ];
			const position = this._pointerPositions[ pointerId ];

			// minimal placeholder event - allows state correction on pointer-up
			this._onTouchStart( { pointerId: pointerId, pageX: position.x, pageY: position.y } );

			break;

	}

}

function onMouseDown( event ) {

	let mouseAction;

	switch ( event.button ) {

		case 0:

			mouseAction = this.mouseButtons.LEFT;
			break;

		case 1:

			mouseAction = this.mouseButtons.MIDDLE;
			break;

		case 2:

			mouseAction = this.mouseButtons.RIGHT;
			break;

		default:

			mouseAction = -1;

	}

	switch ( mouseAction ) {

		case MOUSE.DOLLY:

			if ( this.enableZoom === false ) return;

			this._handleMouseDownDolly( event );

			this.state = _STATE.DOLLY;

			break;

		case MOUSE.ROTATE:

			if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

				if ( this.enablePan === false ) return;

				this._handleMouseDownPan( event );

				this.state = _STATE.PAN;

			} else {

				if ( this.enableRotate === false ) return;

				this._handleMouseDownRotate( event );

				this.state = _STATE.ROTATE;

			}

			break;

		case MOUSE.PAN:

			if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

				if ( this.enableRotate === false ) return;

				this._handleMouseDownRotate( event );

				this.state = _STATE.ROTATE;

			} else {

				if ( this.enablePan === false ) return;

				this._handleMouseDownPan( event );

				this.state = _STATE.PAN;

			}

			break;

		default:

			this.state = _STATE.NONE;

	}

	if ( this.state !== _STATE.NONE ) {

		this.dispatchEvent( _startEvent );

	}

}

function onMouseMove( event ) {

	switch ( this.state ) {

		case _STATE.ROTATE:

			if ( this.enableRotate === false ) return;

			this._handleMouseMoveRotate( event );

			break;

		case _STATE.DOLLY:

			if ( this.enableZoom === false ) return;

			this._handleMouseMoveDolly( event );

			break;

		case _STATE.PAN:

			if ( this.enablePan === false ) return;

			this._handleMouseMovePan( event );

			break;

	}

}

function onMouseWheel( event ) {

	if ( this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE ) return;

	event.preventDefault();

	this.dispatchEvent( _startEvent );

	this._handleMouseWheel( this._customWheelEvent( event ) );

	this.dispatchEvent( _endEvent );

}

function onKeyDown( event ) {

	if ( this.enabled === false ) return;

	this._handleKeyDown( event );

}

function onTouchStart( event ) {

	this._trackPointer( event );

	switch ( this._pointers.length ) {

		case 1:

			switch ( this.touches.ONE ) {

				case TOUCH.ROTATE:

					if ( this.enableRotate === false ) return;

					this._handleTouchStartRotate( event );

					this.state = _STATE.TOUCH_ROTATE;

					break;

				case TOUCH.PAN:

					if ( this.enablePan === false ) return;

					this._handleTouchStartPan( event );

					this.state = _STATE.TOUCH_PAN;

					break;

				default:

					this.state = _STATE.NONE;

			}

			break;

		case 2:

			switch ( this.touches.TWO ) {

				case TOUCH.DOLLY_PAN:

					if ( this.enableZoom === false && this.enablePan === false ) return;

					this._handleTouchStartDollyPan( event );

					this.state = _STATE.TOUCH_DOLLY_PAN;

					break;

				case TOUCH.DOLLY_ROTATE:

					if ( this.enableZoom === false && this.enableRotate === false ) return;

					this._handleTouchStartDollyRotate( event );

					this.state = _STATE.TOUCH_DOLLY_ROTATE;

					break;

				default:

					this.state = _STATE.NONE;

			}

			break;

		default:

			this.state = _STATE.NONE;

	}

	if ( this.state !== _STATE.NONE ) {

		this.dispatchEvent( _startEvent );

	}

}

function onTouchMove( event ) {

	this._trackPointer( event );

	switch ( this.state ) {

		case _STATE.TOUCH_ROTATE:

			if ( this.enableRotate === false ) return;

			this._handleTouchMoveRotate( event );

			this.update();

			break;

		case _STATE.TOUCH_PAN:

			if ( this.enablePan === false ) return;

			this._handleTouchMovePan( event );

			this.update();

			break;

		case _STATE.TOUCH_DOLLY_PAN:

			if ( this.enableZoom === false && this.enablePan === false ) return;

			this._handleTouchMoveDollyPan( event );

			this.update();

			break;

		case _STATE.TOUCH_DOLLY_ROTATE:

			if ( this.enableZoom === false && this.enableRotate === false ) return;

			this._handleTouchMoveDollyRotate( event );

			this.update();

			break;

		default:

			this.state = _STATE.NONE;

	}

}

function onContextMenu( event ) {

	if ( this.enabled === false ) return;

	event.preventDefault();

}

function interceptControlDown( event ) {

	if ( event.key === 'Control' ) {

		this._controlActive = true;

		const document = this.domElement.getRootNode(); // offscreen canvas compatibility

		document.addEventListener( 'keyup', this._interceptControlUp, { passive: true, capture: true } );

	}

}

function interceptControlUp( event ) {

	if ( event.key === 'Control' ) {

		this._controlActive = false;

		const document = this.domElement.getRootNode(); // offscreen canvas compatibility

		document.removeEventListener( 'keyup', this._interceptControlUp, { passive: true, capture: true } );

	}

}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Universal Glow Intensity Filter
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Universal glow intensity calculator based on color luminance
 * @author Emotive Engine Team
 * @version 1.0.0
 * @module utils/glowIntensityFilter
 * @complexity ⭐⭐ Intermediate
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Automatically calculates optimal glow intensity for glass materials based on
 * ║ color luminance. Ensures consistent visibility across all emotions regardless
 * ║ of their native color brightness.
 * ║
 * ║ DERIVED FROM: 14 hand-tuned emotion values using linear regression
 * ║ CORRELATION: -0.89 (very strong inverse relationship)
 * ║ FORMULA: intensity = -1.0692 × luminance + 1.2353
 * ║ WORKS FOR: Any hex color, not just predefined emotions
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


/**
 * Normalize RGB color (0-1 range) to have equal luminance across all colors
 * Same as normalizeColorLuminance but takes RGB array instead of hex string
 *
 * @param {Array} rgb - RGB array [r, g, b] with values in 0-1 range
 * @param {number} targetLuminance - Target luminance value (default 0.5)
 * @returns {Object} RGB object with normalized values {r, g, b} in sRGB space
 */
function normalizeRGBLuminance(rgb, targetLuminance = 0.5) {
    const [r, g, b] = rgb;

    // Convert sRGB to linear RGB (inverse gamma)
    const toLinear = c => c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    const rLin = toLinear(r);
    const gLin = toLinear(g);
    const bLin = toLinear(b);

    // Calculate current luminance in linear space
    const currentLuminance = 0.2126 * rLin + 0.7152 * gLin + 0.0722 * bLin;

    // Calculate scale factor to achieve target luminance
    const scaleFactor = targetLuminance / Math.max(currentLuminance, 0.001);

    // Scale in linear space
    let rLinScaled = rLin * scaleFactor;
    let gLinScaled = gLin * scaleFactor;
    let bLinScaled = bLin * scaleFactor;

    // Clamp in linear space (before gamma) to prevent overflow
    const maxLin = Math.max(rLinScaled, gLinScaled, bLinScaled);
    if (maxLin > 1.0) {
        rLinScaled /= maxLin;
        gLinScaled /= maxLin;
        bLinScaled /= maxLin;
    }

    // Convert back to sRGB (apply gamma)
    const toSRGB = c => c <= 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 1/2.4) - 0.055;

    return {
        r: Math.min(1.0, Math.max(0, toSRGB(rLinScaled))),
        g: Math.min(1.0, Math.max(0, toSRGB(gLinScaled))),
        b: Math.min(1.0, Math.max(0, toSRGB(bLinScaled)))
    };
}

/**
 * Calculate relative luminance using W3C/WCAG sRGB formula
 * Uses ITU-R BT.709 coefficients for color-to-luminance conversion
 *
 * @param {string} hexColor - Hex color code (e.g., '#FF6B35')
 * @returns {number} Relative luminance value between 0 (black) and 1 (white)
 *
 * @example
 * calculateLuminance('#FFEB3B') // 0.8099 (bright yellow)
 * calculateLuminance('#6B46C1') // 0.1136 (dark purple)
 */
function calculateLuminance(hexColor) {
    // Convert hex to RGB (0-1 range)
    const r = parseInt(hexColor.slice(1, 3), 16) / 255;
    const g = parseInt(hexColor.slice(3, 5), 16) / 255;
    const b = parseInt(hexColor.slice(5, 7), 16) / 255;

    // Apply sRGB gamma correction (inverse transfer function)
    // Official threshold is 0.04045 per W3C/sRGB specification
    const linearize = c => {
        return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    };

    const rLinear = linearize(r);
    const gLinear = linearize(g);
    const bLinear = linearize(b);

    // Calculate relative luminance using ITU-R BT.709 coefficients
    // These weights reflect human eye's sensitivity (green > red > blue)
    return 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;
}

/**
 * Calculate optimal glow intensity based on color luminance and material mode
 *
 * GLASS MODE (high transmission):
 * - Bright colors get washed out → need HIGHER intensity
 * - Dark colors stay visible → need LOWER intensity
 * - Formula inverted: positive slope
 *
 * GLOW MODE (dark background):
 * - Bright colors naturally visible → need LOWER intensity
 * - Dark colors hard to see → need HIGHER intensity
 * - Formula: negative slope (original)
 *
 * @param {string} hexColor - Hex color code (e.g., '#FF6B35')
 * @param {number} calibrationOffset - Optional offset to adjust global brightness (default: 0)
 * @param {string} mode - Material mode: 'glass' or 'glow' (default: 'glass')
 * @returns {number} Optimal glow intensity (typically 0.4 - 1.3)
 *
 * @example
 * // GLASS MODE (default) - bright colors need MORE intensity
 * getGlowIntensityForColor('#FFEB3B', 0, 'glass') // ~1.20 (bright yellow needs boost)
 * getGlowIntensityForColor('#4169E1', 0, 'glass') // ~0.70 (dark blue stays dim)
 *
 * // GLOW MODE - dark colors need MORE intensity
 * getGlowIntensityForColor('#FFEB3B', 0, 'glow') // ~0.37 (bright yellow stays dim)
 * getGlowIntensityForColor('#4169E1', 0, 'glow') // ~1.11 (dark blue needs boost)
 */
function getGlowIntensityForColor(hexColor, calibrationOffset = 0, _mode = 'glow') {
    const luminance = calculateLuminance(hexColor);

    // Target perceived brightness (luminance × intensity = constant)
    // This ensures all colors appear equally bright regardless of their base luminance
    // Higher target needed because darker colors need significant boost
    const targetBrightness = 0.5 + calibrationOffset;

    // To achieve uniform perceived brightness, divide target by luminance
    // Bright colors (high luminance) get low intensity multipliers
    // Dark colors (low luminance) get high intensity multipliers
    // Prevent division by very small numbers with minimum luminance threshold
    const minLuminance = 0.05;
    const intensity = targetBrightness / Math.max(luminance, minLuminance);

    // Clamp to reasonable range
    // Min 0.3: Ensures even brightest colors remain visible
    // Max 10.0: Allows very dark colors to be boosted dramatically
    return Math.max(0.3, Math.min(10.0, intensity));
}

/**
 * Isolated Glow Layer Effect
 *
 * A completely separate rendering layer that creates an expanding luminous halo
 * around the crystal during glow/flash gestures. This effect is:
 *
 * - INVISIBLE at baseline (opacity=0, no geometry rendered)
 * - Only activates when glowAmount > 0
 * - Renders AFTER all existing post-processing
 * - Uses its own dedicated scene/camera/render pass
 *
 * ARCHITECTURE:
 * The key insight is that this layer is completely isolated from the main
 * rendering pipeline. It doesn't touch bloom, materials, or the crystal shader.
 * The glow layer renders as a screen-space overlay guaranteed to appear on top.
 *
 * Visual effect: An expanding luminous halo/ring that emanates from the crystal
 * during glow gestures, fading at the edges like light radiating outward.
 */


class GlowLayer {
    /**
     * Create a glow layer effect
     * @param {THREE.WebGLRenderer} renderer - Three.js renderer
     */
    constructor(renderer) {
        this.renderer = renderer;

        // Current glow state
        this.glowAmount = 0; // 0 = invisible, >0 = visible
        this.targetGlowAmount = 0;
        this.glowColor = new Color(1.0, 1.0, 1.0);
        this.targetGlowColor = new Color(1.0, 1.0, 1.0);
        this.worldPosition = new Vector3(0, 0, 0);

        // Animation state
        this.time = 0;
        this.ringPhase = 0; // For animated ring expansion

        // Own scene and camera for screen-space rendering
        this.scene = new Scene();
        this.camera = new OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        this.camera.position.z = 1;

        // Create the glow geometry and material
        this.createGlowMesh();

        // Temp vectors for calculations
        this._tempVector = new Vector3();
        this._tempColor = new Color();
    }

    /**
     * Create the glow mesh with expandable ring/halo geometry
     * @private
     */
    createGlowMesh() {
        // Create a large quad that covers the screen
        // The shader will handle the actual ring/halo shape
        const geometry = new PlaneGeometry(2, 2);

        const material = new ShaderMaterial({
            uniforms: {
                glowAmount: { value: 0.0 },
                glowColor: { value: new Color(1.0, 1.0, 1.0) },
                centerUV: { value: new Vector2(0.5, 0.5) },
                time: { value: 0.0 },
                ringPhase: { value: 0.0 }, // 0 = tight ring, 1 = expanded
                aspectRatio: { value: 1.0 }
            },
            vertexShader: `
                varying vec2 vUv;

                void main() {
                    vUv = uv;
                    gl_Position = vec4(position.xy, 0.0, 1.0);
                }
            `,
            fragmentShader: `
                uniform float glowAmount;
                uniform vec3 glowColor;
                uniform vec2 centerUV;
                uniform float time;
                uniform float ringPhase;
                uniform float aspectRatio;

                varying vec2 vUv;

                void main() {
                    // Aspect-correct UV coordinates - apply aspect to Y instead
                    // This prevents horizontal clipping on wide screens
                    vec2 centeredUV = vUv - centerUV;
                    // Don't multiply by aspect - let glow be circular in screen space

                    float dist = length(centeredUV);

                    // Ring parameters that evolve with ringPhase
                    // MUCH LARGER radii to prevent clipping - glow can extend to screen edges
                    // At ringPhase=0: tight ring close to center
                    // At ringPhase=1: expanded ring that can fill most of screen
                    float innerRadius = mix(0.02, 0.08, ringPhase);
                    float outerRadius = mix(0.15, 1.2, ringPhase);  // Can extend beyond screen!
                    float peakRadius = mix(0.06, 0.25, ringPhase);

                    // Create soft ring falloff
                    // Inner falloff: 0 at center, 1 at peak
                    float innerFalloff = smoothstep(innerRadius * 0.3, peakRadius, dist);

                    // Outer falloff: 1 at peak, 0 at outer edge (very gradual fade)
                    float outerFalloff = 1.0 - smoothstep(peakRadius, outerRadius, dist);

                    // Combine for ring shape
                    float ringIntensity = innerFalloff * outerFalloff;

                    // Add subtle shimmer/undulation
                    float shimmer = 0.9 + 0.1 * sin(time * 3.0 + dist * 20.0);

                    // Final intensity with glow amount control
                    float intensity = ringIntensity * glowAmount * shimmer;

                    // Soft glow color with intensity
                    // Use HDR values (>1.0) for bloom pickup
                    vec3 color = glowColor * intensity * 2.0;

                    // Alpha for blending
                    float alpha = intensity * 0.6;

                    gl_FragColor = vec4(color, alpha);
                }
            `,
            transparent: true,
            blending: AdditiveBlending,
            depthTest: false,
            depthWrite: false
        });

        this.glowMesh = new Mesh(geometry, material);
        this.scene.add(this.glowMesh);
    }

    /**
     * Update glow parameters
     * @param {number} glowAmount - Glow intensity (0 = off, >0 = active)
     * @param {THREE.Color|Array} color - Glow color
     * @param {THREE.Vector3} worldPosition - World position of the glow source
     */
    setGlow(glowAmount, color, worldPosition) {
        this.targetGlowAmount = Math.max(0, glowAmount);

        if (color) {
            if (Array.isArray(color)) {
                this.targetGlowColor.setRGB(color[0], color[1], color[2]);
            } else {
                this.targetGlowColor.copy(color);
            }
        }

        if (worldPosition) {
            this.worldPosition.copy(worldPosition);
        }
    }

    /**
     * Update the glow layer animation
     * @param {number} deltaTime - Time since last frame in milliseconds
     * @param {THREE.Camera} mainCamera - Main scene camera for projection
     */
    update(deltaTime, mainCamera) {
        const dt = deltaTime / 1000; // Convert to seconds
        this.time += dt;

        // Smooth lerp to target glow amount
        const lerpSpeed = 8.0; // Fast response for gestures
        this.glowAmount += (this.targetGlowAmount - this.glowAmount) * Math.min(1.0, lerpSpeed * dt);

        // Smooth lerp color
        this.glowColor.lerp(this.targetGlowColor, Math.min(1.0, lerpSpeed * dt));

        // Update ring phase based on glow amount
        // Ring expands as glow increases, contracts as it fades
        const targetPhase = Math.min(1.0, this.glowAmount);
        this.ringPhase += (targetPhase - this.ringPhase) * Math.min(1.0, 4.0 * dt);

        // Project world position to screen UV
        if (mainCamera) {
            this._tempVector.copy(this.worldPosition);
            this._tempVector.project(mainCamera);

            // Convert from NDC (-1 to 1) to UV (0 to 1)
            const centerU = (this._tempVector.x + 1) / 2;
            const centerV = (this._tempVector.y + 1) / 2;

            this.glowMesh.material.uniforms.centerUV.value.set(centerU, centerV);
        }

        // Update uniforms
        this.glowMesh.material.uniforms.glowAmount.value = this.glowAmount;
        this.glowMesh.material.uniforms.glowColor.value.copy(this.glowColor);
        this.glowMesh.material.uniforms.time.value = this.time;
        this.glowMesh.material.uniforms.ringPhase.value = this.ringPhase;

        // Update aspect ratio
        const canvas = this.renderer.domElement;
        this.glowMesh.material.uniforms.aspectRatio.value = canvas.width / canvas.height;
    }

    /**
     * Render the glow layer
     * Should be called AFTER the main scene render with autoClear: false
     * @param {THREE.WebGLRenderer} renderer - WebGL renderer
     */
    render(renderer) {
        // Only render if there's visible glow
        if (this.glowAmount < 0.001) {
            return;
        }

        // Save renderer state
        const {autoClear} = renderer;
        renderer.autoClear = false;

        // Render glow layer on top of existing frame
        renderer.render(this.scene, this.camera);

        // Restore state
        renderer.autoClear = autoClear;
    }

    /**
     * Check if glow layer is currently active (visible)
     * @returns {boolean} True if glow is active
     */
    isActive() {
        return this.glowAmount > 0.001 || this.targetGlowAmount > 0;
    }

    /**
     * Dispose of glow layer resources
     */
    dispose() {
        if (this.glowMesh) {
            this.glowMesh.geometry.dispose();
            this.glowMesh.material.dispose();
            this.scene.remove(this.glowMesh);
            this.glowMesh = null;
        }

        this.scene = null;
        this.camera = null;
        this._tempVector = null;
        this._tempColor = null;
    }
}

/**
 * CameraPresetManager - Manages camera preset views and transitions
 *
 * Provides smooth camera transitions to predefined viewpoints:
 * - front, side, top, angle, back, bottom
 *
 * Extracted from ThreeRenderer to improve separation of concerns.
 *
 * @module 3d/managers/CameraPresetManager
 */


/**
 * Available camera preset positions
 * @param {number} d - Camera distance from origin
 */
const getPresets = d => ({
    front: { x: 0, y: 0, z: d },
    side: { x: d, y: 0, z: 0 },
    top: { x: 0, y: d, z: 0 },
    angle: { x: d * 0.67, y: d * 0.5, z: d * 0.67 },
    back: { x: 0, y: 0, z: -d },
    bottom: { x: 0, y: -d, z: 0 }
});

class CameraPresetManager {
    /**
     * Create camera preset manager
     * @param {THREE.Camera} camera - The camera to control
     * @param {OrbitControls} controls - The orbit controls
     * @param {number} cameraDistance - Default distance from origin
     */
    constructor(camera, controls, cameraDistance = 3) {
        this.camera = camera;
        this.controls = controls;
        this.cameraDistance = cameraDistance;
        this.animationId = null;
    }

    /**
     * Get list of available presets
     * @returns {string[]}
     */
    getAvailablePresets() {
        return Object.keys(getPresets(this.cameraDistance));
    }

    /**
     * Set camera to a preset view with smooth transition
     * @param {string} preset - Preset name ('front', 'side', 'top', 'angle', 'back', 'bottom')
     * @param {number} duration - Transition duration in ms (default 1000)
     * @param {boolean} preserveTarget - If true, keep the current controls.target (default false)
     */
    setPreset(preset, duration = 1000, preserveTarget = false) {
        if (!this.controls) return;

        const presets = getPresets(this.cameraDistance);
        const targetPos = presets[preset];

        if (!targetPos) {
            console.warn(`Unknown camera preset: ${preset}`);
            return;
        }

        // Cancel any ongoing animation
        this.cancelAnimation();

        // Save current target if we need to preserve it
        const savedTarget = preserveTarget ? this.controls.target.clone() : null;

        // If instant (duration = 0), set position directly
        if (duration === 0) {
            this._setInstant(targetPos, savedTarget);
            return;
        }

        // Animated transition
        this._animateTo(targetPos, duration, savedTarget, preserveTarget);
    }

    /**
     * Set camera position instantly
     * @private
     */
    _setInstant(targetPos, savedTarget) {
        // Fully reset OrbitControls to initial state
        this.controls.reset();
        // Then set to target position
        this.camera.position.set(targetPos.x, targetPos.y, targetPos.z);
        // Preserve or reset the controls target
        if (savedTarget) {
            this.controls.target.copy(savedTarget);
            this.camera.lookAt(savedTarget);
        } else {
            this.controls.target.set(0, 0, 0);
            this.camera.lookAt(0, 0, 0);
        }
        this.controls.update();
    }

    /**
     * Animate camera to target position
     * @private
     */
    _animateTo(targetPos, duration, savedTarget, preserveTarget) {
        // Reset OrbitControls target to center (origin) for animated presets
        if (!preserveTarget) {
            this.controls.target.set(0, 0, 0);
        }

        // Smoothly animate camera to target position
        const startPos = this.camera.position.clone();
        const endPos = new Vector3(targetPos.x, targetPos.y, targetPos.z);
        const startTime = performance.now();

        const animate = currentTime => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1.0);

            // Ease out cubic for smooth deceleration
            const eased = 1 - Math.pow(1 - progress, 3);

            this.camera.position.lerpVectors(startPos, endPos, eased);
            this.camera.lookAt(0, 0, 0);
            this.controls.update();

            if (progress < 1.0) {
                this.animationId = requestAnimationFrame(animate);
            } else {
                this.animationId = null;
            }
        };

        this.animationId = requestAnimationFrame(animate);
    }

    /**
     * Check if animation is in progress
     * @returns {boolean}
     */
    isAnimating() {
        return this.animationId !== null;
    }

    /**
     * Cancel any ongoing camera animation
     */
    cancelAnimation() {
        if (this.animationId !== null) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }

    /**
     * Reset camera to default front view
     * @param {number} duration - Transition duration in ms
     */
    reset(duration = 1000) {
        this.setPreset('front', duration);
    }

    /**
     * Update camera distance (affects preset positions)
     * @param {number} distance - New camera distance
     */
    setCameraDistance(distance) {
        this.cameraDistance = distance;
    }

    /**
     * Dispose manager and clean up
     */
    dispose() {
        this.cancelAnimation();
        this.camera = null;
        this.controls = null;
    }
}

/**
 * ThreeRenderer - Three.js-based WebGL rendering engine
 *
 * Replaces custom WebGL renderer with Three.js for:
 * - Better lighting (three-point lighting system)
 * - Post-processing effects (bloom, glow)
 * - Advanced materials and shaders
 * - Model loading capabilities (GLTF/GLB)
 * - Real-time shadows
 * - GPU-accelerated particles
 *
 * @module ThreeRenderer
 */


class ThreeRenderer {
    constructor(canvas, options = {}) {
        this.canvas = canvas;
        this.options = options;
        this._destroyed = false;

        // Asset base path for loading HDRI and other resources
        // Can be configured for GitHub Pages, CDN, or other hosting scenarios
        this.assetBasePath = options.assetBasePath || '';

        // Create Three.js scene
        this.scene = new Scene();
        this.scene.background = null; // Transparent background for particle overlay

        // Create WebGL renderer with high precision to reduce banding
        this.renderer = new WebGLRenderer({
            canvas,
            alpha: true, // Transparent background
            premultipliedAlpha: false, // Required for CSS backgrounds to blend correctly
            antialias: true,
            powerPreference: 'high-performance',
            preserveDrawingBuffer: false,
            precision: 'highp', // High precision float for smoother gradients
            logarithmicDepthBuffer: false,
            stencil: false
        });

        // Force higher color depth if available
        this.renderer.outputColorSpace = SRGBColorSpace;
        this.renderer.toneMapping = NoToneMapping;
        this.renderer.toneMappingExposure = 1.0;

        // Set clear color with full alpha transparency for CSS backgrounds
        this.renderer.setClearColor(0x000000, 0);

        // CRITICAL: Clear the canvas immediately after renderer creation
        // This ensures no garbage data is visible before the first frame renders
        // Uninitialized GPU framebuffers can contain random colors (often magenta/red)
        this.renderer.clear();

        // CRITICAL: Disable autoClear for transparency to work in newer Three.js versions
        this.renderer.autoClear = false;

        // Use device pixel ratio capped at 1.5 for balance between quality and performance
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        this.renderer.setSize(canvas.width, canvas.height, false);

        // Enable shadows if requested
        if (options.enableShadows) {
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = PCFSoftShadowMap;
        }

        // WebGL context loss handling (critical for mobile stability)
        this._contextLost = false;
        this._boundHandleContextLost = this.handleContextLost.bind(this);
        this._boundHandleContextRestored = this.handleContextRestored.bind(this);
        canvas.addEventListener('webglcontextlost', this._boundHandleContextLost, false);
        canvas.addEventListener('webglcontextrestored', this._boundHandleContextRestored, false);

        // Create camera
        const fov = options.fov !== undefined ? options.fov : 45;
        this.camera = new PerspectiveCamera(
            fov, // FOV (default 45, lower = more zoomed in appearance)
            canvas.width / canvas.height, // aspect
            0.1, // near
            100 // far
        );
        this.cameraDistance = options.cameraDistance !== undefined ? options.cameraDistance : 3;
        this.camera.position.set(0, 0, this.cameraDistance);
        this.camera.lookAt(0, 0, 0);

        // Setup camera controls (OrbitControls)
        if (options.enableControls !== false) {
            this.setupCameraControls();
        }

        // Setup lighting
        this.setupLights();

        // Setup post-processing
        if (options.enablePostProcessing !== false) {
            this.setupPostProcessing();
        }

        // Core mascot mesh (will be created by Core3DManager)
        this.coreMesh = null;

        // Material mode: 'glow' (default) or 'glass'
        this.materialMode = 'glow';
        this.glowMaterial = null;
        this.glassMaterial = null;

        // Animation mixer for GLTF models
        this.mixer = null;
        this.clock = new Clock();

        // Reusable objects to avoid per-frame allocations (performance optimization)
        this._tempColor = new Color();
        this._tempColor2 = new Color();
        this._white = new Color(1, 1, 1);

        // Quaternion/Euler temp objects for render() - avoid 10-15 allocations per frame
        this._tempQuat = new Quaternion();
        this._tempEuler = new Euler();
        this._quatX = new Quaternion();
        this._quatY = new Quaternion();
        this._quatZ = new Quaternion();
        this._rollQuat = new Quaternion();
        this._meshQuat = new Quaternion();
        this._xAxis = new Vector3(1, 0, 0);
        this._yAxis = new Vector3(0, 1, 0);
        this._zAxis = new Vector3(0, 0, 1);
        this._cameraToMesh = new Vector3();
        this._cameraDir = new Vector3();
    }

    /**
     * Setup camera controls (OrbitControls)
     * Allows mouse/touch interaction to rotate and zoom the camera
     */
    setupCameraControls() {
        // IMPORTANT: OrbitControls needs renderer.domElement, not the canvas directly
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);

        // Enable smooth damping for better feel
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.1;

        // Set distance limits (min/max zoom for both mouse wheel and pinch)
        // Use custom min/max if provided, otherwise default to 50%-200% of initial distance
        const minZoom = this.options.minZoom !== undefined ? this.options.minZoom : this.cameraDistance * 0.5;
        const maxZoom = this.options.maxZoom !== undefined ? this.options.maxZoom : this.cameraDistance * 2.0;
        this.controls.minDistance = minZoom;
        this.controls.maxDistance = maxZoom;

        // Disable panning to keep mascot centered
        this.controls.enablePan = false;

        // Enable auto-rotate for gentle spinning (can be toggled)
        this.controls.autoRotate = this.options.autoRotate === true; // default false
        this.controls.autoRotateSpeed = this.options.autoRotateSpeed !== undefined ? this.options.autoRotateSpeed : 0.5; // slow, subtle rotation

        // Limit vertical rotation to prevent upside-down views
        this.controls.minPolarAngle = Math.PI * 0.2; // 36 degrees from top
        this.controls.maxPolarAngle = Math.PI * 0.8; // 36 degrees from bottom

        // Touch-specific optimizations - improved responsiveness
        this.controls.rotateSpeed = 0.8; // Increased from 0.5 for faster touch rotation
        this.controls.zoomSpeed = 1.5; // Increased from 1.2 for more responsive pinch zoom

        // Touch gestures configuration
        // - ONE finger: Rotate (orbit around mascot)
        // - TWO fingers: Pinch to zoom + pan (but pan is disabled above)

        // Mobile-specific tuning
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            this.controls.rotateSpeed = 1.0;
            this.controls.zoomSpeed = 1.2;
        }

        // Prevent browser touch gestures from interfering with canvas interaction
        this.renderer.domElement.style.touchAction = 'none';

        // ═══════════════════════════════════════════════════════════════════════════
        // TOUCH LATENCY FIX: Update controls immediately on pointer events
        // Mobile browsers batch/throttle pointer events to rAF timing. By calling
        // controls.update() directly in the event handler (before rAF), we ensure
        // the camera state is current when the next frame renders.
        // ═══════════════════════════════════════════════════════════════════════════
        const immediateUpdate = () => {
            if (this.controls) {
                this.controls.update();
            }
        };

        // Listen for pointer events at capture phase for earliest possible handling
        this.renderer.domElement.addEventListener('pointermove', immediateUpdate, { passive: true });
        this.renderer.domElement.addEventListener('pointerdown', immediateUpdate, { passive: true });

        // Initialize camera preset manager for smooth view transitions
        this.cameraPresetManager = new CameraPresetManager(this.camera, this.controls, this.cameraDistance);
    }

    /**
     * Setup three-point lighting system
     * Creates ambient, key, fill, and rim lights for professional look
     */
    setupLights() {
        // Scene background - keep transparent for CSS background to show through
        // this.scene.background = new THREE.Color(0x0a0a0f); // Commented out to maintain alpha transparency

        // Ambient light - moderate for balanced visibility
        this.ambientLight = new AmbientLight(0xffffff, 0.3);
        this.ambientLight.name = 'ambientLight';
        this.scene.add(this.ambientLight);

        // Key light - main light source (brightest)
        this.keyLight = new DirectionalLight(0xffffff, 0.8);
        this.keyLight.position.set(2, 2, 2);
        this.keyLight.name = 'keyLight';
        if (this.options.enableShadows) {
            this.keyLight.castShadow = true;
            this.keyLight.shadow.mapSize.width = 1024;
            this.keyLight.shadow.mapSize.height = 1024;
            this.keyLight.shadow.camera.near = 0.5;
            this.keyLight.shadow.camera.far = 10;
        }
        this.scene.add(this.keyLight);

        // Fill light - softer light from side to reduce harsh shadows
        this.fillLight = new DirectionalLight(0xffffff, 0.5);
        this.fillLight.position.set(-2, 1, 1);
        this.fillLight.name = 'fillLight';
        this.scene.add(this.fillLight);

        // Rim light - backlight for depth and separation from background
        this.rimLight = new DirectionalLight(0xffffff, 0.7);
        this.rimLight.position.set(0, 1, -2);
        this.rimLight.name = 'rimLight';
        this.scene.add(this.rimLight);

        // Accent lights for glass material (colored rim lights) - subtle for glass effects only
        // Blue accent from left
        this.accentLight1 = new PointLight(0x00d4ff, 0.3, 10);
        this.accentLight1.position.set(-3, 0, 1);
        this.accentLight1.name = 'accentLight1';
        this.scene.add(this.accentLight1);

        // Pink accent from right
        this.accentLight2 = new PointLight(0xff1493, 0.2, 10);
        this.accentLight2.position.set(3, 0, 1);
        this.accentLight2.name = 'accentLight2';
        this.scene.add(this.accentLight2);

        // Orange accent from top
        this.accentLight3 = new PointLight(0xff6b35, 0.2, 10);
        this.accentLight3.position.set(0, 3, -1);
        this.accentLight3.name = 'accentLight3';
        this.scene.add(this.accentLight3);

        // Create environment map for glass reflections
        this.createEnvironmentMap();
    }

    /**
     * Create environment map for glass material reflections
     * Loads HDRI studio lighting or falls back to procedural generation
     */
    async createEnvironmentMap() {
        // Guard against calls after destroy (React Strict Mode can unmount during async load)
        if (this._destroyed) return;

        // Mark environment loading as in-progress to prevent rendering magenta flash
        this._envMapLoading = true;

        // Try to load optional HDRI (.hdr format) for enhanced reflections
        // HDRI is optional - apps can place studio_1k.hdr in /hdri/ for better crystal reflections
        try {
            // HDRLoader replaces deprecated RGBELoader in Three.js r169+
            const { HDRLoader } = await Promise.resolve().then(function () { return HDRLoader$1; });

            // Check if destroyed during import (React Strict Mode)
            if (this._destroyed) return;

            const pmremGenerator = new PMREMGenerator(this.renderer);
            pmremGenerator.compileEquirectangularShader();

            try {
                const hdrLoader = new HDRLoader();

                // Build HDRI path dynamically based on assetBasePath
                // HDRI files are at /hdri/ (sibling to /assets/), not inside /assets/
                // assetBasePath typically points to /assets or /emotive-engine/assets
                const hdrFileName = 'studio_1k.hdr';
                let hdrPath;

                if (this.assetBasePath) {
                    // Remove trailing slash and /assets suffix to get base path
                    // e.g., '/emotive-engine/assets' -> '/emotive-engine'
                    // e.g., '/assets' -> ''
                    let base = this.assetBasePath.replace(/\/$/, '');
                    if (base.endsWith('/assets')) {
                        base = base.slice(0, -7); // Remove '/assets'
                    }
                    hdrPath = base ? `${base}/hdri/${hdrFileName}` : `/hdri/${hdrFileName}`;
                } else {
                    // Auto-detect base path from current page URL
                    // This handles GitHub Pages and other subdirectory deployments
                    const pathParts = window.location.pathname.split('/');
                    let detectedBase = '';

                    // Check for repo name in path (e.g., /emotive-engine/examples/...)
                    if (pathParts.length > 2 && pathParts[1]) {
                        detectedBase = `/${pathParts[1]}`;
                    }

                    hdrPath = detectedBase ? `${detectedBase}/hdri/${hdrFileName}` : `/hdri/${hdrFileName}`;
                }

                let texture = null;
                try {
                    texture = await hdrLoader.loadAsync(hdrPath);
                } catch (e) {
                    // HDRI loading failed - will fall back to procedural
                }

                // Validate texture was loaded correctly
                if (!texture || !texture.image) {
                    throw new Error(`HDR texture not found at ${hdrPath}`);
                }

                // Check if destroyed during load (React Strict Mode)
                if (this._destroyed) {
                    texture.dispose();
                    pmremGenerator.dispose();
                    return;
                }

                texture.mapping = EquirectangularReflectionMapping;
                this.envMap = pmremGenerator.fromEquirectangular(texture).texture;
                texture.dispose(); // CRITICAL: Dispose source texture after PMREM conversion (GPU memory leak fix)
                pmremGenerator.dispose();
                this._envMapLoading = false; // HDRI loaded successfully
                console.log('[Emotive] HDRI environment map loaded');
                return;
            } catch (hdrError) {
                // HDRI is optional - silently fall back to procedural envmap
                pmremGenerator.dispose();
            }
        } catch (error) {
            // HDRLoader not available - use procedural envmap
        }

        // Check if destroyed before fallback (React Strict Mode)
        if (this._destroyed) return;

        // Fallback: Procedural environment map
        const size = 512;
        const cubeRenderTarget = new WebGLCubeRenderTarget(size);
        const envScene = new Scene();

        const skyColor = new Color(0x5599ff);
        const horizonColor = new Color(0xff6b9d);
        const groundColor = new Color(0x1a1a2e);

        const hemiLight = new HemisphereLight(skyColor, groundColor, 1.5);
        envScene.add(hemiLight);

        const light1 = new PointLight(0x00d4ff, 2, 20);
        light1.position.set(-5, 2, -5);
        envScene.add(light1);

        const light2 = new PointLight(0xff1493, 2, 20);
        light2.position.set(5, 2, -5);
        envScene.add(light2);

        const light3 = new PointLight(0xffaa00, 1.5, 20);
        light3.position.set(0, 5, 0);
        envScene.add(light3);

        envScene.background = horizonColor;

        const cubeCamera = new CubeCamera(0.1, 100, cubeRenderTarget);
        cubeCamera.update(this.renderer, envScene);

        this.envMap = cubeRenderTarget.texture;

        // CRITICAL: Store procedural environment resources for proper disposal (GPU memory leak fix)
        this._envCubeRenderTarget = cubeRenderTarget;
        this._envScene = envScene;
        this._envCubeCamera = cubeCamera;

        // Mark environment loading as complete (using fallback)
        this._envMapLoading = false;
    }

    /**
     * Setup post-processing pipeline
     * Adds bloom/glow effects for emotion-based glow intensity
     */
    setupPostProcessing() {
        // Effect composer for post-processing chain
        // Get actual drawing buffer size (includes pixel ratio)
        const drawingBufferSize = new Vector2();
        this.renderer.getDrawingBufferSize(drawingBufferSize);

        // Create with alpha-enabled render target at full drawing buffer resolution
        const renderTarget = new WebGLRenderTarget(
            drawingBufferSize.x,
            drawingBufferSize.y, {
                format: RGBAFormat,
                type: HalfFloatType,  // HDR: Allow values > 1.0 for proper bloom
                minFilter: LinearFilter,
                magFilter: LinearFilter,
                stencilBuffer: false,
                depthBuffer: true
            });
        this.composer = new EffectComposer(this.renderer, renderTarget);

        // CRITICAL: Clear ALL composer render targets to prevent garbage data flash
        // The composer creates internal read/write buffers that contain uninitialized GPU memory
        // This can show as random colors (often magenta/red) on first frame before RenderPass clears
        this.renderer.setRenderTarget(renderTarget);
        this.renderer.clear();
        this.renderer.setRenderTarget(this.composer.readBuffer);
        this.renderer.clear();
        this.renderer.setRenderTarget(this.composer.writeBuffer);
        this.renderer.clear();
        this.renderer.setRenderTarget(null);

        // Render pass - base scene render
        const renderPass = new RenderPass(this.scene, this.camera);
        // CRITICAL: Set clear color to transparent for CSS background blending
        renderPass.clearColor = new Color(0x000000);
        renderPass.clearAlpha = 0;  // Transparent background
        this.composer.addPass(renderPass);

        // Bloom pass - glow/bloom effect (Unreal Engine style)
        // Reduce bloom resolution on mobile for better performance
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const bloomScale = isMobile ? 0.5 : 1.0; // Half resolution on mobile
        const bloomResolution = new Vector2(
            Math.floor(drawingBufferSize.x * bloomScale),
            Math.floor(drawingBufferSize.y * bloomScale)
        );
        this.bloomPass = new UnrealBloomPassAlpha(
            bloomResolution,
            1.2, // strength - moderate glow
            0.8, // radius - wider spread for stronger bloom
            0.3  // threshold - preserve texture detail
        );
        this.bloomPass.name = 'bloomPass';
        this.bloomPass.enabled = true; // Using proven working blur shader approach
        this.bloomPass.renderToScreen = true; // CRITICAL: Last pass must render to screen
        this.composer.addPass(this.bloomPass);

        // CRITICAL: Clear bloom buffers immediately after creation to prevent garbage data flash
        // Uninitialized GPU memory can contain random colors (often red/magenta on some drivers)
        this.bloomPass.clearBloomBuffers(this.renderer);

        // === SEPARATE PARTICLE BLOOM PIPELINE ===
        // Particles get their own render target with NON-BLACK clear color
        // This prevents dark halos from blur sampling black transparent pixels
        this.particleRenderTarget = new WebGLRenderTarget(
            drawingBufferSize.x,
            drawingBufferSize.y, {
                format: RGBAFormat,
                type: HalfFloatType,
                minFilter: LinearFilter,
                magFilter: LinearFilter,
                stencilBuffer: false,
                depthBuffer: true
            });

        // Clear particle render target
        this.renderer.setRenderTarget(this.particleRenderTarget);
        this.renderer.clear();
        this.renderer.setRenderTarget(null);

        // Particle bloom pass (same settings but separate pipeline)
        this.particleBloomPass = new UnrealBloomPassAlpha(
            bloomResolution,
            0.5, // reduced strength for subtler particle glow
            0.4, // tighter radius
            0.3  // higher threshold for less glow
        );
        this.particleBloomPass.name = 'particleBloomPass';
        this.particleBloomPass.enabled = true;
        // IMPORTANT: Use a non-black clear color for particle bloom
        // This is the key fix - blur will sample white instead of black from transparent areas
        this.particleBloomPass.clearColor = new Color(1, 1, 1); // White clear for particle blur
        // Skip the base copy step - we only want to add bloom on top of existing scene
        this.particleBloomPass.skipBaseCopy = true;

        // Clear particle bloom buffers too
        this.particleBloomPass.clearBloomBuffers(this.renderer);

        // === SOUL REFRACTION RENDER TARGET ===
        // Soul mesh is rendered to this texture first, then sampled by crystal shader
        // with refraction distortion to create proper lensing effect
        this.soulRenderTarget = new WebGLRenderTarget(
            drawingBufferSize.x,
            drawingBufferSize.y, {
                format: RGBAFormat,
                type: HalfFloatType,
                minFilter: LinearFilter,
                magFilter: LinearFilter,
                stencilBuffer: false,
                depthBuffer: true
            });

        // Clear soul render target
        this.renderer.setRenderTarget(this.soulRenderTarget);
        this.renderer.clear();
        this.renderer.setRenderTarget(null);

        // Composite shader to blend particle bloom onto main scene
        this.particleCompositeShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'tParticles': { value: null }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform sampler2D tParticles;
                varying vec2 vUv;

                void main() {
                    vec4 base = texture2D(tDiffuse, vUv);
                    vec4 particles = texture2D(tParticles, vUv);

                    // Alpha-preserving composite: particles over base
                    // Use particle alpha to blend
                    vec3 blended = mix(base.rgb, particles.rgb, particles.a);
                    float alpha = base.a + particles.a * (1.0 - base.a);

                    gl_FragColor = vec4(blended, alpha);
                }
            `
        };

        // === GLOW LAYER ===
        // Isolated screen-space glow effect that activates during glow/flash gestures
        // Completely separate from main bloom pipeline to avoid affecting baseline appearance
        this.glowLayer = new GlowLayer(this.renderer);
    }

    /**
     * Handle WebGL context loss
     * Prevents default behavior and sets flag to stop rendering
     * @param {Event} event - Context lost event
     */
    handleContextLost(event) {
        event.preventDefault();
        this._contextLost = true;
        console.warn('⚠️ WebGL context lost - rendering paused');

        // Cancel any ongoing animation frames
        if (this.cameraAnimationId) {
            cancelAnimationFrame(this.cameraAnimationId);
            this.cameraAnimationId = null;
        }
    }

    /**
     * Handle WebGL context restoration
     * Recreates resources and resumes rendering
     */
    handleContextRestored() {
        this._contextLost = false;

        // Recreate all GPU resources
        this.recreateResources();
    }

    /**
     * Recreate all GPU resources after context loss
     * Rebuilds geometries, materials, textures, and post-processing
     */
    recreateResources() {

        // Recreate environment map
        this.createEnvironmentMap();

        // Recreate materials
        if (this.materialMode === 'glow') {
            this.glowMaterial = this.createGlowMaterial();
            if (this.coreMesh) {
                this.coreMesh.material = this.glowMaterial;
            }
        } else if (this.materialMode === 'glass') {
            this.glassMaterial = this.createGlassMaterial();
            if (this.coreMesh) {
                this.coreMesh.material = this.glassMaterial;
            }
            // Recreate inner core
            if (this.coreMesh) {
                this.createInnerCore();
            }
        }

        // Note: Three.js automatically recreates geometries and textures
        // when they are first accessed after context restoration

    }

    /**
     * Create core mascot mesh with custom glow material
     * @param {THREE.BufferGeometry|THREE.Group} geometry - Three.js geometry or Group (e.g., black hole)
     * @param {THREE.Material} customMaterial - Optional custom material (e.g., moon textures)
     * @returns {THREE.Mesh|THREE.Group}
     */
    createCoreMesh(geometry, customMaterial = null) {
        // Remove existing mesh if present
        if (this.coreMesh) {
            this.scene.remove(this.coreMesh);

            // Handle Group disposal differently
            if (this.coreMesh.isGroup) {
                this.coreMesh.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) this.disposeMaterial(child.material);
                });
            } else {
                if (this.coreMesh.geometry) this.coreMesh.geometry.dispose();
                if (this.coreMesh.material) this.disposeMaterial(this.coreMesh.material);
            }

            this.coreMesh = null;
        }

        // Check if geometry is a THREE.Group (e.g., black hole with multiple meshes)
        if (geometry.isGroup) {
            // For Groups, materials are already applied to child meshes
            this.coreMesh = geometry;
            this.coreMesh.name = 'coreMascot';

            // Apply shadows to all meshes in group
            if (this.options.enableShadows) {
                this.coreMesh.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
            }

            this.scene.add(this.coreMesh);
            return this.coreMesh;
        }

        // Standard BufferGeometry path (sphere, moon, sun, etc.)
        // Determine which material to use
        let material;

        if (customMaterial) {
            // Use provided custom material (e.g., moon with NASA textures)
            material = customMaterial;
        } else {
            // Create glow material and store it
            if (!this.glowMaterial) {
                this.glowMaterial = this.createGlowMaterial();
            }

            // Use current material mode
            material = this.materialMode === 'glass'
                ? (this.glassMaterial || this.createGlassMaterial())
                : this.glowMaterial;
        }

        // Create mesh
        this.coreMesh = new Mesh(geometry, material);
        this.coreMesh.name = 'coreMascot';


        if (this.options.enableShadows) {
            this.coreMesh.castShadow = true;
            this.coreMesh.receiveShadow = true;
        }

        this.scene.add(this.coreMesh);

        // Create white inner core for glass mode (lightsaber effect)
        if (this.materialMode === 'glass') {
            this.createInnerCore();
        }

        return this.coreMesh;
    }

    /**
     * Swap geometry without recreating mesh (performance optimization)
     * @param {THREE.BufferGeometry} newGeometry - New geometry to swap to
     * @param {THREE.Material} customMaterial - Optional custom material to swap to
     */
    swapGeometry(newGeometry, customMaterial = null) {
        if (!this.coreMesh) return;

        // ═══════════════════════════════════════════════════════════════════
        // CLEAR BLOOM BUFFERS
        // Prevents residual glow from old geometry bleeding into new one
        // ═══════════════════════════════════════════════════════════════════
        if (this.bloomPass) {
            this.bloomPass.clearBloomBuffers(this.renderer);
        }
        if (this.particleBloomPass) {
            this.particleBloomPass.clearBloomBuffers(this.renderer);
        }

        // Dispose old geometry
        const oldGeometry = this.coreMesh.geometry;
        if (oldGeometry) {
            oldGeometry.dispose();
        }

        // Swap to new geometry
        this.coreMesh.geometry = newGeometry;

        // If custom material provided, swap material too
        if (customMaterial) {
            // Dispose old material (but NOT if it's glow/glass material - we reuse those)
            if (this.coreMesh.material && this.coreMesh.material !== this.glowMaterial && this.coreMesh.material !== this.glassMaterial) {
                this.disposeMaterial(this.coreMesh.material);
            }
            // Assign new custom material
            this.coreMesh.material = customMaterial;

            // Set resolution uniform for refraction if present
            if (customMaterial.uniforms?.resolution) {
                const size = this.renderer.getDrawingBufferSize(new Vector2());
                customMaterial.uniforms.resolution.value.set(size.x, size.y);
            }
        } else {
            // Swapping back to standard material - restore glow or glass
            const standardMaterial = this.materialMode === 'glass'
                ? (this.glassMaterial || this.createGlassMaterial())
                : this.glowMaterial;

            if (this.coreMesh.material !== standardMaterial) {
                // Dispose custom material
                if (this.coreMesh.material && this.coreMesh.material !== this.glowMaterial && this.coreMesh.material !== this.glassMaterial) {
                    this.disposeMaterial(this.coreMesh.material);
                }
                this.coreMesh.material = standardMaterial;
            }
        }

        // Recreate inner core to match new geometry (if in glass mode and NOT custom material)
        if (this.materialMode === 'glass' && !customMaterial) {
            this.createInnerCore();
        }
    }

    /**
     * Create custom glow material with Fresnel shader
     * Matches the look of the custom WebGL renderer's core.vert/core.frag
     */
    createGlowMaterial() {
        return new ShaderMaterial({
            uniforms: {
                glowColor: { value: new Color(1, 1, 1) },
                glowIntensity: { value: 1.0 },
                coreColor: { value: new Color(1, 1, 1) },
                fresnelPower: { value: 3.0 }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vViewPosition;

                void main() {
                    // Transform normal to view space
                    vNormal = normalize(normalMatrix * normal);

                    // Calculate view space position
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vViewPosition = -mvPosition.xyz;

                    // Output clip space position
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform vec3 glowColor;
                uniform vec3 coreColor;
                uniform float glowIntensity;
                uniform float fresnelPower;

                varying vec3 vNormal;
                varying vec3 vViewPosition;

                void main() {
                    // Fresnel effect: edges glow more than center
                    vec3 viewDir = normalize(vViewPosition);
                    float fresnel = pow(1.0 - abs(dot(vNormal, viewDir)), fresnelPower);

                    // Combine white core with colored glow
                    // Both core and glow respect glowIntensity for proper on/off toggle
                    vec3 finalColor = (coreColor * glowIntensity) + (glowColor * glowIntensity * fresnel);

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `,
            transparent: false,
            side: FrontSide
        });
    }

    /**
     * Create glass material with realistic refraction
     * Uses MeshPhysicalMaterial with transmission for refraction through particles
     */
    createGlassMaterial() {
        // Store default emissive multiplier (can be adjusted via UI)
        // Using white emissive for uniform bloom, so this needs to be low
        this.glassEmissiveMultiplier = 0.60;

        const material = new MeshPhysicalMaterial({
            transmission: 1.0,           // Full interior transparency (refraction)
            thickness: 2.7,              // Strong refraction intensity (user-tuned)
            roughness: 0.37,             // Slightly frosted surface (user-tuned)
            metalness: 0.0,              // Non-metallic
            ior: 1.5,                    // Index of refraction (glass)
            reflectivity: 0.5,           // Subtle surface reflections
            envMapIntensity: 1.2,        // Environment reflection strength (boosted)
            side: DoubleSide,      // Render both faces for proper refraction
            transparent: true,
            opacity: 1.0,
            color: 0xffffff,             // Base color (can be tinted)
            emissive: 0xffffff,          // Internal glow color (white, will be tinted by emotion)
            emissiveIntensity: 0.6,      // Internal glow brightness (raised for visibility)
            clearcoat: 0.8,              // Strong glossy coating for sparkle
            clearcoatRoughness: 0.05,    // Very smooth for sharp highlights
            iridescence: 0.4,            // Color shifting based on viewing angle
            iridescenceIOR: 1.3,         // IOR for iridescence effect
            iridescenceThicknessRange: [100, 400]  // Thickness range for color variation
        });

        // Apply environment map if available
        if (this.envMap) {
            material.envMap = this.envMap;
        }

        return material;
    }

    /**
     * Create white inner core for lightsaber effect in glass mode
     * Creates a smaller mesh inside the glass crystal with bright white emissive
     */
    createInnerCore() {
        // Remove existing inner core if present
        if (this.innerCore) {
            // Inner core is a child of coreMesh, not scene
            if (this.coreMesh) {
                this.coreMesh.remove(this.innerCore);
            }
            this.innerCore.geometry.dispose();
            this.disposeMaterial(this.innerCore.material);
            this.innerCore = null;
            this.innerCoreMaterial = null;
        }

        if (!this.coreMesh || !this.coreMesh.geometry) return;

        // Detect geometry type and create matching inner core
        const outerGeometry = this.coreMesh.geometry;
        let coreGeometry;

        // Check geometry type by constructor or parameters
        if (outerGeometry.type === 'TorusGeometry' || outerGeometry.parameters?.tube !== undefined) {
            // TORUS: Create thinner torus that follows the donut hole
            const params = outerGeometry.parameters;
            const radius = params.radius || 1.0;
            const tubeRadius = (params.tube || 0.4) * 0.25; // Much thinner tube for lightsaber effect
            const radialSegments = params.radialSegments || 16;
            const tubularSegments = params.tubularSegments || 100;
            coreGeometry = new TorusGeometry(radius, tubeRadius, radialSegments, tubularSegments);
        }
        else if (outerGeometry.type === 'SphereGeometry') {
            // SPHERE: Smaller sphere
            const params = outerGeometry.parameters;
            const radius = (params.radius || 1.0) * 0.2;
            coreGeometry = new SphereGeometry(radius, 32, 32);
        }
        else if (outerGeometry.type === 'BoxGeometry') {
            // BOX/CUBE: Smaller box
            const params = outerGeometry.parameters;
            const width = (params.width || 1.0) * 0.2;
            const height = (params.height || 1.0) * 0.2;
            const depth = (params.depth || 1.0) * 0.2;
            coreGeometry = new BoxGeometry(width, height, depth);
        }
        else if (outerGeometry.type === 'IcosahedronGeometry' || outerGeometry.type === 'OctahedronGeometry') {
            // CRYSTAL SHAPES: Smaller version (20% scale works perfectly)
            const params = outerGeometry.parameters;
            const radius = (params.radius || 1.0) * 0.2;
            const detail = params.detail || 2;
            if (outerGeometry.type === 'IcosahedronGeometry') {
                coreGeometry = new IcosahedronGeometry(radius, detail);
            } else {
                coreGeometry = new OctahedronGeometry(radius, detail);
            }
        }
        else {
            // DEFAULT: Use small icosahedron for unknown geometries
            coreGeometry = new IcosahedronGeometry(0.2, 2);
        }

        // Bright white emissive material for lightsaber effect
        // Crystal shapes (crystal, diamond, icosahedron, octahedron) get stronger bloom
        const geometryTypeName = outerGeometry.userData?.geometryType;
        const isCrystalShape =
            outerGeometry.type === 'IcosahedronGeometry' ||
            outerGeometry.type === 'OctahedronGeometry' ||
            geometryTypeName === 'crystal' ||
            geometryTypeName === 'diamond';

        const coreMaterial = new MeshStandardMaterial({
            emissive: 0xffffff,
            emissiveIntensity: isCrystalShape ? 3.5 : 2.0,  // Higher bloom for crystals
            color: 0xffffff,
            transparent: false,
            opacity: 1.0
        });

        // Store reference for color updates in render()
        this.innerCoreMaterial = coreMaterial;

        this.innerCore = new Mesh(coreGeometry, coreMaterial);
        this.innerCore.name = 'innerCore';

        // Add inner core as child of main core mesh so it transforms with it
        this.coreMesh.add(this.innerCore);
    }

    /**
     * Set material mode and swap materials
     * @param {string} mode - 'glow' or 'glass'
     */
    setMaterialMode(mode) {
        if (!this.coreMesh) {
            console.warn('Cannot set material mode: core mesh not created yet');
            this.materialMode = mode; // Store for when mesh is created
            return;
        }

        if (mode === this.materialMode) {
            return; // Already in this mode
        }

        this.materialMode = mode;

        // Create materials if they don't exist
        if (mode === 'glass' && !this.glassMaterial) {
            this.glassMaterial = this.createGlassMaterial();
        } else if (mode === 'glow' && !this.glowMaterial) {
            this.glowMaterial = this.createGlowMaterial();
        }

        // Swap material
        const newMaterial = mode === 'glass' ? this.glassMaterial : this.glowMaterial;
        this.coreMesh.material = newMaterial;

        // Create or remove inner core based on mode
        if (mode === 'glass') {
            this.createInnerCore();
        } else if (this.innerCore) {
            // Remove inner core when switching to glow mode
            this.coreMesh.remove(this.innerCore);
            this.innerCore.geometry.dispose();
            this.disposeMaterial(this.innerCore.material);
            this.innerCore = null;
            this.innerCoreMaterial = null;
        }

    }

    /**
     * Update glass material properties
     * @param {Object} props - Glass properties {transmission, thickness, emissiveMultiplier}
     */
    updateGlassProperties(props) {
        if (!this.glassMaterial) return;

        if (props.transmission !== undefined) {
            this.glassMaterial.transmission = props.transmission;
            this.glassMaterial.needsUpdate = true;
        }
        if (props.thickness !== undefined) {
            this.glassMaterial.thickness = props.thickness;
            this.glassMaterial.needsUpdate = true;
        }
        if (props.roughness !== undefined) {
            this.glassMaterial.roughness = props.roughness;
            this.glassMaterial.needsUpdate = true;
        }
        if (props.emissiveMultiplier !== undefined) {
            this.glassEmissiveMultiplier = props.emissiveMultiplier;
        }
    }

    /**
     * Update lighting based on emotion (with smooth transitions)
     * @param {string} emotion - Emotion name
     * @param {Object} emotionData - Emotion visual parameters
     * @param {number} transitionSpeed - Lerp factor (0.0 - 1.0), default 0.15
     */
    updateLighting(emotion, emotionData, transitionSpeed = 0.15) {
        if (!emotionData || !emotionData.visual) return;

        // Get emotion color (reuse temp color to avoid allocation)
        const glowColor = emotionData.visual.glowColor || '#FFFFFF';
        this._tempColor.set(glowColor);

        // Get emotion intensity
        const targetIntensity = emotionData.visual.glowIntensity || 1.0;

        // Smooth transition for key light (primary accent light)
        if (this.keyLight) {
            this.keyLight.color.lerp(this._tempColor, transitionSpeed);
            this.keyLight.intensity += (0.8 * targetIntensity - this.keyLight.intensity) * transitionSpeed;
        }

        // Subtle tint for fill light (secondary light)
        if (this.fillLight) {
            // Reuse temp color 2 for fill target (blend emotion color with white)
            this._tempColor2.copy(this._tempColor).lerp(this._white, 0.7);
            this.fillLight.color.lerp(this._tempColor2, transitionSpeed * 0.5);
            this.fillLight.intensity += (0.3 * targetIntensity - this.fillLight.intensity) * transitionSpeed;
        }

        // Adjust ambient light intensity
        if (this.ambientLight) {
            const ambientTarget = 0.4 * targetIntensity;
            this.ambientLight.intensity += (ambientTarget - this.ambientLight.intensity) * transitionSpeed;
        }
    }

    /**
     * Update bloom pass strength based on emotion intensity (with smooth transitions)
     * @param {number} targetIntensity - Target glow intensity (0.0 - 2.0)
     * @param {number} transitionSpeed - Lerp factor (0.0 - 1.0), default 0.1
     */
    /**
     * Normalize intensity to a narrow range using logarithmic scaling
     * Compresses wide intensity range (0.3-10.0) to uniform output (0.8-1.2)
     * @param {number} intensity - Raw intensity value
     * @returns {number} Normalized intensity (0.8-1.2)
     */
    normalizeIntensity(intensity) {
        // Logarithmic scaling to compress wide range
        const normalized = Math.log(intensity + 1) / Math.log(11); // 0.3-10.0 → 0.0-1.0
        return 0.8 + normalized * 0.4; // Maps to 0.8-1.2 range (±20% variation)
    }

    /**
     * Calculate relative luminance of RGB color (0-1 range)
     * Uses sRGB formula with gamma correction
     * @param {number} r - Red (0-1)
     * @param {number} g - Green (0-1)
     * @param {number} b - Blue (0-1)
     * @returns {number} Relative luminance (0-1)
     */
    calculateColorLuminance(r, g, b) {
        const linearize = c => c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
        return 0.2126 * linearize(r) + 0.7152 * linearize(g) + 0.0722 * linearize(b);
    }

    updateBloom(targetIntensity, transitionSpeed = 0.1, geometryType = null) {
        if (this.bloomPass) {
            const normalized = this.normalizeIntensity(targetIntensity);
            let targetThreshold, targetStrength, targetRadius;

            // Sun geometry needs controlled bloom for NASA-quality photosphere detail
            if (geometryType === 'sun') {
                targetStrength = 1.5;   // Slightly stronger glow
                targetRadius = 0.4;     // Lower radius prevents pixelation from low-res mips
                targetThreshold = 0.3;  // Higher threshold to preserve texture detail
            } else if (geometryType === 'crystal' || geometryType === 'rough' || geometryType === 'heart') {
                // Crystal/rough/heart need strong bloom for light emission effect
                targetStrength = 1.8;   // Strong bloom with HDR
                targetRadius = 0.7;     // Wide spread for glow halo
                targetThreshold = 0.35; // Low threshold to catch HDR glow
            } else if (this.materialMode === 'glass') {
                // Glass mode needs much lower bloom strength to avoid haziness
                // Since we're using white emissive at fixed intensity for uniformity
                targetStrength = 0.3;  // Low strength for subtle glass glow
                targetRadius = 0.2;     // Tight radius to reduce haze
                targetThreshold = 0.85; // Fixed threshold
            } else {
                // Glow mode uses variable bloom
                targetStrength = 1.0 + normalized * 0.8; // Maps to 1.0-1.8 range
                targetRadius = 0.4;
                targetThreshold = 0.85; // Fixed threshold
            }

            this.bloomPass.strength += (targetStrength - this.bloomPass.strength) * transitionSpeed;
            this.bloomPass.threshold += (targetThreshold - this.bloomPass.threshold) * transitionSpeed;
            this.bloomPass.radius = targetRadius;
        }
    }

    /**
     * Set camera to a preset view with smooth transition
     * @param {string} preset - Preset name ('front', 'side', 'top', 'angle')
     * @param {number} duration - Transition duration in ms (default 1000)
     * @param {boolean} preserveTarget - If true, keep the current controls.target (default false)
     */
    setCameraPreset(preset, duration = 1000, preserveTarget = false) {
        if (!this.controls) return;

        const d = this.cameraDistance;
        const presets = {
            front: { x: 0, y: 0, z: d },
            side: { x: d, y: 0, z: 0 },
            top: { x: 0, y: d, z: 0 },  // True top-down view (directly above)
            angle: { x: d * 0.67, y: d * 0.5, z: d * 0.67 },
            back: { x: 0, y: 0, z: -d },
            bottom: { x: 0, y: -d, z: 0 }  // Bottom view (directly below)
        };

        const targetPos = presets[preset];
        if (!targetPos) {
            console.warn(`Unknown camera preset: ${preset}`);
            return;
        }

        // Save current target if we need to preserve it
        const savedTarget = preserveTarget ? this.controls.target.clone() : null;

        // If instant (duration = 0), set position directly
        if (duration === 0) {
            // Fully reset OrbitControls to initial state
            this.controls.reset();
            // Then set to target position
            this.camera.position.set(targetPos.x, targetPos.y, targetPos.z);
            // Preserve or reset the controls target
            if (savedTarget) {
                this.controls.target.copy(savedTarget);
                this.camera.lookAt(savedTarget);
            } else {
                this.controls.target.set(0, 0, 0);
                this.camera.lookAt(0, 0, 0);
            }
            this.controls.update();
            return;
        }

        // Reset OrbitControls target to center (origin) for animated presets
        if (!preserveTarget) {
            this.controls.target.set(0, 0, 0);
        }

        // Smoothly animate camera to target position
        const startPos = this.camera.position.clone();
        const endPos = new Vector3(targetPos.x, targetPos.y, targetPos.z);
        const startTime = performance.now();

        const animate = currentTime => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1.0);

            // Ease out cubic for smooth deceleration
            const eased = 1 - Math.pow(1 - progress, 3);

            this.camera.position.lerpVectors(startPos, endPos, eased);
            this.camera.lookAt(0, 0, 0);
            this.controls.update();

            if (progress < 1.0) {
                this.cameraAnimationId = requestAnimationFrame(animate);
            } else {
                this.cameraAnimationId = null;
            }
        };

        this.cameraAnimationId = requestAnimationFrame(animate);
    }

    /**
     * Reset camera to default position
     */
    resetCamera() {
        this.setCameraPreset('front', 1000);
    }

    /**
     * Toggle auto-rotate on/off
     * @param {boolean} enabled - Whether auto-rotate should be enabled
     */
    toggleAutoRotate(enabled) {
        if (this.controls) {
            this.controls.autoRotate = enabled !== undefined ? enabled : !this.controls.autoRotate;
        }
    }

    /**
     * Get current auto-rotate state
     * @returns {boolean}
     */
    isAutoRotateEnabled() {
        return this.controls ? this.controls.autoRotate : false;
    }

    /**
     * Render frame
     * @param {Object} params - Render parameters
     * @param {Array<number>} [params.position=[0,0,0]] - Core mesh position [x, y, z]
     * @param {Array<number>} [params.rotation=[0,0,0]] - Core mesh rotation [x, y, z]
     * @param {number} [params.scale=1.0] - Core mesh scale
     * @param {Array<number>} [params.glowColor=[1,1,1]] - Glow color RGB [r, g, b]
     * @param {number} [params.glowIntensity=1.0] - Glow intensity
     * @param {string} [params.glowColorHex=null] - Hex color for luminance normalization
     * @param {boolean} [params.hasActiveGesture=false] - Whether a gesture is currently active
     * @param {Array<number>} [params.calibrationRotation=[0,0,0]] - Manual rotation offset
     * @param {number} [params.cameraRoll=0] - Camera-space roll rotation
     * @param {SolarEclipse} [params.solarEclipse=null] - Solar eclipse manager for synchronized updates
     * @param {number} [params.deltaTime=0] - Delta time for eclipse animation (seconds)
     */
    render(params = {}) {
        // Guard against calls after destroy
        if (this._destroyed) {
            console.log('[ThreeRenderer] render() BLOCKED - destroyed');
            return;
        }

        // Guard against rendering before scene is ready
        if (!this.scene || !this.camera || !this.renderer) {
            console.log(`[ThreeRenderer] render() BLOCKED - scene=${!!this.scene}, camera=${!!this.camera}, renderer=${!!this.renderer}`);
            return;
        }

        // Guard against rendering before coreMesh exists (prevents magenta flash from empty scene + bloom)
        if (!this.coreMesh) {
            return;
        }

        // Guard against rendering while environment map is loading (prevents magenta flash from missing HDR)
        // Three.js shows magenta when textures are pending/failed
        if (this._envMapLoading) {
            return;
        }

        // CRITICAL: Skip the very first frame to allow GPU buffers to be properly initialized
        // This prevents garbage data (often magenta) from flashing before the first real render
        if (!this._firstFrameRendered) {
            this._firstFrameRendered = true;
            // Clear screen to transparent on first frame instead of rendering garbage
            this.renderer.setRenderTarget(null);
            this.renderer.setClearColor(0x000000, 0);
            this.renderer.clear();
            return;
        }

        // DEBUG: Check scene for null children before render and REMOVE them
        // Also recursively check children of children
        const validateObject = (obj, path) => {
            if (!obj || !obj.children) return true;
            for (let i = 0; i < obj.children.length; i++) {
                const child = obj.children[i];
                if (child === null || child === undefined) {
                    console.error(`[ThreeRenderer] NULL CHILD at ${path}.children[${i}] - REMOVING!`);
                    obj.children.splice(i, 1);
                    i--;
                    continue;
                }
                if (child.visible === null || child.visible === undefined) {
                    console.error(`[ThreeRenderer] child.visible is NULL at ${path}.children[${i}] name=${child.name} - REMOVING!`);
                    obj.children.splice(i, 1);
                    i--;
                    continue;
                }
                // Recursively validate children
                validateObject(child, `${path}.children[${i}]`);
            }
            return true;
        };
        validateObject(this.scene, 'scene');


        const {
            position = [0, 0, 0],
            rotation = [0, 0, 0],
            scale = 1.0,
            glowColor = [1, 1, 1],
            glowIntensity = 1.0,
            glowColorHex = null,  // Hex color for luminance normalization
            hasActiveGesture = false,  // Whether a gesture is currently active
            calibrationRotation = [0, 0, 0],  // Manual rotation offset applied on top of animations
            cameraRoll = 0,  // Camera-space roll rotation applied after all other rotations
            solarEclipse = null,  // Solar eclipse manager for synchronized updates
            deltaTime = 0,  // Delta time for eclipse animation
            morphProgress = null  // Morph progress for corona fade-in (null = no morph, 0-1 = morphing)
        } = params;

        // Update camera controls FIRST before any rendering
        // This ensures touch/mouse input is processed immediately
        if (this.controls) {
            this.controls.update();
        }

        // Update core mesh transform
        if (this.coreMesh) {
            this.coreMesh.position.set(...position);

            // Apply animated rotation + calibration offset using quaternions
            // X and Y rotate around world axes, Z rotates around camera's viewing direction

            // Start with base rotation from animation system - REUSE temp objects
            this._tempEuler.set(rotation[0], rotation[1], rotation[2], 'XYZ');
            this._tempQuat.setFromEuler(this._tempEuler);

            // Apply calibration rotations - REUSE quaternions
            this._quatX.setFromAxisAngle(this._xAxis, calibrationRotation[0]); // X-axis (world)
            this._quatY.setFromAxisAngle(this._yAxis, calibrationRotation[1]); // Y-axis (world)

            // Z rotates around camera's viewing direction (camera to moon) - REUSE vector
            this._cameraToMesh.subVectors(this.coreMesh.position, this.camera.position).normalize();
            this._quatZ.setFromAxisAngle(this._cameraToMesh, calibrationRotation[2]); // Z-axis (camera view direction)

            // Combine: base rotation, then X, then Y, then Z
            // Reuse tempQuat for final result (already contains base rotation)
            this._tempQuat.multiply(this._quatX);
            this._tempQuat.multiply(this._quatY);
            this._tempQuat.multiply(this._quatZ);

            this.coreMesh.rotation.setFromQuaternion(this._tempQuat);

            // Apply camera-space roll (rotates around camera's forward vector)
            if (cameraRoll !== 0) {
                // Get camera direction (from camera to mesh) - REUSE vector
                this._cameraDir.subVectors(this.coreMesh.position, this.camera.position).normalize();

                // Create quaternion for rotation around camera direction - REUSE quaternion
                this._rollQuat.setFromAxisAngle(this._cameraDir, cameraRoll);

                // Apply camera roll to mesh rotation - REUSE quaternion
                this._meshQuat.setFromEuler(this.coreMesh.rotation);
                this._meshQuat.premultiply(this._rollQuat);
                this.coreMesh.rotation.setFromQuaternion(this._meshQuat);
            }

            this.coreMesh.scale.setScalar(scale);

            // Update solar eclipse effects after transforms are applied (synchronized movement)
            // CRITICAL: Eclipse update must happen AFTER position/rotation/scale are applied to coreMesh
            // to ensure shadow disk and corona are positioned based on the CURRENT frame's transforms,
            // not the previous frame's. This prevents visible lag during gesture animations.
            if (solarEclipse) {
                solarEclipse.update(this.camera, this.coreMesh, deltaTime, morphProgress);
            }

            // Update material properties based on material type
            // Skip for THREE.Group (like black hole) - materials are on child meshes
            if (this.coreMesh.material && this.coreMesh.material.uniforms) {
                // ShaderMaterial (glow material) - update uniforms
                // Only update glowColor if the uniform exists (crystal uses emotionColor instead)
                if (this.coreMesh.material.uniforms.glowColor) {
                    this._tempColor.setRGB(...glowColor);
                    this.coreMesh.material.uniforms.glowColor.value.lerp(this._tempColor, 0.15);
                }

                // Normalize intensity to prevent huge brightness differences between emotions
                // Use wider range during gestures to make effects visible
                // Only update glowIntensity if the uniform exists (crystal uses emissiveIntensity instead)
                if (this.coreMesh.material.uniforms.glowIntensity) {
                    // Special case: if glowIntensity is 0 (glow disabled), pass 0 directly
                    let targetIntensity;
                    if (glowIntensity === 0) {
                        targetIntensity = 0;
                    } else {
                        if (hasActiveGesture) {
                            // During gestures: bypass normalization entirely, use raw intensity
                            // Direct mapping: gesture outputs 1.0-1.8 → shader sees 1.0-1.8
                            targetIntensity = glowIntensity;
                        } else {
                            // Normal state: use normalized intensity for consistent emotions
                            targetIntensity = this.normalizeIntensity(glowIntensity);
                        }
                    }
                    const currentIntensity = this.coreMesh.material.uniforms.glowIntensity.value;
                    // Use faster lerp (0.5) for gestures, slower (0.15) for smooth emotion transitions
                    const lerpSpeed = hasActiveGesture ? 0.5 : 0.15;
                    this.coreMesh.material.uniforms.glowIntensity.value += (targetIntensity - currentIntensity) * lerpSpeed;
                }
            } else if (this.coreMesh.material && this.coreMesh.material.emissive) {
                // MeshPhysicalMaterial (glass material) - update emissive properties
                // BLOOM + COLOR SOLUTION:
                // User wants BOTH uniform bloom AND visible emotion colors
                // Compromise: Use colored emissive with per-color intensity compensation
                // to MINIMIZE (not eliminate) brightness differences

                // Apply emotion color to emissive
                this._tempColor.setRGB(...glowColor);
                this.coreMesh.material.emissive.lerp(this._tempColor, 0.15);

                // Use the ORIGINAL glowIntensity which compensates for color luminance
                // But keep base multiplier low to minimize remaining differences
                const compensatedIntensity = glowIntensity * 0.15; // Much lower than glow mode
                const currentEmissiveIntensity = this.coreMesh.material.emissiveIntensity;
                // Use faster lerp (0.5) for gestures, slower (0.15) for smooth emotion transitions
                const lerpSpeed = hasActiveGesture ? 0.5 : 0.15;
                this.coreMesh.material.emissiveIntensity += (compensatedIntensity - currentEmissiveIntensity) * lerpSpeed;

                // Keep base color white for clean glass
                this.coreMesh.material.color.lerp(this._white, 0.15);
            }

            // Control inner core visibility and color based on emotion
            if (this.innerCore) {
                // Hide inner core when glow is disabled (intensity = 0)
                this.innerCore.visible = glowIntensity > 0;

                // Update inner core color to match emotion
                if (this.innerCoreMaterial) {
                    this._tempColor.setRGB(...glowColor);
                    this.innerCoreMaterial.emissive.lerp(this._tempColor, 0.15);
                }
            }
        }

        // Update animation mixer if present (for GLTF models)
        if (this.mixer) {
            const delta = this.clock.getDelta();
            this.mixer.update(delta);
        }

        // Manually clear with transparent background (needed when autoClear = false)
        this.renderer.clear();

        // Render with post-processing if enabled, otherwise direct render
        if (this.composer) {
            // === STEP 0: Render soul (layer 2) to texture for refraction sampling ===
            if (this.soulRenderTarget) {
                // Find soul mesh in scene (needed for screen center calculation)
                let soulMesh = null;
                this.scene.traverse(obj => {
                    if (obj.name === 'crystalSoul') soulMesh = obj;
                });

                this.renderer.setRenderTarget(this.soulRenderTarget);
                this.renderer.setClearColor(0x000000, 0);
                this.renderer.clear();

                // Render only soul layer (layer 2)
                this.camera.layers.set(2);
                this.renderer.render(this.scene, this.camera);

                // Pass soul texture and its size to crystal shader for refraction sampling
                if (this.coreMesh?.material?.uniforms?.soulTexture) {
                    this.coreMesh.material.uniforms.soulTexture.value = this.soulRenderTarget.texture;
                    // Pass the actual render target size for correct UV mapping
                    if (this.coreMesh.material.uniforms.soulTextureSize) {
                        this.coreMesh.material.uniforms.soulTextureSize.value.set(
                            this.soulRenderTarget.width,
                            this.soulRenderTarget.height
                        );
                    }
                    // Compute soul's screen center position for refraction sampling
                    if (this.coreMesh.material.uniforms.soulScreenCenter && soulMesh) {
                        const soulWorldPos = soulMesh.position.clone();
                        const soulNDC = soulWorldPos.project(this.camera);
                        // Convert from NDC (-1 to 1) to UV (0 to 1)
                        const soulScreenU = (soulNDC.x + 1.0) * 0.5;
                        const soulScreenV = (soulNDC.y + 1.0) * 0.5;
                        this.coreMesh.material.uniforms.soulScreenCenter.value.set(soulScreenU, soulScreenV);
                    }
                }

                this.renderer.setRenderTarget(null);
                this.renderer.setClearColor(0x000000, 0);
            }

            // === STEP 1: Render main scene (layer 0) through bloom to screen ===
            this.camera.layers.set(0);
            this.composer.render();

            // === STEP 2: Render particles (layer 1) to separate render target ===
            if (this.particleRenderTarget && this.particleBloomPass) {
                // Clear particle render target with WHITE (non-black) to prevent dark halos
                this.renderer.setRenderTarget(this.particleRenderTarget);
                this.renderer.setClearColor(0xffffff, 0); // White RGB, but 0 alpha
                this.renderer.clear();

                // DEPTH PASS: Render crystal (layer 0) to depth buffer only
                // This ensures particles behind the crystal are properly occluded
                // Use overrideMaterial to render only to depth buffer (no color output)
                this.camera.layers.set(0);
                const depthMaterial = this._depthOnlyMaterial || (this._depthOnlyMaterial = new MeshBasicMaterial({
                    colorWrite: false,  // Don't write to color buffer
                    depthWrite: true    // Only write to depth buffer
                }));
                this.scene.overrideMaterial = depthMaterial;
                this.renderer.render(this.scene, this.camera);
                this.scene.overrideMaterial = null;

                // Now render particles with depth testing against the crystal
                this.camera.layers.set(1);
                this.renderer.render(this.scene, this.camera);

                // Apply bloom to particle render target
                const particleReadBuffer = this.particleRenderTarget;

                // Render bloom pass on particles (to screen with additive blending)
                this.particleBloomPass.renderToScreen = true;
                this.particleBloomPass.render(this.renderer, null, particleReadBuffer, 0, false);

                // Reset clear color
                this.renderer.setClearColor(0x000000, 0);
                this.renderer.setRenderTarget(null);
            } else {
                // Fallback: Render particles directly (no bloom)
                this.camera.layers.set(1);
                this.renderer.render(this.scene, this.camera);
            }

            // Reset camera to see all layers
            this.camera.layers.enableAll();

            // === STEP 3: Render glow layer (if active) ===
            // This is an isolated screen-space overlay that only activates during glow gestures
            if (this.glowLayer && this.glowLayer.isActive()) {
                this.glowLayer.render(this.renderer);
            }
        } else {
            this.renderer.render(this.scene, this.camera);

            // Render glow layer even without composer
            if (this.glowLayer && this.glowLayer.isActive()) {
                this.glowLayer.render(this.renderer);
            }
        }
    }

    /**
     * Update glow layer for gesture effects
     * Called from Core3DManager when gesture provides glowBoost output
     * @param {number} glowAmount - Glow boost amount (0 = off, >0 = active glow halo)
     * @param {Array|THREE.Color} glowColor - RGB color for the glow
     * @param {THREE.Vector3} worldPosition - World position of the glow source (typically core mesh center)
     * @param {number} deltaTime - Time since last frame in milliseconds
     */
    updateGlowLayer(glowAmount, glowColor, worldPosition, deltaTime) {
        if (this.glowLayer) {
            this.glowLayer.setGlow(glowAmount, glowColor, worldPosition);
            this.glowLayer.update(deltaTime, this.camera);
        }
    }

    /**
     * Resize renderer and camera
     * @param {number} width - Canvas width
     * @param {number} height - Canvas height
     */
    resize(width, height) {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();

        this.renderer.setSize(width, height, false);

        if (this.composer) {
            // Get actual drawing buffer size (includes pixel ratio)
            const drawingBufferSize = new Vector2();
            this.renderer.getDrawingBufferSize(drawingBufferSize);

            this.composer.setSize(drawingBufferSize.x, drawingBufferSize.y);

            // Update bloom pass resolution to full drawing buffer size for sharp bloom
            if (this.bloomPass && this.bloomPass.resolution) {
                this.bloomPass.resolution.set(drawingBufferSize.x, drawingBufferSize.y);
            }

            // Resize particle render target and bloom pass
            if (this.particleRenderTarget) {
                this.particleRenderTarget.setSize(drawingBufferSize.x, drawingBufferSize.y);
            }
            if (this.particleBloomPass) {
                this.particleBloomPass.setSize(drawingBufferSize.x, drawingBufferSize.y);
            }

            // Resize soul render target for refraction
            if (this.soulRenderTarget) {
                this.soulRenderTarget.setSize(drawingBufferSize.x, drawingBufferSize.y);
            }

            // Update resolution uniform for crystal shader refraction
            if (this.coreMesh?.material?.uniforms?.resolution) {
                this.coreMesh.material.uniforms.resolution.value.set(drawingBufferSize.x, drawingBufferSize.y);
            }
        }
    }

    /**
     * Dispose material and all its textures (prevent GPU memory leaks)
     * @param {THREE.Material} material - Material to dispose
     * @private
     */
    disposeMaterial(material) {
        if (!material) return;

        // Dispose all texture properties (map, normalMap, envMap, etc.)
        const textureProperties = [
            'map', 'lightMap', 'bumpMap', 'normalMap', 'specularMap',
            'envMap', 'alphaMap', 'aoMap', 'displacementMap', 'emissiveMap',
            'gradientMap', 'metalnessMap', 'roughnessMap'
        ];

        textureProperties.forEach(prop => {
            if (material[prop]) {
                material[prop].dispose();
            }
        });

        // For ShaderMaterial, dispose textures and clear Color objects in uniforms
        if (material.uniforms) {
            Object.values(material.uniforms).forEach(uniform => {
                if (uniform.value) {
                    // Dispose textures
                    if (uniform.value.isTexture) {
                        uniform.value.dispose();
                        uniform.value = null;
                    }
                    // Clear Color objects to break references
                    else if (uniform.value.isColor) {
                        uniform.value = null;
                    }
                    // Clear Vector objects to break references
                    else if (uniform.value.isVector2 || uniform.value.isVector3 || uniform.value.isVector4) {
                        uniform.value = null;
                    }
                }
            });
        }

        // Dispose the material itself
        material.dispose();
    }

    /**
     * Cleanup resources
     */
    destroy() {
        console.log(`[ThreeRenderer] destroy() CALLED, scene children=${this.scene?.children?.length}`);

        // Set destroyed flag first to prevent any pending render calls
        this._destroyed = true;

        // Remove WebGL context event listeners
        if (this.canvas) {
            this.canvas.removeEventListener('webglcontextlost', this._boundHandleContextLost, false);
            this.canvas.removeEventListener('webglcontextrestored', this._boundHandleContextRestored, false);
        }

        // Cancel camera animation RAF
        if (this.cameraAnimationId) {
            cancelAnimationFrame(this.cameraAnimationId);
            this.cameraAnimationId = null;
        }

        // Dispose inner core
        if (this.innerCore) {
            if (this.coreMesh) {
                this.coreMesh.remove(this.innerCore);
            }
            this.innerCore.geometry.dispose();
            this.disposeMaterial(this.innerCore.material);
            this.innerCore = null;
            this.innerCoreMaterial = null;
        }

        // Dispose core mesh
        if (this.coreMesh) {
            this.scene.remove(this.coreMesh);
            this.coreMesh.geometry.dispose();
            this.disposeMaterial(this.coreMesh.material);
            this.coreMesh = null;
        }

        // Dispose shared materials (glow and glass)
        if (this.glowMaterial) {
            this.disposeMaterial(this.glowMaterial);
            this.glowMaterial = null;
        }
        if (this.glassMaterial) {
            this.disposeMaterial(this.glassMaterial);
            this.glassMaterial = null;
        }

        // Dispose composer
        if (this.composer) {
            this.composer.dispose();
            this.composer = null;
        }

        // Dispose particle render target and bloom pass
        if (this.particleRenderTarget) {
            this.particleRenderTarget.dispose();
            this.particleRenderTarget = null;
        }
        if (this.particleBloomPass) {
            this.particleBloomPass.dispose();
            this.particleBloomPass = null;
        }

        // Dispose soul render target (for refraction)
        if (this.soulRenderTarget) {
            this.soulRenderTarget.dispose();
            this.soulRenderTarget = null;
        }

        // Dispose glow layer
        if (this.glowLayer) {
            this.glowLayer.dispose();
            this.glowLayer = null;
        }

        // Dispose camera preset manager
        if (this.cameraPresetManager) {
            this.cameraPresetManager.dispose();
            this.cameraPresetManager = null;
        }

        // Dispose controls (removes DOM event listeners)
        if (this.controls) {
            this.controls.dispose();
            this.controls = null;
        }

        // Dispose lights with shadow maps
        if (this.keyLight?.shadow?.map) this.keyLight.shadow.map.dispose();
        if (this.fillLight?.shadow?.map) this.fillLight.shadow.map.dispose();
        if (this.rimLight?.shadow?.map) this.rimLight.shadow.map.dispose();
        this.keyLight = null;
        this.fillLight = null;
        this.rimLight = null;
        this.ambientLight = null;
        this.accentLight1 = null;
        this.accentLight2 = null;
        this.accentLight3 = null;

        // Dispose environment map
        if (this.envMap) {
            this.envMap.dispose();
            this.envMap = null;
        }

        // CRITICAL: Dispose procedural environment resources (GPU memory leak fix)
        if (this._envCubeRenderTarget) {
            this._envCubeRenderTarget.dispose();
            this._envCubeRenderTarget = null;
        }
        if (this._envScene) {
            // Dispose all geometries and materials in environment scene
            this._envScene.traverse(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) this.disposeMaterial(obj.material);
            });
            this._envScene.clear();
            this._envScene = null;
        }
        if (this._envCubeCamera) {
            this._envCubeCamera = null;
        }

        // Dispose renderer
        if (this.renderer) {
            this.renderer.dispose();
            this.renderer = null;
        }

        // Clear scene
        this.scene.clear();

        // Dispose animation mixer
        if (this.mixer) {
            this.mixer.stopAllAction();
            this.mixer = null;
        }

        // Clear clock
        this.clock = null;

        // Clear camera
        this.camera = null;

        // Clear temp THREE objects
        this._tempColor = null;
        this._tempColor2 = null;
        this._white = null;
        this._tempQuat = null;
        this._tempEuler = null;
        this._quatX = null;
        this._quatY = null;
        this._quatZ = null;
        this._rollQuat = null;
        this._meshQuat = null;
        this._xAxis = null;
        this._yAxis = null;
        this._zAxis = null;
        this._cameraToMesh = null;
        this._cameraDir = null;
    }
}

// o object_name | g group_name
const _object_pattern = /^[og]\s*(.+)?/;
// mtllib file_reference
const _material_library_pattern = /^mtllib /;
// usemtl material_name
const _material_use_pattern = /^usemtl /;
// usemap map_name
const _map_use_pattern = /^usemap /;
const _face_vertex_data_separator_pattern = /\s+/;

const _vA = new Vector3();
const _vB = new Vector3();
const _vC = new Vector3();

const _ab = new Vector3();
const _cb = new Vector3();

const _color = new Color();

function ParserState() {

	const state = {
		objects: [],
		object: {},

		vertices: [],
		normals: [],
		colors: [],
		uvs: [],

		materials: {},
		materialLibraries: [],

		startObject: function ( name, fromDeclaration ) {

			// If the current object (initial from reset) is not from a g/o declaration in the parsed
			// file. We need to use it for the first parsed g/o to keep things in sync.
			if ( this.object && this.object.fromDeclaration === false ) {

				this.object.name = name;
				this.object.fromDeclaration = ( fromDeclaration !== false );
				return;

			}

			const previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );

			if ( this.object && typeof this.object._finalize === 'function' ) {

				this.object._finalize( true );

			}

			this.object = {
				name: name || '',
				fromDeclaration: ( fromDeclaration !== false ),

				geometry: {
					vertices: [],
					normals: [],
					colors: [],
					uvs: [],
					hasUVIndices: false
				},
				materials: [],
				smooth: true,

				startMaterial: function ( name, libraries ) {

					const previous = this._finalize( false );

					// New usemtl declaration overwrites an inherited material, except if faces were declared
					// after the material, then it must be preserved for proper MultiMaterial continuation.
					if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {

						this.materials.splice( previous.index, 1 );

					}

					const material = {
						index: this.materials.length,
						name: name || '',
						mtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),
						smooth: ( previous !== undefined ? previous.smooth : this.smooth ),
						groupStart: ( previous !== undefined ? previous.groupEnd : 0 ),
						groupEnd: -1,
						groupCount: -1,
						inherited: false,

						clone: function ( index ) {

							const cloned = {
								index: ( typeof index === 'number' ? index : this.index ),
								name: this.name,
								mtllib: this.mtllib,
								smooth: this.smooth,
								groupStart: 0,
								groupEnd: -1,
								groupCount: -1,
								inherited: false
							};
							cloned.clone = this.clone.bind( cloned );
							return cloned;

						}
					};

					this.materials.push( material );

					return material;

				},

				currentMaterial: function () {

					if ( this.materials.length > 0 ) {

						return this.materials[ this.materials.length - 1 ];

					}

					return undefined;

				},

				_finalize: function ( end ) {

					const lastMultiMaterial = this.currentMaterial();
					if ( lastMultiMaterial && lastMultiMaterial.groupEnd === -1 ) {

						lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
						lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
						lastMultiMaterial.inherited = false;

					}

					// Ignore objects tail materials if no face declarations followed them before a new o/g started.
					if ( end && this.materials.length > 1 ) {

						for ( let mi = this.materials.length - 1; mi >= 0; mi -- ) {

							if ( this.materials[ mi ].groupCount <= 0 ) {

								this.materials.splice( mi, 1 );

							}

						}

					}

					// Guarantee at least one empty material, this makes the creation later more straight forward.
					if ( end && this.materials.length === 0 ) {

						this.materials.push( {
							name: '',
							smooth: this.smooth
						} );

					}

					return lastMultiMaterial;

				}
			};

			// Inherit previous objects material.
			// Spec tells us that a declared material must be set to all objects until a new material is declared.
			// If a usemtl declaration is encountered while this new object is being parsed, it will
			// overwrite the inherited material. Exception being that there was already face declarations
			// to the inherited material, then it will be preserved for proper MultiMaterial continuation.

			if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {

				const declared = previousMaterial.clone( 0 );
				declared.inherited = true;
				this.object.materials.push( declared );

			}

			this.objects.push( this.object );

		},

		finalize: function () {

			if ( this.object && typeof this.object._finalize === 'function' ) {

				this.object._finalize( true );

			}

		},

		parseVertexIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

		},

		parseNormalIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

		},

		parseUVIndex: function ( value, len ) {

			const index = parseInt( value, 10 );
			return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;

		},

		addVertex: function ( a, b, c ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},

		addVertexPoint: function ( a ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

		},

		addVertexLine: function ( a ) {

			const src = this.vertices;
			const dst = this.object.geometry.vertices;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

		},

		addNormal: function ( a, b, c ) {

			const src = this.normals;
			const dst = this.object.geometry.normals;

			dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},

		addFaceNormal: function ( a, b, c ) {

			const src = this.vertices;
			const dst = this.object.geometry.normals;

			_vA.fromArray( src, a );
			_vB.fromArray( src, b );
			_vC.fromArray( src, c );

			_cb.subVectors( _vC, _vB );
			_ab.subVectors( _vA, _vB );
			_cb.cross( _ab );

			_cb.normalize();

			dst.push( _cb.x, _cb.y, _cb.z );
			dst.push( _cb.x, _cb.y, _cb.z );
			dst.push( _cb.x, _cb.y, _cb.z );

		},

		addColor: function ( a, b, c ) {

			const src = this.colors;
			const dst = this.object.geometry.colors;

			if ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
			if ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
			if ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

		},

		addUV: function ( a, b, c ) {

			const src = this.uvs;
			const dst = this.object.geometry.uvs;

			dst.push( src[ a + 0 ], src[ a + 1 ] );
			dst.push( src[ b + 0 ], src[ b + 1 ] );
			dst.push( src[ c + 0 ], src[ c + 1 ] );

		},

		addDefaultUV: function () {

			const dst = this.object.geometry.uvs;

			dst.push( 0, 0 );
			dst.push( 0, 0 );
			dst.push( 0, 0 );

		},

		addUVLine: function ( a ) {

			const src = this.uvs;
			const dst = this.object.geometry.uvs;

			dst.push( src[ a + 0 ], src[ a + 1 ] );

		},

		addFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {

			const vLen = this.vertices.length;

			let ia = this.parseVertexIndex( a, vLen );
			let ib = this.parseVertexIndex( b, vLen );
			let ic = this.parseVertexIndex( c, vLen );

			this.addVertex( ia, ib, ic );
			this.addColor( ia, ib, ic );

			// normals

			if ( na !== undefined && na !== '' ) {

				const nLen = this.normals.length;

				ia = this.parseNormalIndex( na, nLen );
				ib = this.parseNormalIndex( nb, nLen );
				ic = this.parseNormalIndex( nc, nLen );

				this.addNormal( ia, ib, ic );

			} else {

				this.addFaceNormal( ia, ib, ic );

			}

			// uvs

			if ( ua !== undefined && ua !== '' ) {

				const uvLen = this.uvs.length;

				ia = this.parseUVIndex( ua, uvLen );
				ib = this.parseUVIndex( ub, uvLen );
				ic = this.parseUVIndex( uc, uvLen );

				this.addUV( ia, ib, ic );

				this.object.geometry.hasUVIndices = true;

			} else {

				// add placeholder values (for inconsistent face definitions)

				this.addDefaultUV();

			}

		},

		addPointGeometry: function ( vertices ) {

			this.object.geometry.type = 'Points';

			const vLen = this.vertices.length;

			for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {

				const index = this.parseVertexIndex( vertices[ vi ], vLen );

				this.addVertexPoint( index );
				this.addColor( index );

			}

		},

		addLineGeometry: function ( vertices, uvs ) {

			this.object.geometry.type = 'Line';

			const vLen = this.vertices.length;
			const uvLen = this.uvs.length;

			for ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {

				this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );

			}

			for ( let uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {

				this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );

			}

		}

	};

	state.startObject( '', false );

	return state;

}


/**
 * A loader for the OBJ format.
 *
 * The [OBJ format](https://en.wikipedia.org/wiki/Wavefront_.obj_file) is a simple data-format that
 * represents 3D geometry in a human readable format as the position of each vertex, the UV position of
 * each texture coordinate vertex, vertex normals, and the faces that make each polygon defined as a list
 * of vertices, and texture vertices.
 *
 * ```js
 * const loader = new OBJLoader();
 * const object = await loader.loadAsync( 'models/monster.obj' );
 * scene.add( object );
 * ```
 *
 * @augments Loader
 * @three_import import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
 */
class OBJLoader extends Loader {

	/**
	 * Constructs a new OBJ loader.
	 *
	 * @param {LoadingManager} [manager] - The loading manager.
	 */
	constructor( manager ) {

		super( manager );

		/**
		 * A reference to a material creator.
		 *
		 * @type {?MaterialCreator}
		 * @default null
		 */
		this.materials = null;

	}

	/**
	 * Starts loading from the given URL and passes the loaded OBJ asset
	 * to the `onLoad()` callback.
	 *
	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
	 * @param {function(Group)} onLoad - Executed when the loading process has been finished.
	 * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
	 * @param {onErrorCallback} onError - Executed when errors occur.
	 */
	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	/**
	 * Sets the material creator for this OBJ. This object is loaded via {@link MTLLoader}.
	 *
	 * @param {MaterialCreator} materials - An object that creates the materials for this OBJ.
	 * @return {OBJLoader} A reference to this loader.
	 */
	setMaterials( materials ) {

		this.materials = materials;

		return this;

	}

	/**
	 * Parses the given OBJ data and returns the resulting group.
	 *
	 * @param {string} text - The raw OBJ data as a string.
	 * @return {Group} The parsed OBJ.
	 */
	parse( text ) {

		const state = new ParserState();

		if ( text.indexOf( '\r\n' ) !== -1 ) {

			// This is faster than String.split with regex that splits on both
			text = text.replace( /\r\n/g, '\n' );

		}

		if ( text.indexOf( '\\\n' ) !== -1 ) {

			// join lines separated by a line continuation character (\)
			text = text.replace( /\\\n/g, '' );

		}

		const lines = text.split( '\n' );
		let result = [];

		for ( let i = 0, l = lines.length; i < l; i ++ ) {

			const line = lines[ i ].trimStart();

			if ( line.length === 0 ) continue;

			const lineFirstChar = line.charAt( 0 );

			// @todo invoke passed in handler if any
			if ( lineFirstChar === '#' ) continue; // skip comments

			if ( lineFirstChar === 'v' ) {

				const data = line.split( _face_vertex_data_separator_pattern );

				switch ( data[ 0 ] ) {

					case 'v':
						state.vertices.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] ),
							parseFloat( data[ 3 ] )
						);
						if ( data.length >= 7 ) {

							_color.setRGB(
								parseFloat( data[ 4 ] ),
								parseFloat( data[ 5 ] ),
								parseFloat( data[ 6 ] ),
								SRGBColorSpace
							);

							state.colors.push( _color.r, _color.g, _color.b );

						} else {

							// if no colors are defined, add placeholders so color and vertex indices match

							state.colors.push( undefined, undefined, undefined );

						}

						break;
					case 'vn':
						state.normals.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] ),
							parseFloat( data[ 3 ] )
						);
						break;
					case 'vt':
						state.uvs.push(
							parseFloat( data[ 1 ] ),
							parseFloat( data[ 2 ] )
						);
						break;

				}

			} else if ( lineFirstChar === 'f' ) {

				const lineData = line.slice( 1 ).trim();
				const vertexData = lineData.split( _face_vertex_data_separator_pattern );
				const faceVertices = [];

				// Parse the face vertex data into an easy to work with format

				for ( let j = 0, jl = vertexData.length; j < jl; j ++ ) {

					const vertex = vertexData[ j ];

					if ( vertex.length > 0 ) {

						const vertexParts = vertex.split( '/' );
						faceVertices.push( vertexParts );

					}

				}

				// Draw an edge between the first vertex and all subsequent vertices to form an n-gon

				const v1 = faceVertices[ 0 ];

				for ( let j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {

					const v2 = faceVertices[ j ];
					const v3 = faceVertices[ j + 1 ];

					state.addFace(
						v1[ 0 ], v2[ 0 ], v3[ 0 ],
						v1[ 1 ], v2[ 1 ], v3[ 1 ],
						v1[ 2 ], v2[ 2 ], v3[ 2 ]
					);

				}

			} else if ( lineFirstChar === 'l' ) {

				const lineParts = line.substring( 1 ).trim().split( ' ' );
				let lineVertices = [];
				const lineUVs = [];

				if ( line.indexOf( '/' ) === -1 ) {

					lineVertices = lineParts;

				} else {

					for ( let li = 0, llen = lineParts.length; li < llen; li ++ ) {

						const parts = lineParts[ li ].split( '/' );

						if ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );
						if ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );

					}

				}

				state.addLineGeometry( lineVertices, lineUVs );

			} else if ( lineFirstChar === 'p' ) {

				const lineData = line.slice( 1 ).trim();
				const pointData = lineData.split( ' ' );

				state.addPointGeometry( pointData );

			} else if ( ( result = _object_pattern.exec( line ) ) !== null ) {

				// o object_name
				// or
				// g group_name

				// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
				// let name = result[ 0 ].slice( 1 ).trim();
				const name = ( ' ' + result[ 0 ].slice( 1 ).trim() ).slice( 1 );

				state.startObject( name );

			} else if ( _material_use_pattern.test( line ) ) {

				// material

				state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );

			} else if ( _material_library_pattern.test( line ) ) {

				// mtl file

				state.materialLibraries.push( line.substring( 7 ).trim() );

			} else if ( _map_use_pattern.test( line ) ) {

				// the line is parsed but ignored since the loader assumes textures are defined MTL files
				// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)

				console.warn( 'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.' );

			} else if ( lineFirstChar === 's' ) {

				result = line.split( ' ' );

				// smooth shading

				// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
				// but does not define a usemtl for each face set.
				// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
				// This requires some care to not create extra material on each smooth value for "normal" obj files.
				// where explicit usemtl defines geometry groups.
				// Example asset: examples/models/obj/cerberus/Cerberus.obj

				/*
					 * http://paulbourke.net/dataformats/obj/
					 *
					 * From chapter "Grouping" Syntax explanation "s group_number":
					 * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
					 * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
					 * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
					 * than 0."
					 */
				if ( result.length > 1 ) {

					const value = result[ 1 ].trim().toLowerCase();
					state.object.smooth = ( value !== '0' && value !== 'off' );

				} else {

					// ZBrush can produce "s" lines #11707
					state.object.smooth = true;

				}

				const material = state.object.currentMaterial();
				if ( material ) material.smooth = state.object.smooth;

			} else {

				// Handle null terminated files without exception
				if ( line === '\0' ) continue;

				console.warn( 'THREE.OBJLoader: Unexpected line: "' + line + '"' );

			}

		}

		state.finalize();

		const container = new Group();
		container.materialLibraries = [].concat( state.materialLibraries );

		const hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );

		if ( hasPrimitives === true ) {

			for ( let i = 0, l = state.objects.length; i < l; i ++ ) {

				const object = state.objects[ i ];
				const geometry = object.geometry;
				const materials = object.materials;
				const isLine = ( geometry.type === 'Line' );
				const isPoints = ( geometry.type === 'Points' );
				let hasVertexColors = false;

				// Skip o/g line declarations that did not follow with any faces
				if ( geometry.vertices.length === 0 ) continue;

				const buffergeometry = new BufferGeometry();

				buffergeometry.setAttribute( 'position', new Float32BufferAttribute( geometry.vertices, 3 ) );

				if ( geometry.normals.length > 0 ) {

					buffergeometry.setAttribute( 'normal', new Float32BufferAttribute( geometry.normals, 3 ) );

				}

				if ( geometry.colors.length > 0 ) {

					hasVertexColors = true;
					buffergeometry.setAttribute( 'color', new Float32BufferAttribute( geometry.colors, 3 ) );

				}

				if ( geometry.hasUVIndices === true ) {

					buffergeometry.setAttribute( 'uv', new Float32BufferAttribute( geometry.uvs, 2 ) );

				}

				// Create materials

				const createdMaterials = [];

				for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

					const sourceMaterial = materials[ mi ];
					const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;
					let material = state.materials[ materialHash ];

					if ( this.materials !== null ) {

						material = this.materials.create( sourceMaterial.name );

						// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
						if ( isLine && material && ! ( material instanceof LineBasicMaterial ) ) {

							const materialLine = new LineBasicMaterial();
							Material.prototype.copy.call( materialLine, material );
							materialLine.color.copy( material.color );
							material = materialLine;

						} else if ( isPoints && material && ! ( material instanceof PointsMaterial ) ) {

							const materialPoints = new PointsMaterial( { size: 10, sizeAttenuation: false } );
							Material.prototype.copy.call( materialPoints, material );
							materialPoints.color.copy( material.color );
							materialPoints.map = material.map;
							material = materialPoints;

						}

					}

					if ( material === undefined ) {

						if ( isLine ) {

							material = new LineBasicMaterial();

						} else if ( isPoints ) {

							material = new PointsMaterial( { size: 1, sizeAttenuation: false } );

						} else {

							material = new MeshPhongMaterial();

						}

						material.name = sourceMaterial.name;
						material.flatShading = sourceMaterial.smooth ? false : true;
						material.vertexColors = hasVertexColors;

						state.materials[ materialHash ] = material;

					}

					createdMaterials.push( material );

				}

				// Create mesh

				let mesh;

				if ( createdMaterials.length > 1 ) {

					for ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

						const sourceMaterial = materials[ mi ];
						buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );

					}

					if ( isLine ) {

						mesh = new LineSegments( buffergeometry, createdMaterials );

					} else if ( isPoints ) {

						mesh = new Points( buffergeometry, createdMaterials );

					} else {

						mesh = new Mesh( buffergeometry, createdMaterials );

					}

				} else {

					if ( isLine ) {

						mesh = new LineSegments( buffergeometry, createdMaterials[ 0 ] );

					} else if ( isPoints ) {

						mesh = new Points( buffergeometry, createdMaterials[ 0 ] );

					} else {

						mesh = new Mesh( buffergeometry, createdMaterials[ 0 ] );

					}

				}

				mesh.name = object.name;

				container.add( mesh );

			}

		} else {

			// if there is only the default parser state object with no geometry data, interpret data as point cloud

			if ( state.vertices.length > 0 ) {

				const material = new PointsMaterial( { size: 1, sizeAttenuation: false } );

				const buffergeometry = new BufferGeometry();

				buffergeometry.setAttribute( 'position', new Float32BufferAttribute( state.vertices, 3 ) );

				if ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {

					buffergeometry.setAttribute( 'color', new Float32BufferAttribute( state.colors, 3 ) );
					material.vertexColors = true;

				}

				const points = new Points( buffergeometry, material );
				container.add( points );

			}

		}

		return container;

	}

}

/**
 * Moon Crescent Shadow Shader
 *
 * Creates realistic lunar phases using world-space directional lighting.
 * The shadow rotates naturally with the moon sphere.
 *
 * Based on real lunar terminator physics:
 * - Light direction is fixed in world space (like the sun)
 * - Normals rotate with the moon (in world space)
 * - dot(normal, lightDir) < 0 = shadow side
 * - dot(normal, lightDir) > 0 = lit side
 * - Creates smooth curved terminator line like real moon phases
 */

const moonCrescentVertexShader = `
/**
 * Moon Crescent Vertex Shader
 * Passes world-space normal to fragment shader for realistic lighting
 */

varying vec3 vPosition; // LOCAL position
varying vec3 vWorldPosition;
varying vec3 vWorldNormal; // WORLD SPACE normal (rotates with moon)
varying vec3 vViewPosition;
varying vec2 vUv;

void main() {
    vUv = uv;
    vPosition = position;

    // Transform normal to WORLD space (not view space)
    // This makes the shadow rotate with the moon geometry
    vWorldNormal = normalize(mat3(modelMatrix) * normal);

    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    vWorldPosition = worldPosition.xyz;
    vec4 viewPosition = viewMatrix * worldPosition;
    vViewPosition = viewPosition.xyz;
    gl_Position = projectionMatrix * viewPosition;
}
`;

const moonCrescentFragmentShader = `
/**
 * Moon Crescent Fragment Shader
 *
 * Uses directional half-space test in WORLD SPACE to create realistic terminator:
 * - Light direction fixed in world space (like the sun)
 * - Normals rotate with moon geometry (in world space)
 * - dot(normal, lightDir) < 0 = shadow side
 * - dot(normal, lightDir) > 0 = lit side
 * - Smooth terminator with earthshine on dark side
 */

uniform sampler2D colorMap;
uniform sampler2D normalMap;
uniform vec2 shadowOffset; // Controls light direction (x=horizontal, y=vertical)
uniform float shadowCoverage; // Unused for directional shadow
uniform float shadowSoftness; // Terminator edge softness (default: 0.05)
uniform vec3 glowColor;
uniform float glowIntensity;
uniform float opacity; // Fade in opacity (0-1) to prevent gray flash during texture load

// Lunar Eclipse (Blood Moon) uniforms
uniform float eclipseProgress; // 0.0 = no eclipse, 1.0 = totality
uniform float eclipseIntensity; // Darkening strength (0.0-1.0)
uniform vec3 bloodMoonColor; // Deep reddish-orange for total eclipse
uniform float blendMode; // 0=Multiply, 1=LinearBurn, 2=ColorBurn, 3=ColorDodge, 4=Screen, 5=Overlay
uniform float blendStrength; // Blend strength multiplier (0.0-5.0)
uniform float emissiveStrength; // Emissive glow strength (0.0-1.0)

varying vec3 vPosition;
varying vec3 vWorldPosition;
varying vec3 vWorldNormal; // WORLD SPACE normal (rotates with moon)
varying vec3 vViewPosition;
varying vec2 vUv;

void main() {
    // DIRECTIONAL SHADOW in WORLD SPACE - realistic moon phase lighting
    // Light direction is fixed in world space, shadow rotates with moon

    // Use world-space normal (rotates with moon geometry)
    vec3 worldNormal = normalize(vWorldNormal);

    // Light direction in WORLD SPACE
    // shadowOffset.x controls horizontal angle (left/right)
    // shadowOffset.y controls vertical angle (up/down)
    // For thin crescents, we need extreme angles (light from the side or behind)

    float lightX = shadowOffset.x;
    float lightY = shadowOffset.y;

    // Adaptive Z component with LOGARITHMIC scaling for wider angular range
    // Goal: Spread phases across full 0° to 180° instead of plateauing at 135°
    //
    // Target angles after normalization:
    // - Full moon (x=0): 0° (light from front)
    // - Quarter moon (x=1): 90° (light from side)
    // - Crescent (x=3): 120° (thin crescent)
    // - New moon (x=10): 170° (nearly behind)

    float offsetMagnitude = length(vec2(lightX, lightY));

    // Use exponential decay for Z to spread angular range
    // Formula: Z = 1.0 - offsetMagnitude^1.5 for better distribution
    float lightZ = 1.0 - pow(offsetMagnitude, 1.5);

    // Normalize the light direction vector
    vec3 lightDir = normalize(vec3(lightX, lightY, lightZ));

    // Calculate how much this fragment faces the light source
    float facing = dot(worldNormal, lightDir);

    // Smooth transition at terminator (shadow boundary)
    // Softer edge for realistic lunar terminator (like real moon photography)
    // Use fwidth() for automatic screen-space anti-aliasing
    float edgeWidth = max(fwidth(facing) * 4.0, shadowSoftness * 3.0);
    float shadowFactor = smoothstep(-edgeWidth, edgeWidth, facing);

    // Sample moon surface texture
    vec4 texColor = texture2D(colorMap, vUv);

    // Fallback to gray if texture not loaded yet
    float brightness = texColor.r + texColor.g + texColor.b;
    if (brightness < 0.03) {
        texColor = vec4(0.5, 0.5, 0.5, 1.0);
    }

    // LIMB DARKENING: Moon gets darker at edges (spherical falloff)
    vec3 viewDir = normalize(-vViewPosition);
    float rimFactor = dot(worldNormal, viewDir);
    float limbDarkening = smoothstep(0.0, 0.6, rimFactor); // Subtle edge darkening

    // DIFFUSE LIGHTING: Vary brightness across lit surface (not uniform)
    // More realistic Lambertian diffuse reflection
    float diffuse = max(facing, 0.0);
    float diffuseLighting = mix(0.7, 1.0, diffuse); // Subtle variation

    // EARTHSHINE: Almost invisible (~1% for ultimate realism)
    vec3 earthshine = texColor.rgb * 0.01 * vec3(0.35, 0.4, 0.6);

    // Apply dramatic shadow transition with maximum contrast
    float litFactor = pow(shadowFactor, 2.0); // Maximum contrast

    // TEXTURE ENHANCEMENT: Boost surface detail contrast
    // Slightly darken dark areas, brighten bright areas of texture
    vec3 detailEnhanced = texColor.rgb * 1.08; // Subtle boost
    float textureLuminance = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
    detailEnhanced = mix(texColor.rgb * 0.95, texColor.rgb * 1.12, smoothstep(0.3, 0.7, textureLuminance));

    // Combine enhanced texture with diffuse lighting
    vec3 litColor = detailEnhanced * diffuseLighting;
    vec3 shadowedColor = mix(earthshine, litColor, litFactor);

    // Apply limb darkening (slightly stronger for more depth)
    shadowedColor *= mix(0.6, 1.0, limbDarkening);

    // Nearly zero emissive for pure realism
    vec3 emissive = vec3(0.02, 0.02, 0.02) * shadowFactor;

    // Emotion glow (almost invisible)
    vec3 emotionGlow = glowColor * glowIntensity * 0.02 * shadowFactor;

    // Combine all lighting components
    vec3 finalColor = shadowedColor + emissive + emotionGlow;

    // ═══════════════════════════════════════════════════════════════════════════
    // LUNAR ECLIPSE (BLOOD MOON) EFFECT
    // ═══════════════════════════════════════════════════════════════════════════
    // Simulates Earth's umbral shadow with Rayleigh scattering (reddish glow)
    if (eclipseProgress > 0.001) {
        // Calculate gradient from lit edge to dark center
        // Use rim factor (view angle) to create radial gradient
        float gradientFactor = rimFactor; // 1.0 at edges, 0.0 at center

        // Darken the moon (Earth's shadow)
        float darkeningFactor = 1.0 - eclipseIntensity;
        finalColor *= darkeningFactor;

        // ═══════════════════════════════════════════════════════════════════
        // PHOTOSHOP-STYLE BLEND MODES: Multiple modes for deep saturation control
        // ═══════════════════════════════════════════════════════════════════

        // Define blood moon gradient colors
        vec3 deepRed = vec3(0.6, 0.2, 0.12);       // Dark burnt red-orange (center)
        vec3 brightOrange = vec3(0.95, 0.45, 0.22); // Bright burnt orange (edges)

        // Create radial gradient from center (dark) to edge (bright)
        vec3 bloodGradient = mix(deepRed, brightOrange, pow(gradientFactor, 1.8));

        // Apply blend strength multiplier
        vec3 blendColor = bloodGradient * blendStrength;

        // Calculate all blend modes
        vec3 finalBlend;
        int mode = int(blendMode + 0.5); // Round to nearest int

        if (mode == 0) {
            // MULTIPLY: base * blend
            finalBlend = finalColor * blendColor;
        } else if (mode == 1) {
            // LINEAR BURN: base + blend - 1
            finalBlend = max(finalColor + blendColor - vec3(1.0), vec3(0.0));
        } else if (mode == 2) {
            // COLOR BURN: (blend==0.0) ? 0.0 : max((1.0-((1.0-base)/blend)), 0.0)
            finalBlend = vec3(
                blendColor.r == 0.0 ? 0.0 : max(1.0 - ((1.0 - finalColor.r) / blendColor.r), 0.0),
                blendColor.g == 0.0 ? 0.0 : max(1.0 - ((1.0 - finalColor.g) / blendColor.g), 0.0),
                blendColor.b == 0.0 ? 0.0 : max(1.0 - ((1.0 - finalColor.b) / blendColor.b), 0.0)
            );
        } else if (mode == 3) {
            // COLOR DODGE: (blend==1.0) ? 1.0 : min(base/(1.0-blend), 1.0)
            finalBlend = vec3(
                blendColor.r == 1.0 ? 1.0 : min(finalColor.r / (1.0 - blendColor.r), 1.0),
                blendColor.g == 1.0 ? 1.0 : min(finalColor.g / (1.0 - blendColor.g), 1.0),
                blendColor.b == 1.0 ? 1.0 : min(finalColor.b / (1.0 - blendColor.b), 1.0)
            );
        } else if (mode == 4) {
            // SCREEN: 1 - (1 - base) * (1 - blend)
            finalBlend = vec3(1.0) - (vec3(1.0) - finalColor) * (vec3(1.0) - blendColor);
        } else {
            // OVERLAY: base < 0.5 ? (2 * base * blend) : (1 - 2 * (1 - base) * (1 - blend))
            finalBlend = vec3(
                finalColor.r < 0.5 ? (2.0 * finalColor.r * blendColor.r) : (1.0 - 2.0 * (1.0 - finalColor.r) * (1.0 - blendColor.r)),
                finalColor.g < 0.5 ? (2.0 * finalColor.g * blendColor.g) : (1.0 - 2.0 * (1.0 - finalColor.g) * (1.0 - blendColor.g)),
                finalColor.b < 0.5 ? (2.0 * finalColor.b * blendColor.b) : (1.0 - 2.0 * (1.0 - finalColor.b) * (1.0 - blendColor.b))
            );
        }

        // Apply blood moon effect
        finalColor = mix(finalColor, finalBlend, eclipseProgress);

        // Add emissive glow for visibility
        finalColor += bloodGradient * emissiveStrength * eclipseProgress;

        // Add bright rim glow during totality (refracted atmosphere light)
        if (eclipseProgress > 0.7) {
            float rimIntensity = pow(gradientFactor, 2.5); // Sharp falloff from edge
            vec3 rimGlow = brightOrange * rimIntensity * (eclipseProgress - 0.7) * 2.5;
            finalColor += rimGlow;
        }
    }

    // Apply fade-in opacity to prevent gray flash during texture load
    gl_FragColor = vec4(finalColor, opacity);
}
`;

/**
 * Get moon crescent shadow shaders
 * @returns {Object} Object with vertexShader and fragmentShader strings
 */
function getMoonCrescentShaders() {
    return {
        vertexShader: moonCrescentVertexShader,
        fragmentShader: moonCrescentFragmentShader
    };
}

/**
 * Shadow Shader Registry
 *
 * Central export point for all moon shadow effect shaders.
 * Supports multiple shadow types for different visual effects.
 *
 * Available Shadow Types:
 * - crescent: Camera-fixed crescent moon phase (directional shadow)
 * - lunar-eclipse: Total lunar eclipse with red shadow (future)
 * - solar-eclipse: Solar eclipse corona effect (future)
 * - black-hole: Gravitational lensing distortion (future)
 */


// Future implementations (placeholder exports for architecture)
// export { getLunarEclipseShaders } from './lunarEclipse.js';
// export { getSolarEclipseShaders } from './solarEclipse.js';
// export { getBlackHoleShaders } from './blackHole.js';

/**
 * Get shadow shaders by type
 * @param {string} shadowType - Type of shadow effect
 * @returns {Object} Object with vertexShader and fragmentShader strings
 */
function getShadowShaders(shadowType) {
    switch (shadowType) {
    case 'crescent':
        return getMoonCrescentShaders();

        // Future shadow types
        // case 'lunar-eclipse':
        //     return getLunarEclipseShaders();
        // case 'solar-eclipse':
        //     return getSolarEclipseShaders();
        // case 'black-hole':
        //     return getBlackHoleShaders();

    default:
        console.warn(`Unknown shadow type: ${shadowType}, defaulting to crescent`);
        return getMoonCrescentShaders();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Blend Modes Utility (JavaScript loader)
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview JavaScript wrapper for universal blend mode GLSL functions
 * @author Emotive Engine Team
 * @module 3d/shaders/utils/blendModes
 *
 * Provides GLSL code injection for any shader that needs Photoshop-style blend modes.
 */

/**
 * GLSL blend mode functions (18 modes total)
 * Copy this into your fragment shader to use blend modes
 */
const blendModesGLSL = `
/**
 * Apply a single blend mode to two colors
 * @param base - Base color (RGB, 0.0-1.0 range)
 * @param blend - Blend color (RGB, 0.0-1.0 range)
 * @param mode - Blend mode index (0-17)
 * @return Blended color (RGB, 0.0-1.0 range)
 *
 * Blend Mode Reference:
 *  0 = Multiply        (darkening)
 *  1 = Linear Burn     (darkening, linear)
 *  2 = Color Burn      (darkening, intense)
 *  3 = Color Dodge     (brightening, intense)
 *  4 = Screen          (brightening)
 *  5 = Overlay         (contrast, screen/multiply hybrid)
 *  6 = Add             (brightening, additive glow)
 *  7 = Soft Light      (contrast, gentle)
 *  8 = Hard Light      (contrast, strong)
 *  9 = Vivid Light     (contrast, saturation boost)
 * 10 = Linear Light    (contrast, linear)
 * 11 = Difference      (inversion)
 * 12 = Exclusion       (soft inversion)
 * 13 = Darken          (comparison, darker)
 * 14 = Lighten         (comparison, lighter)
 * 15 = Subtract        (darkening, deep shadows)
 * 16 = Divide          (brightening, ethereal glow)
 * 17 = Pin Light       (posterization)
 */
vec3 applyBlendMode(vec3 base, vec3 blend, int mode) {
    if (mode == 0) {
        // MULTIPLY: base * blend
        return base * blend;
    } else if (mode == 1) {
        // LINEAR BURN: base + blend - 1
        return max(base + blend - vec3(1.0), vec3(0.0));
    } else if (mode == 2) {
        // COLOR BURN: (blend==0.0) ? 0.0 : max((1.0-((1.0-base)/blend)), 0.0)
        return vec3(
            blend.r == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.r) / blend.r), 0.0),
            blend.g == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.g) / blend.g), 0.0),
            blend.b == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.b) / blend.b), 0.0)
        );
    } else if (mode == 3) {
        // COLOR DODGE: (blend==1.0) ? 1.0 : min(base/(1.0-blend), 1.0)
        return vec3(
            blend.r == 1.0 ? 1.0 : min(base.r / (1.0 - blend.r), 1.0),
            blend.g == 1.0 ? 1.0 : min(base.g / (1.0 - blend.g), 1.0),
            blend.b == 1.0 ? 1.0 : min(base.b / (1.0 - blend.b), 1.0)
        );
    } else if (mode == 4) {
        // SCREEN: 1 - (1 - base) * (1 - blend)
        return vec3(1.0) - (vec3(1.0) - base) * (vec3(1.0) - blend);
    } else if (mode == 5) {
        // OVERLAY: base < 0.5 ? (2 * base * blend) : (1 - 2 * (1 - base) * (1 - blend))
        return vec3(
            base.r < 0.5 ? (2.0 * base.r * blend.r) : (1.0 - 2.0 * (1.0 - base.r) * (1.0 - blend.r)),
            base.g < 0.5 ? (2.0 * base.g * blend.g) : (1.0 - 2.0 * (1.0 - base.g) * (1.0 - blend.g)),
            base.b < 0.5 ? (2.0 * base.b * blend.b) : (1.0 - 2.0 * (1.0 - base.b) * (1.0 - blend.b))
        );
    } else if (mode == 6) {
        // ADD (LINEAR DODGE): base + blend
        return min(base + blend, vec3(1.0));
    } else if (mode == 7) {
        // SOFT LIGHT: blend < 0.5 ? (2*base*blend + base^2*(1-2*blend)) : (sqrt(base)*(2*blend-1) + 2*base*(1-blend))
        return vec3(
            blend.r < 0.5 ? (2.0 * base.r * blend.r + base.r * base.r * (1.0 - 2.0 * blend.r)) : (sqrt(base.r) * (2.0 * blend.r - 1.0) + 2.0 * base.r * (1.0 - blend.r)),
            blend.g < 0.5 ? (2.0 * base.g * blend.g + base.g * base.g * (1.0 - 2.0 * blend.g)) : (sqrt(base.g) * (2.0 * blend.g - 1.0) + 2.0 * base.g * (1.0 - blend.g)),
            blend.b < 0.5 ? (2.0 * base.b * blend.b + base.b * base.b * (1.0 - 2.0 * blend.b)) : (sqrt(base.b) * (2.0 * blend.b - 1.0) + 2.0 * base.b * (1.0 - blend.b))
        );
    } else if (mode == 8) {
        // HARD LIGHT: blend < 0.5 ? (2 * base * blend) : (1 - 2 * (1 - base) * (1 - blend))
        return vec3(
            blend.r < 0.5 ? (2.0 * base.r * blend.r) : (1.0 - 2.0 * (1.0 - base.r) * (1.0 - blend.r)),
            blend.g < 0.5 ? (2.0 * base.g * blend.g) : (1.0 - 2.0 * (1.0 - base.g) * (1.0 - blend.g)),
            blend.b < 0.5 ? (2.0 * base.b * blend.b) : (1.0 - 2.0 * (1.0 - base.b) * (1.0 - blend.b))
        );
    } else if (mode == 9) {
        // VIVID LIGHT: blend < 0.5 ? ColorBurn(base, 2*blend) : ColorDodge(base, 2*(blend-0.5))
        return vec3(
            blend.r < 0.5 ? (blend.r == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.r) / (2.0 * blend.r)), 0.0)) : (blend.r == 1.0 ? 1.0 : min(base.r / (2.0 * (1.0 - blend.r)), 1.0)),
            blend.g < 0.5 ? (blend.g == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.g) / (2.0 * blend.g)), 0.0)) : (blend.g == 1.0 ? 1.0 : min(base.g / (2.0 * (1.0 - blend.g)), 1.0)),
            blend.b < 0.5 ? (blend.b == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.b) / (2.0 * blend.b)), 0.0)) : (blend.b == 1.0 ? 1.0 : min(base.b / (2.0 * (1.0 - blend.b)), 1.0))
        );
    } else if (mode == 10) {
        // LINEAR LIGHT: blend < 0.5 ? LinearBurn(base, 2*blend) : LinearDodge(base, 2*(blend-0.5))
        return vec3(
            blend.r < 0.5 ? max(base.r + 2.0 * blend.r - 1.0, 0.0) : min(base.r + 2.0 * (blend.r - 0.5), 1.0),
            blend.g < 0.5 ? max(base.g + 2.0 * blend.g - 1.0, 0.0) : min(base.g + 2.0 * (blend.g - 0.5), 1.0),
            blend.b < 0.5 ? max(base.b + 2.0 * blend.b - 1.0, 0.0) : min(base.b + 2.0 * (blend.b - 0.5), 1.0)
        );
    } else if (mode == 11) {
        // DIFFERENCE: abs(base - blend)
        return abs(base - blend);
    } else if (mode == 12) {
        // EXCLUSION: base + blend - 2 * base * blend
        return base + blend - 2.0 * base * blend;
    } else if (mode == 13) {
        // DARKEN: min(base, blend)
        return min(base, blend);
    } else if (mode == 14) {
        // LIGHTEN: max(base, blend)
        return max(base, blend);
    } else if (mode == 15) {
        // SUBTRACT: max(base - blend, 0)
        return max(base - blend, vec3(0.0));
    } else if (mode == 16) {
        // DIVIDE: base / (blend + epsilon)
        return min(base / (blend + vec3(0.001)), vec3(1.0));
    } else {
        // PIN LIGHT (mode 17): Replaces colors based on blend brightness
        float blendLum = (blend.r + blend.g + blend.b) / 3.0;
        if (blendLum > 0.5) {
            // Lighten: replace pixels darker than blend
            return max(base, 2.0 * blend - vec3(1.0));
        } else {
            // Darken: replace pixels lighter than blend
            return min(base, 2.0 * blend);
        }
    }
}
`;

/**
 * Blend mode names for UI dropdowns
 */
const blendModeNames = [
    'Multiply',       // 0 - Darkening
    'Linear Burn',    // 1 - Darkening
    'Color Burn',     // 2 - Darkening (intense)
    'Color Dodge',    // 3 - Brightening (intense)
    'Screen',         // 4 - Brightening
    'Overlay',        // 5 - Contrast
    'Add',            // 6 - Brightening (glow)
    'Soft Light',     // 7 - Contrast (gentle)
    'Hard Light',     // 8 - Contrast (strong)
    'Vivid Light',    // 9 - Saturation boost
    'Linear Light',   // 10 - Linear saturation
    'Difference',     // 11 - Inversion
    'Exclusion',      // 12 - Soft inversion
    'Darken',         // 13 - Comparison (darker)
    'Lighten',        // 14 - Comparison (lighter)
    'Subtract',       // 15 - Deep shadows
    'Divide',         // 16 - Ethereal glow
    'Pin Light'       // 17 - Posterization
];

/**
 * Get blend mode name by index
 * @param {number} index - Blend mode index (0-17)
 * @returns {string} Blend mode name
 */
function getBlendModeName(index) {
    return blendModeNames[index] || 'Unknown';
}

/**
 * Get blend mode index by name
 * @param {string} name - Blend mode name
 * @returns {number} Blend mode index (0-17), or 0 if not found
 */
function getBlendModeIndex(name) {
    const index = blendModeNames.indexOf(name);
    return index !== -1 ? index : 0;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Moon Shader with Blend Layers
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Moon shader extended with universal blend mode layer system
 * @author Emotive Engine Team
 * @module 3d/shaders/shadows/moonWithBlendLayers
 *
 * Extends the standard moon shader with support for multiple sequential blend mode layers.
 * Uses universal blend mode utilities from src/3d/shaders/utils/blendModes.js
 * Allows drag-and-drop layer stacking for complex color grading effects.
 */


const moonWithBlendLayersVertexShader = `
/**
 * Moon Vertex Shader
 * Passes view-space normal for camera-relative moon phase shadows
 */

varying vec3 vPosition; // LOCAL position (object space)
varying vec3 vWorldPosition;
varying vec3 vViewNormal; // VIEW SPACE normal (fixed relative to camera)
varying vec3 vViewPosition;
varying vec2 vUv;

void main() {
    vUv = uv;
    vPosition = position;

    // Transform normal to VIEW space (camera-relative)
    // This keeps the moon phase shadow fixed relative to camera view
    // When you rotate the moon, the texture rotates but the phase shadow stays put
    vViewNormal = normalize(normalMatrix * normal);

    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    vWorldPosition = worldPosition.xyz;
    vec4 viewPosition = viewMatrix * worldPosition;
    vViewPosition = viewPosition.xyz;
    gl_Position = projectionMatrix * viewPosition;
}
`;

const moonWithBlendLayersFragmentShader = `
/**
 * Moon Fragment Shader with Blend Layers
 *
 * Supports up to 4 sequential blend mode layers for complex color grading
 * using universal Photoshop-style blend modes
 */

uniform sampler2D colorMap;
uniform sampler2D normalMap;
uniform vec2 shadowOffset;
uniform float shadowCoverage;
uniform float shadowSoftness;
uniform vec3 glowColor;
uniform float glowIntensity;
uniform float opacity;

// Lunar Eclipse (Blood Moon) uniforms
uniform float eclipseProgress;
uniform float eclipseIntensity;
uniform vec3 bloodMoonColor;
uniform float emissiveStrength;
uniform vec2 eclipseShadowPos;      // Shadow center position (-2 to 1)
uniform float eclipseShadowRadius;  // Shadow radius

// Eclipse Color Grading (from color pickers)
uniform vec3 eclipseShadowColor;
uniform vec3 eclipseMidtoneColor;
uniform vec3 eclipseHighlightColor;
uniform vec3 eclipseGlowColor;

// Brightness model toggle (0 = centeredness-based, 1 = edge-based)
uniform float eclipseBrightnessModel;

// Shadow darkness control (0.0 = no darkening, 1.0 = maximum darkening)
uniform float shadowDarkness;

// Blend Layer Uniforms (up to 4 layers)
uniform float layer1Mode;
uniform float layer1Strength;
uniform float layer1Enabled;

uniform float layer2Mode;
uniform float layer2Strength;
uniform float layer2Enabled;

uniform float layer3Mode;
uniform float layer3Strength;
uniform float layer3Enabled;

uniform float layer4Mode;
uniform float layer4Strength;
uniform float layer4Enabled;

varying vec3 vPosition;
varying vec3 vWorldPosition;
varying vec3 vViewNormal;
varying vec3 vViewPosition;
varying vec2 vUv;

// ═══════════════════════════════════════════════════════════════════════════
// UNIVERSAL BLEND MODES (injected from utils/blendModes.js)
// ═══════════════════════════════════════════════════════════════════════════
${blendModesGLSL}

void main() {
    // DIRECTIONAL SHADOW in VIEW SPACE - camera-relative moon phase
    // Shadow stays fixed relative to screen; rotating moon doesn't change which side is lit
    vec3 viewNormal = normalize(vViewNormal);

    float lightX = shadowOffset.x;
    float lightY = shadowOffset.y;
    float offsetMagnitude = length(vec2(lightX, lightY));
    float lightZ = 1.0 - pow(offsetMagnitude, 1.5);
    vec3 lightDir = normalize(vec3(lightX, lightY, lightZ));

    // Light direction is in view space (camera-relative)
    float facing = dot(viewNormal, lightDir);
    float edgeWidth = max(fwidth(facing) * 4.0, shadowSoftness * 3.0);
    float shadowFactor = smoothstep(-edgeWidth, edgeWidth, facing);

    // Sample moon surface texture
    vec4 texColor = texture2D(colorMap, vUv);
    float brightness = texColor.r + texColor.g + texColor.b;
    if (brightness < 0.03) {
        texColor = vec4(0.5, 0.5, 0.5, 1.0);
    }

    // VIEW DIRECTION (for eclipse rim effects only, NOT for general lighting)
    vec3 viewDir = normalize(-vViewPosition);
    float rimFactor = dot(viewNormal, viewDir);

    // EARTHSHINE - faint blue glow on shadowed side
    vec3 earthshine = texColor.rgb * 0.01 * vec3(0.35, 0.4, 0.6);

    // Apply shadow transition (moon phase only - NOT camera-based)
    // The moon texture is uniformly visible; only the phase shadow creates darkness
    float litFactor = pow(shadowFactor, 2.0);
    vec3 detailEnhanced = texColor.rgb * 1.08;
    float textureLuminance = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
    detailEnhanced = mix(texColor.rgb * 0.95, texColor.rgb * 1.12, smoothstep(0.3, 0.7, textureLuminance));

    // Lit areas show texture; shadowed areas show earthshine
    // NO camera-based limb darkening - moon rotates, texture stays uniformly lit
    vec3 shadowedColor = mix(earthshine, detailEnhanced, litFactor);

    vec3 emissive = vec3(0.02, 0.02, 0.02) * shadowFactor;
    vec3 emotionGlow = glowColor * glowIntensity * 0.02 * shadowFactor;
    vec3 finalColor = shadowedColor + emissive + emotionGlow;

    // ═══════════════════════════════════════════════════════════════════════════
    // LUNAR ECLIPSE EFFECT (Earth's Shadow Sweep)
    // Shadow position drives everything - automatically transitions from dark sharp shadow to red glow
    // ═══════════════════════════════════════════════════════════════════════════
    // Only apply eclipse if shadow is actually near the moon (shadowX > -1.5)
    if (eclipseProgress > 0.001 && eclipseShadowPos.x > -1.5) {
        // Eclipse progress is now pre-modulated by UI based on shadow position
        // No need for shader-side modulation
        float effectiveProgress = eclipseProgress;

        // Calculate distance from shadow center using VIEW-SPACE position (3D spherical)
        // This creates a proper circular shadow on the sphere, not a flat UV-based cutoff
        // viewNormal.xy ranges -1 to 1, scale to match UV range (0 to 0.5 from center)
        vec2 shadowCenter = vec2(eclipseShadowPos.x, eclipseShadowPos.y);
        vec2 spherePos = viewNormal.xy * 0.5; // Scale to UV-equivalent range
        float distFromShadow = length(spherePos - shadowCenter);

        // TOTALITY FACTOR: Based on how centered the shadow is on the moon
        // When shadowX near 0.0 (centered), we're at totality - brightens and reddens
        // When shadowX far from 0.0 (off to side), we're partial - stays dark and diffuse
        float shadowCenteredness = 1.0 - smoothstep(0.0, 0.6, abs(eclipseShadowPos.x));
        float totalityFactor = shadowCenteredness;

        // Earth's umbra (full shadow) - DIFFUSE at partials, sharper at totality
        float umbraRadius = eclipseShadowRadius * 0.7;
        // Edge softness: very diffuse at partials (0.25), sharp at totality (0.05)
        float umbraEdge = mix(0.25, 0.05, totalityFactor);
        float umbra = 1.0 - smoothstep(umbraRadius - umbraEdge, umbraRadius + umbraEdge, distFromShadow);

        // Earth's penumbra (partial shadow) - wider and softer
        // Penumbra extends further at partials, tighter at totality
        float penumbraRadius = eclipseShadowRadius * mix(1.4, 1.1, totalityFactor);
        float penumbraEdge = mix(0.3, 0.15, totalityFactor);
        float penumbra = 1.0 - smoothstep(penumbraRadius - penumbraEdge, penumbraRadius + penumbraEdge, distFromShadow);

        // UMBRA DARKENING: Much darker at partials, lighter at totality
        // Partials: 85% darkening (very dark shadow)
        // Totality: 30% darkening (blood moon glow visible)
        float baseDarkening = mix(0.85, 0.30, totalityFactor);
        float umbraDarkeningAmount = baseDarkening * shadowDarkness;
        float umbraDarkening = umbra * effectiveProgress;

        // Apply base darkening first
        finalColor *= (1.0 - umbraDarkening * umbraDarkeningAmount);

        // PENUMBRA: Darker gradient at partials, lighter at totality
        float penumbraDarkening = (penumbra - umbra) * effectiveProgress;
        float penumbraDarkenAmount = mix(0.50, 0.20, totalityFactor); // 50% at partials, 20% at totality
        finalColor *= (1.0 - penumbraDarkening * penumbraDarkenAmount);

        // BLOOD MOON COLOR: Applied throughout entire eclipse, not just totality
        // Matches real lunar eclipse behavior - color present at all phases
        // Use totality factor to control BRIGHTNESS, not color presence
        float colorStrength = umbra; // Color appears wherever umbra shadow is present
        vec3 bloodMoonTint = mix(vec3(1.0), eclipseMidtoneColor, colorStrength);
        finalColor *= bloodMoonTint;

        // REALISTIC ECLIPSE PROGRESSION (corrected):
        // Shadow sweeps LEFT → RIGHT but NEVER fully covers moon during partials
        // A bright crescent ALWAYS remains visible (shadow stops before covering moon)
        // Just before totality: shadow nearly covers moon, blood moon glow appears
        // The glow spreads FROM the visible bright crescent INTO the shadowed area
        // During totality: shadow finally covers entire moon, full blood moon

        // Use view-space normal for spherical position (not UV)
        // Scale to match UV range
        float pixelX = viewNormal.x * 0.5;

        // THE LIT CRESCENT: Always visible during partial phases
        // During partials, the moon is partially lit (outside umbra)
        // Only during totality does the shadow fully cover the moon

        // Where is the bright crescent? Opposite side from shadow
        // Approaching (shadowX < 0): crescent on RIGHT (positive X)
        // Leaving (shadowX > 0): crescent on LEFT (negative X)
        float crescentSide = -sign(eclipseShadowPos.x);

        // CRESCENT EDGE: Where shadow meets lit surface
        // This is always VISIBLE during partials - never goes to zero
        float umbraEdgeX = eclipseShadowPos.x + (umbraRadius * crescentSide);

        // Distance from this pixel to the lit crescent edge
        // Positive = inside shadow, negative = in lit crescent
        float distFromLitEdge = (pixelX - umbraEdgeX) * crescentSide;

        // GRADIENT: Blood moon glow spreads from the LIT CRESCENT
        // Only pixels INSIDE the shadow get the gradient
        // Gradient is strongest at the umbra edge (where crescent is)
        float crescentGradient = smoothstep(0.5, 0.0, distFromLitEdge);

        // BRIGHTNESS CONTROL: Glow only appears near totality
        // When shadow is far from center: stays dark
        // When shadow approaches center: glow spreads from crescent
        float brightnessControl = umbra * crescentGradient * totalityFactor;

        // During full totality (shadowX ≈ 0), switch to uniform brightness
        brightnessControl = mix(brightnessControl, umbra * totalityFactor, totalityFactor);

        // EMISSIVE GLOW: Blood moon color spreading from crescent
        float glowStrength = mix(0.0, 1.0, brightnessControl);
        vec3 atmosphereGlow = eclipseMidtoneColor * emissiveStrength * glowStrength * umbra;
        finalColor += atmosphereGlow;

        // RIM GLOW: Atmospheric limb brightening
        float limbGlowStrength = mix(0.0, 1.5, brightnessControl);
        float limbGlow = pow(1.0 - rimFactor, 3.0) * umbra;
        vec3 rimColor = mix(eclipseGlowColor, eclipseHighlightColor, 0.5);
        finalColor += rimColor * limbGlow * emissiveStrength * limbGlowStrength;

        // ═══════════════════════════════════════════════════════════════════════════
        // ECLIPSE BLEND LAYERS (Applied AFTER blood moon color)
        // Applied throughout eclipse wherever umbra is present
        // Strength modulated by totality factor for smooth brightness transitions
        // ═══════════════════════════════════════════════════════════════════════════

        // Layer 1: Linear Burn @ 0.634
        if (layer1Enabled > 0.5 && effectiveProgress > 0.1) {
            vec3 blendColor1 = vec3(min(layer1Strength, 1.0));
            int mode1 = int(layer1Mode + 0.5);
            vec3 blended1 = clamp(applyBlendMode(finalColor, blendColor1, mode1), 0.0, 1.0);
            // Apply at FULL strength wherever umbra exists
            finalColor = clamp(mix(finalColor, blended1, umbra), 0.0, 1.0);
        }

        // Layer 2: Multiply @ 3.086 - Brightness enhancement
        if (layer2Enabled > 0.5 && effectiveProgress > 0.1) {
            // Apply full brightness boost wherever umbra exists
            vec3 brightened = clamp(finalColor * min(layer2Strength, 5.0), 0.0, 1.0);
            finalColor = mix(finalColor, brightened, umbra);
        }

        // Layer 3: Hard Light @ 0.351
        if (layer3Enabled > 0.5 && effectiveProgress > 0.1) {
            vec3 blendColor3 = vec3(min(layer3Strength, 1.0));
            int mode3 = int(layer3Mode + 0.5);
            vec3 blended3 = clamp(applyBlendMode(finalColor, blendColor3, mode3), 0.0, 1.0);
            // Apply at FULL strength wherever umbra exists
            finalColor = clamp(mix(finalColor, blended3, umbra), 0.0, 1.0);
        }

        // Layer 4: Manual UI layer
        if (layer4Enabled > 0.5 && effectiveProgress > 0.1) {
            vec3 blendColor4 = vec3(min(layer4Strength, 1.0));
            int mode4 = int(layer4Mode + 0.5);
            vec3 blended4 = clamp(applyBlendMode(finalColor, blendColor4, mode4), 0.0, 1.0);
            finalColor = clamp(mix(finalColor, blended4, umbra), 0.0, 1.0);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // UNIVERSAL BLEND MODE LAYERS (Only applied when eclipse is OFF)
    // These are manual UI-driven color grading tools
    // NOTE: These are DISABLED by default - they're NEVER used since the multiplexer
    // demo doesn't enable them. This section exists for potential future manual control.
    // ═══════════════════════════════════════════════════════════════════════════
    // INTENTIONALLY COMMENTED OUT - these would interfere with eclipse blend layers
    // if (eclipseProgress < 0.001) {
    //     // Layer 1 - manual UI control only
    //     if (layer1Enabled > 0.5) {
    //         vec3 blendColor1 = vec3(layer1Strength);
    //         int mode1 = int(layer1Mode + 0.5);
    //         finalColor = applyBlendMode(finalColor, blendColor1, mode1);
    //     }
    // }

    gl_FragColor = vec4(finalColor, opacity);
}
`;

/**
 * Get moon shader with blend layers
 * @returns {Object} Object with vertexShader and fragmentShader strings
 */
function getMoonWithBlendLayersShaders() {
    return {
        vertexShader: moonWithBlendLayersVertexShader,
        fragmentShader: moonWithBlendLayersFragmentShader
    };
}

/**
 * Moon Geometry with NASA Texture Maps
 *
 * Uses authentic NASA Lunar Reconnaissance Orbiter data:
 * - Color map: LROC Wide Angle Camera imagery
 * - Normal map: Generated from LOLA laser altimeter elevation data
 *
 * @module geometries/Moon
 */


/**
 * Moon Calibration Rotation
 * Calibrated to show the classic "Man in the Moon" Earth-facing view
 * These values rotate the moon texture to match how we see it from Earth
 */
const MOON_CALIBRATION_ROTATION = {
    x: 55.5,   // degrees
    y: -85,  // degrees
    z: -60.5   // degrees
};

/**
 * Moon Tidal Lock Configuration
 * Moon is tidally locked to always show the same face (like Earth's moon)
 */
const MOON_FACING_CONFIG = {
    enabled: true,
    strength: 1.0,        // Full tidal lock
    lockedFace: [0, 0, 1], // +Z axis faces camera
    lerpSpeed: 10.0        // Fast snap to correct orientation
};

/**
 * Moon Phase Definitions
 * Maps phase names to light direction vectors in view space
 *
 * Light direction controls which side of the moon is illuminated:
 * - Positive X: Light from right (waxing phases)
 * - Negative X: Light from left (waning phases)
 * - Larger magnitude: More moon visible
 */
const MOON_PHASES = {
    // Calibrated with exponential Z formula (2025-01-08)
    // Formula: Z = 1.0 - offsetMagnitude^1.5
    // Manually calibrated to match astronomical reference images

    // New moon - Light from directly behind (extreme offset)
    'new': { x: 200.0, y: 0.0, coverage: 0.0 },

    // Waxing phases (light from right side, progressively more frontal)
    'waxing-crescent': { x: 1.5, y: 0.0, coverage: 0.25 },    // Thin crescent on right (CALIBRATED)
    'first-quarter': { x: 1.0, y: 0.0, coverage: 0.5 },       // Half moon, light from right
    'waxing-gibbous': { x: 0.7, y: 0.0, coverage: 0.75 },     // More than half (CALIBRATED)

    // Full moon - Light from directly in front
    'full': { x: 0.0, y: 0.0, coverage: 1.0 },

    // Waning phases (mirror of waxing, light from left side)
    'waning-gibbous': { x: -0.7, y: 0.0, coverage: 0.75 },    // More than half (CALIBRATED)
    'last-quarter': { x: -1, y: 0.0, coverage: 0.5 },       // Half moon, light from left
    'waning-crescent': { x: -1.5, y: 0.0, coverage: 0.25 }    // Thin crescent on left (CALIBRATED)
};

/**
 * Get all available moon phase names
 * @returns {string[]} Array of phase names
 */
function getMoonPhaseNames() {
    return Object.keys(MOON_PHASES);
}

/**
 * Map phase progress (0-1) to light direction
 *
 * The shader uses normalize(shadowOffset.x, shadowOffset.y, 1.0) as light direction.
 * - shadowOffset.x = 0: light from camera (0,0,1) → FULL MOON (completely lit)
 * - shadowOffset.x = large: light from side → NEW MOON (dark/thin crescent)
 *
 * Truth table:
 * 0% -> x: 10 (new moon - dark)
 * 12.5% -> x: 3 (waxing crescent)
 * 25% -> x: 1 (first quarter - half lit)
 * 37.5% -> x: 0.3 (waxing gibbous)
 * 50% -> x: 0 (full moon - fully lit)
 * 62.5% -> x: -0.3 (waning gibbous)
 * 75% -> x: -1 (last quarter - half lit)
 * 87.5% -> x: -3 (waning crescent)
 * 100% -> x: 10 (new moon - cycle complete)
 *
 * @param {number} progress - Phase progress from 0 to 1
 * @returns {Object} Light direction {x, y} and coverage
 */
function getPhaseFromProgress(progress) {
    // Normalize to 0-1 range
    const normalized = ((progress % 1) + 1) % 1;

    let x;
    if (normalized <= 0.5) {
        // Waxing phases: 0 to 0.5 maps to 10 → 0 (dark to full)
        // Use exponential decay to match shader's normalize() compression
        // At 0: x=10, at 0.25: x=1, at 0.5: x=0

        // Map 0-0.5 to 10-0 with proper curve
        // Formula: x = 10 * (1 - t)^2.5 where t goes 0->1
        const t = normalized * 2.0; // 0 to 1
        x = 10.0 * Math.pow(1.0 - t, 2.5);
    } else {
        // Waning phases: 0.5 to 1.0 maps to 0 → 10 (via negative side)
        // 0.5 -> 0, 0.625 -> -0.3, 0.75 -> -1, 0.875 -> -3, 1.0 -> 10

        const t = (normalized - 0.5) * 2.0; // 0 to 1

        if (t <= 0.25) {
            // 0.5 to 0.625: smooth transition to waning gibbous (0 to -0.3)
            x = -0.3 * (t / 0.25);
        } else if (t <= 0.5) {
            // 0.625 to 0.75: waning gibbous to last quarter (-0.3 to -1)
            const subT = (t - 0.25) / 0.25;
            x = -0.3 - (0.7 * subT);
        } else if (t <= 0.75) {
            // 0.75 to 0.875: last quarter to waning crescent (-1 to -3)
            const subT = (t - 0.5) / 0.25;
            x = -1 - (2.0 * subT);
        } else {
            // 0.875 to 1.0: waning crescent to new moon (-3 to 10)
            const subT = (t - 0.75) / 0.25;
            x = -3 + (13.0 * Math.pow(subT, 0.4));
        }
    }

    const coverage = 1.0 - Math.abs(normalized - 0.5) * 2.0;

    return { x, y: 0.0, coverage };
}

/**
 * Create moon sphere geometry
 * Uses high segment count for smooth normals and proper texture mapping
 *
 * @param {number} widthSegments - Horizontal segments (default: 64 for smooth look)
 * @param {number} heightSegments - Vertical segments (default: 64)
 * @returns {THREE.SphereGeometry}
 */
function createMoon(widthSegments = 64, heightSegments = 64) {
    const geometry = new SphereGeometry(
        0.5,           // radius 0.5 = 1.0 diameter (matches sphere geometry)
        widthSegments, // 64 segments for smooth normal mapping
        heightSegments
    );

    // Track for disposal
    geometry.userData.tracked = true;

    return geometry;
}

/**
 * Dispose of moon geometry and material resources
 * Call this when removing a moon from the scene
 *
 * @param {THREE.Mesh} moonMesh - Moon mesh to dispose
 */
function disposeMoon(moonMesh) {
    if (!moonMesh) return;

    // Dispose geometry
    if (moonMesh.geometry) {
        moonMesh.geometry.dispose();
    }

    // Dispose material and its textures
    if (moonMesh.material) {
        const {material} = moonMesh;

        // Clean up pending texture loads
        if (material.userData && material.userData.pendingTextures) {
            material.userData.pendingTextures.forEach(({texture}) => {
                if (texture) {
                    texture.dispose();
                }
            });
            material.userData.pendingTextures.clear();
        }

        // Dispose textures
        if (material.map) material.map.dispose();
        if (material.normalMap) material.normalMap.dispose();

        // Dispose shader material uniforms
        if (material.uniforms) {
            if (material.uniforms.colorMap && material.uniforms.colorMap.value) {
                material.uniforms.colorMap.value.dispose();
            }
            if (material.uniforms.normalMap && material.uniforms.normalMap.value) {
                material.uniforms.normalMap.value.dispose();
            }
        }

        // Dispose material
        material.dispose();
    }
}

/**
 * Create moon material with NASA texture maps
 * Loads color and normal maps asynchronously
 *
 * @param {THREE.TextureLoader} textureLoader - Three.js texture loader
 * @param {Object} options - Material configuration options
 * @param {string} options.resolution - Texture resolution: '2k' or '4k' (default: '4k')
 * @param {THREE.Color} options.glowColor - Emissive glow color (default: white)
 * @param {number} options.glowIntensity - Emissive intensity (default: 0)
 * @returns {THREE.MeshStandardMaterial}
 */
function createMoonMaterial$1(textureLoader, options = {}) {
    const resolution = options.resolution || '4k';
    const assetBasePath = options.assetBasePath || '/assets';

    // Determine texture paths based on resolution
    const colorPath = `${assetBasePath}/textures/Moon/moon-color-${resolution}.jpg`;
    const normalPath = `${assetBasePath}/textures/Moon/moon-normal-${resolution}.jpg`;

    // Initialize pending texture tracking for cleanup
    const pendingTextures = new Map();

    // Load textures asynchronously with tracking
    pendingTextures.set(colorPath, { texture: null });

    const colorMap = textureLoader.load(
        colorPath,
        // onLoad callback
        texture => {
            const pending = pendingTextures.get(colorPath);
            if (pending) {
                pending.texture = texture;
            }
            pendingTextures.delete(colorPath);
        },
        // onProgress callback
        undefined,
        // onError callback
        error => {
            console.error(`❌ Failed to load moon color texture (${resolution}):`, error);
            pendingTextures.delete(colorPath);
        }
    );

    pendingTextures.set(normalPath, { texture: null });

    const normalMap = textureLoader.load(
        normalPath,
        texture => {
            const pending = pendingTextures.get(normalPath);
            if (pending) {
                pending.texture = texture;
            }
            pendingTextures.delete(normalPath);
        },
        undefined,
        error => {
            console.error(`❌ Failed to load moon normal map (${resolution}):`, error);
            pendingTextures.delete(normalPath);
        }
    );

    // Configure texture wrapping for seamless sphere mapping
    colorMap.wrapS = colorMap.wrapT = RepeatWrapping;
    normalMap.wrapS = normalMap.wrapT = RepeatWrapping;

    // Enable anisotropic filtering for better quality at oblique angles
    colorMap.anisotropy = 16;
    normalMap.anisotropy = 16;

    // Create physically-based material with NASA textures
    const material = new MeshStandardMaterial({
        // Base color from NASA LROC imagery
        map: colorMap,

        // Surface detail from LOLA elevation data
        normalMap,
        normalScale: new Vector2(1.5, 1.5), // Adjust bump intensity (1.0 = subtle, 2.0 = pronounced)

        // Material properties for realistic lunar surface
        roughness: 0.7,    // Slightly less rough for more brightness
        metalness: 0.0,    // Non-metallic (moon rock is not metal)

        // Emissive glow (controlled by emotion system) - brightened for visibility
        emissive: new Color(0.3, 0.3, 0.3), // Base gray glow for brightness
        emissiveIntensity: 0.5,  // Boost base brightness

        // Enable transparency for future shader-based crescent clipping
        transparent: false, // Will be true in Phase 3 with shader material
        side: FrontSide
    });

    // Store pending textures for disposal
    material.userData.pendingTextures = pendingTextures;

    return material;
}

/**
 * Create fallback gray material for moon
 * Used as placeholder while textures load or if loading fails
 *
 * @param {THREE.Color} glowColor - Emissive glow color
 * @param {number} glowIntensity - Emissive intensity
 * @returns {THREE.MeshStandardMaterial}
 */
function createMoonFallbackMaterial(glowColor = new Color(0xffffff), glowIntensity = 0) {
    return new MeshStandardMaterial({
        color: 0xe8e8e8,      // Light gray moon surface (matches 2D version)
        roughness: 0.9,
        metalness: 0.0,
        emissive: glowColor,
        emissiveIntensity: glowIntensity
    });
}

/**
 * Create moon material with shader-based shadow effects
 * Supports multiple shadow types and moon phases
 *
 * @param {THREE.TextureLoader} textureLoader - Three.js texture loader
 * @param {Object} options - Material configuration options
 * @param {string} options.resolution - Texture resolution: '2k' or '4k' (default: '4k')
 * @param {THREE.Color} options.glowColor - Emissive glow color (default: white)
 * @param {number} options.glowIntensity - Emissive intensity (default: 1.0)
 * @param {string} options.shadowType - Shadow effect type: 'crescent', 'lunar-eclipse', 'solar-eclipse', 'black-hole' (default: 'crescent')
 * @param {string|number} options.moonPhase - Moon phase name or progress 0-1 (default: 'waxing-crescent')
 * @param {number} options.shadowOffsetX - Manual shadow X offset (overrides moonPhase)
 * @param {number} options.shadowOffsetY - Manual shadow Y offset (overrides moonPhase)
 * @param {number} options.shadowCoverage - Shadow coverage 0-1 (default: 0.85)
 * @returns {THREE.ShaderMaterial}
 */
function createMoonShadowMaterial(textureLoader, options = {}) {
    const resolution = options.resolution || '4k';
    const glowColor = options.glowColor || new Color(1, 1, 1);
    const glowIntensity = options.glowIntensity || 1.0;
    const shadowType = options.shadowType || 'crescent';
    const assetBasePath = options.assetBasePath || '/assets';

    // Determine shadow offset from moonPhase or manual override
    let shadowOffsetX, shadowOffsetY;

    if (options.shadowOffsetX !== undefined) {
        // Manual override
        ({ shadowOffsetX } = options);
        shadowOffsetY = options.shadowOffsetY !== undefined ? options.shadowOffsetY : 0.0;
    } else if (options.moonPhase !== undefined) {
        // Use moon phase
        let phaseData;
        if (typeof options.moonPhase === 'string') {
            [phaseData] = [MOON_PHASES[options.moonPhase]];
            if (!phaseData) {
                console.warn(`Unknown moon phase: ${options.moonPhase}, using waxing-crescent`);
                phaseData = MOON_PHASES['waxing-crescent'];
            }
        } else if (typeof options.moonPhase === 'number') {
            phaseData = getPhaseFromProgress(options.moonPhase);
        } else {
            phaseData = MOON_PHASES['waxing-crescent'];
        }
        shadowOffsetX = phaseData.x;
        shadowOffsetY = phaseData.y;
    } else {
        // Default to waxing-crescent
        const defaultPhase = MOON_PHASES['waxing-crescent'];
        shadowOffsetX = defaultPhase.x;
        shadowOffsetY = defaultPhase.y;
    }

    const shadowCoverage = options.shadowCoverage !== undefined ? options.shadowCoverage : 0.85;

    // Determine texture paths
    const colorPath = `${assetBasePath}/textures/Moon/moon-color-${resolution}.jpg`;
    const normalPath = `${assetBasePath}/textures/Moon/moon-normal-${resolution}.jpg`;

    // Get shaders based on shadow type
    const { vertexShader, fragmentShader } = getShadowShaders(shadowType);

    // Create shader material with placeholder textures
    const material = new ShaderMaterial({
        uniforms: {
            colorMap: { value: null },
            normalMap: { value: null },
            shadowOffset: { value: new Vector2(shadowOffsetX, shadowOffsetY) },
            shadowCoverage: { value: shadowCoverage },
            shadowSoftness: { value: 0.05 }, // Edge blur amount
            glowColor: { value: glowColor },
            glowIntensity: { value: glowIntensity },
            opacity: { value: 0.0 }, // Start invisible, fade in when texture loads
            // Lunar Eclipse (Blood Moon) uniforms
            eclipseProgress: { value: 0.0 },  // 0 = no eclipse, 1 = totality
            eclipseIntensity: { value: 0.0 }, // Darkening strength
            bloodMoonColor: { value: [0.85, 0.18, 0.08] }, // Deep reddish-orange
            blendMode: { value: 0.0 }, // 0=Multiply, 1=LinearBurn, 2=ColorBurn, 3=ColorDodge, 4=Screen, 5=Overlay
            blendStrength: { value: 2.0 }, // Blend strength multiplier (0-5)
            emissiveStrength: { value: 0.39 }, // Emissive glow strength (peak at total eclipse)
            eclipseShadowPos: { value: [-2, 0.0] },
            eclipseShadowRadius: { value: 1.2 },
            // Eclipse color grading
            eclipseShadowColor: { value: [0.85, 0.08, 0.02] },
            eclipseMidtoneColor: { value: [1.0, 0.12, 0.03] },
            eclipseHighlightColor: { value: [1.0, 0.35, 0.08] },
            eclipseGlowColor: { value: [1.0, 0.40, 0.10] }
        },
        vertexShader,
        fragmentShader,
        transparent: true,
        side: FrontSide
    });

    // Initialize pending texture tracking for cleanup
    const pendingTextures = new Map();

    // Load textures and update material when ready
    pendingTextures.set(colorPath, { texture: null });

    const colorMap = textureLoader.load(
        colorPath,
        texture => {
            material.uniforms.colorMap.value = texture;

            // Fade in moon when texture loads (avoid gray flash)
            const startTime = performance.now();
            const fadeIn = () => {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / 300, 1.0); // 300ms fade
                material.uniforms.opacity.value = progress;
                material.needsUpdate = true;

                if (progress < 1.0) {
                    requestAnimationFrame(fadeIn);
                }
            };
            fadeIn();

            const pending = pendingTextures.get(colorPath);
            if (pending) {
                pending.texture = texture;
            }
            pendingTextures.delete(colorPath);
        },
        undefined,
        error => {
            console.error('❌ Failed to load moon crescent color texture:', error);
            pendingTextures.delete(colorPath);
        }
    );

    pendingTextures.set(normalPath, { texture: null });

    const normalMap = textureLoader.load(
        normalPath,
        texture => {
            material.uniforms.normalMap.value = texture;
            material.needsUpdate = true;
            const pending = pendingTextures.get(normalPath);
            if (pending) {
                pending.texture = texture;
            }
            pendingTextures.delete(normalPath);
        },
        undefined,
        error => {
            console.error('❌ Failed to load moon crescent normal map:', error);
            pendingTextures.delete(normalPath);
        }
    );

    // Configure textures
    colorMap.wrapS = colorMap.wrapT = RepeatWrapping;
    normalMap.wrapS = normalMap.wrapT = RepeatWrapping;
    colorMap.anisotropy = 16;
    normalMap.anisotropy = 16;

    // Store pending textures for disposal
    material.userData.pendingTextures = pendingTextures;

    return material;
}

/**
 * Legacy alias for backward compatibility
 * @deprecated Use createMoonShadowMaterial() instead
 */
function createMoonCrescentMaterial(textureLoader, options = {}) {
    return createMoonShadowMaterial(textureLoader, { ...options, shadowType: 'crescent' });
}

/**
 * Set moon phase instantly
 * Changes the shadow position to show a specific lunar phase
 *
 * @param {THREE.ShaderMaterial} material - Moon shadow material
 * @param {string|number} phase - Phase name (e.g., 'waxing-crescent') or progress (0-1)
 * @returns {boolean} True if phase was set successfully
 */
function setMoonPhase(material, phase) {
    if (!material.uniforms || !material.uniforms.shadowOffset) {
        console.warn('Material does not have shadowOffset uniform');
        return false;
    }

    let phaseData;

    // Handle named phase
    if (typeof phase === 'string') {
        phaseData = MOON_PHASES[phase];
        if (!phaseData) {
            console.warn(`Unknown moon phase: ${phase}`);
            return false;
        }
    }
    // Handle numeric progress (0-1)
    else if (typeof phase === 'number') {
        phaseData = getPhaseFromProgress(phase);
    } else {
        console.warn('Phase must be a string or number');
        return false;
    }

    // Update shadow offset uniform
    material.uniforms.shadowOffset.value.set(phaseData.x, phaseData.y);

    return true;
}

/**
 * Animate moon phase transition
 * Smoothly transitions from current phase to target phase
 *
 * @param {THREE.ShaderMaterial} material - Moon shadow material
 * @param {string|number} targetPhase - Target phase name or progress (0-1)
 * @param {number} duration - Animation duration in milliseconds (default: 2000)
 * @returns {Object} Object with { promise, cancel } - promise resolves when animation completes, cancel() stops the animation
 */
function animateMoonPhase(material, targetPhase, duration = 2000) {
    let animationId = null;
    let cancelled = false;

    const promise = new Promise((resolve, reject) => {
        if (!material.uniforms || !material.uniforms.shadowOffset) {
            reject(new Error('Material does not have shadowOffset uniform'));
            return;
        }

        // Get target phase data
        let targetData;
        if (typeof targetPhase === 'string') {
            targetData = MOON_PHASES[targetPhase];
            if (!targetData) {
                reject(new Error(`Unknown moon phase: ${targetPhase}`));
                return;
            }
        } else if (typeof targetPhase === 'number') {
            targetData = getPhaseFromProgress(targetPhase);
        } else {
            reject(new Error('Phase must be a string or number'));
            return;
        }

        // Get current and target positions
        const startX = material.uniforms.shadowOffset.value.x;
        const startY = material.uniforms.shadowOffset.value.y;
        const targetX = targetData.x;
        const targetY = targetData.y;

        const startTime = Date.now();

        // Animation loop
        const animate = () => {
            // Check if animation was cancelled
            if (cancelled) {
                resolve({ cancelled: true });
                return;
            }

            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1.0);

            // Ease in-out cubic
            const eased = progress < 0.5
                ? 4 * progress * progress * progress
                : 1 - Math.pow(-2 * progress + 2, 3) / 2;

            // Interpolate
            const currentX = startX + (targetX - startX) * eased;
            const currentY = startY + (targetY - startY) * eased;

            material.uniforms.shadowOffset.value.set(currentX, currentY);

            if (progress < 1.0) {
                animationId = requestAnimationFrame(animate);
            } else {
                resolve({ cancelled: false });
            }
        };

        animate();
    });

    // Return promise with cancel function
    return {
        promise,
        cancel: () => {
            cancelled = true;
            if (animationId !== null) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
    };
}

/**
 * Update moon material glow (called by emotion system)
 * Works with both MeshStandardMaterial and ShaderMaterial
 *
 * @param {THREE.Material} material - Moon material to update
 * @param {THREE.Color} glowColor - New glow color
 * @param {number} glowIntensity - New glow intensity
 */
function updateMoonGlow(material, glowColor, glowIntensity) {
    // Standard material (Phase 2)
    if (material.emissive) {
        material.emissive.copy(glowColor);
        material.emissiveIntensity = glowIntensity;
    }

    // Shader material (Phase 3)
    if (material.uniforms && material.uniforms.glowColor) {
        material.uniforms.glowColor.value.copy(glowColor);
        material.uniforms.glowIntensity.value = glowIntensity;
    }
}

/**
 * Update crescent shadow parameters
 *
 * @param {THREE.ShaderMaterial} material - Moon crescent shader material
 * @param {number} offsetX - Shadow X offset
 * @param {number} offsetY - Shadow Y offset
 * @param {number} coverage - Shadow coverage (0=full moon, 1=new moon)
 */
function updateCrescentShadow(material, offsetX, offsetY, coverage) {
    if (material.uniforms && material.uniforms.shadowOffset) {
        material.uniforms.shadowOffset.value.set(offsetX, offsetY);
        material.uniforms.shadowCoverage.value = coverage;
    }
}

/**
 * Create Moon Crescent Material with Blend Multiplexer
 * Supports up to 4 sequential blend mode layers for complex color grading
 *
 * @param {THREE.TextureLoader} textureLoader - Three.js texture loader
 * @param {Object} options - Material configuration options
 * @param {THREE.Color} options.glowColor - Glow color (default: white)
 * @param {number} options.glowIntensity - Glow intensity (default: 1.0)
 * @returns {THREE.ShaderMaterial} Shader material with multiplexer blend modes
 */
function createMoonMultiplexerMaterial(textureLoader, options = {}) {
    const {
        resolution = '4k',
        glowColor = new Color(0xffffff),
        glowIntensity = 1.0,
        assetBasePath = '/assets'
    } = options;

    const { vertexShader, fragmentShader } = getMoonWithBlendLayersShaders();

    const material = new ShaderMaterial({
        uniforms: {
            colorMap: { value: null },
            normalMap: { value: null },
            shadowOffset: { value: new Vector2(0, 0) },
            shadowCoverage: { value: 0.5 },
            shadowSoftness: { value: 0.05 },
            glowColor: { value: glowColor },
            glowIntensity: { value: glowIntensity },
            opacity: { value: 0.0 },

            // Lunar Eclipse (Blood Moon) uniforms
            eclipseProgress: { value: 0.0 },
            eclipseIntensity: { value: 0.0 },
            bloodMoonColor: { value: [0.85, 0.18, 0.08] },
            emissiveStrength: { value: 0.39 }, // Peak emissive glow at total eclipse
            eclipseShadowPos: { value: [-2, 0.0] },
            eclipseShadowRadius: { value: 1.2 },
            // Eclipse color grading - CALIBRATED from user screenshot (2025-01-15 v2)
            eclipseShadowColor: { value: [1.00, 0.58, 0.00] },      // Bright orange umbra core
            eclipseMidtoneColor: { value: [0.71, 0.43, 0.03] },     // Medium brownish-orange main body (PRIMARY COLOR)
            eclipseHighlightColor: { value: [1.00, 0.28, 0.10] },   // Bright red-orange atmospheric rim
            eclipseGlowColor: { value: [0.09, 0.09, 0.09] },        // Near-black limb rim (EDGE BRIGHTNESS)
            eclipseBrightnessModel: { value: 0.0 },                 // 0 = centeredness, 1 = edge-based
            shadowDarkness: { value: 0.53 },                        // Peak shadow darkness at total eclipse (0.0 = no darkening, 1.0 = maximum)

            // Blend Multiplexer Layer 1 - Vivid Light @ 0.322
            layer1Mode: { value: 9.0 },  // 9 = Vivid Light
            layer1Strength: { value: 0.322 },
            layer1Enabled: { value: 1.0 },

            // Blend Multiplexer Layer 2 - Multiply @ 2.785
            layer2Mode: { value: 0.0 },  // 0 = Multiply
            layer2Strength: { value: 2.785 },
            layer2Enabled: { value: 1.0 },

            // Blend Multiplexer Layer 3 - Overlay @ 0.199
            layer3Mode: { value: 7.0 },  // 7 = Overlay
            layer3Strength: { value: 0.199 },
            layer3Enabled: { value: 1.0 },

            // Blend Multiplexer Layer 4 - DISABLED
            layer4Mode: { value: 0.0 },
            layer4Strength: { value: 0.0 },
            layer4Enabled: { value: 0.0 }
        },
        vertexShader,
        fragmentShader,
        transparent: true,
        depthWrite: true,
        side: FrontSide
    });

    // Load textures with fade-in (same as standard material)
    const colorPath = `${assetBasePath}/textures/Moon/moon-color-${resolution}.jpg`;
    const normalPath = `${assetBasePath}/textures/Moon/moon-normal-${resolution}.jpg`;

    textureLoader.load(
        colorPath,
        texture => {
            material.uniforms.colorMap.value = texture;

            // Fade in moon when texture loads
            const startTime = performance.now();
            const fadeIn = () => {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / 300, 1.0); // 300ms fade
                material.uniforms.opacity.value = progress;
                material.needsUpdate = true;

                if (progress < 1.0) {
                    requestAnimationFrame(fadeIn);
                }
            };
            fadeIn();
        }
    );

    textureLoader.load(normalPath, texture => {
        material.uniforms.normalMap.value = texture;
    });

    return material;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Sun Shader with Blend Layers
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Sun shader extended with universal blend mode layer system and solar eclipse
 * @author Emotive Engine Team
 * @module 3d/shaders/sunWithBlendLayers
 *
 * Extends the standard sun shader with support for:
 * - Solar eclipse effects (moon's shadow covering sun)
 * - Multiple sequential blend mode layers for eclipse appearance adjustment
 * - Umbra/penumbra shadow calculations
 * - Emissive darkening where shadow covers sun
 *
 * Uses universal blend mode utilities from src/3d/shaders/utils/blendModes.js
 */


const sunWithBlendLayersVertexShader = `
/**
 * Sun Vertex Shader
 * Passes view-space position for camera-relative eclipse shadow calculations
 */

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;
varying vec3 vWorldPosition;
varying vec3 vViewPosition;  // View-space position (camera-relative)

void main() {
    vUv = uv;
    vNormal = normalize(normalMatrix * normal);
    vPosition = position;
    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;

    // Calculate view-space position (camera-relative, always faces camera)
    vec4 viewPos = modelViewMatrix * vec4(position, 1.0);
    vViewPosition = viewPos.xyz;

    gl_Position = projectionMatrix * viewPos;
}
`;

const sunWithBlendLayersFragmentShader = `
/**
 * Sun Fragment Shader with Blend Layers and Solar Eclipse
 *
 * Supports solar eclipse effects with moon's shadow darkening the sun
 * and up to 4 sequential blend mode layers for eclipse appearance adjustment
 */

uniform float time;
uniform sampler2D colorMap;
uniform sampler2D normalMap;
uniform vec3 baseColor;
uniform float emissiveIntensity;
uniform vec2 shadowOffset;
uniform float shadowCoverage;
uniform float shadowSoftness;
uniform float opacity;

// Solar Eclipse uniforms (moon's shadow covering sun)
uniform float eclipseProgress;        // Eclipse progress (0 = no eclipse, 1 = totality)
uniform vec2 eclipseShadowPos;        // Shadow center position in UV space
uniform float eclipseShadowRadius;    // Moon's shadow radius
uniform float shadowDarkness;         // How much to darken the sun (0-1)

// Blend Layer Uniforms (up to 4 layers)
uniform float layer1Mode;
uniform float layer1Strength;
uniform float layer1Enabled;

uniform float layer2Mode;
uniform float layer2Strength;
uniform float layer2Enabled;

uniform float layer3Mode;
uniform float layer3Strength;
uniform float layer3Enabled;

uniform float layer4Mode;
uniform float layer4Strength;
uniform float layer4Enabled;

varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;
varying vec3 vWorldPosition;
varying vec3 vViewPosition;  // View-space position (camera-relative)

// ═══════════════════════════════════════════════════════════════════════════
// UNIVERSAL BLEND MODES (injected from utils/blendModes.js)
// ═══════════════════════════════════════════════════════════════════════════
${blendModesGLSL}

// ═══════════════════════════════════════════════════════════════════════════
// SIMPLEX NOISE (for fire animation - from original sun shader)
// ═══════════════════════════════════════════════════════════════════════════
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float snoise(vec3 v) {
    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

    vec3 i  = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);

    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);

    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;

    i = mod289(i);
    vec4 p = permute(permute(permute(
        i.z + vec4(0.0, i1.z, i2.z, 1.0))
        + i.y + vec4(0.0, i1.y, i2.y, 1.0))
        + i.x + vec4(0.0, i1.x, i2.x, 1.0));

    float n_ = 0.142857142857;
    vec3 ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_);

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);

    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;

    vec3 p0 = vec3(a0.xy, h.x);
    vec3 p1 = vec3(a0.zw, h.y);
    vec3 p2 = vec3(a1.xy, h.z);
    vec3 p3 = vec3(a1.zw, h.w);

    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
}

void main() {
    // ═══════════════════════════════════════════════════════════════════════════
    // BASE SUN RENDERING (photosphere texture + fire animation)
    // ═══════════════════════════════════════════════════════════════════════════

    // Sample base photosphere texture
    vec4 texColor = texture2D(colorMap, vUv);

    // Optimized single-octave noise for subtle fire
    vec3 noiseCoord = vPosition * 30.0 + vec3(0.0, time * 0.025, 0.0);
    float fireNoise = snoise(noiseCoord);

    // Simple threshold - fire appears only in specific noise ranges
    float fireMask = fireNoise * 0.5 + 0.5; // Remap -1..1 to 0..1
    fireMask = step(0.45, fireMask) * (1.0 - step(0.55, fireMask)); // Only 0.45-0.55 range

    // Almost imperceptible warmth shift
    vec3 fireColor = vec3(1.01, 1.0, 0.99);

    // Microscopic blending
    vec3 finalColor = mix(texColor.rgb, fireColor, fireMask * 0.008);

    // Apply base color tinting
    finalColor *= baseColor;

    // Apply emissive intensity for HDR bloom
    finalColor *= emissiveIntensity;

    // ═══════════════════════════════════════════════════════════════════════════
    // LIMB DARKENING (realistic solar effect - edges appear darker than center)
    // ═══════════════════════════════════════════════════════════════════════════

    // Calculate distance from center (0 at center, 1 at edge)
    float distFromCenterLimb = length(vWorldPosition.xy) / 0.5; // normalize by sun radius (0.5)
    distFromCenterLimb = clamp(distFromCenterLimb, 0.0, 1.0);

    // Limb darkening formula: I(μ) = 1 - u*(1-μ) where μ = cos(viewing angle)
    // Simplified using distance: darker at edges, brighter at center
    float mu = sqrt(1.0 - distFromCenterLimb * distFromCenterLimb); // cos approximation
    // EXTREME limb darkening for visibility
    float limbDarkeningCoeff = 0.98; // 98% darkening at edges
    float limbBrightness = 1.0 - limbDarkeningCoeff * (1.0 - mu);
    limbBrightness = pow(limbBrightness, 0.4); // Very aggressive power curve

    // Clamp to prevent over-darkening
    limbBrightness = max(limbBrightness, 0.02); // Edges at least 2% brightness

    // Apply limb darkening (BEFORE bloom processing)
    finalColor *= limbBrightness;

    // ═══════════════════════════════════════════════════════════════════════════
    // SOLAR ECLIPSE EFFECT (Moon Occulting Sun)
    // ═══════════════════════════════════════════════════════════════════════════
    // Solar eclipse: Moon passes BETWEEN viewer and sun, blocking our view
    // The moon appears as a dark circular disk that covers parts of the sun
    // From Earth, moon and sun appear same angular size (0.5°)

    // Only apply eclipse if there's a moon to occlude (radius > 0)
    if (eclipseShadowRadius > 0.01) {
        // Only occlude FRONT-FACING parts of the sun (vViewPosition.z < 0 faces camera in view space)
        // Back of sun should not be affected by moon
        if (vViewPosition.z < 0.1) {
            // Project to screen space - camera-relative, independent of sun rotation
            // vViewPosition.xy is already in camera space, just normalize to sun radius
            // Sun radius in view space is approximately 0.5 at typical camera distance
            vec2 screenPos = vViewPosition.xy;

            // Moon center position in screen space (same coordinate system)
            vec2 moonCenter = eclipseShadowPos;

            // Distance from this sun point to moon center (2D screen space)
            float distToMoon = length(screenPos - moonCenter);

            // Moon's angular size (appears same size as sun from Earth)
            // In normalized screen space, sun radius = 1.0, moon radius = 1.0 for total eclipse
            float moonRadius = eclipseShadowRadius;
            float moonEdge = 0.01; // Sharp edge for moon silhouette

            // Check if moon blocks this point (moon is in front of sun)
            float moonOcclusion = 1.0 - smoothstep(moonRadius - moonEdge, moonRadius + moonEdge, distToMoon);

            // Only apply if moon is actually occluding something
            if (moonOcclusion > 0.001) {
                // Moon completely blocks sun where it overlaps (no light gets through)
                finalColor *= (1.0 - moonOcclusion);

                // Subtle penumbra around moon edge (diffraction)
                float penumbraRadius = moonRadius * 1.02;
                float penumbraEdge = 0.03;
                float penumbra = 1.0 - smoothstep(penumbraRadius - penumbraEdge, penumbraRadius + penumbraEdge, distToMoon);
                float penumbraBlocking = (penumbra - moonOcclusion) * 0.2;
                finalColor *= (1.0 - penumbraBlocking);
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // BLEND LAYERS (Applied globally to entire sun)
    // These allow adjusting the appearance of the sun
    // ═══════════════════════════════════════════════════════════════════════════

    // Layer 1
    if (layer1Enabled > 0.5) {
        vec3 blendColor1 = vec3(min(layer1Strength, 1.0));
        int mode1 = int(layer1Mode + 0.5);
        vec3 blended1 = clamp(applyBlendMode(finalColor, blendColor1, mode1), 0.0, 1.0);
        finalColor = clamp(blended1, 0.0, 1.0);
    }

    // Layer 2
    if (layer2Enabled > 0.5) {
        vec3 blendColor2 = vec3(min(layer2Strength, 1.0));
        int mode2 = int(layer2Mode + 0.5);
        vec3 blended2 = clamp(applyBlendMode(finalColor, blendColor2, mode2), 0.0, 1.0);
        finalColor = clamp(blended2, 0.0, 1.0);
    }

    // Layer 3
    if (layer3Enabled > 0.5) {
        vec3 blendColor3 = vec3(min(layer3Strength, 1.0));
        int mode3 = int(layer3Mode + 0.5);
        vec3 blended3 = clamp(applyBlendMode(finalColor, blendColor3, mode3), 0.0, 1.0);
        finalColor = clamp(blended3, 0.0, 1.0);
    }

    // Layer 4
    if (layer4Enabled > 0.5) {
        vec3 blendColor4 = vec3(min(layer4Strength, 1.0));
        int mode4 = int(layer4Mode + 0.5);
        vec3 blended4 = clamp(applyBlendMode(finalColor, blendColor4, mode4), 0.0, 1.0);
        finalColor = clamp(blended4, 0.0, 1.0);
    }

    // Apply fade-in opacity to prevent texture flash during load
    gl_FragColor = vec4(finalColor, opacity);
}
`;

/**
 * Get sun shader with blend layers
 * @returns {Object} Object with vertexShader and fragmentShader strings
 */
function getSunWithBlendLayersShaders() {
    return {
        vertexShader: sunWithBlendLayersVertexShader,
        fragmentShader: sunWithBlendLayersFragmentShader
    };
}

/**
 * Sun Geometry with NASA-Accurate Photosphere Characteristics
 *
 * Based on NASA Solar Dynamics Observatory (SDO) data and solar physics:
 *
 * PHOTOSPHERE CHARACTERISTICS (NASA):
 * - Temperature: 5,772 K (5,500°C / 10,000°F) - Official NASA effective temperature
 * - Color: Brilliant white (black-body spectrum at 5,772K)
 * - Thickness: 100-400 km
 * - Composition: 74.9% Hydrogen, 23.8% Helium
 * - Surface features: Granules (convection cells ~1,000 km diameter)
 *
 * VISUAL PROPERTIES:
 * - Self-luminous (MeshBasicMaterial - unlit, always at full brightness)
 * - No shadows cast or received (sun is light source)
 * - Radial bloom effect from HDR color values + UnrealBloomPass
 * - Emotion-responsive color tinting over base brilliant white
 * - toneMapped: false to preserve HDR brightness values for bloom
 *
 * THREE.JS IMPLEMENTATION:
 * - Material: MeshStandardMaterial with emissive properties
 * - Emissive: Self-luminous glow (doesn't need external lights)
 * - Normal Map: Shows photosphere granulation detail (convection cells)
 * - toneMapped: false allows HDR values > 1.0 for dramatic bloom
 * - UnrealBloomPass creates the radiant glow effect
 *
 * References:
 * - NASA Sun Fact Sheet: https://nssdc.gsfc.nasa.gov/planetary/factsheet/sunfact.html
 * - NASA Solar Dynamics Observatory: https://sdo.gsfc.nasa.gov/
 * - NASA Sun Facts: https://science.nasa.gov/sun/facts/
 *
 * @module geometries/Sun
 */


/**
 * Sun rotation configuration
 * Defines base rotation speed that gets multiplied by emotional state modifiers
 */
const SUN_ROTATION_CONFIG = {
    baseSpeed: 0.01,    // Base rotation speed (rad/sec) - very slow like real sun
    axes: [0, 1.0, 0]   // Y-axis only rotation (normalized, scaled by baseSpeed)
};

/**
 * Create sun material with NASA photosphere texture and surface fire animation
 *
 * Loads NASA-based photosphere texture and creates self-luminous material with
 * animated fire flowing across the surface using custom shaders.
 *
 * @param {THREE.TextureLoader} textureLoader - Three.js texture loader instance
 * @param {Object} options - Configuration options
 * @param {string} options.resolution - Texture resolution ('2k' or '4k', default: '4k')
 * @param {Array<number>} options.glowColor - RGB color array [r, g, b] for emotion tinting
 * @param {number} options.glowIntensity - Glow intensity multiplier (scales HDR brightness)
 * @param {string} options.materialVariant - Material variant ('multiplexer' for blend layers, default: standard)
 * @returns {THREE.ShaderMaterial}
 */
function createSunMaterial(textureLoader, options = {}) {
    const resolution = options.resolution || '4k';
    const glowColor = options.glowColor || [1, 1, 1];
    const glowIntensity = options.glowIntensity || 1.0;
    const materialVariant = options.materialVariant || null;
    const assetBasePath = options.assetBasePath || '/assets';

    // Determine texture paths based on resolution
    const colorPath = `${assetBasePath}/textures/Sun/sun-photosphere-${resolution}.jpg`;
    const normalPath = `${assetBasePath}/textures/Sun/sun-photosphere-normal-${resolution}.jpg`;

    // NASA-accurate base color: Brilliant white (5,772K black-body radiation)
    // Use HDR values for dramatic bloom
    const brightness = 1.0 + (glowIntensity * 2.0);
    const baseColor = new Color(
        brightness * glowColor[0],
        brightness * glowColor[1],
        brightness * glowColor[2] * 0.95  // Slight warm tint
    );

    // Initialize pending texture tracking for cleanup
    const pendingTextures = new Map();

    // Load color texture asynchronously with tracking
    pendingTextures.set(colorPath, { texture: null });

    const colorMap = textureLoader.load(
        colorPath,
        texture => {
            // Texture loaded - set full opacity immediately
            // (morph transitions handle fade-in/out separately)
            if (material.uniforms?.opacity) {
                material.uniforms.opacity.value = 1.0;
            }

            const pending = pendingTextures.get(colorPath);
            if (pending) {
                pending.texture = texture;
            }
            pendingTextures.delete(colorPath);
        },
        undefined,
        error => {
            console.warn(`⚠️ Failed to load sun texture (${resolution}), using color fallback:`, error);
            pendingTextures.delete(colorPath);
        }
    );

    // Load normal map for granulation detail (optional)
    pendingTextures.set(normalPath, { texture: null });

    const normalMap = textureLoader.load(
        normalPath,
        texture => {
            const pending = pendingTextures.get(normalPath);
            if (pending) {
                pending.texture = texture;
            }
            pendingTextures.delete(normalPath);
        },
        undefined,
        error => {
            console.warn(`⚠️ Sun normal map not found (${resolution}), continuing without surface detail:`, error);
            pendingTextures.delete(normalPath);
        }
    );

    // Configure texture wrapping for seamless sphere mapping
    colorMap.wrapS = colorMap.wrapT = RepeatWrapping;
    normalMap.wrapS = normalMap.wrapT = RepeatWrapping;

    // Enable anisotropic filtering for better quality at oblique angles
    colorMap.anisotropy = 16;
    normalMap.anisotropy = 16;

    // Determine which shaders to use based on materialVariant
    let vertexShader, fragmentShader;
    let additionalUniforms = {};

    if (materialVariant === 'multiplexer') {
        // Use blend layers shader for solar eclipse effects
        const { vertexShader: vs, fragmentShader: fs } = getSunWithBlendLayersShaders();
        vertexShader = vs;
        fragmentShader = fs;

        // Add solar eclipse uniforms
        additionalUniforms = {
            // Solar Eclipse (moon's shadow covering sun - complete occlusion)
            eclipseProgress: { value: 0.0 },
            eclipseShadowPos: { value: [-2, 0.0] },  // Start off-screen
            eclipseShadowRadius: { value: 0.882 },  // User-calibrated: Total eclipse size
            shadowDarkness: { value: 1.00 },  // Always 1.0 - moon blocks 100% of sun's light

            // Blend Multiplexer Layer 1 - Multiply @ 0.230
            layer1Mode: { value: 0.0 },  // 0 = Multiply
            layer1Strength: { value: 0.230 },
            layer1Enabled: { value: 1.0 },

            // Blend Multiplexer Layer 2 - DISABLED
            layer2Mode: { value: 0.0 },
            layer2Strength: { value: 0.0 },
            layer2Enabled: { value: 0.0 },

            // Blend Multiplexer Layer 3 - DISABLED
            layer3Mode: { value: 0.0 },
            layer3Strength: { value: 0.0 },
            layer3Enabled: { value: 0.0 },

            // Blend Multiplexer Layer 4 - DISABLED
            layer4Mode: { value: 0.0 },
            layer4Strength: { value: 0.0 },
            layer4Enabled: { value: 0.0 }
        };
    } else {
        // Use standard sun shader (no eclipse support)
        vertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vWorldPosition;

            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                vPosition = position;
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        fragmentShader = `
            uniform float time;
            uniform sampler2D colorMap;
            uniform sampler2D normalMap;
            uniform vec3 baseColor;
            uniform float emissiveIntensity;
            uniform vec2 shadowOffset;
            uniform float shadowCoverage;
            uniform float shadowSoftness;
            uniform float opacity;  // Fade in opacity (0-1) to prevent texture flash

            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vWorldPosition;

            // Simplex noise for fire animation (Ashima Arts)
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

                vec3 i  = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);

                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);

                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;

                i = mod289(i);
                vec4 p = permute(permute(permute(
                    i.z + vec4(0.0, i1.z, i2.z, 1.0))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0));

                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;

                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);

                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);

                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);

                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));

                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;

                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);

                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;

                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }

            void main() {
                // Sample base photosphere texture
                vec4 texColor = texture2D(colorMap, vUv);

                // Optimized single-octave noise for subtle fire (was 2 FBM calls with 3 octaves each)
                // Using position-based noise with time offset for animation
                vec3 noiseCoord = vPosition * 30.0 + vec3(0.0, time * 0.025, 0.0);
                float fireNoise = snoise(noiseCoord);

                // Simple threshold - fire appears only in specific noise ranges
                // Using step functions instead of smoothstep for performance
                float fireMask = fireNoise * 0.5 + 0.5; // Remap -1..1 to 0..1
                fireMask = step(0.45, fireMask) * (1.0 - step(0.55, fireMask)); // Only 0.45-0.55 range

                // Almost imperceptible warmth shift (same visual as before)
                vec3 fireColor = vec3(1.01, 1.0, 0.99);

                // Microscopic blending - nearly invisible (same blend factor)
                vec3 finalColor = mix(texColor.rgb, fireColor, fireMask * 0.008);

                // Apply base color tinting
                finalColor *= baseColor;

                // Apply emissive intensity for HDR bloom
                finalColor *= emissiveIntensity;

                // ═══════════════════════════════════════════════════════════════════════════
                // LIMB DARKENING (realistic solar effect - edges appear darker than center)
                // ═══════════════════════════════════════════════════════════════════════════

                // Calculate distance from center (0 at center, 1 at edge)
                float distFromCenterLimb = length(vWorldPosition.xy) / 0.5; // normalize by sun radius (0.5)
                distFromCenterLimb = clamp(distFromCenterLimb, 0.0, 1.0);

                // Limb darkening formula: I(μ) = 1 - u*(1-μ) where μ = cos(viewing angle)
                // Simplified using distance: darker at edges, brighter at center
                float mu = sqrt(1.0 - distFromCenterLimb * distFromCenterLimb); // cos approximation
                float limbDarkeningCoeff = 0.6; // NASA solar data: ~60% darkening at limb
                float limbBrightness = 1.0 - limbDarkeningCoeff * (1.0 - mu);

                // Apply limb darkening (preserves bright core for bloom)
                finalColor *= limbBrightness;

                // ═══════════════════════════════════════════════════════════════════════════
                // SHADOW DARKENING (applied AFTER bloom intensity so it doesn't affect bloom)
                // ═══════════════════════════════════════════════════════════════════════════

                // Sun sphere center (world space origin)
                float sunRadius = 0.5; // Matches geometry radius

                // Shadow sphere center (offset from sun center)
                vec3 shadowCenter = vec3(shadowOffset.x, shadowOffset.y, 0.0);

                // Calculate distance from fragment to shadow sphere center
                float distToShadow = distance(vWorldPosition, shadowCenter);

                // Shadow threshold (shadow sphere radius adjusted by coverage)
                float shadowRadius = sunRadius * shadowCoverage;

                // Calculate shadow factor (0 = full shadow, 1 = no shadow)
                float shadowFactor = smoothstep(shadowRadius - shadowSoftness, shadowRadius + shadowSoftness, distToShadow);

                // Darken ONLY the final color output (not the bloom calculation)
                float shadowDarkness = 0.05; // How dark the shadow gets (5% brightness)
                finalColor *= mix(shadowDarkness, 1.0, shadowFactor);

                // ═══════════════════════════════════════════════════════════════════════════
                // RADIAL CORONA WAVES (applied AFTER shadow, visible around eclipse edge)
                // ═══════════════════════════════════════════════════════════════════════════

                // Calculate angle from sun center in world space XY plane
                float angle = atan(vWorldPosition.y, vWorldPosition.x);

                // Create radial wave pattern (16 petals for finer detail, rotating slowly)
                float wave = sin(angle * 16.0 + time * 0.3) * 0.5 + 0.5;

                // Apply waves to visible (non-shadowed) edges
                float distFromCenter = length(vWorldPosition.xy);

                // Edge factor: strong at sun's edge where bloom will amplify it
                float edgeFactor = smoothstep(0.35, 0.5, distFromCenter);

                // Only apply waves to non-shadowed areas (visible during eclipse)
                // Combine with shadow factor so waves appear around shadow edge
                float waveStrength = edgeFactor * shadowFactor;

                // Very strong modulation (2x variation) for dramatic eclipse corona
                float coronaModulation = 1.0 + (wave * 2.0 - 1.0) * waveStrength;
                finalColor *= coronaModulation;

                // Apply fade-in opacity to prevent texture flash during load
                gl_FragColor = vec4(finalColor, opacity);
            }
        `;
    }

    // Custom ShaderMaterial with surface-mapped fire animation
    const material = new ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            colorMap: { value: colorMap },
            normalMap: { value: normalMap },
            baseColor: { value: baseColor },
            emissiveIntensity: { value: 1.2 },  // Moderate intensity to avoid blown-out bloom
            glowColor: { value: new Color(1, 1, 1) },  // For ThreeRenderer compatibility
            glowIntensity: { value: 1.0 },  // For ThreeRenderer compatibility
            // Shadow uniforms (same as moon crescent shader)
            shadowOffset: { value: new Vector2(200.0, 0.0) },  // Start far away (no shadow)
            shadowCoverage: { value: 0.5 },  // Shadow coverage (0.5 = half the sun radius)
            shadowSoftness: { value: 0.1 },   // Edge softness for anti-aliasing
            opacity: { value: 0.0 },  // Start invisible, fade in when texture loads
            ...additionalUniforms  // Add eclipse/blend layer uniforms if using multiplexer variant
        },
        vertexShader,
        fragmentShader,
        transparent: true,  // Enable opacity/alpha blending for fade-in
        toneMapped: false
    });

    // Store uniforms reference for updates
    material.userData.uniforms = material.uniforms;

    // Store pending textures for disposal
    material.userData.pendingTextures = pendingTextures;

    return material;
}

/**
 * Create sun geometry with NASA-accurate characteristics
 *
 * The sun is rendered as a self-luminous sphere using MeshBasicMaterial.
 * The base color is brilliant white (5,772K black-body spectrum), with emotion-based
 * tinting applied over time. Uses HDR color values (>1.0) for dramatic bloom effect.
 *
 * @param {THREE.TextureLoader} textureLoader - Three.js texture loader instance (optional)
 * @param {Object} options - Configuration options
 * @param {Array<number>} options.glowColor - RGB color array [r, g, b] for emotion tinting
 * @param {number} options.glowIntensity - Glow intensity multiplier (scales HDR brightness)
 * @param {string} options.resolution - Texture resolution ('2k' or '4k', default: '4k')
 * @param {string} options.materialVariant - Material variant ('multiplexer' for blend layers, default: standard)
 * @returns {THREE.Mesh} Sun mesh with self-luminous material
 */
function createSunGeometry(textureLoader = null, options = {}) {
    const glowColor = options.glowColor || [1, 1, 1];
    const glowIntensity = options.glowIntensity || 1.0;
    const resolution = options.resolution || '4k';
    const materialVariant = options.materialVariant || null;

    // Create high-res sphere geometry for smooth bloom (no edge artifacts)
    // 128x128 = 16,384 quads = 32,768 triangles (smooth at any zoom)
    const geometry = new SphereGeometry(
        0.5,  // radius 0.5 = 1.0 diameter (matches sphere geometry)
        128,  // width segments (smooth edges, no bloom artifacts)
        128   // height segments
    );

    // Track for disposal
    geometry.userData.tracked = true;

    let material;

    // Use textured material if loader provided, otherwise fallback to color-only
    if (textureLoader) {
        material = createSunMaterial(textureLoader, { glowColor, glowIntensity, resolution, materialVariant });
    } else {
        // Fallback: color-only material (no texture)
        const brightness = 1.0 + (glowIntensity * 2.0);
        const baseColor = new Color(
            brightness * glowColor[0],
            brightness * glowColor[1],
            brightness * glowColor[2] * 0.95  // Slight warm tint
        );

        material = new MeshBasicMaterial({
            color: baseColor,
            toneMapped: false // Bypass tone mapping to preserve HDR brightness for bloom
        });
    }

    const mesh = new Mesh(geometry, material);
    mesh.castShadow = false;  // Sun doesn't cast shadows (it IS the light source)
    mesh.receiveShadow = false; // Sun doesn't receive shadows

    return mesh;
}

/**
 * Update sun material based on emotion state and time
 *
 * Applies emotion-based color tinting and HDR brightness over the NASA-accurate white base.
 * Updates animation time for surface fire effect.
 * Uses HDR color values (>1.0) for dramatic bloom effect.
 *
 * @param {THREE.Mesh} sunMesh - The sun mesh to update
 * @param {Array<number>} glowColor - RGB color array [r, g, b] for emotion tinting
 * @param {number} glowIntensity - Glow intensity multiplier (scales HDR brightness)
 * @param {number} deltaTime - Time delta for animation (optional)
 */
function updateSunMaterial(sunMesh, glowColor, glowIntensity = 1.0, deltaTime = 0) {
    if (!sunMesh || !sunMesh.material) return;

    const {material} = sunMesh;

    // Check if using custom shader material with uniforms
    if (material.uniforms && material.uniforms.baseColor) {
        // Direct access to ShaderMaterial uniforms
        const {uniforms} = material;

        // Update animation time with modulo to prevent unbounded growth
        // Reset every ~6.28 seconds (2π) to keep noise patterns seamless
        if (deltaTime > 0) {
            uniforms.time.value = (uniforms.time.value + deltaTime) % (Math.PI * 2.0);
        }

        // Sun is ALWAYS NASA-accurate brilliant white (5,772K photosphere)
        // Ignores emotion colors - calibrated for "joy" emotion
        const brightness = 1.0 + (glowIntensity * 2.0);

        // DO NOT apply emotion tinting - sun stays white regardless of emotion
        // This preserves the NASA-accurate 5,772K color temperature
        // Reuse temp color to avoid per-frame allocations
        uniforms.baseColor.value.setRGB(brightness, brightness, brightness * 0.95);
        uniforms.emissiveIntensity.value = 1.2;  // Moderate intensity to avoid blown-out bloom
    } else if (material.color) {
        // Fallback for basic material (no shader uniforms)
        // Sun is ALWAYS NASA white - ignores emotion colors
        const brightness = 1.0 + (glowIntensity * 2.0);

        // DO NOT apply emotion tinting - sun stays white regardless of emotion
        // Set color directly to avoid per-frame allocations
        material.color.setRGB(brightness, brightness, brightness * 0.95);
    }
}

/**
 * Dispose of sun geometry and material resources
 * Call this when removing a sun from the scene
 *
 * @param {THREE.Mesh} sunMesh - Sun mesh to dispose
 */
function disposeSun(sunMesh) {
    if (!sunMesh) return;

    // Dispose geometry
    if (sunMesh.geometry) {
        sunMesh.geometry.dispose();
    }

    // Dispose material and its textures
    if (sunMesh.material) {
        const {material} = sunMesh;

        // Clean up pending texture loads
        if (material.userData && material.userData.pendingTextures) {
            material.userData.pendingTextures.forEach(({texture}) => {
                if (texture) {
                    texture.dispose();
                }
            });
            material.userData.pendingTextures.clear();
        }

        // Dispose textures (for shader material)
        if (material.uniforms) {
            if (material.uniforms.colorMap && material.uniforms.colorMap.value) {
                material.uniforms.colorMap.value.dispose();
            }
            if (material.uniforms.normalMap && material.uniforms.normalMap.value) {
                material.uniforms.normalMap.value.dispose();
            }
        }

        // Dispose textures (for standard material)
        if (material.map) material.map.dispose();
        if (material.normalMap) material.normalMap.dispose();

        // Dispose material
        material.dispose();
    }
}

/**
 * Heart Geometry Loader
 *
 * Loads the heart.obj model, similar to how crystal.obj is loaded.
 */


/**
 * Generate simple planar UV coordinates for a geometry
 * Uses XY position mapped to 0-1 range (no seams/streaks)
 * @param {THREE.BufferGeometry} geometry
 */
function generatePlanarUVs$1(geometry) {
    geometry.computeBoundingBox();
    const bbox = geometry.boundingBox;
    const positions = geometry.attributes.position;
    const uvs = new Float32Array(positions.count * 2);

    const sizeX = bbox.max.x - bbox.min.x;
    const sizeY = bbox.max.y - bbox.min.y;

    for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);

        // Simple planar projection from front
        uvs[i * 2] = (x - bbox.min.x) / sizeX;
        uvs[i * 2 + 1] = (y - bbox.min.y) / sizeY;
    }

    geometry.setAttribute('uv', new BufferAttribute(uvs, 2));
}

/**
 * Load heart OBJ model asynchronously
 * @param {string} assetBasePath - Base path for assets (default: '/assets')
 * @returns {Promise<THREE.BufferGeometry>} Heart geometry
 */
function loadHeartGeometry(assetBasePath = '/assets') {
    return new Promise(resolve => {
        const loader = new OBJLoader();
        loader.load(
            `${assetBasePath}/models/Crystal/heart.obj`,
            obj => {
                let geometry = null;
                obj.traverse(child => {
                    if (child.isMesh && child.geometry) {
                        ({ geometry } = child);
                    }
                });

                if (geometry) {
                    // Center the geometry
                    geometry.computeBoundingBox();
                    const center = new Vector3();
                    geometry.boundingBox.getCenter(center);
                    geometry.translate(-center.x, -center.y, -center.z);

                    // Scale heart smaller than crystal (~1.2 diameter vs 1.6)
                    const size = new Vector3();
                    geometry.boundingBox.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 1.2 / maxDim;
                    geometry.scale(scale, scale, scale);

                    // Compute normals
                    geometry.computeVertexNormals();
                    geometry.computeBoundingBox();

                    // Only generate UVs if OBJ doesn't have them
                    if (!geometry.attributes.uv) {
                        generatePlanarUVs$1(geometry);
                    }

                    resolve(geometry);
                } else {
                    console.warn('💗 [HEART] No mesh in OBJ, using fallback');
                    resolve(createFallbackHeart());
                }
            },
            undefined,
            error => {
                console.warn('💗 [HEART] OBJ load failed:', error);
                resolve(createFallbackHeart());
            }
        );
    });
}

/**
 * Fallback procedural heart if OBJ fails to load
 */
function createFallbackHeart() {
    const geometry = new SphereGeometry(0.5, 32, 32);
    // Deform sphere into rough heart shape
    const positions = geometry.attributes.position;
    for (let i = 0; i < positions.count; i++) {
        let x = positions.getX(i);
        const y = positions.getY(i);
        let z = positions.getZ(i);

        // Heart deformation
        const heartScale = 1 + 0.3 * Math.max(0, y);
        x *= heartScale;
        z *= heartScale * 0.8;

        // Bottom point
        if (y < -0.3) {
            const factor = (-y - 0.3) / 0.2;
            x *= 1 - factor * 0.8;
            z *= 1 - factor * 0.8;
        }

        positions.setXYZ(i, x, y, z);
    }
    geometry.computeVertexNormals();
    return geometry;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Star Geometry Loader
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Star crystal geometry loader for 3D rendering
 * @author Emotive Engine Team
 * @module 3d/geometries/Star
 *
 * Loads the star.obj model and prepares it for use with the crystal material system.
 * The star geometry uses the citrine SSS preset by default for a warm golden appearance.
 *
 * Assets required:
 * - /assets/models/Crystal/star.obj - Star 3D model
 * - /assets/textures/Crystal/star.png - Star texture for internal patterns
 */


/**
 * Generate simple planar UV coordinates for a geometry
 * Uses XY position mapped to 0-1 range (no seams/streaks)
 * @param {THREE.BufferGeometry} geometry
 */
function generatePlanarUVs(geometry) {
    geometry.computeBoundingBox();
    const bbox = geometry.boundingBox;
    const positions = geometry.attributes.position;
    const uvs = new Float32Array(positions.count * 2);

    const sizeX = bbox.max.x - bbox.min.x;
    const sizeY = bbox.max.y - bbox.min.y;

    for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);

        // Simple planar projection from front
        uvs[i * 2] = (x - bbox.min.x) / sizeX;
        uvs[i * 2 + 1] = (y - bbox.min.y) / sizeY;
    }

    geometry.setAttribute('uv', new BufferAttribute(uvs, 2));
}

/**
 * Load star OBJ model asynchronously
 * @param {string} assetBasePath - Base path for assets (default: '/assets')
 * @returns {Promise<THREE.BufferGeometry>} Star geometry
 */
function loadStarGeometry(assetBasePath = '/assets') {
    return new Promise(resolve => {
        const loader = new OBJLoader();
        loader.load(
            `${assetBasePath}/models/Crystal/star.obj`,
            obj => {
                let geometry = null;
                obj.traverse(child => {
                    if (child.isMesh && child.geometry) {
                        ({ geometry } = child);
                    }
                });

                if (geometry) {
                    // Center the geometry
                    geometry.computeBoundingBox();
                    const center = new Vector3();
                    geometry.boundingBox.getCenter(center);
                    geometry.translate(-center.x, -center.y, -center.z);

                    // Scale star to match other crystals (~1.4 diameter)
                    const size = new Vector3();
                    geometry.boundingBox.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 1.4 / maxDim;
                    geometry.scale(scale, scale, scale);

                    // Compute normals
                    geometry.computeVertexNormals();
                    geometry.computeBoundingBox();

                    // Only generate UVs if OBJ doesn't have them
                    if (!geometry.attributes.uv) {
                        generatePlanarUVs(geometry);
                    }

                    resolve(geometry);
                } else {
                    console.warn('⭐ [STAR] No mesh in OBJ, using fallback');
                    resolve(createFallbackStar());
                }
            },
            undefined,
            error => {
                console.warn('⭐ [STAR] OBJ load failed:', error);
                resolve(createFallbackStar());
            }
        );
    });
}

/**
 * Fallback procedural star if OBJ fails to load
 * Creates a 5-pointed star shape
 */
function createFallbackStar() {
    // Use dodecahedron as fallback for star
    const geometry = new DodecahedronGeometry(0.5, 0);
    geometry.computeVertexNormals();
    return geometry;
}

/**
 * Three.js Procedural Geometries
 *
 * Replaces custom WebGL geometries with Three.js BufferGeometry
 * Maintains same shape designs but uses Three.js infrastructure
 */


/**
 * Load crystal OBJ model asynchronously
 * @param {string} assetBasePath - Base path for assets (default: '/assets')
 * @returns {Promise<THREE.BufferGeometry>} Crystal geometry
 */
function loadCrystalGeometry(assetBasePath = '/assets') {
    return new Promise((resolve, reject) => {
        const loader = new OBJLoader();
        loader.load(
            `${assetBasePath}/models/Crystal/crystal.obj`,
            obj => {
                let geometry = null;
                obj.traverse(child => {
                    if (child.isMesh && child.geometry) {
                        ({ geometry } = child);
                    }
                });

                if (geometry) {
                    geometry.computeBoundingBox();
                    const center = new Vector3();
                    geometry.boundingBox.getCenter(center);
                    geometry.translate(-center.x, -center.y, -center.z);

                    const size = new Vector3();
                    geometry.boundingBox.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 1.6 / maxDim;  // Scale to ~1.6 diameter to match sun/moon size
                    geometry.scale(scale, scale, scale);
                    // Preserve original OBJ normals if present, otherwise compute them
                    if (!geometry.attributes.normal) {
                        geometry.computeVertexNormals();
                    }
                    // else: keep original normals from OBJ file

                    // Recompute bounding box after transforms
                    geometry.computeBoundingBox();
                    const finalSize = new Vector3();
                    geometry.boundingBox.getSize(finalSize);


                    // Simplify geometry to reduce triangle count
                    let finalGeometry = geometry;

                    // Compute normals - smooth or faceted
                    {
                        // Faceted look - each triangle has its own normals
                        finalGeometry.computeVertexNormals();
                    }

                    resolve(finalGeometry);
                } else {
                    console.warn('💎 [CRYSTAL] No mesh in OBJ, using fallback');
                    const fallback = createProceduralCrystal();
                    resolve(fallback);
                }
            },
            progress => {
            },
            error => {
                console.warn('💎 [CRYSTAL] OBJ load FAILED:', error);
                const fallback = createProceduralCrystal();
                resolve(fallback);
            }
        );
    });
}

/**
 * Create procedural crystal geometry (fallback)
 * Scaled to match OBJ-loaded crystal (~1.6 diameter)
 * @returns {THREE.BufferGeometry}
 */
function createProceduralCrystal() {
    const segments = 6;
    // Base dimensions (will be scaled down to match OBJ size)
    const height = 3.0;
    const radius = 1.0;
    const pointHeight = 0.8;

    const geometry = new BufferGeometry();
    const vertices = [];
    const indices = [];

    vertices.push(0, height / 2 + pointHeight, 0);

    for (let i = 0; i < segments; i++) {
        const angle = (i / segments) * Math.PI * 2;
        vertices.push(Math.cos(angle) * radius, height / 2, Math.sin(angle) * radius);
    }

    for (let i = 0; i < segments; i++) {
        const angle = (i / segments) * Math.PI * 2;
        vertices.push(Math.cos(angle) * radius, -height / 2, Math.sin(angle) * radius);
    }

    vertices.push(0, -height / 2 - pointHeight, 0);

    for (let i = 0; i < segments; i++) {
        const next = (i + 1) % segments;
        indices.push(0, 1 + i, 1 + next);
    }

    for (let i = 0; i < segments; i++) {
        const next = (i + 1) % segments;
        indices.push(1 + i, 1 + segments + i, 1 + next);
        indices.push(1 + next, 1 + segments + i, 1 + segments + next);
    }

    const bottomIdx = 1 + segments * 2;
    for (let i = 0; i < segments; i++) {
        const next = (i + 1) % segments;
        indices.push(bottomIdx, 1 + segments + next, 1 + segments + i);
    }

    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setIndex(indices);

    // Scale to match OBJ-loaded crystal (~1.6 diameter)
    // Current max dimension is height + 2*pointHeight = 3.0 + 1.6 = 4.6
    const scale = 1.6 / 4.6;
    geometry.scale(scale, scale, scale);

    geometry.computeVertexNormals();
    return geometry;
}

/**
 * Load rough OBJ model asynchronously
 * @param {string} assetBasePath - Base path for assets (default: '/assets')
 * @returns {Promise<THREE.BufferGeometry>} Rough geometry
 */
function loadRoughGeometry(assetBasePath = '/assets') {
    return new Promise(resolve => {
        const loader = new OBJLoader();
        loader.load(
            `${assetBasePath}/models/Crystal/rough.obj`,
            obj => {
                let geometry = null;
                obj.traverse(child => {
                    if (child.isMesh && child.geometry) {
                        ({ geometry } = child);
                    }
                });

                if (geometry) {
                    // Center the geometry
                    geometry.computeBoundingBox();
                    const center = new Vector3();
                    geometry.boundingBox.getCenter(center);
                    geometry.translate(-center.x, -center.y, -center.z);

                    // Scale to ~1.6 diameter to match other geometries
                    const size = new Vector3();
                    geometry.boundingBox.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 1.6 / maxDim;
                    geometry.scale(scale, scale, scale);

                    // Compute normals
                    geometry.computeVertexNormals();
                    geometry.computeBoundingBox();

                    resolve(geometry);
                } else {
                    console.warn('💎 [ROUGH] No mesh in OBJ, using fallback sphere');
                    resolve(new SphereGeometry(0.5, 32, 32));
                }
            },
            undefined,
            error => {
                console.warn('💎 [ROUGH] OBJ load failed:', error);
                resolve(new SphereGeometry(0.5, 32, 32));
            }
        );
    });
}

/**
 * Core geometry registry using Three.js
 *
 * Safe geometries only - all use compatible material systems:
 * - Crystal-type: crystal, rough, heart, star (CrystalSoul + SSS shader)
 * - Moon: Custom lunar shader with phases and eclipse
 * - Sun: Emissive shader with corona and eclipse effects
 */
const THREE_GEOMETRIES = {
    moon: {
        geometry: createMoon(64, 64),
        material: 'custom',
        blink: { type: 'gentle-pulse', duration: 180, scaleAxis: [0.95, 0.95, 0.95], glowBoost: 0.2, curve: 'sine' },
        particleRadiusMultiplier: 1.4  // Wider sphere needs particles further out
    },

    sun: {
        geometry: new SphereGeometry(0.5, 64, 64),
        material: 'emissive',
        blink: { type: 'radial-pulse', duration: 200, scaleAxis: [1.05, 1.05, 1.05], glowBoost: 0.5, curve: 'sine' },
        particleRadiusMultiplier: 1.5  // Sun with corona needs particles even further
    },

    // Crystal with inner soul glow
    crystal: {
        geometry: null,
        geometryLoader: loadCrystalGeometry,
        material: 'custom',
        blink: { type: 'facet-flash', duration: 160, scaleAxis: [0.95, 0.95, 0.95], glowBoost: 0.4, curve: 'sine' },
        particleRadiusMultiplier: 1.4  // Spread particles out from the crystal
    },

    // Rough (raw crystal formation)
    rough: {
        geometry: null,
        geometryLoader: loadRoughGeometry,
        material: 'custom',
        blink: { type: 'facet-flash', duration: 150, scaleAxis: [0.95, 0.95, 0.95], glowBoost: 0.5, curve: 'sine' },
        particleRadiusMultiplier: 1.3  // Spread particles out from the rough formation
    },

    // Heart-cut crystal
    heart: {
        geometry: null,
        geometryLoader: loadHeartGeometry,
        material: 'custom',
        blink: { type: 'gentle-pulse', duration: 180, scaleAxis: [0.92, 0.92, 0.92], glowBoost: 0.6, curve: 'sine' },
        particleRadiusMultiplier: 1.3  // Spread particles out from the heart
    },

    // Star-cut crystal
    star: {
        geometry: null,
        geometryLoader: loadStarGeometry,
        material: 'custom',
        blink: { type: 'facet-flash', duration: 150, scaleAxis: [0.93, 0.93, 0.93], glowBoost: 0.5, curve: 'sine' },
        particleRadiusMultiplier: 1.4  // Spread particles out from the star
    }
};

/**
 * ProceduralAnimator - Code-driven animation system for 3D mascot
 *
 * Maps emotive-engine gestures to 3D transforms without asset files.
 * Handles emotion animations, gesture playback, and smooth transitions.
 */

class ProceduralAnimator {
    constructor() {
        this.currentAnimation = null;
        this.animations = [];
        this.time = 0;
    }

    /**
     * Play emotion animation (affects scale, glow)
     */
    playEmotion(emotion, callbacks = {}) {
        const animation = this.createEmotionAnimation(emotion);
        this.startAnimation(animation, callbacks);
    }

    /**
     * Play gesture animation (affects position, rotation)
     */
    playGesture(gestureName, callbacks = {}) {
        const animation = this.createGestureAnimation(gestureName);
        this.startAnimation(animation, callbacks);
    }

    /**
     * Play morph animation (affects geometry transition)
     */
    playMorph(fromShape, toShape, callbacks = {}) {
        const animation = this.createMorphAnimation(fromShape, toShape);
        this.startAnimation(animation, callbacks);
    }

    /**
     * Update animations (called each frame)
     *
     * NOTE: Gesture blending is now handled externally in Core3DManager.render()
     * This method only updates time and removes completed animations.
     * The blending system calls evaluate() directly and accumulates outputs.
     */
    update(deltaTime) {
        this.time += deltaTime;

        // Remove completed animations
        for (let i = this.animations.length - 1; i >= 0; i--) {
            const anim = this.animations[i];
            const durationMs = anim.duration; // Duration in milliseconds
            const progress = Math.min((this.time - anim.startTime) / durationMs, 1.0);

            // Check if animation is complete
            if (progress >= 1.0) {
                if (anim.callbacks && anim.callbacks.onComplete) {
                    anim.callbacks.onComplete();
                }
                this.animations.splice(i, 1);
            }
        }
    }

    /**
     * Create emotion animation definition
     */
    createEmotionAnimation(emotion) {
        const animations = {
            joy: {
                duration: 0.6,
                evaluate: t => ({
                    scale: 1.0 + Math.sin(t * Math.PI) * 0.15,
                    glowIntensity: 1.0 + Math.sin(t * Math.PI) * 0.15  // Gentle pulse ±15%
                })
            },
            love: {
                duration: 1.2,
                evaluate: t => ({
                    scale: 1.0 + Math.sin(t * Math.PI * 2) * 0.08,
                    glowIntensity: 1.0 + Math.sin(t * Math.PI * 2) * 0.1  // Gentle pulse ±10%
                })
            },
            curiosity: {
                duration: 0.8,
                evaluate: t => {
                    const wiggle = Math.sin(t * Math.PI * 4) * 0.1;
                    return {
                        rotation: [0, wiggle, 0],
                        scale: 1.0 + Math.sin(t * Math.PI) * 0.05,
                        glowIntensity: 1.0  // Steady glow
                    };
                }
            },
            sadness: {
                duration: 1.5,
                evaluate: t => ({
                    scale: 1.0 - t * 0.1,
                    glowIntensity: 1.0 - Math.sin(t * Math.PI) * 0.15  // Gentle fade ±15%
                })
            },
            anger: {
                duration: 0.4,
                evaluate: t => {
                    const shake = Math.sin(t * Math.PI * 8) * 0.15;
                    return {
                        rotation: [shake, shake, 0],
                        scale: 1.1 + Math.sin(t * Math.PI) * 0.1,
                        glowIntensity: 1.0 + Math.sin(t * Math.PI * 8) * 0.15  // Rapid flicker ±15%
                    };
                }
            },
            fear: {
                duration: 0.5,
                evaluate: t => {
                    const tremble = Math.sin(t * Math.PI * 10) * 0.08;
                    return {
                        scale: 0.9 + tremble,
                        rotation: [tremble, 0, tremble],
                        glowIntensity: 1.0 + Math.sin(t * Math.PI * 10) * 0.1  // Nervous flicker ±10%
                    };
                }
            },
            surprise: {
                duration: 0.4,
                evaluate: t => ({
                    scale: 1.0 + (1.0 - Math.cos(t * Math.PI)) * 0.25,
                    glowIntensity: 1.0 + (1.0 - Math.cos(t * Math.PI)) * 0.2  // Quick burst +20%
                })
            },
            neutral: {
                duration: 0.5,
                evaluate: _t => ({
                    scale: 1.0,
                    glowIntensity: 1.0  // Steady baseline
                })
            }
        };

        return animations[emotion] || animations.neutral;
    }

    /**
     * Create gesture animation definition
     *
     * GESTURE CATEGORIES:
     * - "Absolute" gestures (bounce, spin, float): Create their own motion, compete with groove
     * - "Accent" gestures (pop, punch, swell): Multiply/boost existing groove, work as punctuation
     *
     * For dancing, prefer accent gestures - they complement the groove instead of fighting it.
     */
    createGestureAnimation(gestureName) {
        const gestures = {
            // ═══════════════════════════════════════════════════════════════════════════
            // ACCENT GESTURES (Dance-friendly - boost groove, don't compete)
            // These use 'isAccent: true' to signal multiplicative blending
            // ═══════════════════════════════════════════════════════════════════════════

            // ───────────────────────────────────────────────────────────────
            // POP: Pure scale pulse - the classic beat hit
            // Character: Quick size bump, no rotation/position
            // ───────────────────────────────────────────────────────────────
            pop: {
                duration: 0.2,
                isAccent: true,
                evaluate: t => {
                    const envelope = Math.sin(t * Math.PI);
                    return {
                        scaleBoost: 1.0 + envelope * 0.025  // 2.5% scale only
                    };
                }
            },

            // ───────────────────────────────────────────────────────────────
            // BOB: Forward tilt accent - head nod feel
            // Character: Rotation only, like nodding to the beat
            // ───────────────────────────────────────────────────────────────
            bob: {
                duration: 0.25,
                isAccent: true,
                evaluate: t => {
                    const envelope = Math.sin(t * Math.PI);
                    return {
                        rotationBoost: [envelope * 0.025, 0, 0]  // Forward tilt only
                    };
                }
            },

            // ───────────────────────────────────────────────────────────────
            // SWELL: Glow build with scale - for transitions and builds
            // Character: Glowing expansion, like breathing in deeply
            // ───────────────────────────────────────────────────────────────
            swell: {
                duration: 0.6,
                isAccent: true,
                evaluate: t => {
                    // Smooth bell curve envelope
                    const envelope = Math.sin(t * Math.PI);
                    // Slight ease-out for organic feel
                    const eased = 1 - Math.pow(1 - envelope, 2);
                    return {
                        scaleBoost: 1.0 + eased * 0.04,  // 4% scale growth (visible)
                        glowBoost: eased * 0.3           // 30% glow boost (noticeable)
                    };
                }
            },

            // ───────────────────────────────────────────────────────────────
            // SWAGGER: Side lean - attitude/groove feel
            // Character: Z-rotation lean, slight X drift
            // ───────────────────────────────────────────────────────────────
            swagger: {
                duration: 0.4,
                isAccent: true,
                evaluate: t => {
                    const envelope = Math.sin(t * Math.PI);
                    return {
                        rotationBoost: [0, 0, envelope * 0.04],  // Side lean
                        positionBoost: [envelope * 0.01, 0, 0]   // Slight drift
                    };
                }
            },

            // ───────────────────────────────────────────────────────────────
            // DIP: Downward bob - groove dip feel
            // Character: Y-position dip with tiny squish
            // ───────────────────────────────────────────────────────────────
            dip: {
                duration: 0.25,
                isAccent: true,
                evaluate: t => {
                    const envelope = Math.sin(t * Math.PI);
                    return {
                        positionBoost: [0, -envelope * 0.015, 0],  // Down dip
                        scaleBoost: 1.0 - envelope * 0.015         // Tiny squish
                    };
                }
            },

            // ───────────────────────────────────────────────────────────────
            // FLARE: Combined accent - scale + glow burst
            // Character: The "big" accent for drops/hits
            // ───────────────────────────────────────────────────────────────
            flare: {
                duration: 0.3,
                isAccent: true,
                evaluate: t => {
                    const envelope = Math.sin(t * Math.PI);
                    return {
                        scaleBoost: 1.0 + envelope * 0.03,
                        glowBoost: envelope * 0.25
                    };
                }
            },

            // ═══════════════════════════════════════════════════════════════════════════
            // ABSOLUTE GESTURES (Original - create their own motion)
            // These compete with groove, use sparingly during dance
            // ═══════════════════════════════════════════════════════════════════════════

            bounce: {
                duration: 1.0,
                evaluate: t => {
                    // Smooth elastic bounce with ease-out
                    // Two bounces: main bounce + smaller secondary
                    const phase = t * Math.PI * 2;
                    const decay = 1 - t * 0.6; // Gradual decay
                    const mainBounce = Math.sin(phase) * decay;
                    const secondaryBounce = Math.sin(phase * 2) * decay * 0.3;
                    const bounce = Math.max(0, mainBounce + secondaryBounce);

                    // Squash and stretch for expressiveness
                    const squash = 1.0 - bounce * 0.08; // Squash when landing
                    const stretch = 1.0 + bounce * 0.05; // Stretch when rising

                    return {
                        position: [0, bounce * 0.35, 0],
                        scale: bounce > 0.5 ? stretch : squash
                    };
                }
            },
            pulse: {
                duration: 0.6,
                evaluate: t => {
                    const pulse = Math.sin(t * Math.PI);
                    return {
                        scale: 1.0 + pulse * 0.2,
                        glowIntensity: 1.0 + pulse * 0.5
                    };
                }
            },
            spin: {
                duration: 1.0,
                evaluate: t => ({
                    rotation: [0, t * Math.PI * 2, 0]
                })
            },
            wobble: {
                duration: 1.0,
                evaluate: t => {
                    const wobble = Math.sin(t * Math.PI * 3);
                    return {
                        rotation: [wobble * 0.3, 0, wobble * 0.2]
                    };
                }
            },
            float: {
                duration: 2.0,
                evaluate: t => {
                    const float = Math.sin(t * Math.PI);
                    return {
                        position: [0, float * 0.3, 0]
                    };
                }
            },
            shake: {
                duration: 0.5,
                evaluate: t => {
                    const shake = Math.sin(t * Math.PI * 6) * (1.0 - t);
                    return {
                        position: [shake * 0.2, 0, 0],
                        rotation: [0, 0, shake * 0.1]
                    };
                }
            },
            // Nod: Tidally locked double-nod toward camera
            // Uses cameraRelativePosition so Z moves toward camera regardless of angle
            nod: {
                duration: 0.5,
                evaluate: t => {
                    // Two quick forward dips (like nodding "yes yes")
                    // First nod: 0-0.4, second nod: 0.4-0.8, settle: 0.8-1.0
                    let forward = 0;
                    if (t < 0.4) {
                        // First nod - full strength
                        const nodT = t / 0.4;
                        forward = Math.sin(nodT * Math.PI) * 0.12;
                    } else if (t < 0.8) {
                        // Second nod - smaller
                        const nodT = (t - 0.4) / 0.4;
                        forward = Math.sin(nodT * Math.PI) * 0.07;
                    }
                    // else: settle back to 0

                    return {
                        // Z in camera-relative = toward camera (tidally locked!)
                        cameraRelativePosition: [0, 0, forward],
                        // Subtle scale accompaniment
                        scale: 1.0 - Math.abs(forward) * 0.3,
                        glowIntensity: 1.0 + Math.abs(forward) * 0.5
                    };
                }
            },

            // Wiggle: Rapid horizontal shimmy in camera-relative space
            // Like excited shaking side to side (relative to camera view)
            wiggle: {
                duration: 0.4,
                evaluate: t => {
                    // Fast decay
                    const decay = Math.pow(1 - t, 0.6);
                    // Rapid oscillation - left/right shimmy
                    const osc = Math.sin(t * Math.PI * 12) * decay;

                    return {
                        // X in camera-relative = horizontal shimmy (always side-to-side in view)
                        cameraRelativePosition: [osc * 0.04, 0, 0],
                        // Slight scale pulse
                        scale: 1.0 + Math.abs(osc) * 0.03,
                        glowIntensity: 1.0 + Math.abs(osc) * 0.1
                    };
                }
            },

            // HeadBob: Tidally locked forward bob toward camera
            // Quick dip toward the camera - like a rhythmic head bob
            headBob: {
                duration: 0.3,
                evaluate: t => {
                    // Sharp attack, smooth decay (like head bob on beat)
                    const envelope = t < 0.15
                        ? t / 0.15  // Quick attack
                        : Math.pow(1 - (t - 0.15) / 0.85, 2);  // Smooth return

                    const forward = envelope * 0.08;  // Move toward camera

                    return {
                        // Z in camera-relative = toward camera (tidally locked!)
                        cameraRelativePosition: [0, 0, forward],
                        // Slight Y dip for weight feel
                        position: [0, -envelope * 0.015, 0],
                        // Scale accompaniment
                        scale: 1.0 - envelope * 0.05,
                        glowIntensity: 1.0 + envelope * 0.15
                    };
                }
            },

            // Sway: Gentle side-to-side lean with smooth onset
            sway: {
                duration: 1.2,
                evaluate: t => {
                    // Ease-in-out envelope for smooth entry and exit
                    const envelope = t < 0.15
                        ? t / 0.15 * t / 0.15  // Quadratic ease-in at start
                        : t > 0.85
                            ? Math.pow((1 - t) / 0.15, 2) // Quadratic ease-out at end
                            : 1.0;

                    // Smooth sine sway motion
                    const sway = Math.sin(t * Math.PI * 2) * envelope;

                    return {
                        rotation: [0, 0, sway * 0.12],
                        position: [sway * 0.06, 0, 0]
                    };
                }
            },

            // Jump: Quick up movement
            jump: {
                duration: 0.6,
                evaluate: t => {
                    // Parabolic jump (up fast, down slow)
                    const jumpHeight = Math.sin(t * Math.PI);
                    const squash = t < 0.1 ? 1.0 - t * 3 : (t > 0.9 ? 1.0 - (1 - t) * 3 : 1.0);
                    return {
                        position: [0, jumpHeight * 0.4, 0],
                        scale: squash
                    };
                }
            },

            // Twist: Quick Y rotation
            twist: {
                duration: 0.5,
                evaluate: t => {
                    const twist = Math.sin(t * Math.PI * 2) * (1 - t * 0.5);
                    return {
                        rotation: [0, twist * 0.3, 0]
                    };
                }
            },

            // Hula: Circular hip motion
            hula: {
                duration: 1.0,
                evaluate: t => {
                    const phase = t * Math.PI * 2;
                    return {
                        position: [Math.sin(phase) * 0.05, 0, Math.cos(phase) * 0.03],
                        rotation: [0, 0, Math.sin(phase) * 0.05]
                    };
                }
            },

            // Lean: Side-to-side tilt (Z-rotation = always perpendicular to camera view)
            // Enhanced with X-position drift for more natural lean feel
            lean: {
                duration: 0.6,
                evaluate: t => {
                    // Smooth envelope
                    const envelope = Math.sin(t * Math.PI);
                    const lean = envelope;

                    return {
                        // Z-rotation is perpendicular to camera (side tilt)
                        rotation: [0, 0, lean * 0.15],
                        // Drift in direction of lean for weight shift feel
                        position: [lean * 0.04, -Math.abs(lean) * 0.01, 0]
                    };
                }
            },

            // Tilt: Forward nod toward camera (X-rotation + Z-position)
            // Redesigned to feel like "looking up/down" not "bowing"
            tilt: {
                duration: 0.5,
                evaluate: t => {
                    const envelope = Math.sin(t * Math.PI);
                    const tilt = envelope;

                    return {
                        // Primary: Z-position toward camera (forward motion)
                        position: [0, 0, tilt * 0.05],
                        // Secondary: Subtle X-rotation for tilt feel
                        rotation: [tilt * 0.08, 0, 0]
                    };
                }
            },

            // Twitch: Quick small jerk
            twitch: {
                duration: 0.2,
                evaluate: t => {
                    const twitch = (1 - t) * Math.sin(t * Math.PI * 6);
                    return {
                        rotation: [twitch * 0.03, twitch * 0.03, 0]
                    };
                }
            },

            // ═══════════════════════════════════════════════════════════════════════════
            // GLOW-BASED GESTURES (Rate-limited for epilepsy safety)
            // ═══════════════════════════════════════════════════════════════════════════

            // Flash: Quick bright pulse - like a camera flash
            // Safety: Single pulse, no rapid flickering
            flash: {
                duration: 0.3,
                evaluate: t => {
                    // Quick attack, slower decay (like real flash)
                    const flash = t < 0.2
                        ? t / 0.2  // Fast attack
                        : 1 - (t - 0.2) / 0.8;  // Slow decay

                    return {
                        glowIntensity: 1.0 + flash * 0.4,  // +40% brightness
                        scale: 1.0 + flash * 0.03          // Tiny scale pop
                    };
                }
            },

            // Glow: Gentle sustained brightness increase
            // Warm, soft feel - like embers glowing
            glow: {
                duration: 0.8,
                evaluate: t => {
                    // Smooth bell curve
                    const glow = Math.sin(t * Math.PI);

                    return {
                        glowIntensity: 1.0 + glow * 0.25,  // +25% brightness
                        scale: 1.0 + glow * 0.02           // Very subtle scale
                    };
                }
            },

            // Burst: Explosive "toward camera" burst with scale and glow
            // Like an energy release - dramatically moves toward viewer then recoils
            burst: {
                duration: 0.6,
                evaluate: t => {
                    // Phase 1: Explosive forward burst (0-0.15)
                    // Phase 2: Overshoot recoil back (0.15-0.35)
                    // Phase 3: Settle with damped oscillation (0.35-1.0)
                    let forward = 0, scale = 1.0, glow = 1.0;

                    if (t < 0.15) {
                        // Explosive forward burst toward camera
                        const attack = t / 0.15;
                        const eased = 1 - Math.pow(1 - attack, 3); // Ease-out
                        forward = eased * 0.15;  // Surge toward camera
                        scale = 1.0 + eased * 0.2;
                        glow = 1.0 + eased * 0.5;
                    } else if (t < 0.35) {
                        // Recoil back past origin
                        const recoilT = (t - 0.15) / 0.2;
                        const bounce = Math.sin(recoilT * Math.PI);
                        forward = 0.15 * (1 - recoilT * 1.5); // Go past zero
                        scale = 1.0 + 0.2 * (1 - recoilT) - bounce * 0.1;
                        glow = 1.0 + (1 - recoilT) * 0.4;
                    } else {
                        // Damped settle
                        const settleT = (t - 0.35) / 0.65;
                        const decay = Math.pow(1 - settleT, 2);
                        const ring = Math.sin(settleT * Math.PI * 2) * decay;
                        forward = ring * 0.03;
                        scale = 1.0 + ring * 0.05;
                        glow = 1.0 + Math.abs(ring) * 0.15;
                    }

                    return {
                        // Dramatic forward/back motion in camera-relative space
                        cameraRelativePosition: [0, 0, forward],
                        scale,
                        glowIntensity: glow
                    };
                }
            },

            // Flicker: Subtle rapid shimmer - like candlelight
            // Safe rate: 2 flickers over duration (not strobing)
            flicker: {
                duration: 0.6,
                evaluate: t => {
                    // Envelope to prevent hard start/stop
                    const envelope = Math.sin(t * Math.PI);
                    // Two gentle flickers (safe rate)
                    const flicker = Math.sin(t * Math.PI * 4) * envelope;

                    return {
                        glowIntensity: 1.0 + flicker * 0.15,  // ±15% flicker
                        scale: 1.0 + flicker * 0.01           // Barely perceptible scale
                    };
                }
            }
        };

        return gestures[gestureName] || gestures.pulse;
    }

    /**
     * Create morph animation (cross-fade between geometries)
     */
    createMorphAnimation(fromShape, toShape) {
        return {
            duration: 1.0,
            fromShape,
            toShape,
            evaluate: t => ({
                morphProgress: t,
                scale: 1.0 + Math.sin(t * Math.PI) * 0.1,
                rotation: [0, t * Math.PI * 0.5, 0]
            })
        };
    }

    /**
     * Start animation
     */
    startAnimation(animation, callbacks) {
        this.animations.push({
            ...animation,
            startTime: this.time,
            callbacks: callbacks || {}
        });

        this.currentAnimation = animation;
    }

    /**
     * Stop all animations
     */
    stopAll() {
        this.animations = [];
        this.currentAnimation = null;
    }

    /**
     * Cleanup all resources
     */
    destroy() {
        this.stopAll();
        this.animations = null;
        this.currentAnimation = null;
        this.time = 0;
    }

    /**
     * Easing function (smooth in-out)
     */
    easeInOutCubic(t) {
        return t < 0.5
            ? 4 * t * t * t
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    /**
     * Get idle animation (continuous subtle movement)
     */
    getIdleAnimation() {
        return {
            duration: 3.0,
            loop: true,
            evaluate: t => {
                const breathe = Math.sin(t * Math.PI * 2);
                const drift = Math.sin(t * Math.PI);
                return {
                    scale: 1.0 + breathe * 0.02,
                    position: [drift * 0.05, breathe * 0.03, 0],
                    rotation: [0, drift * 0.05, 0],
                    glowIntensity: 1.0 + breathe * 0.1
                };
            }
        };
    }

    /**
     * Check if any animation is playing
     */
    isPlaying() {
        return this.animations.length > 0;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - 3D Breathing Animator
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Handles breathing animations for 3D rendering
 * @author Emotive Engine Team
 * @module 3d/animation/BreathingAnimator
 *
 * Manages:
 * - Breathing phase and timing
 * - Emotion-specific breathing patterns
 * - Undertone modifiers
 * - Scale calculation for breathing effect
 */

class BreathingAnimator {
    constructor() {
        // Base breathing configuration
        this.breathingSpeed = 1.0;      // Base breathing speed
        this.breathingDepth = 0.03;     // Base breathing depth (3% scale oscillation)

        // Breathing state
        this.breathingPhase = 0;        // Current phase in breathing cycle [0, 2π]
        this.breathRate = 1.0;          // Emotion-specific rate multiplier
        this.breathDepth = 0.03;        // Emotion-specific depth
        this.breathRateMult = 1.0;      // Undertone rate multiplier
        this.breathDepthMult = 1.0;     // Undertone depth multiplier

        // Rhythm coordination
        this.rhythmAdapter = null;      // Optional Rhythm3DAdapter reference
        this.grooveBlendFactor = 0.4;   // Reduce breathing to 40% during groove

        // Emotion-specific breathing patterns (matches 2D BreathingAnimator)
        this.emotionBreathPatterns = {
            happy: { rate: 1.1, depth: 1.2 },
            sad: { rate: 0.8, depth: 0.7 },
            angry: { rate: 1.4, depth: 1.3 },
            calm: { rate: 0.7, depth: 0.9 },
            excited: { rate: 1.5, depth: 1.4 },
            focused: { rate: 0.9, depth: 0.6 },
            neutral: { rate: 1.0, depth: 1.0 },
            love: { rate: 1.2, depth: 1.3 },
            surprised: { rate: 1.3, depth: 1.1 },
            confused: { rate: 1.1, depth: 0.9 },
            amused: { rate: 1.2, depth: 1.1 },
            bored: { rate: 0.6, depth: 0.8 },
            tired: { rate: 0.5, depth: 1.2 },
            anxious: { rate: 1.6, depth: 0.9 },
            determined: { rate: 1.1, depth: 1.0 },
            proud: { rate: 0.9, depth: 1.3 },
            content: { rate: 0.8, depth: 1.0 },
            hopeful: { rate: 1.0, depth: 1.1 },
            zen: { rate: 0.4, depth: 1.5 },
            intrigued: { rate: 1.1, depth: 0.8 },
            embarrassed: { rate: 1.3, depth: 0.7 },
            grateful: { rate: 0.9, depth: 1.1 },
            inspired: { rate: 1.0, depth: 1.3 },
            silly: { rate: 1.4, depth: 1.2 },
            sleepy: { rate: 0.3, depth: 1.4 }
        };
    }

    /**
     * Update breathing animation
     * @param {number} deltaTime - Time since last frame in ms
     * @param {string} emotion - Current emotion
     * @param {Object} undertoneModifier - Undertone modifier with '3d' section
     */
    update(deltaTime, emotion, undertoneModifier = null) {
        // Apply emotion-specific breathing pattern
        const pattern = this.emotionBreathPatterns[emotion] || { rate: 1.0, depth: 1.0 };

        // Apply undertone modifiers
        if (undertoneModifier && undertoneModifier['3d'] && undertoneModifier['3d'].scale) {
            this.breathRateMult = undertoneModifier['3d'].scale.breathRateMultiplier || 1.0;
            this.breathDepthMult = undertoneModifier['3d'].scale.breathDepthMultiplier || 1.0;
        } else {
            this.breathRateMult = 1.0;
            this.breathDepthMult = 1.0;
        }

        // Calculate final breathing parameters
        this.breathRate = pattern.rate * this.breathRateMult;
        this.breathDepth = this.breathingDepth * pattern.depth * this.breathDepthMult;

        // Update breathing phase (sine wave oscillation)
        const phaseIncrement = this.breathingSpeed * this.breathRate * (deltaTime / 1000);
        this.breathingPhase += phaseIncrement;

        // Keep phase in [0, 2π] range
        if (this.breathingPhase > Math.PI * 2) {
            this.breathingPhase -= Math.PI * 2;
        }
    }

    /**
     * Set rhythm adapter for groove coordination
     * When groove is active, breathing depth is reduced to prevent visual interference
     * @param {Object|null} rhythmAdapter - Rhythm3DAdapter instance or null to disable
     */
    setRhythmAdapter(rhythmAdapter) {
        this.rhythmAdapter = rhythmAdapter;
    }

    /**
     * Get current breathing scale multiplier
     * When groove is active, breathing is reduced to complement rather than compete
     * @returns {number} Scale factor for breathing (1.0 ± breathDepth)
     */
    getBreathingScale() {
        // Check if groove is active
        const isGrooving = this.rhythmAdapter?.isPlaying?.() ?? false;

        // When grooving, reduce breathing depth to avoid fighting with groove pulse
        const grooveReduction = isGrooving ? this.grooveBlendFactor : 1.0;

        return 1.0 + Math.sin(this.breathingPhase) * this.breathDepth * grooveReduction;
    }

    /**
     * Set emotion (updates breathing pattern immediately)
     * @param {string} emotion - Emotion name
     * @param {Object} undertoneModifier - Undertone modifier
     */
    setEmotion(emotion, undertoneModifier = null) {
        const pattern = this.emotionBreathPatterns[emotion] || { rate: 1.0, depth: 1.0 };

        // Apply undertone modifiers
        if (undertoneModifier && undertoneModifier['3d'] && undertoneModifier['3d'].scale) {
            this.breathRateMult = undertoneModifier['3d'].scale.breathRateMultiplier || 1.0;
            this.breathDepthMult = undertoneModifier['3d'].scale.breathDepthMultiplier || 1.0;
        } else {
            this.breathRateMult = 1.0;
            this.breathDepthMult = 1.0;
        }

        // Calculate final breathing parameters
        this.breathRate = pattern.rate * this.breathRateMult;
        this.breathDepth = this.breathingDepth * pattern.depth * this.breathDepthMult;
    }

    /**
     * Reset breathing to default state
     */
    reset() {
        this.breathingPhase = 0;
        this.breathRate = 1.0;
        this.breathDepth = this.breathingDepth;
        this.breathRateMult = 1.0;
        this.breathDepthMult = 1.0;
    }

    /**
     * Get breathing info for debugging
     * @returns {Object} Breathing state info
     */
    getBreathingInfo() {
        return {
            phase: this.breathingPhase,
            rate: this.breathRate,
            depth: this.breathDepth,
            scale: this.getBreathingScale(),
            rateMult: this.breathRateMult,
            depthMult: this.breathDepthMult
        };
    }

    /**
     * Cleanup all resources
     */
    destroy() {
        this.emotionBreathPatterns = null;
        this.rhythmAdapter = null;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - 3D Gesture Blender
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Handles blending of multiple simultaneous 3D gestures
 * @author Emotive Engine Team
 * @module 3d/animation/GestureBlender
 *
 * Manages:
 * - Accumulation of multiple gesture channels (position, rotation, scale, glow, glowBoost)
 * - Channel-specific blending modes (additive vs multiplicative)
 * - Quaternion-based rotation composition
 * - Isolated glowBoost for screen-space glow layer (separate from material glow)
 * - ACCENT GESTURES: scaleBoost, positionBoost, rotationBoost for dance punctuation
 */


class GestureBlender {
    constructor() {
        // Temp objects for quaternion calculations (reused to avoid allocations)
        this.tempEuler = new Euler();
        this.tempQuat = new Quaternion();
        this.accumulatedRotationQuat = new Quaternion();
        this.finalQuaternion = new Quaternion();
    }

    /**
     * Blend multiple gesture animations into a single output
     *
     * Supports two types of gestures:
     * 1. ABSOLUTE gestures: position, rotation, scale - create their own motion
     * 2. ACCENT gestures: positionBoost, rotationBoost, scaleBoost - boost/multiply existing groove
     *
     * Accent gestures are designed to work as "punctuation" on top of groove, not compete with it.
     *
     * @param {Array} animations - Array of active animations from ProceduralAnimator
     * @param {number} currentTime - Current animator time in milliseconds
     * @param {THREE.Quaternion} baseQuaternion - Base rotation quaternion
     * @param {number} baseScale - Base scale value
     * @param {number} baseGlowIntensity - Base glow intensity
     * @returns {Object} Blended gesture output
     */
    blend(animations, currentTime, baseQuaternion, baseScale, baseGlowIntensity) {
        // Reset accumulated rotation quaternion to identity (reuse instead of allocate)
        this.accumulatedRotationQuat.identity();

        // Initialize accumulator with identity values
        const accumulated = {
            // ABSOLUTE channels (create motion)
            position: [0, 0, 0],                               // Additive channel (world-space)
            rotationQuat: this.accumulatedRotationQuat,        // Multiplicative channel (reused)
            scale: 1.0,                                        // Multiplicative channel
            glowIntensity: 1.0,                                // Multiplicative channel
            glowBoost: 0.0,                                    // Additive channel (for glow layer)

            // CAMERA-RELATIVE position (transformed in Core3DManager)
            // Z = toward camera, Y = up, X = right (in view space)
            cameraRelativePosition: [0, 0, 0],

            // ACCENT/BOOST channels (enhance groove without replacing it)
            positionBoost: [0, 0, 0],                          // Additive boost to groove position
            rotationBoost: [0, 0, 0],                          // Additive boost to groove rotation
            scaleBoost: 1.0,                                   // Multiplicative boost (1.0 = no change)

            // Track if we have any accent gestures (affects groove blending behavior)
            hasAccentGestures: false,
            hasAbsoluteGestures: false,
            hasCameraRelativeGestures: false
        };

        // Blend all active animations
        for (const animation of animations) {
            if (animation.evaluate) {
                const elapsed = currentTime - animation.startTime;
                const durationMs = animation.duration; // Duration in milliseconds
                const progress = Math.min(elapsed / durationMs, 1);
                const output = animation.evaluate(progress);

                if (output) {
                    // Track gesture type for groove blending decisions
                    const isAccent = animation.isAccent === true;
                    if (isAccent) {
                        accumulated.hasAccentGestures = true;
                    } else if (output.position || output.rotation || output.scale !== undefined) {
                        accumulated.hasAbsoluteGestures = true;
                    }

                    // ═══════════════════════════════════════════════════════════════
                    // ABSOLUTE CHANNELS (create their own motion)
                    // ═══════════════════════════════════════════════════════════════

                    // POSITION: Additive blending (bounce + sway)
                    if (output.position) {
                        accumulated.position[0] += output.position[0];
                        accumulated.position[1] += output.position[1];
                        accumulated.position[2] += output.position[2];
                    }

                    // ROTATION: Quaternion multiplication (orbital * twist)
                    if (output.rotation) {
                        this.tempEuler.set(
                            output.rotation[0],
                            output.rotation[1],
                            output.rotation[2],
                            'XYZ'
                        );
                        this.tempQuat.setFromEuler(this.tempEuler);
                        accumulated.rotationQuat.multiply(this.tempQuat);
                    }

                    // SCALE: Multiplicative blending (expand × shrink)
                    if (output.scale !== undefined) {
                        accumulated.scale *= output.scale;
                    }

                    // GLOW: Multiplicative blending (glow × pulse)
                    if (output.glowIntensity !== undefined) {
                        accumulated.glowIntensity *= output.glowIntensity;
                    }

                    // GLOW BOOST: Additive blending for isolated glow layer
                    if (output.glowBoost !== undefined) {
                        accumulated.glowBoost += output.glowBoost;
                    }

                    // ═══════════════════════════════════════════════════════════════
                    // ACCENT/BOOST CHANNELS (enhance groove as punctuation)
                    // ═══════════════════════════════════════════════════════════════

                    // POSITION BOOST: Additive accent to groove position
                    if (output.positionBoost) {
                        accumulated.positionBoost[0] += output.positionBoost[0];
                        accumulated.positionBoost[1] += output.positionBoost[1];
                        accumulated.positionBoost[2] += output.positionBoost[2];
                    }

                    // ROTATION BOOST: Additive accent to groove rotation
                    if (output.rotationBoost) {
                        accumulated.rotationBoost[0] += output.rotationBoost[0];
                        accumulated.rotationBoost[1] += output.rotationBoost[1];
                        accumulated.rotationBoost[2] += output.rotationBoost[2];
                    }

                    // SCALE BOOST: Multiplicative accent (1.1 = 10% bigger, 0.9 = 10% smaller)
                    // Clamped to prevent extreme stacking when multiple gestures fire
                    if (output.scaleBoost !== undefined) {
                        accumulated.scaleBoost *= output.scaleBoost;
                    }

                    // ═══════════════════════════════════════════════════════════════
                    // CAMERA-RELATIVE POSITION (tidally locked gestures)
                    // ═══════════════════════════════════════════════════════════════
                    // Position in view space: Z = toward camera, Y = up, X = right
                    // Transformed to world-space in Core3DManager using camera direction
                    if (output.cameraRelativePosition) {
                        accumulated.cameraRelativePosition[0] += output.cameraRelativePosition[0];
                        accumulated.cameraRelativePosition[1] += output.cameraRelativePosition[1];
                        accumulated.cameraRelativePosition[2] += output.cameraRelativePosition[2];
                        accumulated.hasCameraRelativeGestures = true;
                    }
                }
            }
        }

        // Clamp accumulated boost values to prevent extreme visual artifacts
        // scaleBoost: limit to ±15% (0.85 to 1.15)
        accumulated.scaleBoost = Math.max(0.85, Math.min(1.15, accumulated.scaleBoost));

        // glowBoost: limit to 0.5 (prevents blinding flashes)
        accumulated.glowBoost = Math.min(0.5, accumulated.glowBoost);

        // positionBoost: limit each axis to ±0.05 (prevents wild movements)
        for (let i = 0; i < 3; i++) {
            accumulated.positionBoost[i] = Math.max(-0.05, Math.min(0.05, accumulated.positionBoost[i]));
        }

        // rotationBoost: limit each axis to ±0.1 radians (~6 degrees)
        for (let i = 0; i < 3; i++) {
            accumulated.rotationBoost[i] = Math.max(-0.1, Math.min(0.1, accumulated.rotationBoost[i]));
        }

        // Combine base quaternion with accumulated gesture rotation
        // finalQuaternion = baseQuaternion * gestureQuaternion
        // This applies gesture rotation in the local space of the base rotation
        this.finalQuaternion.copy(baseQuaternion).multiply(accumulated.rotationQuat);

        // Convert final quaternion back to Euler angles
        this.tempEuler.setFromQuaternion(this.finalQuaternion, 'XYZ');
        const finalRotation = [
            this.tempEuler.x,
            this.tempEuler.y,
            this.tempEuler.z
        ];

        // Apply base values to accumulated results
        const finalScale = baseScale * accumulated.scale;
        const finalGlowIntensity = baseGlowIntensity * accumulated.glowIntensity;

        return {
            // Absolute gesture outputs
            position: accumulated.position,
            rotation: finalRotation,
            scale: finalScale,
            glowIntensity: finalGlowIntensity,
            glowBoost: accumulated.glowBoost,

            // Camera-relative position (view-space, transformed in Core3DManager)
            cameraRelativePosition: accumulated.cameraRelativePosition,

            // Accent gesture outputs (for groove enhancement)
            positionBoost: accumulated.positionBoost,
            rotationBoost: accumulated.rotationBoost,
            scaleBoost: accumulated.scaleBoost,

            // Gesture type flags (for groove blending decisions)
            hasAccentGestures: accumulated.hasAccentGestures,
            hasAbsoluteGestures: accumulated.hasAbsoluteGestures,
            hasCameraRelativeGestures: accumulated.hasCameraRelativeGestures,

            gestureQuaternion: accumulated.rotationQuat // For debugging/inspection
        };
    }

    /**
     * Cleanup all resources
     */
    destroy() {
        this.tempEuler = null;
        this.tempQuat = null;
        this.accumulatedRotationQuat = null;
        this.finalQuaternion = null;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Emotion Plugin Adapter
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Bridge between plugin system and emotion registry
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module emotions/plugin-adapter
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Adapter for dynamic emotion registration from plugins.                            
 * ║ • Maintains separate registry for plugin emotions                                 
 * ║ • Validates emotion definitions for required properties                           
 * ║ • Provides legacy format conversion for older plugins                             
 * ║ • Enables runtime registration and unregistration                                 
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Plugin emotion registry
 */
const pluginEmotions = new Map();

/**
 * Register a plugin emotion
 * @param {string} name - Emotion name
 * @param {Object} emotionDef - Emotion definition object
 */
function registerPluginEmotion(name, emotionDef) {
    // Ensure emotion has required properties
    if (!emotionDef.color) {
        return false;
    }
    
    // Add name if not present
    if (!emotionDef.name) {
        emotionDef.name = name;
    }
    
    // Ensure visual and modifiers exist
    if (!emotionDef.visual) {
        emotionDef.visual = {
            primaryColor: emotionDef.color,
            particleCount: emotionDef.particleCount || 15,
            particleSize: emotionDef.particleSize || { min: 2, max: 6 }
        };
    }
    
    if (!emotionDef.modifiers) {
        emotionDef.modifiers = {
            speed: 1.0,
            amplitude: 1.0,
            intensity: 1.0
        };
    }
    
    pluginEmotions.set(name, emotionDef);
    
    return true;
}

/**
 * Unregister a plugin emotion
 * @param {string} name - Emotion name to remove
 */
function unregisterPluginEmotion(name) {
    if (pluginEmotions.has(name)) {
        pluginEmotions.delete(name);
        
        return true;
    }
    return false;
}

/**
 * Get a plugin emotion by name
 * @param {string} name - Emotion name
 * @returns {Object|null} Emotion object or null if not found
 */
function getPluginEmotion(name) {
    return pluginEmotions.get(name) || null;
}

/**
 * Get all plugin emotion names
 * @returns {Array<string>} Array of emotion names
 */
function getAllPluginEmotions() {
    return Array.from(pluginEmotions.keys());
}

/**
 * Clear all plugin emotions
 */
function clearPluginEmotions() {
    pluginEmotions.clear();
}

/**
 * Convert legacy plugin emotion format to new format
 * @param {Object} legacyEmotion - Old format emotion
 * @returns {Object} New format emotion
 */
function createLegacyAdapter$2(legacyEmotion) {
    return {
        name: legacyEmotion.name || 'unknown',
        emoji: legacyEmotion.emoji || '🔌',
        color: legacyEmotion.primaryColor || legacyEmotion.color || '#7B68EE',
        energy: legacyEmotion.energy || 'medium',
        
        visual: {
            primaryColor: legacyEmotion.primaryColor || legacyEmotion.color || '#7B68EE',
            secondaryColor: legacyEmotion.secondaryColor,
            particleCount: legacyEmotion.particleCount || legacyEmotion.particleRate || 15,
            particleSize: legacyEmotion.particleSize || { min: 2, max: 6 },
            glowIntensity: legacyEmotion.glowIntensity || 0.5,
            trailLength: legacyEmotion.trailLength || 5,
            pulseRate: legacyEmotion.pulseRate || legacyEmotion.breathRate || 1.0
        },
        
        particles: {
            behavior: legacyEmotion.particleBehavior || 'ambient',
            density: legacyEmotion.particleDensity || 'medium',
            speed: legacyEmotion.particleSpeed || 'normal'
        },
        
        modifiers: {
            speed: legacyEmotion.speedMultiplier || 1.0,
            amplitude: legacyEmotion.amplitudeMultiplier || 1.0,
            intensity: legacyEmotion.intensityMultiplier || 1.0,
            smoothness: legacyEmotion.smoothnessMultiplier || 1.0
        },
        
        gestures: legacyEmotion.gestures || [],
        transitions: legacyEmotion.transitions || {}
    };
}

// Export adapter interface
var pluginAdapter$2 = {
    registerPluginEmotion,
    unregisterPluginEmotion,
    getPluginEmotion,
    getAllPluginEmotions,
    clearPluginEmotions,
    createLegacyAdapter: createLegacyAdapter$2
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Neutral Emotion Base
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Neutral emotional state - calm baseline (base configuration without rhythm)
 * @author Emotive Engine Team
 * @module emotions/base/neutral
 * @complexity ⭐ Beginner-friendly
 * @audience Good example to learn emotion structure. Copy this to create new emotions.
 */

/**
 * Neutral emotion configuration
 * The default calm state, baseline for all other emotions
 */
var neutral = {
    name: 'neutral',
    emoji: '😐',
    description: 'Calm, balanced emotional state',

    // Visual properties
    visual: {
        glowColor: '#00BCD4',        // Cyan baseline (more modern)
        particleRate: 2,              // Minimal particle generation
        minParticles: 8,             // Baseline particle presence
        maxParticles: 10,            // Limited particle count
        particleBehavior: 'ambient', // Gentle floating behavior
        breathRate: 1.0,             // Normal, relaxed breathing
        breathDepth: 0.08,           // Subtle breath variation
        coreJitter: false,           // Stable, still core
        blinkRate: 1.0,              // Baseline blink frequency
        blinkSpeed: 1.0,             // Baseline blink animation speed
        particleColors: [
            { color: '#00BCD4', weight: 25 },  // Primary cyan
            { color: '#00ACC1', weight: 20 },  // Darker cyan
            { color: '#26C6DA', weight: 15 },  // Light cyan
            { color: '#B2EBF2', weight: 15 },  // Pale cyan highlight
            { color: '#0097A7', weight: 10 },  // Deep cyan shadow
            { color: '#80DEEA', weight: 10 },  // Cyan light
            { color: '#E0F7FA', weight: 5 }    // Very pale cyan
        ]
    },

    // Gesture modifiers
    modifiers: {
        speed: 1.0,        // Baseline movement speed
        amplitude: 1.0,    // Standard motion range
        intensity: 1.0,    // Default force level
        smoothness: 1.0,   // Natural motion flow
        regularity: 1.0    // Consistent patterns
    },

    // Typical gestures for this emotion
    typicalGestures: [
        'breathe',   // Calm breathing
        'float',     // Gentle floating
        'idle',      // Idle animation
        'blink'      // Occasional blinks
    ],

    // Transition hints
    transitions: {
        duration: 500,      // Standard transition duration
        easing: 'easeInOut', // Balanced transition curve
        priority: 0         // Baseline priority level
    },

    /**
     * Get core rendering parameters
     * @param {Object} _state - Current renderer state
     * @returns {Object} Core rendering configuration
     */
    getCoreParams(_state) {
        return {
            scaleX: 1.0,
            scaleY: 1.0,
            eyeOpenness: 1.0,
            eyeExpression: 'neutral', // neutral, happy, sad, focused
            pupilOffset: { x: 0, y: 0 }
        };
    },

    /**
     * Optional: Custom core rendering
     * @param {CanvasRenderingContext2D} _ctx - Canvas context
     * @param {number} _x - Center X
     * @param {number} _y - Center Y
     * @param {number} _radius - Core radius
     * @returns {boolean} True if custom rendering was done
     */
    renderCore(_ctx, _x, _y, _radius) {
        // Return false to use default rendering
        return false;
    },

    // 3D rotation behavior and effects
    '3d': {
        rotation: {
            type: 'gentle',             // Smooth slow spin
            speed: 1.0,                 // 1.0x baseline rotation speed
            axes: [0, 0.3, 0],          // Rotation rates [X, Y, Z] - 0.3 rad/sec (~10 sec per rotation)
            musicSync: false            // Neutral doesn't sync to music
        },
        glow: {
            color: '#00BCD4',           // Cyan baseline
            intensity: 0.9,             // Slightly softer glow
            pulse: {
                speed: 1.0,             // Normal pulsing (matches breathRate)
                range: [0.8, 1.0]       // Subtle pulse between 80% and 100%
            }
        },
        scale: {
            base: 1.0,
            breathe: {
                enabled: true,
                depth: 0.08,            // 8% size variation (matches breathDepth)
                rate: 1.0               // Normal breathing (matches breathRate)
            }
        }
    },

    // Soul/energy animation parameters (geometry-agnostic)
    // Used by: Crystal (inner core), Sun (plasma flow), Moon (subtle glow pulse)
    soulAnimation: {
        driftSpeed: 0.5,        // Energy movement speed - calm, steady baseline
        shimmerSpeed: 0.5,      // Vertical pulse speed - gentle
        turbulence: 0.2         // Chaos/randomness factor - minimal
    }

    // Note: Black hole behavior auto-derives from modifiers (speed: 1.0, intensity: 1.0, smoothness: 1.0)
    // Results in: baseline disk rotation, balanced turbulence, moderate doppler, neutral shadow glow
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Joy Emotion Base
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Joy emotional state - playful happiness (base configuration without rhythm)
 * @author Emotive Engine Team
 * @module emotions/base/joy
 * @complexity ⭐ Beginner-friendly
 * @audience Good example to learn emotion structure. Copy this to create new emotions.
 */

/**
 * Joy emotion configuration
 * Playful happiness with popcorn popping particles
 */
var joy = {
    name: 'joy',
    emoji: '😊',
    description: 'Playful happiness and celebration',

    // Visual properties
    visual: {
        glowColor: '#FFEB3B',       // Bright yellow sunshine
        particleRate: 8,            // Celebratory flow - 8/sec with max 50 = ~6 sec particle life
        minParticles: 0,            // Can start from stillness
        maxParticles: 50,           // Match 3D system limit
        particleBehavior: 'popcorn', // Spontaneous popping effect
        breathRate: 1.5,            // Excited, happy breathing
        breathDepth: 0.10,          // Moderate breath variation
        coreJitter: false,          // Stable, confident happiness
        blinkRate: 1.3,             // More frequent blinking (happy)
        blinkSpeed: 1.1,            // Slightly faster blink animation
        particleColors: [
            { color: '#FFEB3B', weight: 25 },  // Bright sunshine yellow
            { color: '#FFC107', weight: 20 },  // Amber joy
            { color: '#FFFF00', weight: 15 },  // Pure yellow burst
            { color: '#FFD700', weight: 15 },  // Gold celebration
            { color: '#FFF59D', weight: 10 },  // Pale yellow sparkle
            { color: '#FF9800', weight: 10 },  // Orange warmth
            { color: '#FFFDE7', weight: 5 }    // Light cream highlight
        ]
    },

    // Gesture modifiers
    modifiers: {
        speed: 1.8,        // Energetic, lively pace
        amplitude: 1.9,    // Expansive, celebratory movements
        intensity: 1.1,    // Enhanced joyful energy
        smoothness: 1.0,   // Natural, flowing motion
        regularity: 0.9,   // Playful, varied rhythm
        addBounce: true    // Extra springiness effect
    },

    // Typical gestures for joy
    typicalGestures: [
        'bounce',    // Happy bouncing
        'spin',      // Joyful spinning
        'wave',      // Excited waving
        'expand',    // Expanding with joy
        'shake',     // Excited shaking (gentle)
        'float'      // Floating with happiness
    ],

    // Transition hints
    transitions: {
        duration: 400,         // Swift mood elevation
        easing: 'easeOutBack', // Bouncy, playful entrance
        priority: 5,           // Elevated positive priority
        burstOnEntry: true     // Celebratory particle burst
    },

    /**
     * Get core rendering parameters for joy
     */
    getCoreParams(_state) {
        return {
            scaleX: 1.0,
            scaleY: 1.0,
            eyeOpenness: 1.0,
            eyeExpression: 'happy',  // ∪ shaped eyes
            pupilOffset: { x: 0, y: -0.1 },  // Looking slightly up
            sparkle: true  // Add sparkle effect
        };
    },

    // 3D rotation behavior and effects
    '3d': {
        rotation: {
            type: 'rhythmic',           // Syncs to music BPM
            speed: 1.8,                 // 1.8x faster rotation (matches modifiers.speed)
            axes: [0, 0.3, 0],          // Rotation rates [X, Y, Z] - 0.3 rad/sec base
            musicSync: true             // Sync rotation speed pulses to BPM
        },
        glow: {
            color: '#FFEB3B',           // Bright sunshine yellow
            intensity: 1.6,             // Strong cheerful glow
            pulse: {
                speed: 1.5,             // Excited pulsing (matches breathRate)
                range: [1.2, 1.8]       // Pulse between 120% and 180% intensity
            }
        },
        scale: {
            base: 1.0,
            breathe: {
                enabled: true,
                depth: 0.10,            // 10% size variation (matches breathDepth)
                rate: 1.5               // Excited breathing (matches breathRate)
            }
        }
    },

    // Soul/energy animation parameters (geometry-agnostic)
    // Used by: Crystal (inner core), Sun (plasma flow), Moon (subtle glow pulse)
    soulAnimation: {
        driftSpeed: 1.2,        // Energy movement speed - lively, bouncy
        shimmerSpeed: 1.5,      // Vertical pulse speed - excited pulsing
        turbulence: 0.3         // Chaos/randomness factor - playful variation
    }

    // Note: Black hole behavior auto-derives from modifiers (speed: 1.8, intensity: 1.1, smoothness: 1.0)
    // Results in: fast disk rotation, high turbulence, enhanced doppler effect, bright shadow glow
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Sadness Emotion Base
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Sadness emotional state - melancholic sorrow (base configuration without rhythm)
 * @author Emotive Engine Team
 * @module emotions/base/sadness
 * @complexity ⭐ Beginner-friendly
 * @audience Good example to learn emotion structure. Copy this to create new emotions.
 */

var sadness = {
    name: 'sadness',
    emoji: '😢',
    description: 'Deep melancholic sorrow',

    // Visual properties
    visual: {
        glowColor: '#4169E1',       // Royal blue melancholy
        particleRate: 6,            // Gentle rain - 6/sec with max 50 = ~8 sec particle life
        minParticles: 0,            // Can fade to emptiness
        maxParticles: 50,           // Match 3D system limit
        particleBehavior: 'falling', // Tears falling downward
        breathRate: 0.6,            // Slow, heavy breathing
        breathDepth: 0.12,          // Deep, sighing breaths
        coreJitter: false,          // Still, heavy core
        blinkRate: 0.6,             // Less frequent blinking (withdrawn)
        blinkSpeed: 0.8,            // Slower, heavier blink animation
        particleColors: [
            { color: '#4169E1', weight: 25 },  // Royal blue sorrow
            { color: '#1E90FF', weight: 20 },  // Dodger blue tears
            { color: '#6495ED', weight: 15 },  // Cornflower blue melancholy
            { color: '#B0C4DE', weight: 15 },  // Light steel blue mist
            { color: '#191970', weight: 10 },  // Midnight blue depth
            { color: '#87CEEB', weight: 10 },  // Sky blue glimmer
            { color: '#2F4F4F', weight: 5 }    // Dark slate gray shadow
        ]
    },

    // Gesture modifiers
    modifiers: {
        speed: 0.7,         // Slowed, weary pace
        amplitude: 0.6,     // Diminished movement range
        intensity: 0.8,     // Weakened emotional force
        smoothness: 1.3,    // Smooth, flowing sorrow
        regularity: 1.1,    // Slightly monotonous patterns
        addGravity: true    // Downward, heavy feeling
    },

    // Typical gestures for sadness
    typicalGestures: [
        'droop',
        'sway',
        'contract',
        'drift',
        'sink'
    ],

    // Transition configuration
    transitions: {
        duration: 800,         // Gradual mood shift
        easing: 'easeInOut',  // Smooth emotional transition
        priority: 3           // Lower emotional priority
    },

    // 3D rotation behavior and effects
    '3d': {
        rotation: {
            type: 'gentle',             // Slow, heavy drifting - melancholic
            speed: 0.7,                 // Slow rotation (matches modifiers.speed)
            axes: [0, 0.2, 0],          // Slow Y-axis drift
            musicSync: false            // Sadness doesn't sync to music
        },
        glow: {
            color: '#4169E1',           // Royal blue (matches visual.glowColor)
            intensity: 0.65,            // Dimmer subdued glow
            pulse: {
                speed: 0.6,             // Slow heavy pulsing (matches breathRate)
                range: [0.5, 0.8]       // Subtle pulse (muted)
            }
        },
        scale: {
            base: 1.0,
            breathe: {
                enabled: true,
                depth: 0.12,            // Deep sighing breaths (matches breathDepth)
                rate: 0.6               // Slow breathing (matches breathRate)
            }
        }
    },

    // Soul/energy animation parameters (geometry-agnostic)
    // Used by: Crystal (inner core), Sun (plasma flow), Moon (subtle glow pulse)
    soulAnimation: {
        driftSpeed: 0.2,        // Energy movement speed - sluggish, heavy
        shimmerSpeed: 0.3,      // Vertical pulse speed - slow, weighted
        turbulence: 0.1         // Chaos/randomness factor - minimal, subdued
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Anger Emotion Base
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Anger emotional state - intense rage (base configuration without rhythm)
 * @author Emotive Engine Team
 * @module emotions/base/anger
 * @complexity ⭐ Beginner-friendly
 * @audience Good example to learn emotion structure. Copy this to create new emotions.
 */

/**
 * Anger emotion configuration
 * Intense aggressive state with rapid, chaotic particles
 */
var anger = {
    name: 'anger',
    emoji: '😠',
    description: 'Intense rage and aggression',

    // Visual properties
    visual: {
        glowColor: '#DC143C',       // Crimson rage - more intense
        particleRate: 8,            // Aggressive flow - 8/sec with max 50 = ~6 sec particle life
        minParticles: 8,            // Maintain constant agitation
        maxParticles: 50,           // Match 3D system limit
        particleBehavior: 'aggressive', // Erratic, forceful particle movement
        breathRate: 2.2,            // Rapid, agitated breathing rhythm
        breathDepth: 0.15,          // Deep, forceful breath cycles
        coreJitter: true,           // Visual tremor from internal rage
        blinkRate: 1.6,             // More frequent blinking (agitated)
        blinkSpeed: 1.3,            // Faster, snappier blink animation
        particleColors: [
            { color: '#DC143C', weight: 25 },  // Crimson rage
            { color: '#FF0000', weight: 20 },  // Pure red fury
            { color: '#B22222', weight: 15 },  // FireBrick intensity
            { color: '#FF4500', weight: 15 },  // OrangeRed flames
            { color: '#8B0000', weight: 10 },  // Dark red depth
            { color: '#FF6347', weight: 10 },  // Tomato heat
            { color: '#660000', weight: 5 }    // Nearly black ember
        ]
    },

    // Gesture modifiers
    modifiers: {
        speed: 1.5,        // Accelerated motion for urgency
        amplitude: 1.4,    // Exaggerated movement range
        intensity: 1.3,    // Heightened force and impact
        smoothness: 0.3,   // Sharp, abrupt transitions
        regularity: 0.7,   // Erratic, unpredictable patterns
        addShake: true     // Tremor effect from rage
    },

    // Typical gestures for anger
    typicalGestures: [
        'shake',     // Violent shaking
        'vibrate',   // Angry vibration
        'expand',    // Explosive expansion
        'pulse',     // Angry pulsing
        'flicker',   // Rage flickering
        'strike'     // Strike motion
    ],

    // Transition hints
    transitions: {
        duration: 300,          // Swift state change
        easing: 'easeOutExpo',  // Explosive, sudden entrance
        priority: 8,            // High priority emotional state
        shakeOnEntry: true      // Trigger screen disturbance
    },

    // Special anger properties
    special: {
        screenShake: true,         // Environmental disturbance effect
        particleTrails: 'fire',    // Incendiary particle trail style
        glowPulse: true,          // Rhythmic aura fluctuation
        temperatureEffect: 'hot'   // Warm spectrum color shifting
    },

    // 3D rotation behavior and effects
    '3d': {
        rotation: {
            type: 'unstable',           // Trembling rage with explosive bursts
            speed: 1.5,                 // 1.5x faster than neutral rotation
            axes: [0, 0.3, 0],          // Rotation rates [X, Y, Z] - only Y-axis base spin
            shake: {
                amplitude: 0.02,        // Max safe trembling (hard-limited by RotationBehavior)
                frequency: 7.0          // Rapid vibration (7 Hz) - barely contained fury
            },
            eruption: {
                enabled: true,          // Periodic explosive bursts
                interval: 3000,         // Burst every 3 seconds
                speedMultiplier: 3.5,   // Rotation speeds up 3.5x during burst
                duration: 400           // Burst lasts 400ms
            },
            musicSync: false            // Anger doesn't sync to music - chaotic
        },
        glow: {
            color: '#DC143C',           // Crimson rage (matches visual.glowColor)
            intensity: 1.8,             // Strong burning aura
            pulse: {
                speed: 2.2,             // Rapid pulsing (matches breathRate)
                range: [0.8, 2.0]       // Pulse between 80% and 200% intensity
            }
        },
        scale: {
            base: 1.0,                  // Normal size
            breathe: {
                enabled: true,
                depth: 0.15,            // 15% size variation (matches breathDepth)
                rate: 2.2               // Rapid breathing (matches breathRate)
            }
        }
    },

    // Soul/energy animation parameters (geometry-agnostic)
    // Used by: Crystal (inner core), Sun (plasma flow), Moon (subtle glow pulse)
    soulAnimation: {
        driftSpeed: 2.0,        // Energy movement speed - aggressive, surging
        shimmerSpeed: 0.8,      // Vertical pulse speed - intense throb
        turbulence: 0.8         // Chaos/randomness factor - chaotic, unstable
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Fear Emotion Base
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Fear emotional state - anxious state with fleeing particles (base configuration without rhythm)
 * @author Emotive Engine Team
 * @module emotions/base/fear
 * @complexity ⭐ Beginner-friendly
 * @audience Good example to learn emotion structure. Copy this to create new emotions.
 */

var fear = {
    name: 'fear',
    emoji: '😨',
    description: 'Anxious state with fleeing particles',

    // Visual properties
    visual: {
        glowColor: '#8A2BE2',       // Dark violet (BlueViolet) - more ominous
        particleRate: 8,            // Anxious flow - 8/sec with max 50 = ~6 sec particle life
        minParticles: 8,            // Constant anxious presence
        maxParticles: 50,           // Match 3D system limit
        particleBehavior: 'scattering', // Particles flee outward
        breathRate: 2.5,            // Rapid, shallow breathing
        breathDepth: 0.06,          // Short, panicked breaths
        coreJitter: true,           // Trembling with anxiety
        blinkRate: 1.7,             // Very frequent blinking (anxious)
        blinkSpeed: 1.4,            // Faster blink animation (nervous)
        particleColors: [
            { color: '#8A2BE2', weight: 25 },  // Dark violet base
            { color: '#4B0082', weight: 20 },  // Indigo dread
            { color: '#9400D3', weight: 15 },  // Dark violet panic
            { color: '#6B46C1', weight: 15 },  // Deep purple anxiety
            { color: '#9932CC', weight: 10 },  // Dark orchid fear
            { color: '#E6E6FA', weight: 8 },   // Pale lavender flash
            { color: '#301934', weight: 7 }    // Almost black shadow
        ]
    },

    // Gesture modifiers
    modifiers: {
        speed: 1.4,        // Quick, reactive movements
        amplitude: 0.8,    // Restricted, defensive range
        intensity: 1.2,    // Heightened fight-or-flight response
        smoothness: 0.5,   // Jerky, startled transitions
        regularity: 0.5,   // Unpredictable panic patterns
        addJitter: true    // Nervous trembling overlay
    },

    // Typical gestures for fear
    typicalGestures: ['shake', 'vibrate', 'contract', 'flicker', 'retreat'],

    // Transition configuration
    transitions: {
        duration: 400,       // Quick fear response
        easing: 'easeOut',  // Sudden onset
        priority: 7         // High alert priority
    },

    // 3D rotation behavior and effects
    '3d': {
        rotation: {
            type: 'unstable',           // Trembling, jerky pattern - anxious shaking
            speed: 1.4,                 // Faster rotation (matches modifiers.speed)
            axes: [0, 0.3, 0],          // Only Y-axis base spin
            shake: {
                amplitude: 0.015,       // Subtle trembling (reduced to not overcome righting)
                frequency: 3.5          // Rapid shaking (higher than anger)
            },
            musicSync: false            // Fear doesn't sync to music - chaotic
        },
        glow: {
            color: '#8A2BE2',           // Dark violet (matches visual.glowColor)
            intensity: 0.9,             // Pulsing glow
            pulse: {
                speed: 2.5,             // Rapid pulsing (matches breathRate)
                range: [0.6, 1.2]       // Moderate pulse range
            }
        },
        scale: {
            base: 1.0,
            breathe: {
                enabled: true,
                depth: 0.06,            // Short panicked breaths (matches breathDepth)
                rate: 2.5               // Rapid breathing (matches breathRate)
            }
        }
    },

    // Soul/energy animation parameters (geometry-agnostic)
    // Used by: Crystal (inner core), Sun (plasma flow), Moon (subtle glow pulse)
    soulAnimation: {
        driftSpeed: 1.8,        // Energy movement speed - frantic, erratic
        shimmerSpeed: 2.5,      // Vertical pulse speed - rapid flickering
        turbulence: 0.6         // Chaos/randomness factor - nervous instability
    }

    // Note: Black hole behavior auto-derives from modifiers (speed: 1.4, intensity: 1.2, smoothness: 0.5)
    // Results in: faster disk rotation, high turbulence, stronger doppler effect, brighter shadow glow
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Surprise Emotion Base
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Surprise emotional state - sudden shock with explosive particles (base configuration without rhythm)
 * @author Emotive Engine Team
 * @module emotions/base/surprise
 * @complexity ⭐ Beginner-friendly
 * @audience Good example to learn emotion structure. Copy this to create new emotions.
 */

var surprise = {
    name: 'surprise',
    emoji: '😲',
    description: 'Sudden shock with explosive particles',

    // Visual properties
    visual: {
        glowColor: '#FFD700',       // Bright gold (shining surprise)
        particleRate: 5,            // Burst flow - 5/sec with max 15 = ~3 sec particle life
        minParticles: 0,            // Can start from nothing
        maxParticles: 15,           // Burst of shocked particles
        particleBehavior: 'burst',  // Explosive outward motion
        breathRate: 0.3,            // Gasping, held breath
        breathDepth: 0.18,          // Large shocked inhale
        coreJitter: false,          // Frozen in surprise
        blinkRate: 1.4,             // More frequent blinking (shocked)
        blinkSpeed: 1.2,            // Faster blink animation (startled)
        particleColors: [
            { color: '#FFD700', weight: 25 },  // Gold burst
            { color: '#FFA500', weight: 20 },  // Orange shock
            { color: '#FFFF00', weight: 15 },  // Yellow flash
            { color: '#FF6347', weight: 15 },  // Tomato red excitement
            { color: '#FFE4B5', weight: 10 },  // Moccasin highlight
            { color: '#FF4500', weight: 10 },  // OrangeRed pop
            { color: '#FFFACD', weight: 5 }    // LemonChiffon sparkle
        ]
    },

    // Gesture modifiers
    modifiers: {
        speed: 1.6,         // Rapid, startled reactions
        amplitude: 1.5,     // Large, exaggerated movements
        intensity: 1.4,     // Strong shock force
        smoothness: 0.7,    // Abrupt, jerky motions
        regularity: 0.8,    // Erratic surprise patterns
        addPop: true        // Popping, explosive effect
    },

    // Typical gestures for surprise
    typicalGestures: ['expand', 'bounce', 'flash', 'pulse', 'pop'],

    // Transition configuration
    transitions: {
        duration: 200,           // Instant shock response
        easing: 'easeOutBack',  // Snappy, elastic reaction
        priority: 6             // High interrupt priority
    },

    // 3D rotation behavior and effects
    '3d': {
        rotation: {
            type: 'unstable',           // Jerky, startled pattern
            speed: 1.6,                 // Rapid rotation (matches modifiers.speed)
            axes: [0, 0.45, 0],         // Fast Y-axis spin
            shake: {
                amplitude: 0.01,        // Minimal startled wobble (reduced to not overcome righting)
                frequency: 3.0          // Medium frequency jerking
            },
            musicSync: false            // Surprise is chaotic
        },
        glow: {
            color: '#FFD700',           // Bright gold (matches visual.glowColor)
            intensity: 1.8,             // Very intense flash
            pulse: {
                speed: 0.3,             // Gasping pulsing (matches breathRate)
                range: [1.0, 2.2]       // Large pulse variation (shock)
            }
        },
        scale: {
            base: 1.0,
            breathe: {
                enabled: true,
                depth: 0.18,            // Large shocked inhale (matches breathDepth)
                rate: 0.3               // Gasping breathing (matches breathRate)
            }
        }
    },

    // Soul/energy animation parameters (geometry-agnostic)
    // Used by: Crystal (inner core), Sun (plasma flow), Moon (subtle glow pulse)
    soulAnimation: {
        driftSpeed: 1.5,        // Energy movement speed - sudden, startled bursts
        shimmerSpeed: 2.0,      // Vertical pulse speed - shocked flashing
        turbulence: 0.5         // Chaos/randomness factor - unexpected variation
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Disgust Emotion Base
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Disgust emotional state - revulsion with repelling particles (base configuration without rhythm)
 * @author Emotive Engine Team
 * @module emotions/base/disgust
 * @complexity ⭐ Beginner-friendly
 * @audience Good example to learn emotion structure. Copy this to create new emotions.
 */

var disgust = {
    name: 'disgust',
    emoji: '🤢',
    description: 'Revulsion with repelling particles',

    // Visual properties
    visual: {
        glowColor: '#9ACD32',       // Sickly yellow-green (YellowGreen)
        particleRate: 4,            // Repulsive flow - 4/sec with max 12 = ~3 sec particle life
        minParticles: 5,            // Maintain visible repulsion
        maxParticles: 12,           // Controlled rejection display
        particleBehavior: 'repelling', // Particles flee from center
        breathRate: 0.7,            // Slow, queasy breathing
        breathDepth: 0.04,          // Shallow, uncomfortable breaths
        coreJitter: false,          // Stable but uneasy core
        blinkRate: 0.9,             // Slightly less frequent blinking (discomfort)
        blinkSpeed: 0.9,            // Slightly slower blink animation
        particleColors: [
            { color: '#9ACD32', weight: 25 },  // Yellow-green toxic
            { color: '#ADFF2F', weight: 20 },  // Bright acid green
            { color: '#7FFF00', weight: 15 },  // Chartreuse nausea
            { color: '#BDB76B', weight: 15 },  // Dark khaki sick
            { color: '#6B8E23', weight: 10 },  // Olive drab decay
            { color: '#CCFF00', weight: 8 },   // Fluorescent bile
            { color: '#556B2F', weight: 7 }    // Dark olive shadow
        ]
    },

    // Gesture modifiers
    modifiers: {
        speed: 0.9,        // Slightly slowed movements
        amplitude: 0.7,    // Restricted, withdrawn motion
        intensity: 0.9,    // Controlled repulsion force
        smoothness: 0.8,   // Mostly smooth with discomfort
        regularity: 1.0,   // Consistent rejection pattern
        addRecoil: true    // Recoiling motion effect
    },

    // Typical gestures for disgust
    typicalGestures: ['contract', 'shake', 'recoil', 'wobble'],

    // Transition configuration
    transitions: {
        duration: 600,       // Moderate transition speed
        easing: 'easeIn',   // Gradual onset of revulsion
        priority: 4         // Mid-level priority state
    },

    // 3D rotation behavior and effects
    '3d': {
        rotation: {
            type: 'gentle',             // Subtle wobble - uneasy motion
            speed: 0.9,                 // Slower rotation (matches modifiers.speed)
            axes: [0, 0.25, 0],         // Slower Y-axis spin
            musicSync: false            // Disgust doesn't sync to music
        },
        glow: {
            color: '#9ACD32',           // Sickly yellow-green (matches visual.glowColor)
            intensity: 1.0,             // Toxic glow
            pulse: {
                speed: 0.7,             // Slow queasy pulsing (matches breathRate)
                range: [0.7, 1.2]       // Moderate pulse
            }
        },
        scale: {
            base: 1.0,
            breathe: {
                enabled: true,
                depth: 0.04,            // Shallow uncomfortable breaths (matches breathDepth)
                rate: 0.7               // Slow breathing (matches breathRate)
            }
        }
    },

    // Soul/energy animation parameters (geometry-agnostic)
    // Used by: Crystal (inner core), Sun (plasma flow), Moon (subtle glow pulse)
    soulAnimation: {
        driftSpeed: 0.4,        // Energy movement speed - slow, unsettled
        shimmerSpeed: 0.6,      // Vertical pulse speed - queasy wavering
        turbulence: 0.35        // Chaos/randomness factor - nauseating irregularity
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Love Emotion Base
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Love emotional state - warm affection with orbiting particles (base configuration without rhythm)
 * @author Emotive Engine Team
 * @module emotions/base/love
 * @complexity ⭐ Beginner-friendly
 * @audience Good example to learn emotion structure. Copy this to create new emotions.
 */

var love = {
    name: 'love',
    emoji: '💕',
    description: 'Warm affection with orbiting particles',

    // Visual properties
    visual: {
        glowColor: '#FF1493',       // Deep passionate pink (DeepPink)
        particleRate: 6,            // Gentle flow - 6/sec with max 50 = ~8 sec particle life
        minParticles: 15,           // Constant loving presence
        maxParticles: 50,           // Match 3D system limit
        particleBehavior: 'orbiting', // Particles orbit romantically
        breathRate: 0.75,           // Slow, content breathing
        breathDepth: 0.15,          // Deep, satisfied breaths
        coreJitter: false,          // Stable, secure feeling
        blinkRate: 1.2,             // Slightly more frequent blinking (affectionate)
        blinkSpeed: 1.0,            // Normal blink animation speed
        particleColors: [
            { color: '#FF1493', weight: 30 },  // Deep passionate pink
            { color: '#FF69B4', weight: 25 },  // Hot pink
            { color: '#FF007F', weight: 15 },  // Rose red
            { color: '#FFB6C1', weight: 10 },  // Light pink highlights
            { color: '#FF45A0', weight: 10 },  // Vibrant magenta
            { color: '#E91E63', weight: 5 },   // Material pink accent
            { color: '#FFC0CB', weight: 5 }    // Soft pink glow
        ]
    },

    // Gesture modifiers
    modifiers: {
        speed: 0.9,         // Gentle, romantic pace
        amplitude: 1.1,     // Slightly expanded movements
        intensity: 1.2,     // Enhanced emotional depth
        smoothness: 1.4,    // Extra smooth, flowing motion
        regularity: 1.2,    // Consistent, rhythmic patterns
        addWarmth: true     // Warm, inviting quality
    },

    // Typical gestures for love
    typicalGestures: ['pulse', 'sway', 'orbit', 'glow', 'breathe', 'float'],

    // Transition configuration
    transitions: {
        duration: 700,         // Gradual emotional shift
        easing: 'easeInOut',  // Smooth, gentle transition
        priority: 5           // Moderate emotional priority
    },

    // 3D rotation behavior and effects
    '3d': {
        rotation: {
            type: 'gentle',             // Smooth gentle rotation (wobble-free)
            speed: 0.9,                 // Gentle rotation (matches modifiers.speed)
            axes: [0, 0.28, 0],         // Smooth Y-axis orbit
            musicSync: true             // Love syncs beautifully with music
        },
        glow: {
            color: '#FF1493',           // Deep passionate pink (matches visual.glowColor)
            intensity: 1.8,             // Strong radiant warmth
            pulse: {
                speed: 0.75,            // Slow content pulsing (matches breathRate)
                range: [1.3, 2.0]       // Strong pulse variation (heartbeat-like)
            }
        },
        scale: {
            base: 1.0,
            breathe: {
                enabled: true,
                depth: 0.15,            // Deep satisfied breaths (matches breathDepth)
                rate: 0.75              // Slow breathing (matches breathRate)
            }
        }
    },

    // Soul/energy animation parameters (geometry-agnostic)
    // Used by: Crystal (inner core), Sun (plasma flow), Moon (subtle glow pulse)
    soulAnimation: {
        driftSpeed: 0.8,        // Energy movement speed - warm, flowing
        shimmerSpeed: 1.2,      // Vertical pulse speed - heartbeat-like rhythm
        turbulence: 0.2         // Chaos/randomness factor - smooth, romantic
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Suspicion Emotion Base
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Suspicion emotional state - paranoid watchfulness with surveillance scanning (base configuration without rhythm)
 * @author Emotive Engine Team
 * @module emotions/base/suspicion
 * @complexity ⭐ Beginner-friendly
 * @audience Good example to learn emotion structure. Copy this to create new emotions.
 */

var suspicion = {
    name: 'suspicion',
    emoji: '🤨',
    description: 'Paranoid watchfulness with surveillance scanning',

    // Visual properties
    visual: {
        glowColor: '#6B46C1',       // Deep purple paranoia
        particleRate: 4,            // Watchful flow - 4/sec with max 12 = ~3 sec particle life
        minParticles: 6,            // More eyes watching
        maxParticles: 12,           // Heightened alert capacity
        particleBehavior: 'surveillance',  // NEW: Searchlight scanning behavior
        particleSpeed: 0.2,         // Base particle speed
        breathRate: 0.6,            // Slower, more deliberate breathing
        breathDepth: 0.04,          // Very shallow, tense breaths
        coreJitter: 0.02,           // Slight nervous tremor
        blinkRate: 1.1,             // Slightly more frequent blinking (watchful)
        blinkSpeed: 1.0,            // Normal blink animation speed
        particleColors: [
            { color: '#6B46C1', weight: 30 },  // Deep purple paranoia
            { color: '#4A5568', weight: 25 },  // Shadowy slate gray
            { color: '#8B4789', weight: 20 },  // Dark magenta mystery
            { color: '#9F7AEA', weight: 15 },  // Alert purple highlights
            { color: '#2D3748', weight: 10 }   // Deep shadow lurking
        ],
        // Dynamic threat level properties
        threatLevel: 0,             // 0-1 scale, updated by gaze distance
        getGlowIntensity() {
            return 0.3 + (this.threatLevel * 0.7);
        },
        getParticleSpeed() {
            return 0.2 + (this.threatLevel * 0.8);
        },
        getGlowColor() {
            // Color shifts from purple to red as threat increases
            const baseColor = { r: 107, g: 70, b: 193 };  // #6B46C1
            const alertColor = { r: 220, g: 38, b: 127 }; // #DC267F (magenta-red)

            const t = this.threatLevel || 0;

            const r = Math.round(baseColor.r + (alertColor.r - baseColor.r) * t);
            const g = Math.round(baseColor.g + (alertColor.g - baseColor.g) * t);
            const b = Math.round(baseColor.b + (alertColor.b - baseColor.b) * t);

            // Convert to hex
            const toHex = val => val.toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }
    },

    // Gesture modifiers
    modifiers: {
        speed: 0.4,         // Slower, more deliberate movements
        amplitude: 0.6,     // Smaller, controlled movements
        intensity: 1.2,     // Higher alertness
        smoothness: 0.3,    // Jerky, paranoid movements
        regularity: 0.2,    // Highly unpredictable patterns
        focus: 1.5,         // Hyper-focused attention
        addWobble: true     // Uncertain, questioning motion
    },

    // Typical gestures for suspicion
    typicalGestures: ['scan', 'twitch', 'peek', 'tilt', 'hold'],

    // Transition configuration
    transitions: {
        duration: 500,       // Moderate alertness shift
        easing: 'linear',   // Steady, controlled transition
        priority: 4         // Mid-level alert priority
    },

    // Special suspicion properties
    special: {
        coreSquint: 0.6,        // More pronounced eye narrowing
        scanInterval: 2000,     // More frequent scans
        scanDuration: 1200,     // Longer, more thorough scanning
        scanAngle: 60,          // Wider scanning range
        twitchChance: 0.02,     // 2% chance per frame to twitch
        peekInterval: 4000,     // Time between peek gestures
        maxThreatDistance: 300, // Distance for threat calculation
        alertThreshold: 0.7     // Threat level for maximum alert
    },

    // 3D rotation behavior and effects
    '3d': {
        rotation: {
            type: 'suspicious',         // Biased toward facing forward - nervous watchfulness
            speed: 1.0,                 // Normal speed for 4-second cycle
            axes: [0, 0, 0],            // Managed by suspicious behavior (sawtooth rotation)
            musicSync: false            // Suspicion doesn't sync to music
        },
        glow: {
            color: '#6B46C1',           // Deep purple paranoia
            intensity: 0.85,            // Watchful glow
            pulse: {
                speed: 0.6,             // Slow deliberate pulse (matches breathRate)
                range: [0.7, 1.0]       // Subtle pulse (tense, controlled)
            }
        },
        scale: {
            base: 1.0,
            breathe: {
                enabled: true,
                depth: 0.04,            // Very shallow breathing (matches breathDepth)
                rate: 0.6               // Slow deliberate breathing (matches breathRate)
            }
        }
    },

    // Soul/energy animation parameters (geometry-agnostic)
    // Used by: Crystal (inner core), Sun (plasma flow), Moon (subtle glow pulse)
    soulAnimation: {
        driftSpeed: 0.9,        // Energy movement speed - watchful scanning
        shimmerSpeed: 1.8,      // Vertical pulse speed - alert flickering
        turbulence: 0.4         // Chaos/randomness factor - paranoid uncertainty
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Excited Emotion Base
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Excited emotional state - high energy with rapid particles (base configuration without rhythm)
 * @author Emotive Engine Team
 * @module emotions/base/excited
 * @complexity ⭐ Beginner-friendly
 * @audience Good example to learn emotion structure. Copy this to create new emotions.
 */

var excited = {
    name: 'excited',
    emoji: '🤩',
    description: 'High energy with rapid particles',

    // Visual properties
    visual: {
        glowColor: '#FF6B35',       // Vibrant orange-red energy
        particleRate: 8,            // Energetic flow - 8/sec with max 50 = ~6 sec particle life
        minParticles: 10,           // Constant energetic particles
        maxParticles: 50,           // Match 3D system limit
        particleBehavior: 'burst',  // Explosive particle behavior
        breathRate: 2.0,            // Quick, excited breathing
        breathDepth: 0.14,          // Deep, energized breaths
        coreJitter: true,           // Vibrating with enthusiasm
        blinkRate: 1.5,             // More frequent blinking (energetic)
        blinkSpeed: 1.2,            // Faster blink animation (snappier)
        particleColors: [
            { color: '#FF6B35', weight: 25 },  // Vibrant orange energy
            { color: '#FF1744', weight: 20 },  // Red accent excitement
            { color: '#FFC107', weight: 15 },  // Amber sparkle
            { color: '#FF9100', weight: 15 },  // Deep orange burst
            { color: '#FFEB3B', weight: 10 },  // Yellow flash
            { color: '#FF5722', weight: 10 },  // Deep orange-red
            { color: '#FFF59D', weight: 5 }    // Pale yellow highlight
        ]
    },

    // Gesture modifiers
    modifiers: {
        speed: 1.4,         // Quickened, energetic pace
        amplitude: 1.3,     // Expansive, enthusiastic movements
        intensity: 1.3,     // Strong energetic force
        smoothness: 0.8,    // Smooth with energetic bursts
        regularity: 0.7,    // Spontaneous, varied patterns
        addVibration: true  // Buzzing with excitement
    },

    // Typical gestures for excitement
    typicalGestures: ['bounce', 'spin', 'vibrate', 'expand', 'shake', 'pulse'],

    // Transition configuration
    transitions: {
        duration: 300,              // Quick state entry
        easing: 'easeOutElastic',  // Bouncy, elastic entrance
        priority: 6                // High-energy priority level
    },

    // 3D rotation behavior and effects
    '3d': {
        rotation: {
            type: 'unstable',           // Vibrating pattern - buzzing with excitement
            speed: 1.4,                 // Fast rotation (matches modifiers.speed)
            axes: [0, 0.4, 0],          // Faster Y-axis spin (more energetic than neutral)
            shake: {
                amplitude: 0.01,        // Subtle vibration (reduced to not overcome righting)
                frequency: 4.0          // High-frequency buzzing
            },
            musicSync: false            // Could sync to music in future
        },
        glow: {
            color: '#FF6B35',           // Vibrant orange-red (matches visual.glowColor)
            intensity: 1.5,             // Strong energetic aura
            pulse: {
                speed: 2.0,             // Quick pulsing (matches breathRate)
                range: [1.0, 1.8]       // Strong pulse variation
            }
        },
        scale: {
            base: 1.0,
            breathe: {
                enabled: true,
                depth: 0.14,            // Deep energized breaths (matches breathDepth)
                rate: 2.0               // Quick breathing (matches breathRate)
            }
        }
    },

    // Soul/energy animation parameters (geometry-agnostic)
    // Used by: Crystal (inner core), Sun (plasma flow), Moon (subtle glow pulse)
    soulAnimation: {
        driftSpeed: 1.5,        // Energy movement speed - rapid, buzzing
        shimmerSpeed: 2.0,      // Vertical pulse speed - vibrant pulsing
        turbulence: 0.5         // Chaos/randomness factor - energetic chaos
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Resting Emotion Base
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Resting emotional state - deep relaxation with slow drift (base configuration without rhythm)
 * @author Emotive Engine Team
 * @module emotions/base/resting
 * @complexity ⭐ Beginner-friendly
 * @audience Good example to learn emotion structure. Copy this to create new emotions.
 */

var resting$1 = {
    name: 'resting',
    emoji: '😴',
    description: 'Deep relaxation with slow drift',

    // Visual properties
    visual: {
        glowColor: '#9370DB',       // Sleepy purple twilight
        particleRate: 1,            // Lazy flow - 1/sec with max 5 = ~5 sec particle life
        minParticles: 3,            // Minimal sleepy presence
        maxParticles: 5,            // Few drifting particles
        particleBehavior: 'resting', // Slow, floating behavior
        breathRate: 0.8,            // Deep, slow breathing
        breathDepth: 0.12,          // Pronounced rest breaths
        coreJitter: false,          // Perfectly still core
        blinkRate: 0.4,             // Very infrequent blinking (sleepy)
        blinkSpeed: 0.7,            // Slower, drowsy blink animation
        particleColors: [
            { color: '#9370DB', weight: 30 },  // Primary sleepy purple
            { color: '#A591C4', weight: 20 },  // Soft lavender drift
            { color: '#B366FF', weight: 20 },  // Dreamy violet accent
            { color: '#B8A1E6', weight: 15 },  // Light drowsy highlights
            { color: '#674D9B', weight: 15 }   // Deep sleep shadows
        ]
    },

    // Gesture modifiers
    modifiers: {
        speed: 0.5,         // Slowed, drowsy pace
        amplitude: 0.4,     // Minimal movement range
        intensity: 0.5,     // Reduced energy level
        smoothness: 1.4,    // Extra smooth drifting
        regularity: 0.9,    // Slightly irregular, natural rest
        addWeight: true     // Heavy, weighted feeling
    },

    // Typical gestures for resting
    typicalGestures: ['breathe', 'drift', 'sway', 'float'],

    // Transition configuration
    transitions: {
        duration: 1000,         // Slow fade to rest
        easing: 'easeInOut',   // Gentle transition
        priority: 2            // Low priority state
    },

    // 3D rotation behavior and effects
    '3d': {
        rotation: {
            type: 'gentle',             // Minimal drifting - sleeping
            speed: 0.5,                 // Very slow rotation (matches modifiers.speed)
            axes: [0, 0.15, 0],         // Minimal Y-axis drift
            musicSync: false            // Resting doesn't sync to music
        },
        glow: {
            color: '#9370DB',           // Sleepy purple (matches visual.glowColor)
            intensity: 0.8,             // Dimmed drowsy glow
            pulse: {
                speed: 0.8,             // Deep slow pulsing (matches breathRate)
                range: [0.6, 1.0]       // Subtle pulse (restful)
            }
        },
        scale: {
            base: 1.0,
            breathe: {
                enabled: true,
                depth: 0.12,            // Pronounced rest breaths (matches breathDepth)
                rate: 0.8               // Deep slow breathing (matches breathRate)
            }
        }
    },

    // Soul/energy animation parameters (geometry-agnostic)
    // Used by: Crystal (inner core), Sun (plasma flow), Moon (subtle glow pulse)
    soulAnimation: {
        driftSpeed: 0.15,       // Energy movement speed - nearly still, dreaming
        shimmerSpeed: 0.1,      // Vertical pulse speed - deep sleep rhythm
        turbulence: 0.05        // Chaos/randomness factor - peaceful stillness
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Euphoria Emotion Base
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Euphoria emotional state - radiant hope and new beginnings (base configuration without rhythm)
 * @author Emotive Engine Team
 * @module emotions/base/euphoria
 * @complexity ⭐ Beginner-friendly
 * @audience Good example to learn emotion structure. Copy this to create new emotions.
 */

var euphoria = {
    name: 'euphoria',
    emoji: '🌟',
    description: 'Radiant hope and new beginnings',

    // Visual properties
    visual: {
        glowColor: '#FFB6C1',       // Light pink euphoric glow
        particleRate: 6,            // Radiant flow - 6/sec with max 30 = ~5 sec particle life
        minParticles: 15,           // Abundant positive energy
        maxParticles: 30,           // Radiant display limit
        particleBehavior: 'radiant', // Outward radiating particles
        breathRate: 1.3,            // Elevated, joyful breathing
        breathDepth: 0.25,          // Full, satisfied breaths
        coreJitter: false,          // Stable, confident core
        blinkRate: 1.4,             // More frequent blinking (euphoric)
        blinkSpeed: 1.1,            // Slightly faster blink animation
        particleColors: [
            { color: '#FFB6C1', weight: 20 },  // Light pink bliss
            { color: '#FFD700', weight: 18 },  // Golden joy
            { color: '#87CEEB', weight: 15 },  // Sky blue serenity
            { color: '#DDA0DD', weight: 15 },  // Plum transcendence
            { color: '#98FB98', weight: 12 },  // Pale green harmony
            { color: '#FFA07A', weight: 10 },  // Light salmon warmth
            { color: '#E6E6FA', weight: 8 },   // Lavender dream
            { color: '#FFFFFF', weight: 2 }    // Pure white sparkle
        ]
    },

    // Gesture modifiers
    modifiers: {
        speed: 1.4,         // Energized, flowing pace
        amplitude: 1.5,     // Expansive, reaching movements
        intensity: 1.6,     // Powerful positive force
        smoothness: 1.3,    // Extra fluid, graceful motion
        regularity: 0.8,    // Natural variation in rhythm
        addWarmth: true,    // Warm, inviting quality
        addLift: true       // Upward, elevating tendency
    },

    // Typical gestures for euphoria
    typicalGestures: ['expand', 'radiate', 'pulse', 'glow', 'float', 'bloom'],

    // Transition configuration
    transitions: {
        duration: 600,           // Smooth emergence
        easing: 'easeOutExpo',  // Explosive, radiant entrance
        priority: 8             // High priority transcendent state
    },

    // 3D rotation behavior and effects
    '3d': {
        rotation: {
            type: 'rhythmic',           // Graceful, flowing pattern - transcendent dance
            speed: 1.4,                 // Energized rotation (matches modifiers.speed)
            axes: [0, 0.35, 0],         // Slightly faster than neutral
            musicSync: true             // Euphoria syncs beautifully with music
        },
        glow: {
            color: '#FFB6C1',           // Light pink (matches visual.glowColor)
            intensity: 1.2,             // Bright radiance
            pulse: {
                speed: 1.3,             // Elevated pulsing (matches breathRate)
                range: [0.9, 1.5]       // Graceful pulse variation
            }
        },
        scale: {
            base: 1.0,
            breathe: {
                enabled: true,
                depth: 0.25,            // Full satisfied breaths (matches breathDepth)
                rate: 1.3               // Elevated breathing (matches breathRate)
            }
        }
    },

    // Soul/energy animation parameters (geometry-agnostic)
    // Used by: Crystal (inner core), Sun (plasma flow), Moon (subtle glow pulse)
    soulAnimation: {
        driftSpeed: 1.8,        // Energy movement speed - radiant, flowing
        shimmerSpeed: 2.5,      // Vertical pulse speed - transcendent pulsing
        turbulence: 0.7         // Chaos/randomness factor - ecstatic variation
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Focused Emotion Base
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Focused emotional state - intense concentration with directed flow (base configuration without rhythm)
 * @author Emotive Engine Team
 * @module emotions/base/focused
 * @complexity ⭐ Beginner-friendly
 * @audience Good example to learn emotion structure. Copy this to create new emotions.
 */

var focused = {
    name: 'focused',
    emoji: '🎯',
    description: 'Intense concentration with directed flow',

    // Visual properties
    visual: {
        glowColor: '#00CED1',       // Sharp cyan concentration
        particleRate: 4,            // Focused flow - 4/sec with max 12 = ~3 sec particle life
        minParticles: 5,            // Consistent focus presence
        maxParticles: 12,           // Controlled attention display
        particleBehavior: 'directed', // Particles follow target
        breathRate: 1.2,            // Steady, measured breathing
        breathDepth: 0.08,          // Controlled, regular breaths
        coreJitter: true,           // Minimal tracking adjustments
        blinkRate: 0.7,             // Less frequent blinking (concentrating)
        blinkSpeed: 1.0,            // Normal blink animation speed
        particleColors: [
            { color: '#00CED1', weight: 30 },  // Primary focused cyan
            { color: '#4A9FA0', weight: 20 },  // Muted concentration tone
            { color: '#00FFFF', weight: 20 },  // Bright attention burst
            { color: '#5FE5E7', weight: 15 },  // Light focus highlights
            { color: '#006B6D', weight: 15 }   // Deep concentration base
        ],
        eyeOpenness: 0.7,           // Narrowed for concentration
        microAdjustments: true      // Subtle tracking movements
    },

    // Gesture modifiers
    modifiers: {
        speed: 1.0,         // Baseline, deliberate pace
        amplitude: 0.9,     // Controlled movement range
        intensity: 1.1,     // Enhanced focus strength
        smoothness: 1.1,    // Precise, smooth tracking
        regularity: 1.2,    // Consistent, predictable patterns
        addPrecision: true  // Enhanced accuracy mode
    },

    // Typical gestures for focus
    typicalGestures: ['track', 'lock', 'scan', 'pulse', 'vibrate'],

    // Transition configuration
    transitions: {
        duration: 400,       // Moderate focus shift
        easing: 'easeIn',   // Gradual concentration
        priority: 5         // Mid-level attention priority
    },

    // Core appearance parameters
    getCoreParams(_state) {
        return {
            scaleX: 1.1,              // Slightly widened awareness
            scaleY: 0.7,              // Narrowed for concentration
            eyeOpenness: 0.7,         // Focused gaze intensity
            eyeExpression: 'focused', // Concentrated expression
            pupilOffset: { x: 0, y: 0 }, // Centered attention
            microAdjustments: true    // Small tracking movements
        };
    },

    // 3D rotation behavior and effects
    '3d': {
        rotation: {
            type: 'still',              // Minimal rotation - locked concentration
            speed: 0.5,                 // Very slow rotation
            axes: [0, 0.1, 0],          // Minimal Y-axis drift
            musicSync: false            // Focus doesn't sync to music
        },
        glow: {
            color: '#00CED1',           // Sharp cyan (matches visual.glowColor)
            intensity: 1.2,             // Clear defined aura
            pulse: {
                speed: 1.2,             // Steady pulsing (matches breathRate)
                range: [1.0, 1.3]       // Subtle pulse (controlled)
            }
        },
        scale: {
            base: 1.0,
            breathe: {
                enabled: true,
                depth: 0.08,            // Controlled breaths (matches breathDepth)
                rate: 1.2               // Steady breathing (matches breathRate)
            }
        }
    },

    // Soul/energy animation parameters (geometry-agnostic)
    // Used by: Crystal (inner core), Sun (plasma flow), Moon (subtle glow pulse)
    soulAnimation: {
        driftSpeed: 0.6,        // Energy movement speed - steady, directed
        shimmerSpeed: 0.2,      // Vertical pulse speed - minimal distraction
        turbulence: 0.1         // Chaos/randomness factor - laser-focused precision
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Glitch Emotion Base (Simplified)
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Glitch emotional state - surprised sadness with rainbow colors and glitch wiggle (base configuration without rhythm)
 * @author Emotive Engine Team
 * @module emotions/base/glitch
 * @complexity ⭐ Beginner-friendly
 * @audience Good example to learn emotion structure. Copy this to create new emotions.
 */

var glitch = {
    name: 'glitch',
    emoji: '🌈',
    description: 'Surprised sadness with rainbow colors and glitch wiggle',

    // Visual properties - simplified combination of surprise + sadness
    visual: {
        primaryColor: '#FF6B9D',    // Pink surprise
        glowColor: '#4169E1',       // Blue sadness
        glowIntensity: 1.2,         // Moderate intensity (surprise + sadness)
        particleRate: 5,            // Glitchy flow - 5/sec with max 15 = ~3 sec particle life
        minParticles: 5,            // Some constant presence
        maxParticles: 15,           // Moderate burst
        particleBehavior: 'burst',  // Simplified from spaz to burst
        particleSpeed: 1.0,         // Moderate speed
        breathRate: 0.4,            // Between surprise (0.3) and sadness (0.6)
        breathDepth: 0.15,          // Between surprise (0.18) and sadness (0.12)
        coreJitter: false,          // No core shake
        coreSize: 1.0,              // Normal size
        eyeOpenness: 0.8,           // Wide but not fully open
        blinkRate: 1.3,             // More frequent blinking (erratic)
        blinkSpeed: 1.2,            // Faster blink animation (glitchy)
        particleColors: [
            // Enhanced rainbow colors - more vibrant and balanced
            { color: '#FF0080', weight: 18 },  // Bright magenta
            { color: '#00FF80', weight: 18 },  // Bright green
            { color: '#8000FF', weight: 18 },  // Bright purple
            { color: '#FF8000', weight: 15 },  // Bright orange
            { color: '#0080FF', weight: 15 },  // Bright blue
            { color: '#FFFF00', weight: 10 },  // Bright yellow
            { color: '#FF6B9D', weight: 6 }    // Pink surprise
        ],
        // Glitch wiggle effect for particles
        particleGlitchWiggle: true,
        glitchWiggleIntensity: 0.3,
        glitchWiggleFrequency: 0.1
    },

    // Gesture modifiers - simplified
    modifiers: {
        speed: 1.1,         // Moderate speed
        amplitude: 1.0,      // Normal range
        intensity: 1.1,      // Slightly elevated
        smoothness: 0.8,     // Somewhat jerky
        regularity: 0.7,     // Somewhat erratic
        focus: 0.6           // Somewhat scattered
    },

    // Typical gestures - simplified
    typicalGestures: ['bounce', 'sway', 'pulse', 'drift', 'flash'],

    // Transition configuration - simplified
    transitions: {
        duration: 300,          // Moderate transition
        easing: 'easeInOut',    // Smooth transition
        priority: 5             // Medium priority
    },

    // 3D rotation behavior and effects
    '3d': {
        rotation: {
            type: 'unstable',           // Glitchy, erratic pattern
            speed: 1.1,                 // Moderate speed (matches modifiers.speed)
            axes: [0, 0.35, 0],         // Moderate Y-axis spin
            shake: {
                amplitude: 0.02,        // Moderate glitch wobble (reduced to not overcome righting)
                frequency: 5.0          // Very high frequency glitching
            },
            musicSync: false            // Glitch is chaotic
        },
        glow: {
            color: '#FF6B9D',           // Pink surprise (matches visual.primaryColor)
            intensity: 1.2,             // Moderate intensity
            pulse: {
                speed: 0.4,             // Slow pulsing (matches breathRate)
                range: [0.8, 1.6]       // Wide pulse variation (glitchy)
            }
        },
        scale: {
            base: 1.0,
            breathe: {
                enabled: true,
                depth: 0.15,            // Moderate breaths (matches breathDepth)
                rate: 0.4               // Slow breathing (matches breathRate)
            }
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Calm Emotion Base
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Calm emotional state - serene and peaceful (base configuration without rhythm)
 * @author Emotive Engine Team
 * @module emotions/base/calm
 * @complexity ⭐ Beginner-friendly
 * @audience Good example to learn emotion structure. Copy this to create new emotions.
 */

/**
 * Calm emotion configuration
 * A state of deep tranquility and inner peace
 */
var calm = {
    name: 'calm',
    emoji: '😌',
    description: 'Serene, peaceful state with gentle movements',

    // Visual properties
    visual: {
        glowColor: '#66D9CC',        // Bright mint/turquoise (more distinct from neutral blue)
        particleRate: 6,             // Peaceful flow - 6/sec with max 50 = ~8 sec particle life
        minParticles: 10,            // Keep some particles always
        maxParticles: 50,            // Match 3D system limit
        particleBehavior: 'zen',     // Zen orbital behavior
        breathRate: 0.4,             // Much slower breathing than neutral (1.0)
        breathDepth: 0.12,           // Deeper breaths than neutral (0.08)
        coreJitter: false,           // Perfectly still core
        blinkRate: 0.8,              // Less frequent blinking (relaxed)
        blinkSpeed: 1.0,             // Normal blink animation speed
        particleColors: [
            { color: '#66D9CC', weight: 35 },  // Bright turquoise
            { color: '#99E6D9', weight: 25 },  // Light mint
            { color: '#40BFB3', weight: 20 },  // Medium teal
            { color: '#B3F2E6', weight: 15 },  // Pale mint
            { color: '#339980', weight: 5 }    // Deep teal shadow
        ]
    },

    // Gesture modifiers
    modifiers: {
        speed: 0.5,         // Much slower than neutral (1.0)
        amplitude: 0.3,     // Significantly reduced motion range
        intensity: 0.4,     // Very gentle force level
        smoothness: 2.0,    // Much smoother than neutral
        regularity: 1.5,    // More consistent patterns
        addWeight: false,   // Light, floating feeling
        floatHeight: 0.2,   // Minimal floating height
        swayAmount: 0.15,   // Very minimal side-to-side sway
        duration: 1.5       // Extend gesture duration
    },

    // Typical gestures for this emotion
    typicalGestures: [
        'breathe',   // Deep, slow breathing
        'float',     // Gentle floating
        'drift',     // Slow drifting
        'idle'       // Peaceful idle state
    ],

    // Transition hints
    transitions: {
        duration: 800,           // Slower transition into calm
        easing: 'easeInOutSine', // Very smooth sine curve
        priority: 1              // Low-medium priority
    },

    // Movement patterns
    movement: {
        floatPattern: 'sine_slow',     // Slow sine wave floating
        floatPeriod: 6000,              // 6 second float cycle
        floatAmplitude: 8,              // 8 pixel vertical range
        swayPattern: 'gentle',          // Gentle side sway
        swayPeriod: 8000,               // 8 second sway cycle
        swayAmplitude: 5,               // 5 pixel horizontal range
        microMovements: false           // No jittery movements
    },

    /**
     * Get core rendering parameters
     * @param {Object} state - Current renderer state
     * @returns {Object} Core rendering configuration
     */
    getCoreParams(state) {
        const time = state.time || Date.now();
        const breathPhase = Math.sin(time * 0.0006) * 0.5 + 0.5; // Very slow breathing

        return {
            scaleX: 1.0 - (breathPhase * 0.02),  // Very subtle breathing scale
            scaleY: 1.0 - (breathPhase * 0.02),
            eyeOpenness: 0.85,                   // Relaxed eyes
            eyeExpression: 'serene',             // New serene expression
            pupilOffset: {
                x: Math.sin(time * 0.0003) * 2,  // Slow, minimal eye movement
                y: Math.cos(time * 0.0004) * 1
            },
            glowPulse: 0.95 + (breathPhase * 0.05)  // Very subtle glow pulse
        };
    },

    /**
     * Optional: Custom particle behavior for calm state
     * @param {Object} particle - Particle to update
     * @param {number} deltaTime - Time since last update
     */
    updateParticle(particle, deltaTime) {
        // Super slow drift
        particle.x += Math.sin(particle.life * 0.001) * 0.1;
        particle.y -= deltaTime * 0.02; // Very slow rise

        // Gentle fade based on life
        particle.opacity = Math.sin(particle.life * 0.002) * 0.3 + 0.2;

        // Slow size pulse
        particle.size = particle.baseSize * (1 + Math.sin(particle.life * 0.001) * 0.2);
    },

    /**
     * Optional: Custom core rendering
     * @param {CanvasRenderingContext2D} _ctx - Canvas context
     * @param {number} _x - Center X
     * @param {number} _y - Center Y
     * @param {number} _radius - Core radius
     * @returns {boolean} True if custom rendering was done
     */
    renderCore(_ctx, _x, _y, _radius) {
        // Return false to use default rendering with parameters
        return false;
    },

    // 3D rotation behavior and effects
    '3d': {
        rotation: {
            type: 'gentle',             // Smooth slow spin
            speed: 0.5,                 // 0.5x slower rotation (matches modifiers.speed)
            axes: [0, 0.3, 0],          // Rotation rates [X, Y, Z] - 0.3 rad/sec base (speed 0.5x = 0.15 rad/sec actual)
            musicSync: true             // Can sync to slow ambient music
        },
        glow: {
            color: '#66D9CC',           // Bright turquoise/mint
            intensity: 0.6,             // Softer glow
            pulse: {
                speed: 0.4,             // Very slow pulsing (matches breathRate)
                range: [0.5, 0.7]       // Gentle pulse between 50% and 70%
            }
        },
        scale: {
            base: 1.0,
            breathe: {
                enabled: true,
                depth: 0.12,            // 12% size variation (matches breathDepth)
                rate: 0.4               // Very slow breathing (matches breathRate)
            }
        }
    },

    // Soul/energy animation parameters (geometry-agnostic)
    // Used by: Crystal (inner core), Sun (plasma flow), Moon (subtle glow pulse)
    soulAnimation: {
        driftSpeed: 0.3,        // Energy movement speed - serene, peaceful
        shimmerSpeed: 0.4,      // Vertical pulse speed - deep, meditative
        turbulence: 0.1         // Chaos/randomness factor - tranquil stillness
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Emotion Registry
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Central emotion registry with full plugin support
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module emotions
 * @complexity ⭐⭐ Intermediate
 * @audience Modify this to register new emotions or change emotion loading logic
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Central registry for modular emotion system with plugin adapter integration.
 * ║ • Core emotions are loaded synchronously at startup
 * ║ • Plugin emotions can be registered dynamically via adapter
 * ║ • Each emotion is self-contained with visual, gesture, and transition data
 * ║ • Value-agnostic design allows easy tuning without code changes
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


// Registry to store all registered emotions
const emotionRegistry = new Map();

// Emotion aliases for compatibility
const emotionAliases = {
    'happy': 'joy',
    'peaceful': 'calm',
    'curious': 'surprise',
    'frustrated': 'anger',
    'sad': 'sadness',
    'excitement': 'excited'
};

// Register all emotions SYNCHRONOUSLY
[neutral, joy, sadness, anger, fear, surprise, disgust,
    love, suspicion, excited, resting$1, euphoria, focused, glitch, calm].forEach(emotion => {
    if (emotion && emotion.name) {
        emotionRegistry.set(emotion.name, emotion);
    }
});

/**
 * Get emotion configuration by name (checks both core and plugin emotions)
 * @param {string} emotionName - Name of the emotion (or alias)
 * @returns {Object|null} The emotion configuration or null if not found
 */
function getEmotion(emotionName) {
    // Check aliases first
    const resolvedName = emotionAliases[emotionName] || emotionName;

    // Check core emotions
    const coreEmotion = emotionRegistry.get(resolvedName);
    if (coreEmotion) {
        return coreEmotion;
    }

    // Check plugin emotions
    const pluginEmotion = pluginAdapter$2.getPluginEmotion(resolvedName);
    if (pluginEmotion) {
        return pluginEmotion;
    }

    return null;
}

/**
 * Get emotion parameters (visual properties) with dynamic evaluation
 * @param {string} emotionName - Name of the emotion
 * @returns {Object} Visual parameters for the emotion
 */
function getEmotionVisualParams(emotionName) {
    const emotion = getEmotion(emotionName);
    if (!emotion) {
        return getEmotion('neutral').visual;
    }

    // Make sure visual exists
    if (!emotion.visual) {
        return {};
    }
    
    // Create a copy of visual properties, excluding functions
    const {visual} = emotion;
    const params = {};
    
    // Copy non-function properties
    for (const key in visual) {
        if (typeof visual[key] !== 'function') {
            params[key] = visual[key];
        }
    }
    
    // Evaluate dynamic functions if they exist and override static values
    if (typeof visual.getGlowIntensity === 'function') {
        params.glowIntensity = visual.getGlowIntensity();
    }
    
    if (typeof visual.getParticleSpeed === 'function') {
        params.particleSpeed = visual.getParticleSpeed();
    }
    
    if (typeof visual.getParticleRate === 'function') {
        params.particleRate = visual.getParticleRate();
    }
    
    if (typeof visual.getGlowColor === 'function') {
        params.glowColor = visual.getGlowColor();
    }
    
    return params;
}

/**
 * Get emotion modifiers (gesture adjustments)
 * @param {string} emotionName - Name of the emotion
 * @returns {Object} Gesture modifiers for the emotion
 */
function getEmotionModifiers(emotionName) {
    const emotion = getEmotion(emotionName);
    if (!emotion) {
        return getEmotion('neutral').modifiers;
    }
    return emotion.modifiers;
}

/**
 * Get list of available emotions (core and plugin)
 * @returns {Array<string>} List of emotion names
 */
function listEmotions() {
    const coreEmotions = Array.from(emotionRegistry.keys());
    const pluginEmotions = pluginAdapter$2.getAllPluginEmotions();
    return [...coreEmotions, ...pluginEmotions];
}

/**
 * Get emotion transition parameters
 * @param {string} fromEmotion - Starting emotion
 * @param {string} toEmotion - Target emotion
 * @returns {Object} Transition parameters
 */
function getTransitionParams(fromEmotion, toEmotion) {
    const from = getEmotion(fromEmotion);
    const to = getEmotion(toEmotion);
    
    if (!from || !to) {
        return {
            duration: 1000,
            easing: 'ease-in-out'
        };
    }
    
    // Check if 'to' emotion has specific transition hints
    if (to.transitions && to.transitions[fromEmotion]) {
        return to.transitions[fromEmotion];
    }
    
    // Use default transition
    return {
        duration: 1000,
        easing: 'ease-in-out',
        gesture: to.transitions?.defaultGesture || null
    };
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - 3D Blink Animator
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Emotion-aware blink animation system for 3D geometries
 * @author Emotive Engine Team
 * @module 3d/animation/BlinkAnimator
 *
 * Manages:
 * - Geometry-specific blink behaviors
 * - Emotion-modulated timing and speed
 * - Smooth blink animations with playful accents
 */


class BlinkAnimator {
    constructor(geometryConfig, options = {}) {
        // Geometry-specific blink config
        this.blinkConfig = geometryConfig.blink || this.getDefaultBlinkConfig();
        this.currentGeometryType = null;

        // Timing (modulated by emotion)
        this.baseDuration = this.blinkConfig.duration || 150;
        this.baseMinInterval = 3000;  // 3 seconds
        this.baseMaxInterval = 7000;  // 7 seconds

        // Current emotion modifiers
        this.emotionBlinkRate = 1.0;   // Affects interval between blinks
        this.emotionBlinkSpeed = 1.0;  // Affects blink animation speed

        // State
        this.isBlinking = false;
        this.blinkTimer = 0;
        this.nextBlinkTime = this.getRandomBlinkTime();
        this.enabled = true;

        // Animation state
        this.blinkProgress = 0;  // 0→1 (linear progress through blink)
    }

    /**
     * Update emotion modifiers when emotion changes
     * @param {string} emotionName - Name of the emotion
     */
    setEmotion(emotionName) {
        const emotion = getEmotion(emotionName);
        this.emotionBlinkRate = emotion?.visual?.blinkRate || 1.0;
        this.emotionBlinkSpeed = emotion?.visual?.blinkSpeed || 1.0;
    }

    /**
     * Update geometry config when shape changes
     * @param {Object} geometryConfig - Geometry configuration with blink settings
     */
    setGeometry(geometryConfig) {
        this.blinkConfig = geometryConfig.blink || this.getDefaultBlinkConfig();
        this.baseDuration = this.blinkConfig.duration || 150;
    }

    /**
     * Main update loop
     * @param {number} deltaTime - Time since last frame in ms
     * @returns {Object} Current blink state
     */
    update(deltaTime) {
        if (!this.enabled) return this.getIdleState();

        if (this.isBlinking) {
            // Update blink animation
            this.blinkTimer += deltaTime;
            const duration = this.baseDuration / this.emotionBlinkSpeed;

            if (this.blinkTimer >= duration) {
                this.completeBlink();
                return this.getIdleState();
            }

            // Calculate progress (0→1)
            const rawProgress = this.blinkTimer / duration;
            this.blinkProgress = rawProgress;

            return this.getBlinkState();
        } else {
            // Wait for next blink
            if (Date.now() >= this.nextBlinkTime) {
                this.startBlink();
                return this.getBlinkState();
            }

            return this.getIdleState();
        }
    }

    /**
     * Start blink animation
     */
    startBlink() {
        if (!this.enabled) return;
        this.isBlinking = true;
        this.blinkTimer = 0;
        this.blinkProgress = 0;
    }

    /**
     * Complete blink and schedule next
     */
    completeBlink() {
        this.isBlinking = false;
        this.blinkTimer = 0;
        this.blinkProgress = 0;
        this.nextBlinkTime = Date.now() + this.getRandomBlinkTime();
    }

    /**
     * Get random interval until next blink (emotion-modulated)
     * @returns {number} Time in milliseconds
     */
    getRandomBlinkTime() {
        const min = this.baseMinInterval / this.emotionBlinkRate;
        const max = this.baseMaxInterval / this.emotionBlinkRate;
        return min + Math.random() * (max - min);
    }

    /**
     * Calculate current blink animation state
     * @returns {Object} Blink state with scale, rotation, glow
     */
    getBlinkState() {
        const config = this.blinkConfig;

        // Sine wave: 0→1→0 (smooth blink curve)
        const sineCurve = Math.sin(this.blinkProgress * Math.PI);

        // Apply playful accents if configured
        let playfulMultiplier = 1.0;
        if (config.playful) {
            // Anticipation (first 10%)
            if (this.blinkProgress < 0.1) {
                const anticipationPhase = this.blinkProgress / 0.1;
                const anticipation = Math.sin(anticipationPhase * Math.PI);
                playfulMultiplier -= anticipation * config.playful.anticipation;
            }
            // Overshoot (last 20%)
            else if (this.blinkProgress > 0.8) {
                const overshootPhase = (this.blinkProgress - 0.8) / 0.2;
                const overshoot = Math.sin(overshootPhase * Math.PI);
                playfulMultiplier += overshoot * config.playful.overshoot;
            }
        }

        const blinkAmount = sineCurve * playfulMultiplier;

        // Calculate scale based on geometry config
        const scale = [
            1.0 - (1.0 - config.scaleAxis[0]) * blinkAmount,
            1.0 - (1.0 - config.scaleAxis[1]) * blinkAmount,
            1.0 - (1.0 - config.scaleAxis[2]) * blinkAmount
        ];

        // Optional rotation
        let rotation = null;
        if (config.rotation) {
            rotation = [
                config.rotation[0] * blinkAmount,
                config.rotation[1] * blinkAmount,
                config.rotation[2] * blinkAmount
            ];
        }

        // Optional glow boost
        let glowBoost = 0;
        if (config.glowBoost) {
            glowBoost = config.glowBoost * blinkAmount;
        }

        return {
            isBlinking: true,
            progress: this.blinkProgress,
            scale,
            rotation,
            glowBoost
        };
    }

    /**
     * Get idle state (no blink)
     * @returns {Object} Idle state
     */
    getIdleState() {
        return {
            isBlinking: false,
            progress: 0,
            scale: [1, 1, 1],
            rotation: null,
            glowBoost: 0
        };
    }

    /**
     * Default blink config fallback
     * @returns {Object} Default blink configuration
     */
    getDefaultBlinkConfig() {
        return {
            type: 'vertical-squish',
            duration: 150,
            scaleAxis: [1.0, 0.3, 1.0],
            curve: 'sine'
        };
    }

    /**
     * Pause blinks (during geometry morph, etc.)
     */
    pause() {
        this.enabled = false;
        if (this.isBlinking) {
            this.completeBlink();
        }
    }

    /**
     * Resume blinks
     */
    resume() {
        this.enabled = true;
        this.nextBlinkTime = Date.now() + this.getRandomBlinkTime();
    }

    /**
     * Get current state for debugging
     * @returns {Object} Current animator state
     */
    getState() {
        return {
            isBlinking: this.isBlinking,
            enabled: this.enabled,
            blinkProgress: this.blinkProgress,
            emotionBlinkRate: this.emotionBlinkRate,
            emotionBlinkSpeed: this.emotionBlinkSpeed,
            nextBlinkTime: this.nextBlinkTime
        };
    }

    /**
     * Cleanup all resources
     */
    destroy() {
        this.blinkConfig = null;
        this.enabled = false;
        this.isBlinking = false;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Rhythm Core
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 * 
 * @fileoverview Core rhythm timing engine for musical synchronization
 * @author Emotive Engine Team
 * @module core/rhythm
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║ CONCEPT                                                                           
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Central timing engine that provides musical time references to all subsystems.    
 * ║ Does NOT dictate what animations do - only provides timing information.           
 * ║ Each subsystem maintains its own rhythm configuration in its files.              
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 * 
 * ARCHITECTURE:
 * • Provides beat events and musical time references
 * • Supports multiple time signatures and tempo changes
 * • Enables audio synchronization from external sources
 * • Each gesture/emotion/behavior defines its own rhythm response
 * 
 * ┌──────────────────────────────────────────────────────────────────────────────────┐
 * │  TIMING FLOW                                                                      │
 * │                                                                                   │
 * │  Audio Input ──┐                                                                 │
 * │                ↓                                                                  │
 * │  [Rhythm Engine] ← Internal Clock                                                │
 * │        ↓                                                                          │
 * │   Beat Events → Subsystems (each with own rhythm config)                        │
 * │                                                                                   │
 * └──────────────────────────────────────────────────────────────────────────────────┘
 */

class RhythmEngine {
    constructor() {
        // Core timing properties
        this.bpm = 120;                    // Default BPM (beats per minute)
        this.timeSignature = [4, 4];       // Default 4/4 time
        this.isPlaying = false;            // Whether rhythm is active
        
        // Musical time tracking
        this.startTime = 0;                // When rhythm started
        this.currentBeat = 0;              // Current beat number
        this.currentBar = 0;               // Current bar/measure number
        this.beatProgress = 0;             // Progress within current beat (0-1)
        this.barProgress = 0;              // Progress within current bar (0-1)
        
        // Timing calculations
        this.beatDuration = 60000 / this.bpm;  // Milliseconds per beat
        this.barDuration = this.beatDuration * this.timeSignature[0];
        this.lastBeatTime = 0;             // Timestamp of last beat
        this.nextBeatTime = 0;             // Timestamp of next beat
        
        // Event listeners
        this.listeners = new Map();        // Event type -> Set of callbacks
        this.beatCallbacks = new Set();    // Callbacks for every beat
        this.barCallbacks = new Set();     // Callbacks for every bar
        
        // Subdivisions for finer timing
        this.subdivisions = {
            sixteenth: 0,    // 16th note position
            eighth: 0,       // 8th note position
            triplet: 0,      // Triplet position
            swing: 0         // Swing timing offset
        };
        
        // Sync state
        this.audioSync = null;             // External audio sync source
        this.syncOffset = 0;               // Timing offset for sync
        this.autoSync = false;             // Auto-detect tempo from audio
        
        // Musical dynamics
        this.intensity = 1.0;              // Current musical intensity (0-1)
        this.groove = 0;                   // Groove/swing amount (0-1)
        this.humanize = 0.05;              // Timing humanization factor
        
        // Pattern tracking
        this.patterns = new Map();         // Named rhythm patterns
        this.currentPattern = null;        // Active rhythm pattern
        
        // Initialize default patterns
        this.initializePatterns();
    }
    
    /**
     * Initialize default rhythm patterns
     */
    initializePatterns() {
        // Basic patterns - these are just timing references
        // Actual animations define their own responses to these patterns
        
        // Common time signatures
        this.patterns.set('4/4', {
            name: '4/4',
            description: 'Common time - 4 beats per bar',
            timeSignature: [4, 4],
            groove: 0,
            accents: [1, 0.5, 0.7, 0.5]  // Beat emphasis pattern
        });
        
        this.patterns.set('straight', {
            name: 'straight',
            description: 'Straight, even timing',
            groove: 0,
            accents: [1, 0.5, 0.7, 0.5]  // Beat emphasis pattern
        });
        
        this.patterns.set('swing', {
            name: 'swing',
            description: 'Swing/shuffle timing',
            groove: 0.67,  // 2:1 swing ratio
            accents: [1, 0.3, 0.8, 0.3]
        });
        
        this.patterns.set('3/4', {
            name: '3/4',
            description: 'Waltz time - 3 beats per bar',
            timeSignature: [3, 4],
            accents: [1, 0.5, 0.5]
        });
        
        this.patterns.set('waltz', {
            name: 'waltz',
            description: '3/4 waltz timing',
            timeSignature: [3, 4],
            accents: [1, 0.5, 0.5]
        });
        
        this.patterns.set('6/8', {
            name: '6/8',
            description: 'Compound duple time',
            timeSignature: [6, 8],
            accents: [1, 0.3, 0.3, 0.7, 0.3, 0.3]
        });
        
        this.patterns.set('5/4', {
            name: '5/4',
            description: 'Complex meter - 5 beats per bar',
            timeSignature: [5, 4],
            accents: [1, 0.5, 0.6, 0.5, 0.7]
        });
        
        this.patterns.set('7/8', {
            name: '7/8',
            description: 'Irregular meter',
            timeSignature: [7, 8],
            accents: [1, 0.5, 0.5, 0.7, 0.5, 0.5, 0.6]
        });
        
        this.patterns.set('dubstep', {
            name: 'dubstep',
            description: 'Dubstep half-time feel',
            accents: [0.2, 0.2, 1, 0.2],  // Heavy on beat 3
            subdivisions: { wobble: true }
        });
        
        this.patterns.set('breakbeat', {
            name: 'breakbeat',
            description: 'Broken beat pattern',
            accents: [1, 0.2, 0.7, 0.9, 0.2, 0.8, 0.4, 0.2]
        });
    }
    
    /**
     * Start the rhythm engine
     */
    start() {
        if (this.isPlaying) return;

        this.isPlaying = true;
        this.isRunning = true; // Add explicit running flag
        this.startTime = performance.now();
        this.lastBeatTime = this.startTime;
        this.nextBeatTime = this.startTime + this.beatDuration;
        this.currentBeat = 0;
        this.currentBar = 0;

        // Emit start event
        this.emit('start', {
            bpm: this.bpm,
            timeSignature: this.timeSignature,
            pattern: this.currentPattern
        });

        // Start update loop
        this.update();
    }
    
    /**
     * Stop the rhythm engine
     */
    stop() {
        if (!this.isPlaying) return;
        
        this.isPlaying = false;
        this.emit('stop', {
            totalBeats: this.currentBeat,
            totalBars: this.currentBar
        });
    }
    
    /**
     * Main update loop
     */
    update() {
        if (!this.isPlaying) return;
        
        const now = performance.now();
        const elapsed = now - this.startTime;
        
        // Calculate musical time positions
        const beatsSinceStart = elapsed / this.beatDuration;
        const newBeat = Math.floor(beatsSinceStart);
        this.beatProgress = beatsSinceStart % 1;
        
        // Check for beat change
        if (newBeat > this.currentBeat) {
            this.onBeat(newBeat);
        }
        
        // Calculate bar position
        const newBar = Math.floor(newBeat / this.timeSignature[0]);
        if (newBar > this.currentBar) {
            this.onBar(newBar);
        }
        
        this.currentBeat = newBeat;
        this.currentBar = newBar;
        this.barProgress = (newBeat % this.timeSignature[0]) / this.timeSignature[0];
        
        // Calculate subdivisions
        this.updateSubdivisions();
        
        // Emit continuous update
        this.emit('update', this.getTimeInfo());
        
        // Continue loop only if still playing
        if (this.isPlaying) {
            requestAnimationFrame(() => this.update());
        }
    }
    
    /**
     * Handle beat event
     */
    onBeat(beatNumber) {
        const beatInBar = beatNumber % this.timeSignature[0];
        const accent = this.getAccent(beatInBar);
        
        // Add humanization
        const humanTiming = this.humanize * (Math.random() - 0.5) * this.beatDuration;
        
        const beatInfo = {
            beat: beatNumber,
            beatInBar,
            bar: this.currentBar,
            accent,
            intensity: this.intensity * accent,
            humanTiming,
            timestamp: performance.now()
        };
        
        // Emit beat event
        this.emit('beat', beatInfo);
        
        // Call beat callbacks
        this.beatCallbacks.forEach(callback => callback(beatInfo));
        
        // Update timing
        this.lastBeatTime = performance.now();
        this.nextBeatTime = this.lastBeatTime + this.beatDuration;
    }
    
    /**
     * Handle bar event
     */
    onBar(barNumber) {
        const barInfo = {
            bar: barNumber,
            timeSignature: this.timeSignature,
            pattern: this.currentPattern,
            timestamp: performance.now()
        };
        
        // Emit bar event
        this.emit('bar', barInfo);
        
        // Call bar callbacks
        this.barCallbacks.forEach(callback => callback(barInfo));
    }
    
    /**
     * Update subdivision timings
     */
    updateSubdivisions() {
        // Calculate subdivision positions within beat
        this.subdivisions.sixteenth = (this.beatProgress * 4) % 1;
        this.subdivisions.eighth = (this.beatProgress * 2) % 1;
        this.subdivisions.triplet = (this.beatProgress * 3) % 1;
        
        // Apply swing/groove
        if (this.groove > 0) {
            const swingRatio = 0.5 + this.groove * 0.17; // Max 67% swing
            if (this.subdivisions.eighth < 0.5) {
                this.subdivisions.swing = this.subdivisions.eighth / swingRatio;
            } else {
                this.subdivisions.swing = 0.5 + (this.subdivisions.eighth - 0.5) / (1 - swingRatio);
            }
        } else {
            this.subdivisions.swing = this.subdivisions.eighth;
        }
    }
    
    /**
     * Get accent level for beat position
     */
    getAccent(beatInBar) {
        if (this.currentPattern && this.patterns.has(this.currentPattern)) {
            const pattern = this.patterns.get(this.currentPattern);
            if (pattern.accents && pattern.accents[beatInBar] !== undefined) {
                return pattern.accents[beatInBar];
            }
        }
        
        // Default accent pattern (strong on 1, medium on 3 in 4/4)
        if (beatInBar === 0) return 1.0;
        if (beatInBar === 2 && this.timeSignature[0] === 4) return 0.7;
        return 0.5;
    }
    
    /**
     * Get current time information
     */
    getTimeInfo() {
        return {
            // Absolute time
            elapsed: performance.now() - this.startTime,
            
            // Musical time
            beat: this.currentBeat,
            bar: this.currentBar,
            beatInBar: this.currentBeat % this.timeSignature[0],
            
            // Progress values (0-1)
            beatProgress: this.beatProgress,
            barProgress: this.barProgress,
            
            // Subdivisions
            subdivisions: { ...this.subdivisions },
            
            // Timing info
            bpm: this.bpm,
            beatDuration: this.beatDuration,
            timeSignature: [...this.timeSignature],
            
            // Musical properties
            intensity: this.intensity,
            groove: this.groove,
            pattern: this.currentPattern,
            
            // Next beat timing
            nextBeatIn: this.nextBeatTime - performance.now(),
            
            // Accent for current beat
            accent: this.getAccent(this.currentBeat % this.timeSignature[0])
        };
    }
    
    /**
     * Set BPM (beats per minute)
     */
    setBPM(bpm) {
        this.bpm = Math.max(20, Math.min(360, bpm));
        this.beatDuration = 60000 / this.bpm;
        this.barDuration = this.beatDuration * this.timeSignature[0];
        
        this.emit('tempoChange', { bpm: this.bpm });
    }
    
    /**
     * Set time signature
     */
    setTimeSignature(numerator, denominator) {
        this.timeSignature = [numerator, denominator];
        this.barDuration = this.beatDuration * numerator;
        
        this.emit('timeSignatureChange', { 
            timeSignature: this.timeSignature 
        });
    }
    
    /**
     * Set rhythm pattern
     */
    setPattern(patternName) {
        if (!this.patterns.has(patternName)) {
            return;
        }
        
        const pattern = this.patterns.get(patternName);
        this.currentPattern = patternName;
        
        // Apply pattern settings
        if (pattern.timeSignature) {
            this.setTimeSignature(...pattern.timeSignature);
        }
        if (pattern.groove !== undefined) {
            this.groove = pattern.groove;
        }
        
        this.emit('patternChange', { pattern: patternName });
    }
    
    /**
     * Register for beat events
     */
    onBeatCallback(callback) {
        this.beatCallbacks.add(callback);
        return () => this.beatCallbacks.delete(callback);
    }
    
    /**
     * Register for bar events
     */
    onBarCallback(callback) {
        this.barCallbacks.add(callback);
        return () => this.barCallbacks.delete(callback);
    }
    
    /**
     * Emit event to listeners
     */
    emit(event, data) {
        if (this.listeners.has(event)) {
            this.listeners.get(event).forEach(callback => callback(data));
        }
    }
    
    /**
     * Listen for events
     */
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, new Set());
        }
        this.listeners.get(event).add(callback);
        
        // Return unsubscribe function
        return () => {
            if (this.listeners.has(event)) {
                this.listeners.get(event).delete(callback);
            }
        };
    }
    
    /**
     * Sync to audio source (stub for future implementation)
     */
    syncToAudio(audioContext, audioSource) {
        this.audioSync = { context: audioContext, source: audioSource };
        // Future: Implement beat detection and tempo extraction
    }
    
    /**
     * Get rhythm adapter for subsystems
     * Returns timing info and utilities for rhythm-aware animations
     */
    getAdapter() {
        return {
            // Current time info
            getTimeInfo: () => this.getTimeInfo(),
            
            // Check if on beat (with tolerance)
            isOnBeat: (tolerance = 0.1) => {
                return this.beatProgress < tolerance || this.beatProgress > (1 - tolerance);
            },
            
            // Check if on specific subdivision
            isOnSubdivision: (subdivision, tolerance = 0.1) => {
                const value = this.subdivisions[subdivision] || 0;
                return value < tolerance || value > (1 - tolerance);
            },
            
            // Get interpolated value synced to beat
            getBeatSync: (min = 0, max = 1, curve = 'linear') => {
                let progress = this.beatProgress;
                
                // Apply curve
                switch(curve) {
                case 'ease':
                    progress = 0.5 - Math.cos(progress * Math.PI) / 2;
                    break;
                case 'bounce':
                    progress = Math.abs(Math.sin(progress * Math.PI));
                    break;
                case 'pulse':
                    progress = Math.pow(Math.sin(progress * Math.PI), 2);
                    break;
                }
                
                return min + (max - min) * progress;
            },
            
            // Get value with musical accent
            getAccentedValue: (baseValue, accentMultiplier = 2) => {
                const accent = this.getAccent(this.currentBeat % this.timeSignature[0]);
                return baseValue * (1 + (accent - 0.5) * accentMultiplier);
            },
            
            // Subscribe to beat events
            onBeat: callback => this.onBeatCallback(callback),
            onBar: callback => this.onBarCallback(callback),
            
            // Musical time utilities
            beatsToMs: beats => beats * this.beatDuration,
            msToBeats: ms => ms / this.beatDuration,
            
            // Current musical state
            isPlaying: () => this.isPlaying,
            getBPM: () => this.bpm,
            getPattern: () => this.currentPattern
        };
    }
}

// Create singleton instance - SHARED across bundles via window global
// This ensures the 3D bundle can access the same rhythmEngine as the 2D bundle
// when audio starts playing through the 2D AudioManager
let rhythmEngine;

if (typeof window !== 'undefined' && window.__emotiveRhythmEngine) {
    // Reuse existing shared instance (e.g., from 2D bundle)
    rhythmEngine = window.__emotiveRhythmEngine;
} else {
    // Create new instance and share it globally
    rhythmEngine = new RhythmEngine();
    if (typeof window !== 'undefined') {
        window.__emotiveRhythmEngine = rhythmEngine;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - 3D Rhythm Adapter
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Bridges RhythmEngine with the 3D animation system
 * @author Emotive Engine Team
 * @module 3d/animation/Rhythm3DAdapter
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║ CONCEPT
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Translates musical timing from RhythmEngine into multipliers and modulation
 * ║ values that the 3D system (GestureBlender, Core3DManager) can use to sync
 * ║ animations with rhythm.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * FEATURES:
 * • Beat-synced gesture intensity modulation
 * • Accent-aware animation scaling
 * • Ambient groove idle animations (subtle bounce/sway when no gestures)
 * • BPM-aware duration conversion for gestures
 * • Pattern-specific modulation overrides
 * • Multiple groove presets with seamless transitions
 *
 * GROOVE PRESETS:
 * • groove1 (subtle): Minimal, elegant - gentle bounce and sway
 * • groove2 (energetic): Bouncy, lively - pronounced vertical motion
 * • groove3 (flowing): Smooth, languid - emphasis on rotation and sway
 *
 * ARCHITECTURE:
 * ┌──────────────────────────────────────────────────────────────────────────────────┐
 * │  RHYTHM FLOW TO 3D                                                               │
 * │                                                                                   │
 * │  [RhythmEngine] → [Rhythm3DAdapter] → [GestureBlender / Core3DManager]          │
 * │       ↓                   ↓                                                      │
 * │   beat/accent         modulation                                                 │
 * │   intensity          multipliers                                                 │
 * │                                                                                   │
 * └──────────────────────────────────────────────────────────────────────────────────┘
 *
 * TIMING MODEL (Frame-Rate Independent):
 * ┌──────────────────────────────────────────────────────────────────────────────────┐
 * │  • RhythmEngine provides absolute beatProgress/barProgress from performance.now()│
 * │  • Groove computed from absolute beat phase (NOT accumulated frame deltas)       │
 * │  • Smoothing applied only to OUTPUT values, not timing                          │
 * │  • deltaTime clamped to prevent overshoot during frame drops                    │
 * └──────────────────────────────────────────────────────────────────────────────────┘
 */


// ═══════════════════════════════════════════════════════════════════════════════════════
// GROOVE PRESETS
// ═══════════════════════════════════════════════════════════════════════════════════════

/**
 * Groove preset definitions
 * Each preset defines the character of the ambient groove animation
 */
const GROOVE_PRESETS = {
    // Subtle, minimal groove - elegant and understated
    groove1: {
        name: 'groove1',
        description: 'Subtle, elegant - gentle bounce and sway',
        bounceAmount: 0.015,      // Vertical bounce amplitude
        swayAmount: 0.012,        // Horizontal sway amplitude
        pulseAmount: 0.02,        // Scale pulse amplitude
        rotationAmount: 0.015,    // Rotation sway amplitude
        bounceFreq: 1,            // Bounce cycles per beat
        swayFreq: 0.5,            // Sway cycles per bar (half-bar period)
        phaseOffset: 0,           // Phase offset in radians
        easing: 'sine'            // Easing curve type
    },

    // Energetic, bouncy groove - lively and playful
    groove2: {
        name: 'groove2',
        description: 'Energetic, bouncy - pronounced vertical motion',
        bounceAmount: 0.035,      // More pronounced bounce
        swayAmount: 0.02,         // Moderate sway
        pulseAmount: 0.045,       // Strong scale pulse
        rotationAmount: 0.025,    // Moderate rotation
        bounceFreq: 1,            // Standard beat-synced bounce
        swayFreq: 1,              // Faster sway (full bar period)
        phaseOffset: 0,
        easing: 'bounce'          // Snappier easing
    },

    // Smooth, flowing groove - languid and expressive
    groove3: {
        name: 'groove3',
        description: 'Smooth, flowing - emphasis on rotation and sway',
        bounceAmount: 0.01,       // Subtle bounce
        swayAmount: 0.03,         // Pronounced sway
        pulseAmount: 0.015,       // Gentle pulse
        rotationAmount: 0.04,     // Strong rotation emphasis
        bounceFreq: 0.5,          // Slower bounce (half-beat)
        swayFreq: 0.25,           // Very slow sway (quarter-bar)
        phaseOffset: Math.PI / 4, // Phase offset for flowing feel
        easing: 'sine'            // Smooth sine easing
    }
};

// Default groove preset
const DEFAULT_GROOVE = 'groove1';

class Rhythm3DAdapter {
    /**
     * Create a new Rhythm3DAdapter instance
     * Bridges RhythmEngine with the 3D animation system for audio-reactive animations
     */
    constructor() {
        // Adapter state
        this.enabled = false;
        this.adapter = null;

        // Cached rhythm values (updated each frame)
        this.beatProgress = 0;
        this.barProgress = 0;
        this.accent = 0.5;
        this.intensity = 1.0;
        this.bpm = 120;
        this.isOnBeat = false;
        this.pattern = null;

        // Ambient groove state
        this.grooveEnabled = true;
        this.currentGroove = DEFAULT_GROOVE;
        this.targetGroove = DEFAULT_GROOVE;
        this.grooveTransition = 0;        // 0 = at current, 1 = at target
        this.grooveTransitionSpeed = 2.0; // Transition speed (per second)

        // Groove confidence: scales animation amplitude based on BPM detection confidence
        // Ranges from 0.15 (tentative) to 1.0 (fully locked), provided by BPM detector
        this.grooveConfidence = 1.0;      // Default to full when not using BPM detection

        // Modulation output (computed each frame) - these are the SMOOTHED values
        this.modulation = {
            scaleMultiplier: 1.0,      // Applied to gesture scale output
            glowMultiplier: 1.0,       // Applied to gesture glow output
            positionMultiplier: 1.0,   // Applied to gesture position output
            rotationMultiplier: 1.0,   // Applied to gesture rotation output
            accentBoost: 0.0,          // Extra boost on accented beats
            grooveOffset: [0, 0, 0],   // Ambient groove position offset
            grooveScale: 1.0,          // Ambient groove scale pulse
            grooveRotation: [0, 0, 0], // Ambient groove rotation sway
            grooveGlow: 1.0            // Ambient groove glow pulse (beat-synced)
        };

        // Target values (raw computed values before smoothing)
        this._target = {
            scaleMultiplier: 1.0,
            glowMultiplier: 1.0,
            positionMultiplier: 1.0,
            rotationMultiplier: 1.0,
            accentBoost: 0.0,
            grooveOffset: [0, 0, 0],
            grooveScale: 1.0,
            grooveRotation: [0, 0, 0],
            grooveGlow: 1.0
        };

        // Configuration
        this.config = {
            // Beat sync intensity
            beatSyncStrength: 0.3,     // How much beat affects animations (0-1)
            accentMultiplier: 1.5,     // Boost on accented beats

            // Smoothing settings
            smoothingSpeed: 8.0,       // How fast values ease toward target (higher = faster)
            grooveSmoothingSpeed: 12.0 // Groove smoothing (higher for tighter beat sync)
        };

        // Maximum deltaTime to prevent smoothing overshoot during frame drops
        this._maxDeltaTime = 0.05; // 50ms cap (~20 FPS minimum)

        // Pending groove change (for quantized transitions)
        this._pendingGroove = null;
        this._pendingGrooveOptions = null;
    }

    /**
     * Smooth interpolation helper (exponential ease)
     * @private
     * @param {number} current - Current value
     * @param {number} target - Target value
     * @param {number} speed - Interpolation speed
     * @param {number} deltaTime - Time delta in seconds (clamped)
     * @returns {number} Interpolated value
     */
    _lerp(current, target, speed, deltaTime) {
        const t = 1 - Math.exp(-speed * deltaTime);
        return current + (target - current) * t;
    }

    /**
     * Smooth interpolation for arrays
     * @private
     * @param {number[]} current - Current values
     * @param {number[]} target - Target values
     * @param {number} speed - Interpolation speed
     * @param {number} deltaTime - Time delta in seconds (clamped)
     * @returns {number[]} Interpolated values
     */
    _lerpArray(current, target, speed, deltaTime) {
        const t = 1 - Math.exp(-speed * deltaTime);
        return current.map((v, i) => v + (target[i] - v) * t);
    }

    /**
     * Apply easing curve to a normalized value (-1 to 1 or 0 to 1)
     * Each preset can specify an easing type for different character
     * @private
     * @param {number} value - Input value (typically from sine wave, -1 to 1)
     * @param {string} easingType - Easing curve type ('sine', 'bounce', 'elastic')
     * @returns {number} Eased value
     */
    _applyEasing(value, easingType) {
        switch (easingType) {
            case 'bounce':
                // Sharper attack, slower decay - snappier, more rhythmic feel
                // Uses power curve to create punch on peaks
                return Math.sign(value) * Math.pow(Math.abs(value), 0.6);

            case 'elastic':
                // Playful overshoot with subtle wobble
                // Good for excited/energetic moods
                return value * (1 + 0.15 * Math.sin(Math.abs(value) * Math.PI * 2));

            case 'sine':
            default:
                // Smooth sine wave - current behavior, elegant and flowing
                return value;
        }
    }

    /**
     * Get groove preset by name
     * @private
     * @param {string} name - Preset name
     * @returns {Object} Groove preset configuration
     */
    _getGroovePreset(name) {
        return GROOVE_PRESETS[name] || GROOVE_PRESETS[DEFAULT_GROOVE];
    }

    /**
     * Interpolate between two groove presets
     * @private
     * @param {Object} from - Source preset
     * @param {Object} to - Target preset
     * @param {number} t - Interpolation factor (0-1)
     * @returns {Object} Interpolated preset values
     */
    _interpolatePresets(from, to, t) {
        return {
            bounceAmount: from.bounceAmount + (to.bounceAmount - from.bounceAmount) * t,
            swayAmount: from.swayAmount + (to.swayAmount - from.swayAmount) * t,
            pulseAmount: from.pulseAmount + (to.pulseAmount - from.pulseAmount) * t,
            rotationAmount: from.rotationAmount + (to.rotationAmount - from.rotationAmount) * t,
            bounceFreq: from.bounceFreq + (to.bounceFreq - from.bounceFreq) * t,
            swayFreq: from.swayFreq + (to.swayFreq - from.swayFreq) * t,
            phaseOffset: from.phaseOffset + (to.phaseOffset - from.phaseOffset) * t
        };
    }

    /**
     * Initialize the adapter by connecting to RhythmEngine
     */
    initialize() {
        this.adapter = rhythmEngine.getAdapter();
        this.enabled = true;

        // Subscribe to beat events for accent tracking
        this.adapter.onBeat(beatInfo => {
            this.accent = beatInfo.accent;
            this.isOnBeat = true;
            // Clear on-beat flag after short window
            setTimeout(() => { this.isOnBeat = false; }, 100);
        });
    }

    /**
     * Start rhythm playback
     * Must be called to activate rhythm sync (or it auto-starts with audio detection)
     * @param {number} bpm - Beats per minute (default: 120)
     * @param {string} pattern - Rhythm pattern name (default: 'straight')
     */
    start(bpm = 120, pattern = 'straight') {
        if (!this.enabled) {
            this.initialize();
        }
        if (bpm) rhythmEngine.setBPM(bpm);
        if (pattern) rhythmEngine.setPattern(pattern);
        rhythmEngine.start();
    }

    /**
     * Stop rhythm playback
     */
    stop() {
        rhythmEngine.stop();
    }

    /**
     * Set BPM (beats per minute)
     * @param {number} bpm - BPM value (20-360)
     */
    setBPM(bpm) {
        rhythmEngine.setBPM(bpm);
        this.bpm = bpm;
    }

    /**
     * Set rhythm pattern
     * @param {string} pattern - Pattern name: 'straight', 'swing', 'waltz', 'dubstep', etc.
     */
    setPattern(pattern) {
        rhythmEngine.setPattern(pattern);
        this.pattern = pattern;
    }

    /**
     * Set the active groove preset
     * @param {string} grooveName - Groove preset name ('groove1', 'groove2', 'groove3')
     * @param {Object} [options] - Transition options
     * @param {number} [options.bars] - Transition duration in bars (default: immediate)
     * @param {number} [options.duration] - Transition duration in seconds (alternative to bars)
     * @param {boolean} [options.quantize] - Wait for next bar boundary before transitioning
     */
    setGroove(grooveName, options = {}) {
        if (!GROOVE_PRESETS[grooveName]) {
            console.warn(`[Rhythm3DAdapter] Unknown groove preset: ${grooveName}`);
            return;
        }

        // If same groove, no-op
        if (this.currentGroove === grooveName && this.grooveTransition >= 1) {
            return;
        }

        // If quantize is requested, queue the change for next bar boundary
        if (options.quantize) {
            this._pendingGroove = grooveName;
            // Store options without quantize flag to avoid infinite loop
            this._pendingGrooveOptions = { ...options, quantize: false };
            return;
        }

        // Set up transition
        this.targetGroove = grooveName;

        if (options.bars || options.duration) {
            // Gradual transition
            this.grooveTransition = 0;

            if (options.bars) {
                // Calculate transition speed based on bars at current BPM
                const barDuration = (60 / this.bpm) * 4; // seconds per bar (4/4)
                const transitionDuration = options.bars * barDuration;
                this.grooveTransitionSpeed = 1 / transitionDuration;
            } else if (options.duration) {
                this.grooveTransitionSpeed = 1 / options.duration;
            }
        } else {
            // Immediate transition (but still smoothed via grooveSmoothingSpeed)
            this.currentGroove = grooveName;
            this.grooveTransition = 1;
        }
    }

    /**
     * Get available groove preset names
     * @returns {string[]} Array of groove preset names
     */
    getGroovePresets() {
        return Object.keys(GROOVE_PRESETS);
    }

    /**
     * Get current groove preset name
     * @returns {string} Current groove preset name
     */
    getCurrentGroove() {
        return this.grooveTransition >= 1 ? this.targetGroove : this.currentGroove;
    }

    /**
     * Update rhythm state and compute modulation values
     * Should be called each frame before gesture blending
     *
     * IMPORTANT: This method is frame-rate independent.
     * - beatProgress/barProgress come from RhythmEngine (performance.now() based)
     * - Groove computed from absolute beat phase, NOT accumulated frame time
     * - deltaTime clamped to prevent smoothing overshoot
     *
     * @param {number} deltaTime - Time since last frame in ms
     */
    update(deltaTime) {
        // Convert to seconds and clamp to prevent smoothing overshoot during frame drops
        const dt = Math.min(deltaTime / 1000, this._maxDeltaTime);

        // Auto-initialize on first update if not done yet
        if (!this.adapter) {
            this.adapter = rhythmEngine.getAdapter();
        }

        if (!this.adapter) {
            this.resetModulation(dt);
            return;
        }

        // Check if rhythm is actually playing (started by any system - 2D or 3D)
        const playing = this.adapter.isPlaying();
        if (!playing) {
            this.resetModulation(dt);
            return;
        }

        // Mark as enabled if rhythm is playing (auto-enable when rhythm starts)
        this.enabled = true;

        // Get rhythm values directly from RhythmEngine (performance.now() based)
        // This is frame-rate independent - beatProgress is computed from elapsed time
        const timeInfo = this.adapter.getTimeInfo();

        // Use absolute beat/bar progress from RhythmEngine (already frame-rate independent)
        this.beatProgress = timeInfo.beatProgress;
        this.barProgress = timeInfo.barProgress;
        this.intensity = timeInfo.intensity;
        this.bpm = timeInfo.bpm || this.bpm;
        this.pattern = timeInfo.pattern;

        // Check for pending groove change at bar boundary (quantized transitions)
        // Trigger when barProgress is near 0 (start of new bar)
        if (this._pendingGroove && this.barProgress < 0.05) {
            this.setGroove(this._pendingGroove, this._pendingGrooveOptions || {});
            this._pendingGroove = null;
            this._pendingGrooveOptions = null;
        }

        // Update groove transition (for morphing between presets)
        if (this.grooveTransition < 1) {
            this.grooveTransition = Math.min(1, this.grooveTransition + this.grooveTransitionSpeed * dt);
            if (this.grooveTransition >= 1) {
                // Transition complete - swap current to target
                this.currentGroove = this.targetGroove;
            }
        }

        // Compute target modulation values (raw, unsmoothed)
        this.computeModulation();

        // Apply smoothing to reach target values
        this.applySmoothing(dt);
    }

    /**
     * Compute rhythm modulation TARGET values based on current beat state
     * These are raw values that will be smoothed before output
     * @private
     */
    computeModulation() {
        const { beatSyncStrength, accentMultiplier } = this.config;

        // Beat pulse curve: smooth sine wave, gentler than cosine^2
        // This creates a natural breathing rhythm that peaks on the beat
        const beatPhase = this.beatProgress * Math.PI * 2;
        const beatPulse = (Math.cos(beatPhase) + 1) * 0.5; // 0 to 1, peaks at beat start

        // Scale multiplier: subtle pulse on beat
        // 1.0 at rest, up to 1.0 + beatSyncStrength at beat
        this._target.scaleMultiplier = 1.0 + beatPulse * beatSyncStrength * 0.4;

        // Glow multiplier: brighter on beat (slightly more pronounced)
        this._target.glowMultiplier = 1.0 + beatPulse * beatSyncStrength * 0.8;

        // Position/rotation multipliers for gestures (subtle)
        this._target.positionMultiplier = 1.0 + beatPulse * beatSyncStrength * 0.2;
        this._target.rotationMultiplier = 1.0 + beatPulse * beatSyncStrength * 0.15;

        // Accent boost on strong beats (smoothed separately)
        this._target.accentBoost = this.isOnBeat ? (this.accent - 0.5) * accentMultiplier : 0;

        // Compute ambient groove (always active when rhythm is playing)
        if (this.grooveEnabled) {
            this.computeGroove();
        } else {
            this._target.grooveOffset = [0, 0, 0];
            this._target.grooveScale = 1.0;
            this._target.grooveRotation = [0, 0, 0];
        }
    }

    /**
     * Compute ambient groove animation (subtle idle motion synced to rhythm)
     * Uses absolute beat/bar progress for frame-rate independence
     * Supports morphing between groove presets
     * Animation amplitudes are scaled by grooveConfidence (0.15-1.0)
     *
     * @private
     */
    computeGroove() {
        // Get current and target presets
        const fromPreset = this._getGroovePreset(this.currentGroove);
        const toPreset = this._getGroovePreset(this.targetGroove);

        // Interpolate preset values for smooth transitions
        const preset = this.grooveTransition >= 1
            ? toPreset
            : this._interpolatePresets(fromPreset, toPreset, this.grooveTransition);

        // Scale amplitudes by grooveConfidence
        // At 0.15 (tentative): animations are very subtle, searching feel
        // At 1.0 (locked): full groove amplitude
        const conf = this.grooveConfidence;
        const bounceAmount = preset.bounceAmount * conf;
        const swayAmount = preset.swayAmount * conf;
        const pulseAmount = preset.pulseAmount * conf;
        const rotationAmount = preset.rotationAmount * conf;
        const { bounceFreq, swayFreq, phaseOffset, easing } = preset;

        // Compute groove motions from ABSOLUTE beat/bar progress
        // This is frame-rate independent because beatProgress/barProgress come from
        // RhythmEngine which uses performance.now(), not accumulated frame deltas

        // Vertical bounce: synced to beat with configurable frequency
        const bouncePhase = (this.beatProgress * bounceFreq * Math.PI * 2) + phaseOffset;
        const rawBounce = Math.sin(bouncePhase);
        const easedBounce = this._applyEasing(rawBounce, easing);

        // Horizontal sway: synced to bar with configurable frequency
        const swayPhase = (this.barProgress * swayFreq * Math.PI * 2) + phaseOffset;
        const rawSway = Math.sin(swayPhase);
        const easedSway = this._applyEasing(rawSway, easing);

        // Accent response: smooth curve that peaks at beat start, scaled by accent level
        // Uses cosine curve centered on beat boundaries (0 and 1) for smooth falloff
        // beatProgress 0.0 → peak, 0.5 → minimum, 1.0 → peak again
        const beatProximity = (Math.cos(this.beatProgress * Math.PI * 2) + 1) * 0.5; // 0-1, peaks at beat
        const accentStrength = Math.max(0, this.accent - 0.4) / 0.6; // 0-1, normalized above 0.4 threshold
        const accentBoost = beatProximity * accentStrength * 0.25; // Smooth accent curve

        // Apply easing and accent to motion values
        const bounce = easedBounce * bounceAmount * (1 + accentBoost);
        const sway = easedSway * swayAmount;

        // Scale pulse: synced to beat with accent boost
        const rawPulse = Math.sin(bouncePhase);
        const pulse = 1.0 + this._applyEasing(rawPulse, easing) * pulseAmount * (1 + accentBoost * 0.5);

        // Rotation sway: synced to bar for smooth rotation
        const rotationSway = easedSway * rotationAmount;

        // Multi-axis motion for organic 3D feel
        // Use different phase relationships so axes don't move in lockstep
        // Z-drift: subtle forward/back bobbing, offset from sway for depth
        const zDrift = Math.sin(swayPhase + Math.PI / 3) * swayAmount * 0.3;

        // X/Y rotation for "head tilt" effect - slower frequencies for subtle organic motion
        const tiltX = Math.sin(swayPhase * 0.5) * rotationAmount * 0.4;
        const tiltY = Math.cos(bouncePhase * 0.7) * rotationAmount * 0.25;

        // Groove glow: subtle beat-synced glow pulse with accent response
        // Uses cosine for peak at beat start (when bouncePhase = 0)
        const glowBase = 1.0 + (Math.cos(bouncePhase) + 1) * 0.5 * 0.12 * conf;
        const accentGlow = beatProximity * accentStrength * 0.12; // Smooth glow accent
        const grooveGlow = glowBase + accentGlow;

        // Write to target values (these get smoothed in applySmoothing)
        // Position: X sway, Y bounce, Z drift (forward/back)
        this._target.grooveOffset = [sway, bounce, zDrift];
        this._target.grooveScale = pulse;
        // Rotation: X tilt (nod), Y tilt (turn), Z sway (lean)
        this._target.grooveRotation = [tiltX, tiltY, rotationSway];
        this._target.grooveGlow = grooveGlow;
    }

    /**
     * Apply exponential smoothing from current values toward targets
     * Smoothing is applied to OUTPUT values only, not to timing
     * @private
     */
    applySmoothing(dt) {
        const { smoothingSpeed, grooveSmoothingSpeed } = this.config;

        // Smooth beat-sync multipliers
        this.modulation.scaleMultiplier = this._lerp(
            this.modulation.scaleMultiplier,
            this._target.scaleMultiplier,
            smoothingSpeed, dt
        );
        this.modulation.glowMultiplier = this._lerp(
            this.modulation.glowMultiplier,
            this._target.glowMultiplier,
            smoothingSpeed, dt
        );
        this.modulation.positionMultiplier = this._lerp(
            this.modulation.positionMultiplier,
            this._target.positionMultiplier,
            smoothingSpeed, dt
        );
        this.modulation.rotationMultiplier = this._lerp(
            this.modulation.rotationMultiplier,
            this._target.rotationMultiplier,
            smoothingSpeed, dt
        );
        this.modulation.accentBoost = this._lerp(
            this.modulation.accentBoost,
            this._target.accentBoost,
            smoothingSpeed * 0.5, dt  // Slower decay for accent
        );

        // Smooth groove values
        // Higher smoothing speed keeps groove tightly synced to beat
        this.modulation.grooveOffset = this._lerpArray(
            this.modulation.grooveOffset,
            this._target.grooveOffset,
            grooveSmoothingSpeed, dt
        );
        this.modulation.grooveScale = this._lerp(
            this.modulation.grooveScale,
            this._target.grooveScale,
            grooveSmoothingSpeed, dt
        );
        this.modulation.grooveRotation = this._lerpArray(
            this.modulation.grooveRotation,
            this._target.grooveRotation,
            grooveSmoothingSpeed, dt
        );
        this.modulation.grooveGlow = this._lerp(
            this.modulation.grooveGlow,
            this._target.grooveGlow,
            grooveSmoothingSpeed, dt
        );
    }

    /**
     * Reset modulation to neutral values (when rhythm not playing)
     * Smoothly eases back to neutral instead of snapping
     * @private
     */
    resetModulation(dt = 0.016) {
        // Set targets to neutral
        this._target.scaleMultiplier = 1.0;
        this._target.glowMultiplier = 1.0;
        this._target.positionMultiplier = 1.0;
        this._target.rotationMultiplier = 1.0;
        this._target.accentBoost = 0.0;
        this._target.grooveOffset = [0, 0, 0];
        this._target.grooveScale = 1.0;
        this._target.grooveRotation = [0, 0, 0];
        this._target.grooveGlow = 1.0;

        // Smooth toward neutral (slower speed for graceful fade-out)
        const fadeSpeed = 4.0;
        this.modulation.scaleMultiplier = this._lerp(this.modulation.scaleMultiplier, 1.0, fadeSpeed, dt);
        this.modulation.glowMultiplier = this._lerp(this.modulation.glowMultiplier, 1.0, fadeSpeed, dt);
        this.modulation.positionMultiplier = this._lerp(this.modulation.positionMultiplier, 1.0, fadeSpeed, dt);
        this.modulation.rotationMultiplier = this._lerp(this.modulation.rotationMultiplier, 1.0, fadeSpeed, dt);
        this.modulation.accentBoost = this._lerp(this.modulation.accentBoost, 0.0, fadeSpeed, dt);
        this.modulation.grooveOffset = this._lerpArray(this.modulation.grooveOffset, [0, 0, 0], fadeSpeed, dt);
        this.modulation.grooveScale = this._lerp(this.modulation.grooveScale, 1.0, fadeSpeed, dt);
        this.modulation.grooveRotation = this._lerpArray(this.modulation.grooveRotation, [0, 0, 0], fadeSpeed, dt);
        this.modulation.grooveGlow = this._lerp(this.modulation.grooveGlow, 1.0, fadeSpeed, dt);
    }

    /**
     * Get rhythm modulation to apply to blended gesture output
     * @returns {Object} Modulation values
     */
    getModulation() {
        return this.modulation;
    }

    /**
     * Convert gesture duration to musical time (BPM-aware)
     * @param {number} baseDuration - Base duration in ms
     * @param {Object} rhythmConfig - Gesture's rhythm config (optional)
     * @returns {number} Adjusted duration in ms
     */
    getMusicalDuration(baseDuration, rhythmConfig = null) {
        if (!this.enabled || !this.adapter || !this.adapter.isPlaying()) {
            return baseDuration;
        }

        // If gesture has rhythm config with duration sync, use it
        if (rhythmConfig?.durationSync) {
            const sync = rhythmConfig.durationSync;

            if (sync.mode === 'beats' && sync.beats) {
                return this.adapter.beatsToMs(sync.beats);
            }
            if (sync.mode === 'bars' && sync.bars) {
                return this.adapter.beatsToMs(sync.bars * 4); // Assuming 4/4
            }
        }

        // Otherwise return base duration (no rhythm adjustment)
        return baseDuration;
    }

    /**
     * Check if currently on a beat (for triggering effects)
     * @param {number} tolerance - Tolerance window (0-1, fraction of beat)
     * @returns {boolean}
     */
    isOnBeatNow(tolerance = 0.1) {
        if (!this.enabled || !this.adapter) return false;
        return this.adapter.isOnBeat(tolerance);
    }

    /**
     * Check if currently on an accented beat
     * @param {number} accentThreshold - Minimum accent level (0-1)
     * @returns {boolean}
     */
    isOnAccent(accentThreshold = 0.7) {
        return this.isOnBeat && this.accent >= accentThreshold;
    }

    /**
     * Get beat-synced interpolated value
     * @param {number} min - Minimum value
     * @param {number} max - Maximum value
     * @param {string} curve - Interpolation curve ('linear', 'ease', 'bounce', 'pulse')
     * @returns {number} Interpolated value
     */
    getBeatSync(min, max, curve = 'pulse') {
        if (!this.enabled || !this.adapter) return min;
        return this.adapter.getBeatSync(min, max, curve);
    }

    /**
     * Apply accent multiplier to a base value
     * @param {number} baseValue - Base value
     * @param {number} multiplier - Accent multiplier strength
     * @returns {number} Accent-modulated value
     */
    getAccentedValue(baseValue, multiplier = 2) {
        if (!this.enabled || !this.adapter) return baseValue;
        return this.adapter.getAccentedValue(baseValue, multiplier);
    }

    /**
     * Enable or disable ambient groove
     * @param {boolean} enabled
     */
    setGrooveEnabled(enabled) {
        this.grooveEnabled = enabled;
        if (!enabled) {
            // Set targets to neutral - smoothing will handle the transition
            this._target.grooveOffset = [0, 0, 0];
            this._target.grooveScale = 1.0;
            this._target.grooveRotation = [0, 0, 0];
        }
    }

    /**
     * Set groove confidence from BPM detector
     * This scales animation amplitudes: 0.15 = tentative, 1.0 = full groove
     * @param {number} confidence - Groove confidence value (0.15 to 1.0)
     */
    setGrooveConfidence(confidence) {
        this.grooveConfidence = Math.max(0, Math.min(1, confidence));
    }

    /**
     * Set groove configuration (for custom tuning)
     * @param {Object} config - Groove settings
     */
    setGrooveConfig(config) {
        Object.assign(this.config, config);
    }

    /**
     * Set beat sync strength
     * @param {number} strength - Sync strength (0-1)
     */
    setBeatSyncStrength(strength) {
        this.config.beatSyncStrength = Math.max(0, Math.min(1, strength));
    }

    /**
     * Check if rhythm is currently playing
     * @returns {boolean}
     */
    isPlaying() {
        return this.enabled && this.adapter && this.adapter.isPlaying();
    }

    /**
     * Get current BPM
     * @returns {number}
     */
    getBPM() {
        return this.bpm;
    }

    /**
     * Get current pattern name
     * @returns {string|null}
     */
    getPattern() {
        return this.pattern;
    }

    /**
     * Cleanup
     */
    destroy() {
        this.enabled = false;
        this.adapter = null;
        this.resetModulation();
    }
}

// Export singleton for easy access
const rhythm3DAdapter = new Rhythm3DAdapter();

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - 3D Geometry Morpher
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Smooth geometry morphing system for 3D shapes
 * @author Emotive Engine Team
 * @module 3d/utils/GeometryMorpher
 *
 * Manages smooth transitions between geometries similar to 2D ShapeMorpher
 */

class GeometryMorpher {
    constructor() {
        this.isTransitioning = false;
        this.currentGeometryType = null;
        this.targetGeometryType = null;
        this.morphStartTime = 0;
        this.morphDuration = 1000; // Smooth, relaxed transition (increased from 800ms)
        this.morphProgress = 0;
        this.visualProgress = 0; // Smoothed progress for rendering
        this.hasSwappedGeometry = false; // Track if we've swapped at midpoint
        this.isPausedAtSwap = false; // Paused waiting for async geometry load
        this.pausedAtTime = 0; // Time when paused (to resume correctly)

        // Easing function
        this.easing = 'easeInOutCubic';
    }

    /**
     * Start morphing to a new geometry
     * Handles interruptions gracefully - if called during an active morph,
     * will smoothly transition to the new target without visual glitches.
     *
     * @param {string} currentType - Current geometry type name
     * @param {string} targetType - Target geometry type name
     * @param {number} duration - Duration in milliseconds
     * @returns {boolean} True if morph started, false if already at target
     */
    startMorph(currentType, targetType, duration = 1000) {
        // If already at target and not transitioning, skip
        if (currentType === targetType && !this.isTransitioning) {
            return false;
        }

        // If already transitioning to this exact target, skip
        if (this.isTransitioning && this.targetGeometryType === targetType) {
            return false;
        }

        // ═══════════════════════════════════════════════════════════════════
        // INTERRUPTION HANDLING - Smooth transition when morph is interrupted
        // ═══════════════════════════════════════════════════════════════════
        if (this.isTransitioning) {
            // We're interrupting an active morph - handle gracefully
            const currentScale = this.calculateScaleMultiplier(this.visualProgress);

            if (!this.hasSwappedGeometry) {
                // Still in SHRINK phase (haven't swapped yet)
                // Continue shrinking to 0, but swap to NEW target at midpoint
                // Keep current progress, just change the target
                this.targetGeometryType = targetType;
                // Signal that we need a new geometry loaded (handled by Core3DManager)
                this._interruptedTarget = targetType;
                return true;
            } else {

                // Reset to shrink phase with current scale as starting point
                this.morphStartTime = Date.now();
                this.morphDuration = duration;
                // Map current scale back to progress (inverse of shrink calculation)
                // scale = 1 - (progress*2)^2, so progress = sqrt(1-scale) / 2
                const inverseProgress = currentScale > 0
                    ? Math.sqrt(1 - Math.min(currentScale, 1)) / 2
                    : 0.5;
                this.morphProgress = inverseProgress;
                this.visualProgress = inverseProgress;
                this.hasSwappedGeometry = false; // Need to swap again at midpoint
                this.targetGeometryType = targetType;
                this._interruptedTarget = targetType;
                this.isPausedAtSwap = false;
                this.isGrowIn = false;

                // Adjust start time so animation continues from current visual state
                const elapsedEquivalent = inverseProgress * duration;
                this.morphStartTime = Date.now() - elapsedEquivalent;

                return true;
            }
        }

        // Start fresh transition (no interruption)
        this.currentGeometryType = currentType;
        this.targetGeometryType = targetType;
        this.morphStartTime = Date.now();
        this.morphDuration = duration;
        this.morphProgress = 0;
        this.visualProgress = 0;
        this.isTransitioning = true;
        this.hasSwappedGeometry = false; // Reset swap flag
        this.isPausedAtSwap = false; // Reset pause flag
        this.pausedAtTime = 0;
        this.isGrowIn = false; // Not a grow-in animation
        this._interruptedTarget = null;

        return true;
    }

    /**
     * Check if the current morph was interrupted and needs a new target geometry
     * @returns {string|null} The new target geometry type, or null if not interrupted
     */
    getInterruptedTarget() {
        const target = this._interruptedTarget;
        this._interruptedTarget = null; // Clear after reading
        return target;
    }

    /**
     * Start a grow-in animation from scale 0 to 1 (no geometry swap)
     * Used for initial appearance of mascots
     * @param {string} geometryType - Current geometry type
     * @param {number} duration - Duration in milliseconds (default: 500ms for snappy pop)
     * @returns {boolean} True if grow-in started
     */
    growIn(geometryType, duration = 500) {
        // If already transitioning, skip
        if (this.isTransitioning) {
            return false;
        }

        // Start grow-in transition (just the grow phase, no shrink)
        this.currentGeometryType = geometryType;
        this.targetGeometryType = geometryType; // Same geometry
        this.morphStartTime = Date.now();
        this.morphDuration = duration;
        this.morphProgress = 0;
        this.visualProgress = 0;
        this.isTransitioning = true;
        this.hasSwappedGeometry = true; // Already "swapped" - skip swap logic
        this.isPausedAtSwap = false;
        this.pausedAtTime = 0;
        this.isGrowIn = true; // Flag for grow-only animation

        return true;
    }

    /**
     * Pause morph at swap point (waiting for async geometry)
     */
    pauseAtSwap() {
        if (this.isTransitioning && !this.isPausedAtSwap) {
            this.isPausedAtSwap = true;
            this.pausedAtTime = Date.now();
        }
    }

    /**
     * Resume morph after async geometry loaded
     */
    resumeFromSwap() {
        if (this.isPausedAtSwap) {
            // Adjust start time so morph continues from where it was
            const pauseDuration = Date.now() - this.pausedAtTime;
            this.morphStartTime += pauseDuration;
            this.isPausedAtSwap = false;
            this.pausedAtTime = 0;
        }
    }

    /**
     * Update morph animation
     * @param {number} deltaTime - Time since last frame in ms
     * @returns {Object} Current morph state
     */
    update(_deltaTime) {
        if (!this.isTransitioning) {
            return {
                isTransitioning: false,
                progress: 0,
                visualProgress: 0,
                scaleMultiplier: 1.0
            };
        }

        // If paused at swap point, hold at minimum scale (0 for invisible swap)
        if (this.isPausedAtSwap) {
            return {
                isTransitioning: true,
                progress: 0.5,
                visualProgress: 0.5,
                scaleMultiplier: 0.0,
                waitingForGeometry: true
            };
        }

        // Calculate progress
        const elapsed = Date.now() - this.morphStartTime;
        const rawProgress = Math.min(elapsed / this.morphDuration, 1.0);

        // Apply easing
        this.morphProgress = this.applyEasing(rawProgress);

        // Smooth visual progress for ultra-smooth rendering (like 2D)
        // Lighter smoothing (60/40) so scale can reach 0 at midpoint
        this.visualProgress = this.visualProgress * 0.6 + this.morphProgress * 0.4;

        // Snap to target when close (ensures we hit 0 at midpoint and 1 at end)
        if (Math.abs(this.visualProgress - this.morphProgress) < 0.01) {
            this.visualProgress = this.morphProgress;
        }

        // Calculate scale multiplier for shrink/grow effect
        const scaleMultiplier = this.calculateScaleMultiplier(this.visualProgress);

        // Signal to swap geometry at midpoint (when scale is at minimum ~0.5)
        // This makes the swap imperceptible
        let shouldSwap = false;
        if (!this.hasSwappedGeometry && this.morphProgress >= 0.5) {
            this.hasSwappedGeometry = true;
            shouldSwap = true;
        }

        // Check if complete
        if (this.morphProgress >= 1.0) {
            this.completeMorph();
            return {
                isTransitioning: false,
                progress: 1.0,
                visualProgress: 1.0,
                scaleMultiplier: 1.0,
                completed: true
            };
        }

        return {
            isTransitioning: true,
            progress: this.morphProgress,
            visualProgress: this.visualProgress,
            scaleMultiplier,
            shouldSwapGeometry: shouldSwap
        };
    }

    /**
     * Calculate scale multiplier for shrink/grow animation
     * Shrinks to 0 at midpoint for invisible geometry swap, then grows back
     * Uses smooth easing for jaunty blink effect
     * @param {number} progress - Visual progress (0-1)
     * @returns {number} Scale multiplier
     */
    calculateScaleMultiplier(progress) {
        // For grow-in animations, just scale 0→1 (no shrink phase)
        if (this.isGrowIn) {
            // Use easeOutBack for bouncy pop-in effect
            // easeOutBack: overshoots slightly then settles
            const c1 = 1.70158;
            const c3 = c1 + 1;
            const eased = 1 + c3 * Math.pow(progress - 1, 3) + c1 * Math.pow(progress - 1, 2);
            return Math.max(0, eased); // Clamp to prevent negative scale
        }

        // Shrink phase (0 to 0.5): scale goes from 1.0 to 0.0
        // Grow phase (0.5 to 1.0): scale goes from 0.0 to 1.0
        // This creates a smooth "blink out, swap, blink in" effect

        if (progress <= 0.5) {
            // Shrinking: progress 0->0.5 maps to scale 1->0
            // Use easeInQuad for accelerating shrink (jaunty feel)
            const shrinkProgress = progress * 2; // 0 to 1
            const eased = shrinkProgress * shrinkProgress; // easeIn
            return 1.0 - eased;
        } else {
            // Growing: progress 0.5->1.0 maps to scale 0->1
            // Use easeOutQuad for decelerating grow (bouncy arrival)
            const growProgress = (progress - 0.5) * 2; // 0 to 1
            const eased = growProgress * (2 - growProgress); // easeOut
            return eased;
        }
    }

    /**
     * Complete the morph transition
     */
    completeMorph() {
        this.currentGeometryType = this.targetGeometryType;
        this.targetGeometryType = null;
        this.isTransitioning = false;
        this.morphProgress = 0;
        this.visualProgress = 0;
    }

    /**
     * Apply easing function to progress
     * @param {number} t - Raw progress (0-1)
     * @returns {number} Eased progress (0-1)
     */
    applyEasing(t) {
        switch (this.easing) {
        case 'linear':
            return t;
        case 'easeInQuad':
            return t * t;
        case 'easeOutQuad':
            return t * (2 - t);
        case 'easeInOutQuad':
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        case 'easeInOutSine':
            return -(Math.cos(Math.PI * t) - 1) / 2;
        case 'easeInOutCubic':
        default:
            // Same as 2D ShapeMorpher
            return t < 0.5
                ? 4 * t * t * t
                : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
    }

    /**
     * Get current state
     * @returns {Object} Current morph state
     */
    getState() {
        return {
            isTransitioning: this.isTransitioning,
            currentGeometryType: this.currentGeometryType,
            targetGeometryType: this.targetGeometryType,
            progress: this.morphProgress,
            visualProgress: this.visualProgress
        };
    }

    /**
     * Cancel current morph
     */
    cancel() {
        this.isTransitioning = false;
        this.targetGeometryType = null;
        this.morphProgress = 0;
        this.visualProgress = 0;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Gesture Plugin Adapter
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Bridge between plugin system and gesture registry
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module gestures/plugin-adapter
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Adapter for dynamic gesture registration from plugins.                            
 * ║ • Maintains separate registry for plugin gestures                                 
 * ║ • Validates gesture definitions for required apply() function                     
 * ║ • Provides legacy format conversion for older plugins                             
 * ║ • Enables runtime registration and unregistration                                 
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Plugin gesture registry
 */
const pluginGestures = new Map();

/**
 * Register a plugin gesture
 * @param {string} name - Gesture name
 * @param {Object} gestureDef - Gesture definition object
 */
function registerPluginGesture(name, gestureDef) {
    // Ensure gesture has required properties
    if (!gestureDef.apply && !gestureDef.type) {
        return false;
    }
    
    // Add name if not present
    if (!gestureDef.name) {
        gestureDef.name = name;
    }
    
    // Set default type if not specified
    if (!gestureDef.type) {
        gestureDef.type = 'blending';
    }
    
    pluginGestures.set(name, gestureDef);
    
    return true;
}

/**
 * Unregister a plugin gesture
 * @param {string} name - Gesture name to remove
 */
function unregisterPluginGesture(name) {
    if (pluginGestures.has(name)) {
        pluginGestures.delete(name);
        
        return true;
    }
    return false;
}

/**
 * Get a plugin gesture by name
 * @param {string} name - Gesture name
 * @returns {Object|null} Gesture object or null if not found
 */
function getPluginGesture(name) {
    return pluginGestures.get(name) || null;
}

/**
 * Get all plugin gesture names
 * @returns {Array<string>} Array of gesture names
 */
function getAllPluginGestures() {
    return Array.from(pluginGestures.keys());
}

/**
 * Clear all plugin gestures
 */
function clearPluginGestures() {
    pluginGestures.clear();
}

/**
 * Convert legacy plugin gesture format to new format
 * @param {Object} legacyGesture - Old format gesture
 * @returns {Object} New format gesture
 */
function createLegacyAdapter$1(legacyGesture) {
    return {
        name: legacyGesture.name || 'unknown',
        type: legacyGesture.type || 'blending',
        emoji: legacyGesture.emoji || '🔌',
        description: legacyGesture.description || 'Plugin gesture',
        config: legacyGesture.config || {},
        
        apply(particle, progress, motion, dt, centerX, centerY) {
            // Adapt old plugin format to new format
            if (legacyGesture.animate) {
                // Old plugins might use 'animate' instead of 'apply'
                legacyGesture.animate(particle, progress, motion, dt, centerX, centerY);
            } else if (legacyGesture.apply) {
                legacyGesture.apply(particle, progress, motion, dt, centerX, centerY);
            }
        },
        
        cleanup: legacyGesture.cleanup || function(particle) {
            // Default cleanup
            if (particle.gestureData && particle.gestureData[this.name]) {
                delete particle.gestureData[this.name];
            }
        }
    };
}

// Export adapter interface
var pluginAdapter$1 = {
    registerPluginGesture,
    unregisterPluginGesture,
    getPluginGesture,
    getAllPluginGestures,
    clearPluginGestures,
    createLegacyAdapter: createLegacyAdapter$1
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Bounce Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Bounce gesture - vertical oscillation motion
 * @author Emotive Engine Team
 * @module gestures/motions/bounce
 * @complexity ⭐⭐ Intermediate
 * @audience Motion patterns for particle animations
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a bouncing motion with particles oscillating vertically.                  
 * ║ This is a BLENDING gesture that adds to existing particle motion.                 
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ↑
 *       ⭐      <- peak
 *      ↗ ↘
 *     ↗   ↘
 *    ⭐     ⭐   <- midpoint
 *   ↗       ↘
 *  ↗         ↘
 * ⭐           ⭐ <- trough
 * 
 * USED BY:
 * - Joy emotions (playful bouncing)
 * - Excited states (energetic movement)
 * - Celebration gestures
 */

/**
 * Bounce gesture configuration and implementation
 */
var bounce = {
    name: 'bounce',
    emoji: '⬆️',
    type: 'blending', // Adds to existing motion
    description: 'Vertical oscillation with smooth easing',
    
    // Default configuration
    config: {
        duration: 800,      // Legacy fallback
        musicalDuration: { musical: true, beats: 2 }, // 2 beats
        amplitude: 30,      // Bounce height range
        frequency: 2,       // Number of oscillations
        axis: 'vertical',   // Movement axis: 'vertical' or 'horizontal'
        damping: true,      // Enable amplitude reduction over time
        easing: 'sine',     // Animation curve type
        strength: 0.6,      // Overall motion intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'bounce',
            axis: 'vertical',   // Oscillation direction
            strength: 0.6,      // Particle bounce strength
            frequency: 2        // Particle oscillation count
        }
    },
    
    // Rhythm configuration - bounce syncs perfectly to beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Each bounce lands on a beat
        timingSync: 'nextBeat',     // Start on next beat
        interruptible: true,         // Can interrupt mid-bounce
        priority: 3,                 // Lower priority
        blendable: true,             // Can blend with other effects
        crossfadePoint: 'anyBeat',   // Can transition out on any beat
        
        // Bounce height syncs to beat intensity
        amplitudeSync: {
            onBeat: 1.8,      // Higher bounce on beat
            offBeat: 0.6,     // Lower between beats
            curve: 'bounce'   // Natural bounce curve
        },
        
        // Frequency can sync to tempo
        frequencySync: {
            mode: 'tempo',    // Bounces per beat scale with BPM
            multiplier: 1.0   // 1 bounce per beat
        },
        
        // Duration syncs to musical time
        durationSync: {
            mode: 'beats',    // Duration in beats
            beats: 4          // Bounce for 4 beats (1 bar in 4/4)
        },
        
        // Accent response for stronger downbeats
        accentResponse: {
            enabled: true,
            multiplier: 1.5   // 50% higher on accented beats
        },
        
        // Pattern-specific bouncing styles
        patternOverrides: {
            'waltz': {
                // 3/4 time creates elegant triple bounce
                frequencySync: { multiplier: 0.75 },
                durationSync: { beats: 3 }
            },
            'swing': {
                // Jazzy swing bounce with syncopation
                amplitudeSync: { onBeat: 2.0, offBeat: 0.4, curve: 'ease' }
            },
            'dubstep': {
                // Heavy drop on beat 3
                amplitudeSync: { 
                    onBeat: 1.5,
                    dropBeat: 3.0,  // Massive bounce on the drop
                    curve: 'pulse'
                }
            },
            'breakbeat': {
                // Chaotic broken rhythm bouncing
                frequencySync: { multiplier: 1.5 },
                amplitudeSync: { onBeat: 2.2, offBeat: 0.3 }
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * Called once when gesture starts
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     */
    initialize(particle, _motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        particle.gestureData.bounce = {
            startY: particle.y,
            startX: particle.x,
            startVx: particle.vx,
            startVy: particle.vy,
            initialized: true
        };
    },
    
    /**
     * Apply bounce motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, _centerX, _centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.bounce?.initialized) {
            this.initialize(particle, motion);
        }
        
        const config = { ...this.config, ...motion };
        const strength = config.strength || this.config.strength || 1.0;
        
        // Apply easing
        const easeProgress = this.easeInOutCubic(progress);
        
        // Calculate oscillation
        let {frequency} = config;
        const phase = motion.phase || 0;
        
        // Apply rhythm modulation if present
        let amplitude = config.amplitude * strength * particle.scaleFactor;
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            // Frequency modulation for tempo sync
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }
        
        const oscillation = Math.sin((easeProgress + phase) * Math.PI * 2 * frequency);
        if (config.damping && progress > 0.7) {
            // Reduce amplitude toward end of animation
            const dampProgress = (progress - 0.7) / 0.3;
            amplitude *= (1 - dampProgress * 0.8);
        }
        
        // Apply motion based on axis
        if (config.axis === 'vertical') {
            particle.vy += oscillation * amplitude * 0.01 * dt;
            
            // Dampen horizontal movement slightly for stability
            if (progress > 0.9) {
                particle.vx *= 0.98;
            }
        } else if (config.axis === 'horizontal') {
            particle.vx += oscillation * amplitude * 0.01 * dt;
            
            // Dampen vertical movement slightly for stability
            if (progress > 0.9) {
                particle.vy *= 0.98;
            }
        }
        
        // Smooth ending - gradually reduce velocity modifications
        if (progress > 0.9) {
            const endFactor = 1 - ((progress - 0.9) * 10);
            particle.vx = particle.vx * (0.95 + endFactor * 0.05);
            particle.vy = particle.vy * (0.95 + endFactor * 0.05);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.bounce) {
            delete particle.gestureData.bounce;
        }
    },
    
    /**
     * Easing function for smooth animation
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutCubic(t) {
        return t < 0.5
            ? 4 * t * t * t
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },

    /**
     * 3D core translation
     * Maps bounce motion to 3D transforms with proper squash/stretch
     */
    '3d': {
        /**
         * Evaluate 3D properties at given progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration
         * @returns {Object} 3D transform properties {position, rotation, scale}
         */
        evaluate(progress, motion) {
            const config = motion || {};
            const amplitudePixels = config.amplitude || 30;
            const frequency = config.frequency || 2;
            const strength = config.strength || 0.6;

            // Scale pixels to 3D units - keep bounce subtle to stay on-screen
            const PIXEL_TO_3D = 0.003; // 30px = 0.09 units max, 0.054 with strength
            const amplitude = amplitudePixels * PIXEL_TO_3D * strength;

            // Apply easing
            const easeProgress = progress < 0.5
                ? 4 * progress * progress * progress
                : 1 - Math.pow(-2 * progress + 2, 3) / 2;

            // Calculate bounce with proper physics curve
            // Use abs(sin) for bounce effect - always positive (up from ground)
            const bouncePhase = easeProgress * Math.PI * frequency;
            const bounceHeight = Math.abs(Math.sin(bouncePhase));

            // Apply damping
            let dampedAmplitude = amplitude;
            if (progress > 0.7) {
                const dampProgress = (progress - 0.7) / 0.3;
                dampedAmplitude *= (1 - dampProgress * 0.8);
            }

            // Y position - bounce up from neutral
            const yPosition = bounceHeight * dampedAmplitude;

            // Subtle scale pulse for bounce feel
            // Slight expansion at peak of bounce for energy
            const scalePulse = 1.0 + bounceHeight * 0.08; // Up to 8% larger at peak

            return {
                position: [0, yPosition, 0],
                rotation: [0, 0, 0],
                scale: scalePulse
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Pulse Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Pulse gesture - radial expansion and contraction
 * @author Emotive Engine Team
 * @module gestures/motions/pulse
 * @complexity ⭐⭐ Intermediate
 * @audience Motion patterns for particle animations
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a breathing/heartbeat effect with particles expanding and contracting      
 * ║ radially from the center. This is a BLENDING gesture that modifies positions.     
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *     Expand          Contract         Expand
 *    ← · · · →         → ⭐ ←         ← · · · →
 *    ↖ · · ↗           ↘ ↓ ↙           ↖ · · ↗
 *    · · ⭐ · ·   →    · ⭐ ·     →   · · ⭐ · ·
 *    ↙ · · ↘           ↗ ↑ ↖           ↙ · · ↘
 *    ← · · · →         → ⭐ ←         ← · · · →
 * 
 * USED BY:
 * - Love emotions (heartbeat rhythm)
 * - Breathing/calm states
 * - Emphasis gestures
 */

/**
 * Pulse gesture configuration and implementation
 */
var pulse = {
    name: 'pulse',
    emoji: '💗',
    type: 'blending', // Adds to existing motion
    description: 'Radial expansion and contraction from center',
    
    // Default configuration
    config: {
        duration: 600,      // Animation duration
        amplitude: 30,      // Expansion distance
        frequency: 1,       // Number of pulses
        holdPeak: 0.1,      // Peak expansion hold time
        easing: 'sine',     // Animation curve type
        scaleAmount: 0.2,   // Orb scale variation
        glowAmount: 0.3,    // Orb glow intensity change
        strength: 0.15,     // Particle motion strength
        direction: 'outward', // Radial direction
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'pulse',
            strength: 0.15,
            direction: 'outward',
            frequency: 1
        }
    },
    
    // Rhythm configuration - pulse as heartbeat synced to music
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Heartbeat on every beat
        
        // Pulse strength syncs to beat
        amplitudeSync: {
            onBeat: 1.6,      // Strong expansion on beat
            offBeat: 0.8,     // Gentle contraction off beat
            curve: 'pulse'    // Sharp attack, gradual release
        },
        
        // Frequency locks to tempo
        frequencySync: {
            mode: 'locked',   // One pulse per beat
            subdivision: 'quarter'  // Pulse on quarter notes
        },
        
        // Duration in musical time
        durationSync: {
            mode: 'beats',
            beats: 1          // One pulse per beat
        },
        
        // Stronger pulse on downbeats
        accentResponse: {
            enabled: true,
            multiplier: 2.0   // Double strength on accent
        },
        
        // Pattern-specific pulse styles
        patternOverrides: {
            'waltz': {
                // Elegant 3/4 heartbeat
                amplitudeSync: { onBeat: 2.0, offBeat: 0.5 },
                durationSync: { beats: 3 }
            },
            'swing': {
                // Syncopated jazz pulse
                amplitudeSync: { onBeat: 1.8, offBeat: 0.6, curve: 'ease' },
                frequencySync: { subdivision: 'swing' }
            },
            'dubstep': {
                // Deep bass pulse on drop
                amplitudeSync: {
                    onBeat: 1.2,
                    dropBeat: 4.0,  // Massive pulse on beat 3
                    curve: 'pulse'
                }
            },
            'breakbeat': {
                // Erratic heartbeat
                frequencySync: { mode: 'random', range: [0.5, 2.0] },
                amplitudeSync: { onBeat: 2.5, offBeat: 0.3 }
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate initial distance and angle from center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        
        particle.gestureData.pulse = {
            baseDistance: distance,
            angle,
            startX: particle.x,
            startY: particle.y,
            initialized: true
        };
    },
    
    /**
     * Apply pulse motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.pulse?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.pulse;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Apply easing
        const easeProgress = this.easeInOutSine(progress);
        
        // Calculate pulse with optional peak hold
        let pulseValue;
        let {frequency} = config;
        let {amplitude} = config;
        
        // Apply rhythm modulation if present
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }
        
        const rawPulse = (easeProgress * frequency * 2) % 2;
        
        if (config.holdPeak > 0 && rawPulse > (1 - config.holdPeak) && rawPulse < (1 + config.holdPeak)) {
            // Hold at peak
            pulseValue = 1;
        } else {
            // Normal sine wave
            pulseValue = Math.sin(easeProgress * Math.PI * 2 * frequency);
        }
        
        // Calculate expansion amount
        const expansion = pulseValue * amplitude * strength * particle.scaleFactor;
        
        // Calculate target position
        const targetDistance = data.baseDistance + expansion;
        const targetX = centerX + Math.cos(data.angle) * targetDistance;
        const targetY = centerY + Math.sin(data.angle) * targetDistance;
        
        // Smoothly move toward target
        const moveSpeed = 0.15 * dt;
        particle.vx += (targetX - particle.x) * moveSpeed * 0.1;
        particle.vy += (targetY - particle.y) * moveSpeed * 0.1;
        
        // Fade effect at the end
        if (progress > 0.9) {
            const fadeFactor = 1 - ((progress - 0.9) * 10);
            particle.vx *= (0.9 + fadeFactor * 0.1);
            particle.vy *= (0.9 + fadeFactor * 0.1);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.pulse) {
            delete particle.gestureData.pulse;
        }
    },
    
    /**
     * Sine easing for smooth breathing motion
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutSine(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
    },

    /**
     * 3D core translation
     * Maps pulse motion to 3D transforms
     */
    '3d': {
        /**
         * Evaluate 3D properties at given progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration
         * @returns {Object} 3D transform properties {position, rotation, scale, glowIntensity, glowBoost}
         */
        evaluate(progress, motion) {
            const config = motion || {};
            const frequency = config.frequency || 1;
            const strength = config.strength || 0.15;
            const scaleAmount = config.scaleAmount || 0.2;
            const glowAmount = config.glowAmount || 0.3;

            // Apply easing
            const easeProgress = -(Math.cos(Math.PI * progress) - 1) / 2;

            // Calculate pulse value
            const pulseValue = Math.sin(easeProgress * Math.PI * 2 * frequency);

            // Calculate glow variation (clamped to ±30% max for more visible effect)
            const glowVariation = Math.max(-0.3, Math.min(0.3, pulseValue * glowAmount * strength * 2));

            // Glow boost for screen-space halo - pulses with heartbeat
            const glowBoost = Math.max(0, pulseValue * 0.8);

            return {
                position: [0, 0, 0],
                rotation: [0, 0, 0],
                scale: 1.0 + pulseValue * scaleAmount * strength,
                glowIntensity: 1.0 + glowVariation,
                glowBoost
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Shake Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Shake gesture - random jitter motion
 * @author Emotive Engine Team
 * @module gestures/motions/shake
 * @complexity ⭐⭐ Intermediate
 * @audience Motion patterns for particle animations
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a shaking/vibrating effect with random jitter. Perfect for expressing     
 * ║ nervousness, excitement, or impact effects. This is a BLENDING gesture.           
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *     Frame 1        Frame 2        Frame 3
 *        ⭐      →    ⭐       →      ⭐
 *       ↙↗↘↖         ↖↘↗↙          ↗↖↙↘
 *    (random)      (random)       (random)
 * 
 * USED BY:
 * - Nervous/anxious states
 * - Anger (trembling with rage)
 * - Cold/shivering effects
 * - Impact reactions
 */

/**
 * Shake gesture configuration and implementation
 */
var shake = {
    name: 'shake',
    emoji: '🫨',
    type: 'blending', // Adds to existing motion
    description: 'Random jitter movement for vibration effects',
    
    // Default configuration
    config: {
        duration: 400,      // Animation duration
        amplitude: 15,      // Shake movement range
        frequency: 15,      // Oscillation speed
        decay: 0.9,         // Intensity reduction over time
        smoothing: 0.1,     // Motion smoothness factor
        axes: 'both',       // Affected axes: 'both', 'horizontal', 'vertical'
        easing: 'linear',   // Animation curve type
        strength: 3.0,      // Overall shake intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'shake',
            strength: 3.0,      // Particle shake strength
            frequency: 15,      // Particle oscillation rate
            decay: false        // Maintain consistent intensity
        }
    },
    
    // Rhythm configuration - shake intensifies with tempo
    rhythm: {
        enabled: true,
        syncMode: 'subdivision',  // Shake on subdivisions
        
        // Shake intensity modulation
        amplitudeSync: {
            subdivision: 'sixteenth',  // Shake on 16th notes
            onBeat: 2.5,              // Violent shake on beat
            offBeat: 0.7,             // Gentler between beats
            curve: 'pulse'            // Sharp attack
        },
        
        // Frequency scales with tempo
        frequencySync: {
            mode: 'tempo',
            baseFrequency: 15,        // Base at 120 BPM
            scaling: 'linear'         // Linear scaling with BPM
        },
        
        // Duration in musical time
        durationSync: {
            mode: 'beats',
            beats: 2                  // Shake for 2 beats
        },
        
        // Pattern-specific shake styles
        patternOverrides: {
            'breakbeat': {
                // Chaotic broken shake
                amplitudeSync: { onBeat: 3.0, offBeat: 0.2 },
                frequencySync: { mode: 'random', range: [8, 20] }
            },
            'dubstep': {
                // Bass wobble shake
                amplitudeSync: {
                    subdivision: 'eighth',
                    onBeat: 4.0,
                    dropBeat: 6.0,  // Massive shake on drop
                    curve: 'pulse'
                }
            },
            'swing': {
                // Jazzy shimmy shake
                amplitudeSync: { onBeat: 1.8, offBeat: 1.0, curve: 'ease' }
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     */
    initialize(particle, _motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        particle.gestureData.shake = {
            originalX: particle.x,  // Store original position
            originalY: particle.y,  // Store original position
            randomAngle: Math.random() * Math.PI * 2, // Random shake direction per particle
            initialized: true
        };
    },
    
    /**
     * Apply shake motion to particle
     * Creates synchronized vibration effect matching orb shake
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, _dt, _centerX, _centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.shake?.initialized) {
            this.initialize(particle, motion);
        }
        
        const data = particle.gestureData.shake;
        const config = { ...this.config, ...motion };
        const strength = config.strength || this.config.strength || 1.0;
        
        // Apply rhythm modulation if present
        let {amplitude} = config;
        let {frequency} = config;
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }
        
        // Match orb shake logic for synchronized movement
        // Apply decay if enabled to reduce intensity over time
        const decay = config.decay ? (1 - progress) : 1;
        const shake = Math.sin(progress * Math.PI * frequency) * amplitude * decay * strength * particle.scaleFactor;
        
        // Calculate directional offset using particle's random angle
        const offsetX = shake * Math.cos(data.randomAngle);
        const offsetY = shake * Math.sin(data.randomAngle);
        
        // Set particle position directly for perfect synchronization
        // Particles shake in unison with the orb
        particle.x = data.originalX + offsetX;
        particle.y = data.originalY + offsetY;
    },
    
    /**
     * Generate pseudo-random number from seed
     * @param {number} seed - Seed value
     * @returns {number} Pseudo-random value between 0 and 1
     */
    pseudoRandom(seed) {
        const x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.shake) {
            // Restore original position
            particle.x = particle.gestureData.shake.originalX;
            particle.y = particle.gestureData.shake.originalY;
            delete particle.gestureData.shake;
        }
    },

    /**
     * 3D core translation
     * Maps shake motion to 3D transforms
     */
    '3d': {
        /**
         * Evaluate 3D properties at given progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration
         * @returns {Object} 3D transform properties {position, rotation, scale}
         */
        evaluate(progress, motion) {
            const config = motion || {};
            const amplitude = (config.amplitude || 15) * 0.015;
            const frequency = config.frequency || 15;
            const strength = config.strength || 1.0;
            const decay = config.decay ? (1 - progress) : 1;

            // High-frequency shake
            const shake = Math.sin(progress * Math.PI * frequency) * amplitude * decay * strength;

            // Random seed for consistent randomness per frame
            const seed = Math.floor(progress * frequency);
            const randomX = (Math.sin(seed) * 10000) % 1;
            const randomZ = (Math.sin(seed * 1.3) * 10000) % 1;
            const randomRoll = (Math.sin(seed * 1.7) * 10000) % 1;

            return {
                position: [
                    shake * (randomX - 0.5) * 2,
                    0,
                    shake * (randomZ - 0.5) * 2
                ],
                rotation: [0, 0, shake * (randomRoll - 0.5) * 0.5],
                scale: 1.0
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Nod Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Nod gesture - vertical agreement motion
 * @author Emotive Engine Team
 * @module gestures/motions/nod
 * @complexity ⭐⭐ Intermediate
 * @audience Motion patterns for particle animations
 */

var nod = {
    name: 'nod',
    emoji: '🙂',
    type: 'blending',
    description: 'Vertical nodding motion',
    
    // Default configuration
    config: {
        duration: 500,      // Animation duration
        amplitude: 15,      // Vertical movement range
        frequency: 2,       // Number of nod cycles
        easing: 'sine',     // Animation curve type
        strength: 0.4,      // Overall motion intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'bounce',
            axis: 'vertical',   // Movement direction
            strength: 0.4,      // Particle nod strength
            frequency: 2,       // Particle nod count
            phase: 0           // Synchronization with orb
        }
    },
    
    // Rhythm configuration - nod as agreement to the beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',
        timingSync: 'nextBeat',     // Wait for next beat to start
        interruptible: false,        // Must complete the nod
        priority: 5,                 // Medium priority
        blendable: false,            // Don't blend with other motions
        minDuration: 'halfBar',      // Minimum time before interrupt
        
        // Nod frequency locks to beat
        frequencySync: {
            mode: 'subdivision',
            subdivision: 'half',  // Nod on half notes
            multiplier: 1.0
        },
        
        // Amplitude stronger on downbeats
        amplitudeSync: {
            onBeat: 1.4,
            offBeat: 0.8,
            curve: 'ease'
        },
        
        // Duration in beats
        durationSync: {
            mode: 'beats',
            beats: 2  // Nod for 2 beats
        },
        
        // Pattern-specific nodding
        patternOverrides: {
            'waltz': {
                // Graceful 3/4 nod
                frequencySync: { subdivision: 'quarter' },
                amplitudeSync: { onBeat: 1.6, curve: 'ease' }
            },
            'swing': {
                // Jazzy syncopated nod
                amplitudeSync: { onBeat: 1.5, offBeat: 0.9 }
            },
            'dubstep': {
                // Heavy head-bang on drop
                amplitudeSync: {
                    onBeat: 1.2,
                    dropBeat: 3.0,
                    curve: 'pulse'
                }
            }
        }
    },
    
    initialize(particle, _motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.nod = {
            startY: particle.y,
            initialized: true
        };
    },
    
    apply(particle, progress, motion, dt, _centerX, _centerY) {
        if (!particle.gestureData?.nod?.initialized) {
            this.initialize(particle, motion);
        }
        
        const config = { ...this.config, ...motion };
        const strength = config.strength || this.config.strength || 1.0;
        let {frequency} = config;
        let {amplitude} = config;
        
        // Apply rhythm modulation if present
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }
        
        const oscillation = Math.sin(progress * Math.PI * 2 * frequency);
        amplitude = amplitude * strength * particle.scaleFactor;
        
        // Apply vertical nodding motion
        particle.vy += oscillation * amplitude * 0.01 * dt;
        
        // Dampen at the end
        if (progress > 0.9) {
            particle.vy *= 0.95;
        }
    },
    
    cleanup(particle) {
        if (particle.gestureData?.nod) {
            delete particle.gestureData.nod;
        }
    },

    /**
     * 3D translation for nod gesture
     * Uses cameraRelativePosition for tidally-locked motion toward camera
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transform with cameraRelativePosition
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };
            let {amplitude} = config;

            // Apply rhythm modulation if present
            if (motion.rhythmModulation) {
                amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
                amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            }

            // Two quick forward dips toward camera (like nodding "yes yes")
            // First nod: 0-0.4, second nod: 0.4-0.8, settle: 0.8-1.0
            let forward = 0;
            if (progress < 0.4) {
                // First nod - full strength
                const nodT = progress / 0.4;
                forward = Math.sin(nodT * Math.PI) * 0.12;
            } else if (progress < 0.8) {
                // Second nod - smaller
                const nodT = (progress - 0.4) / 0.4;
                forward = Math.sin(nodT * Math.PI) * 0.07;
            }
            // else: settle back to 0

            // Scale by amplitude for rhythm modulation
            const ampScale = amplitude / 15; // Normalize against default amplitude
            forward *= ampScale;

            return {
                // Z in camera-relative = toward camera (tidally locked!)
                cameraRelativePosition: [0, 0, forward],
                // Subtle scale accompaniment
                scale: 1.0 - Math.abs(forward) * 0.3,
                glowIntensity: 1.0 + Math.abs(forward) * 0.5
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Vibrate Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Vibrate gesture - high frequency micro-shake
 * @author Emotive Engine Team
 * @module gestures/motions/vibrate
 * @complexity ⭐⭐ Intermediate
 * @audience Motion patterns for particle animations
 */

var vibrate = {
    name: 'vibrate',
    emoji: '📳',
    type: 'blending',
    description: 'High frequency vibration',
    
    // Default configuration
    config: {
        duration: 500,      // Animation duration
        frequency: 20,      // Vibration frequency
        amplitude: 8,       // Vibration amplitude
        easing: 'linear',   // Animation curve type
        strength: 2.0,      // Overall motion intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'shake',
            strength: 2.0,
            frequency: 20,
            amplitude: 8
        }
    },
    
    // Rhythm configuration - vibrate as tremolo effect
    rhythm: {
        enabled: true,
        syncMode: 'subdivision',
        
        // Vibration frequency syncs to tempo
        frequencySync: {
            subdivision: 'thirty-second',  // Very fast subdivisions
            baseFrequency: 20,
            tempoScaling: true  // Scale with BPM
        },
        
        // Amplitude pulses with beat
        amplitudeSync: {
            onBeat: 1.5,
            offBeat: 0.8,
            curve: 'pulse'
        },
        
        // Duration in musical time
        durationSync: {
            mode: 'beats',
            beats: 1  // Vibrate for 1 beat
        },
        
        // Pattern-specific vibration
        patternOverrides: {
            'dubstep': {
                // Bass wobble vibration
                frequencySync: { subdivision: 'sixteenth' },
                amplitudeSync: { onBeat: 2.0, dropBeat: 3.0 }
            },
            'breakbeat': {
                // Chaotic vibration
                frequencySync: { mode: 'random', range: [15, 30] }
            }
        }
    },
    
    initialize(particle, _motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.vibrate = {
            timer: 0,
            seed: Math.random() * 1000,
            initialized: true
        };
    },
    
    apply(particle, progress, motion, dt, _centerX, _centerY) {
        if (!particle.gestureData?.vibrate?.initialized) {
            this.initialize(particle, motion);
        }
        
        const data = particle.gestureData.vibrate;
        const config = { ...this.config, ...motion };
        const strength = config.strength || this.config.strength || 1.0;
        
        // Apply rhythm modulation if present
        let {amplitude} = config;
        let {frequency} = config;
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }
        
        // Update timer
        data.timer += dt * frequency;
        
        // High frequency vibration
        const vibrateX = (Math.random() - 0.5) * amplitude * strength;
        const vibrateY = (Math.random() - 0.5) * amplitude * strength;
        
        // Apply rapid vibration movements
        particle.vx += vibrateX * 0.5 * dt;
        particle.vy += vibrateY * 0.5 * dt;
        
        // Apply damping for control
        particle.vx *= 0.9;
        particle.vy *= 0.9;
        
        // Fade out at the end
        if (progress > 0.8) {
            const fadeFactor = 1 - ((progress - 0.8) * 5);
            particle.vx *= fadeFactor;
            particle.vy *= fadeFactor;
        }
    },
    
    cleanup(particle) {
        if (particle.gestureData?.vibrate) {
            delete particle.gestureData.vibrate;
        }
    },

    /**
     * 3D translation for vibrate gesture
     * High-frequency XYZ position jitter creating chaotic vibration
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transform { position: [x,y,z], rotation: [x,y,z], scale: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };
            let {amplitude} = config;
            const strength = config.strength || this.config.strength || 1.0;

            // Apply rhythm modulation if present
            if (motion.rhythmModulation) {
                amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
                amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            }

            // Scale down amplitude and use sin wave to return to origin
            const PIXEL_TO_3D = 0.003; // Convert pixel amplitude to 3D units
            const fadeOut = Math.sin(progress * Math.PI); // 0 → 1 → 0 (returns to origin)
            const vibrateScale = amplitude * strength * PIXEL_TO_3D * fadeOut;

            // High-frequency random jitter in all three axes
            const jitterX = (Math.random() - 0.5) * vibrateScale;
            const jitterY = (Math.random() - 0.5) * vibrateScale;
            const jitterZ = (Math.random() - 0.5) * vibrateScale;

            // Subtle rotation jitter for added chaos
            const rotJitterX = (Math.random() - 0.5) * 0.01 * fadeOut;
            const rotJitterY = (Math.random() - 0.5) * 0.01 * fadeOut;
            const rotJitterZ = (Math.random() - 0.5) * 0.01 * fadeOut;

            return {
                position: [jitterX, jitterY, jitterZ],
                rotation: [rotJitterX, rotJitterY, rotJitterZ],
                scale: 1.0 + (Math.random() - 0.5) * 0.01 * fadeOut
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Orbit Gesture Motion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview 3D orbital motion where particles circle around the orb
 * @author Emotive Engine Team
 * @module gestures/motions/orbit
 * @complexity ⭐⭐ Intermediate
 * @audience Motion patterns for particle animations
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a mesmerizing 3D orbit effect where particles circle around the orb,      
 * ║ dynamically transitioning between foreground and background layers using the      
 * ║ z-coordinate system. Like planets orbiting a star or a hula-hoop in motion.       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM (Top View):
 *     · → · → ·
 *   ↓           ↑
 *   ·    ⭐    ·   ← particles orbit around center
 *   ↑           ↓  
 *     · ← · ← ·
 * 
 * VISUAL DIAGRAM (Side View):
 *   front  ·····   back
 *         /     \
 *        ·   ⭐  ·  ← z-coordinate changes as particles orbit
 *         \     /
 *   back   ·····   front
 */

/**
 * Apply orbital motion to a particle
 * Particles orbit around the center with dynamic z-depth changes
 *
 * @param {Object} particle - The particle to animate
 * @param {number} progress - Gesture progress (0-1)
 * @param {Object} motion - Gesture motion configuration
 * @param {number} dt - Delta time (unused for orbit)
 * @param {number} centerX - Orb center X
 * @param {number} centerY - Orb center Y
 */
function applyOrbit(particle, progress, motion, dt, centerX, centerY) {
    // Get or initialize gesture data
    if (!particle.gestureData) {
        particle.gestureData = {};
    }
    const gestureData = particle.gestureData;

    // Extract config and strength from motion
    // motion contains the merged config from default + rhythm modulation
    const config = motion;
    const strength = motion.amplitude || 1.0;

    // Initialize gesture data if needed
    if (!gestureData.initialized) {
        // Store original position and velocity
        gestureData.originalX = particle.x;
        gestureData.originalY = particle.y;
        gestureData.originalZ = particle.z || 0;
        gestureData.originalVx = particle.vx || 0;
        gestureData.originalVy = particle.vy || 0;
        
        // Calculate initial angle and radius from center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        gestureData.radius = Math.sqrt(dx * dx + dy * dy);
        
        // Ensure minimum radius to prevent clustering at center
        if (gestureData.radius < 50) {
            gestureData.radius = 50 + Math.random() * 100;
        }
        
        gestureData.initialAngle = Math.atan2(dy, dx);
        
        // Random orbit parameters for variety
        gestureData.orbitSpeed = config.speed * (0.8 + Math.random() * 0.4); // Speed variation
        gestureData.orbitTilt = Math.random() * 0.3; // Slight tilt for realism
        
        gestureData.initialized = true;
    }
    
    // Apply rhythm modulation if present
    let {rotations} = config;
    let radiusPulseAmount = 0.05;
    if (config.rhythmModulation) {
        if (config.rhythmModulation.speedMultiplier) {
            gestureData.orbitSpeed *= config.rhythmModulation.speedMultiplier;
        }
        if (config.rhythmModulation.rotationMultiplier) {
            rotations *= config.rhythmModulation.rotationMultiplier;
        }
        if (config.rhythmModulation.radiusPulse) {
            radiusPulseAmount = config.rhythmModulation.radiusPulse;
        }
    }
    
    // Smooth entry/exit transitions
    let transitionFactor = 1.0;
    let velocityTransition = 1.0;
    
    if (progress < 0.15) {
        // Smooth entry (first 15%)
        transitionFactor = progress / 0.15;
        transitionFactor = transitionFactor * transitionFactor * (3 - 2 * transitionFactor); // Smooth step
        velocityTransition = transitionFactor;
    } else if (progress > 0.85) {
        // Smooth exit (last 15%)
        transitionFactor = (1 - progress) / 0.15;
        transitionFactor = transitionFactor * transitionFactor * (3 - 2 * transitionFactor); // Smooth step
        velocityTransition = transitionFactor;
    }
    
    // Calculate current angle based on progress with smooth acceleration
    const angle = gestureData.initialAngle + (progress * Math.PI * 2 * rotations * transitionFactor);
    
    // Calculate orbital radius (can pulse slightly) with transition
    const radiusPulse = 1 + Math.sin(progress * Math.PI * 4) * radiusPulseAmount * transitionFactor;
    const currentRadius = gestureData.radius * strength * radiusPulse * transitionFactor;
    
    // Calculate new position in orbit
    const targetX = centerX + Math.cos(angle) * currentRadius;
    const targetY = centerY + Math.sin(angle) * currentRadius;
    
    // CRITICAL: Update z-coordinate for 3D effect with smooth transition
    // Particles in front (positive z) when at top of orbit, behind (negative z) at bottom
    const zAngle = angle * config.zRotations; // Can rotate in z-plane at different rate
    particle.z = Math.sin(zAngle) * 0.8 * transitionFactor + gestureData.originalZ * (1 - transitionFactor);
    
    // During entry, smoothly transition from original position
    if (progress < 0.15) {
        const entryLerp = transitionFactor * 0.3; // Slower entry
        particle.x = gestureData.originalX + (targetX - gestureData.originalX) * entryLerp;
        particle.y = gestureData.originalY + (targetY - gestureData.originalY) * entryLerp;
        
        // Smooth velocity transition
        const orbitalVx = -Math.sin(angle) * currentRadius * gestureData.orbitSpeed;
        const orbitalVy = Math.cos(angle) * currentRadius * gestureData.orbitSpeed;
        particle.vx = gestureData.originalVx + (orbitalVx - gestureData.originalVx) * velocityTransition;
        particle.vy = gestureData.originalVy + (orbitalVy - gestureData.originalVy) * velocityTransition;
    } 
    // During exit, smoothly return to original
    else if (progress > 0.85) {
        particle.x = targetX + (gestureData.originalX - targetX) * (1 - transitionFactor);
        particle.y = targetY + (gestureData.originalY - targetY) * (1 - transitionFactor);
        
        // Smooth velocity transition back
        const orbitalVx = -Math.sin(angle) * currentRadius * gestureData.orbitSpeed;
        const orbitalVy = Math.cos(angle) * currentRadius * gestureData.orbitSpeed;
        particle.vx = orbitalVx * velocityTransition + gestureData.originalVx * (1 - velocityTransition);
        particle.vy = orbitalVy * velocityTransition + gestureData.originalVy * (1 - velocityTransition);
    }
    // Normal orbit
    else {
        // Add vertical oscillation for hula-hoop effect if enabled
        if (config.verticalOscillation > 0) {
            const verticalOffset = Math.sin(angle * 2) * config.verticalOscillation * strength;
            particle.y = targetY + verticalOffset;
            particle.x = targetX;
        } else {
            // Smooth interpolation to target position
            const lerpFactor = config.smoothness || 0.1;
            particle.x += (targetX - particle.x) * lerpFactor;
            particle.y += (targetY - particle.y) * lerpFactor;
        }
        
        // Set orbital velocity
        particle.vx = -Math.sin(angle) * currentRadius * gestureData.orbitSpeed;
        particle.vy = Math.cos(angle) * currentRadius * gestureData.orbitSpeed;
    }
    
    // Apply centripetal acContinceleration effect (particles speed up when closer)
    if (config.centripetal) {
        const speed = 1 + (1 - Math.abs(particle.z)) * 0.3; // Speed varies with z-position
        const speedAngle = gestureData.initialAngle + (progress * Math.PI * 2 * config.rotations * speed);
        particle.x = centerX + Math.cos(speedAngle) * currentRadius;
        particle.y = centerY + Math.sin(speedAngle) * currentRadius;
    }
}

// Export gesture configuration
var orbit = {
    name: 'orbit',
    emoji: '🪐',
    description: '3D orbital motion around center',
    type: 'override', // Takes full control of particle position
    
    // Default configuration
    config: {
        speed: 1.0,              // Base orbital speed
        rotations: 1,            // Number of full rotations per gesture
        zRotations: 1,           // Z-plane rotation ratio (1 = same as xy, 2 = twice as fast)
        smoothness: 0.15,        // Position interpolation factor
        verticalOscillation: 0,  // Hula-hoop vertical movement (0 = flat orbit)
        centripetal: false,      // Enable speed variation based on position
    },
    
    // Rhythm configuration - orbital motion syncs to musical cycles
    rhythm: {
        enabled: true,
        syncMode: 'bar',  // Complete orbit per bar
        
        // Orbital speed syncs to tempo
        speedSync: {
            mode: 'tempo',
            baseSpeed: 1.0,
            scaling: 'linear'  // Speed scales with BPM
        },
        
        // Rotations per musical period
        rotationSync: {
            mode: 'bars',
            rotationsPerBar: 1,  // One full orbit per bar
            zSync: true  // Z-rotation also syncs
        },
        
        // Radius pulses with beat
        radiusSync: {
            subdivision: 'quarter',
            pulsAmount: 0.1,  // 10% radius variation
            curve: 'ease'
        },
        
        // Pattern-specific orbital styles
        patternOverrides: {
            'waltz': {
                // Elegant 3-step orbit
                rotationSync: { rotationsPerBar: 0.75 },
                radiusSync: { pulsAmount: 0.15 }
            },
            'swing': {
                // Jazzy elliptical orbit
                speedSync: { mode: 'swing', ratio: 0.67 },
                verticalOscillation: 0.2
            },
            'dubstep': {
                // Wobbling orbit with drops
                radiusSync: { 
                    subdivision: 'eighth',
                    pulsAmount: 0.3,
                    dropMultiplier: 2.0
                }
            },
            'breakbeat': {
                // Chaotic orbital patterns
                speedSync: { mode: 'random', range: [0.5, 2.0] },
                centripetal: true
            }
        }
    },
    
    // Apply function
    apply: applyOrbit,
    
    // Supported emotions (great for mystical/energetic states)
    emotions: ['zen', 'love', 'excited', 'surprise'],
    
    // Gesture-specific features
    features: {
        uses3D: true,           // Uses z-coordinate system
        smooth: true,           // Smooth continuous motion
        looping: true,          // Natural looping animation
        dramatic: true          // Visually impressive effect
    },

    /**
     * 3D translation for orbit gesture
     * Note: Orbit is a motion BLENDING gesture, not to be confused with orbital
     * This creates subtle 3D rotation to enhance the blended motion feel
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transform { position: [x,y,z], rotation: [x,y,z], scale: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };
            let {rotations} = config;
            const {zRotations} = config;

            // Apply rhythm modulation if present
            if (motion.rhythmModulation) {
                if (motion.rhythmModulation.rotationMultiplier) {
                    rotations *= motion.rhythmModulation.rotationMultiplier;
                }
            }

            // Smooth entry/exit transitions
            let transitionFactor = 1.0;
            if (progress < 0.15) {
                transitionFactor = progress / 0.15;
                transitionFactor = transitionFactor * transitionFactor * (3 - 2 * transitionFactor);
            } else if (progress > 0.85) {
                transitionFactor = (1 - progress) / 0.15;
                transitionFactor = transitionFactor * transitionFactor * (3 - 2 * transitionFactor);
            }

            // Circular motion creates gentle rotation effect
            const angle = progress * Math.PI * 2 * rotations * transitionFactor;
            const zAngle = angle * zRotations;

            // Subtle rotation around all axes for blended orbital feel
            const yRotation = Math.sin(angle) * 0.1 * transitionFactor;
            const xRotation = Math.cos(angle) * 0.05 * transitionFactor;
            const zRotation = Math.sin(zAngle) * 0.05 * transitionFactor;

            // Minimal z-depth variation
            const zPosition = Math.sin(zAngle) * 0.2 * transitionFactor;

            // Slight scale pulsing
            const scalePulse = 1 + Math.sin(angle * 2) * 0.03 * transitionFactor;

            return {
                position: [0, 0, zPosition],
                rotation: [xRotation, yRotation, zRotation],
                scale: scalePulse
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Twitch Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Paranoid twitching motion for suspicious/nervous states
 * @author Emotive Engine Team
 * @module gestures/motions/twitch
 * @complexity ⭐⭐ Intermediate
 * @audience Motion patterns for particle animations
 * 
 * GESTURE TYPE:
 * type: 'blending' - Adds to existing particle motion
 * 
 * VISUAL EFFECT:
 * Random, sudden jerky movements that blend with existing behavior.
 * Creates a nervous, paranoid feeling with unpredictable micro-movements.
 */

var twitch = {
    name: 'twitch',
    emoji: '⚡',
    type: 'blending',
    description: 'Nervous, paranoid twitching',
    
    // Default configuration
    config: {
        intensity: 8,           // Twitch strength
        frequency: 0.08,        // Chance of twitching per frame
        duration: 100,          // How long each twitch lasts (ms)
        recovery: 200,          // Recovery time between twitches
        maxOffset: 15,          // Maximum twitch distance
        sharpness: 0.9         // How sudden the movements are
    },
    
    // Rhythm configuration - twitch syncs to nervous subdivisions
    rhythm: {
        enabled: true,
        syncMode: 'subdivision',
        
        // Twitch probability increases on beat
        probabilitySync: {
            subdivision: 'sixteenth',
            onBeat: 0.3,        // 30% chance on beat
            offBeat: 0.05,      // 5% chance off beat
            accentBoost: 2.0    // Double on accents
        },
        
        // Intensity follows rhythm
        intensitySync: {
            onBeat: 2.0,
            offBeat: 0.8,
            curve: 'pulse'      // Sharp, sudden
        },
        
        // Pattern-specific twitching
        patternOverrides: {
            'breakbeat': {
                // Erratic broken twitches
                probabilitySync: { onBeat: 0.5, offBeat: 0.1 },
                intensitySync: { onBeat: 3.0, offBeat: 0.5 }
            },
            'dubstep': {
                // Heavy twitch on drop
                intensitySync: {
                    onBeat: 1.5,
                    dropBeat: 5.0,
                    curve: 'pulse'
                }
            }
        }
    },
    
    apply(particle, progress, motion, dt, _centerX, _centerY) {
        // Initialize twitch data if needed
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        if (!particle.gestureData.twitch) {
            particle.gestureData.twitch = {
                twitchOffset: { x: 0, y: 0 },
                targetOffset: { x: 0, y: 0 },
                isTwitching: false,
                twitchTimer: 0,
                cooldownTimer: 0,
                lastTwitch: 0
            };
        }
        
        const data = particle.gestureData.twitch;
        const {config} = this;
        let intensity = motion.intensity || config.intensity;

        // Apply rhythm modulation if present
        if (motion.rhythmModulation) {
            intensity *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            intensity *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.probabilityMultiplier) ;
        }
        
        // Update timers
        const currentTime = Date.now();
        
        // Check for new twitch
        if (!data.isTwitching && data.cooldownTimer <= 0) {
            if (Math.random() < (motion.frequency || config.frequency)) {
                // Start a new twitch
                data.isTwitching = true;
                data.twitchTimer = config.duration;
                data.cooldownTimer = config.recovery;
                
                // Random twitch direction and distance
                const angle = Math.random() * Math.PI * 2;
                const distance = (config.maxOffset * 0.5) + Math.random() * (config.maxOffset * 0.5);
                
                data.targetOffset = {
                    x: Math.cos(angle) * distance * intensity / 8,
                    y: Math.sin(angle) * distance * intensity / 8
                };
                
                data.lastTwitch = currentTime;
            }
        }
        
        // Update cooldown
        if (data.cooldownTimer > 0) {
            data.cooldownTimer -= dt * 16;
        }
        
        // Apply twitch motion
        if (data.isTwitching) {
            data.twitchTimer -= dt * 16;
            
            if (data.twitchTimer > 0) {
                // Sharp movement toward target
                const {sharpness} = config;
                data.twitchOffset.x += (data.targetOffset.x - data.twitchOffset.x) * sharpness;
                data.twitchOffset.y += (data.targetOffset.y - data.twitchOffset.y) * sharpness;
            } else {
                // Twitch complete, start returning
                data.isTwitching = false;
            }
        } else {
            // Return to normal position
            data.twitchOffset.x *= 0.85;
            data.twitchOffset.y *= 0.85;
        }
        
        // Apply the twitch offset to velocity (blending mode)
        particle.vx += data.twitchOffset.x * dt * 0.5;
        particle.vy += data.twitchOffset.y * dt * 0.5;
        
        // Add micro-jitter for constant nervousness
        if (Math.random() < 0.1) {
            particle.vx += (Math.random() - 0.5) * intensity * 0.3;
            particle.vy += (Math.random() - 0.5) * intensity * 0.3;
        }
    },
    
    cleanup(particle) {
        if (particle.gestureData?.twitch) {
            delete particle.gestureData.twitch;
        }
    },

    /**
     * 3D translation for twitch gesture
     * Quick sudden movements in random directions with rotation
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transform { position: [x,y,z], rotation: [x,y,z], scale: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = motion.config || {};
            let intensity = config.intensity || 8;
            const maxOffset = config.maxOffset || 15;
            const frequency = config.frequency || 0.08;

            // Apply rhythm modulation if present
            if (motion.rhythmModulation) {
                intensity *= (motion.rhythmModulation.amplitudeMultiplier || 1);
                intensity *= (motion.rhythmModulation.accentMultiplier || 1);
            }

            // Create random twitch seed based on progress to get consistent but chaotic movement
            const twitchPhase = Math.floor(progress * 10); // Creates discrete twitch moments
            const seed = twitchPhase * 9999;

            // Pseudo-random but repeatable based on seed
            const random = offset => {
                const x = Math.sin(seed + offset) * 10000;
                return x - Math.floor(x);
            };

            // Determine if currently twitching (sharp probability spikes)
            const isTwitching = random(0) < frequency * 3;

            if (isTwitching) {
                // Random direction for position
                const angle = random(1) * Math.PI * 2;
                const PIXEL_TO_3D = 0.005; // 15px max = 0.075 units
                const distance = maxOffset * intensity / 8 * PIXEL_TO_3D;

                const posX = Math.cos(angle) * distance * random(2);
                const posY = Math.sin(angle) * distance * random(3);
                const posZ = (random(4) - 0.5) * distance;

                // Random rotation twitch
                const rotX = (random(5) - 0.5) * 0.2;
                const rotY = (random(6) - 0.5) * 0.2;
                const rotZ = (random(7) - 0.5) * 0.2;

                // Sharp scale variation
                const scale = 1.0 + (random(8) - 0.5) * 0.1;

                return {
                    position: [posX, posY, posZ],
                    rotation: [rotX, rotY, rotZ],
                    scale
                };
            } else {
                // Return to neutral with micro-jitter
                const microJitter = 0.5;
                return {
                    position: [
                        (random(10) - 0.5) * microJitter,
                        (random(11) - 0.5) * microJitter,
                        (random(12) - 0.5) * microJitter
                    ],
                    rotation: [
                        (random(13) - 0.5) * 0.01,
                        (random(14) - 0.5) * 0.01,
                        (random(15) - 0.5) * 0.01
                    ],
                    scale: 1.0
                };
            }
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Sway Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var sway = {
    name: 'sway',
    type: 'blending',
    emoji: '🌊',
    description: 'Gentle side-to-side swaying motion',
    
    config: {
        duration: 2000,
        amplitude: 20,
        frequency: 1,
        strength: 0.5
    },
    
    // Rhythm configuration - sway naturally follows the beat
    rhythm: {
        enabled: true,
        syncMode: 'bar',  // Sway completes one cycle per bar
        
        // Amplitude increases on downbeats
        amplitudeSync: {
            onBeat: 1.2,
            offBeat: 0.9,
            curve: 'ease'  // Smooth transitions
        },
        
        // Duration syncs to bars for natural rhythm
        durationSync: {
            mode: 'bars',
            bars: 1  // One full sway per bar
        },
        
        // Pattern-specific swaying
        patternOverrides: {
            'waltz': {
                // 3/4 time creates elegant waltz sway
                durationSync: { bars: 1 },
                amplitudeSync: { onBeat: 1.5, curve: 'ease' }
            },
            'swing': {
                // Jazzy swing sway
                amplitudeSync: { onBeat: 1.3, offBeat: 0.7, curve: 'bounce' }
            }
        }
    },
    
    /**
     * Apply sway motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, _centerX, _centerY) {
        const config = { ...this.config, ...motion };
        const amplitude = config.amplitude || this.config.amplitude;
        const frequency = config.frequency || this.config.frequency;
        const strength = config.strength || this.config.strength;
        
        // Smooth side-to-side motion
        const sway = Math.sin(progress * Math.PI * 2 * frequency) * amplitude;
        
        // Apply horizontal sway
        particle.vx += sway * 0.01 * dt * strength;
        
        // Slight vertical drift for natural feel
        particle.vy += Math.cos(progress * Math.PI * 4) * 0.5 * dt * strength;
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(_particle) {
        // No cleanup needed for sway
    },

    /**
     * 3D translation for sway gesture
     * Gentle side-to-side rocking motion with subtle rotation
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transform { position: [x,y,z], rotation: [x,y,z], scale: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };
            let amplitude = config.amplitude || this.config.amplitude;
            const frequency = config.frequency || this.config.frequency;
            const strength = config.strength || this.config.strength;

            // Apply rhythm modulation if present
            if (motion.rhythmModulation) {
                amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
                amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            }

            // Smooth sinusoidal sway
            const sway = Math.sin(progress * Math.PI * 2 * frequency);
            const verticalDrift = Math.cos(progress * Math.PI * 4) * 0.3;

            // Side-to-side position movement - scale amplitude from pixels to 3D units
            // amplitude is in pixels (e.g., 20), convert to reasonable 3D range
            const PIXEL_TO_3D = 0.01; // 20px = 0.2 units
            const swayAmount = amplitude * strength * 0.3 * PIXEL_TO_3D;
            const posX = sway * swayAmount;
            const posY = verticalDrift * swayAmount;

            // Gentle rocking rotation around Z-axis (roll)
            const rollRotation = sway * 0.15 * strength;

            // Subtle Y-axis rotation (yaw) for natural look
            const yawRotation = sway * 0.08 * strength;

            // Slight forward/back depth
            const posZ = Math.sin(progress * Math.PI * frequency) * swayAmount * 0.5;

            return {
                position: [posX, posY, posZ],
                rotation: [0, yawRotation, rollRotation],
                scale: 1.0
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Float Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var float = {
    name: 'float',
    type: 'blending',
    emoji: '🎈',
    description: 'Gentle floating upward motion',
    
    config: {
        duration: 2000,
        amplitude: 80,  // Increased for more visible effect
        wobbleAmount: 20,  // More wobble
        strength: 1.0  // Full strength
    },
    
    // Rhythm configuration - defines how this gesture responds to musical timing
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // 'beat', 'bar', 'continuous', or 'none'
        
        // How amplitude changes with beat
        amplitudeSync: {
            onBeat: 1.5,      // Multiply amplitude on beat
            offBeat: 0.8,     // Reduce amplitude off beat
            curve: 'bounce'   // Animation curve: 'linear', 'ease', 'bounce', 'pulse'
        },
        
        // How wobble syncs to subdivisions
        wobbleSync: {
            subdivision: 'eighth',  // Sync to 8th notes
            intensity: 0.7          // How much rhythm affects wobble
        },
        
        // Duration can sync to musical time
        durationSync: {
            mode: 'bars',     // Duration in bars instead of milliseconds
            bars: 2           // Float for 2 bars
        },
        
        // Response to musical accents
        accentResponse: {
            enabled: true,
            multiplier: 1.3   // Boost effect on accented beats
        },
        
        // Optional: Different behavior for different patterns
        patternOverrides: {
            'waltz': {
                wobbleSync: { subdivision: 'quarter', intensity: 0.9 }
            },
            'dubstep': {
                amplitudeSync: { onBeat: 2.0, curve: 'pulse' }
            }
        }
    },
    
    /**
     * Apply float motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, _centerX, _centerY) {
        // Store original values on first frame
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        if (!particle.gestureData.float) {
            particle.gestureData.float = {
                originalSize: particle.size,
                originalOpacity: particle.opacity || 1
            };
        }
        
        const config = { ...this.config, ...motion };
        let amplitude = config.amplitude || this.config.amplitude;
        let wobbleAmount = config.wobbleAmount || this.config.wobbleAmount;
        const strength = config.strength || this.config.strength;
        
        // Apply rhythm modulation if present (passed from GestureMotion.js)
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            wobbleAmount *= (motion.rhythmModulation.wobbleMultiplier || 1);
        }
        
        // Upward floating with slight wobble
        const wobble = Math.sin(progress * Math.PI * 4) * wobbleAmount;
        
        // Apply upward force and wobble
        particle.vy -= amplitude * 0.01 * dt * strength * (1 - progress * 0.5);
        particle.vx += wobble * 0.01 * dt * strength;
        
        // Slight size variation for depth effect
        particle.size = particle.baseSize * (1 + progress * 0.1);
        
        // Fade slightly as it floats up
        particle.opacity = 1 - progress * 0.3;
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        // Reset to original values
        if (particle.gestureData?.float) {
            particle.opacity = particle.gestureData.float.originalOpacity;
            particle.size = particle.gestureData.float.originalSize;
            delete particle.gestureData.float;
        } else {
            // Fallback if no data stored
            particle.opacity = 1;
            particle.size = particle.baseSize;
        }

        // Dampen velocity to help particle settle
        particle.vx *= 0.5;
        particle.vy *= 0.5;
    },

    /**
     * 3D translation for float gesture
     * Upward floating motion with Y position and gentle rotation
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transform { position: [x,y,z], rotation: [x,y,z], scale: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };
            let amplitude = config.amplitude || this.config.amplitude;
            let wobbleAmount = config.wobbleAmount || this.config.wobbleAmount;
            const strength = config.strength || this.config.strength;

            // Apply rhythm modulation if present
            if (motion.rhythmModulation) {
                amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
                amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
                wobbleAmount *= (motion.rhythmModulation.wobbleMultiplier || 1);
            }

            // Upward Y movement - float up and back down (return to origin)
            // Use sine wave: starts at 0, peaks at middle, returns to 0
            const PIXEL_TO_3D = 0.005; // 80px = 0.4 units
            const floatCurve = Math.sin(progress * Math.PI); // 0 → 1 → 0
            const floatDistance = amplitude * floatCurve * strength * PIXEL_TO_3D;

            // Horizontal wobble as it floats - scale from pixels
            const wobble = Math.sin(progress * Math.PI * 4) * wobbleAmount * 0.3 * PIXEL_TO_3D;

            // Gentle spinning rotation as it rises - returns to 0
            const spinCurve = Math.sin(progress * Math.PI); // 0 → 1 → 0
            const spinRotation = spinCurve * Math.PI * 0.5 * strength;

            // Slight tilt for natural balloon-like motion - returns to 0
            const tiltCurve = Math.sin(progress * Math.PI); // 0 → 1 → 0
            const tiltX = tiltCurve * Math.sin(progress * Math.PI * 2) * 0.1;
            const tiltZ = tiltCurve * Math.cos(progress * Math.PI * 3) * 0.08;

            // Scale pulses with float height (depth perception) - returns to 1.0
            const scale = 1.0 + floatCurve * 0.1; // Grows with height, shrinks back

            return {
                position: [wobble, floatDistance, 0], // Positive Y for upward in 3D
                rotation: [tiltX, spinRotation, tiltZ],
                scale
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Jitter Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var jitter = {
    name: 'jitter',
    type: 'blending',
    emoji: '🫨',
    description: 'Nervous jittery movement',
    
    config: {
        duration: 1000,
        intensity: 15,  // Increased for more visible jitter
        frequency: 30,  // Higher frequency
        strength: 1.0  // Full strength
    },
    
    // Rhythm configuration - jitter intensifies on beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',
        
        // Jitter intensity syncs to beat
        amplitudeSync: {
            onBeat: 2.0,      // Double jitter on beat
            offBeat: 0.5,     // Calmer between beats
            curve: 'pulse'    // Sharp attack
        },
        
        // Different patterns create different nervousness
        patternOverrides: {
            'breakbeat': {
                // Chaotic jitter for breakbeat
                amplitudeSync: { onBeat: 3.0, offBeat: 0.3 }
            },
            'dubstep': {
                // Freeze then explode
                amplitudeSync: { onBeat: 5.0, offBeat: 0.1, curve: 'pulse' }
            }
        }
    },
    
    /**
     * Apply jitter motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, _centerX, _centerY) {
        // Store original values on first frame
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        if (!particle.gestureData.jitter) {
            particle.gestureData.jitter = {
                originalSize: particle.size
            };
        }
        
        const config = { ...this.config, ...motion };
        let intensity = config.intensity || this.config.intensity;
        const strength = config.strength || this.config.strength;
        
        // Apply rhythm modulation if present
        if (motion.rhythmModulation) {
            intensity *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            intensity *= (motion.rhythmModulation.accentMultiplier || 1);
        }
        
        // Random jitter in both directions
        const jitterX = (Math.random() - 0.5) * intensity * strength;
        const jitterY = (Math.random() - 0.5) * intensity * strength;
        
        // Apply jitter with decreasing intensity over time
        const fadeOut = 1 - progress * 0.5;
        particle.vx += jitterX * 0.1 * dt * fadeOut;
        particle.vy += jitterY * 0.1 * dt * fadeOut;
        
        // Slight size variation for nervous effect
        particle.size = particle.baseSize * (1 + (Math.random() - 0.5) * 0.1);
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        // Reset to original values
        if (particle.gestureData?.jitter) {
            particle.size = particle.gestureData.jitter.originalSize;
            delete particle.gestureData.jitter;
        } else {
            particle.size = particle.baseSize;
        }

        // Dampen velocity to help particle settle
        particle.vx *= 0.7;
        particle.vy *= 0.7;
    },

    /**
     * 3D translation for jitter gesture
     * Random micro-movements in all directions
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transform { position: [x,y,z], rotation: [x,y,z], scale: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };
            let intensity = config.intensity || this.config.intensity;
            const strength = config.strength || this.config.strength;

            // Apply rhythm modulation if present
            if (motion.rhythmModulation) {
                intensity *= (motion.rhythmModulation.amplitudeMultiplier || 1);
                intensity *= (motion.rhythmModulation.accentMultiplier || 1);
            }

            // Scale down amplitude and use sin wave to return to origin
            const PIXEL_TO_3D = 0.002; // Convert pixel amplitude to 3D units
            const fadeOut = Math.sin(progress * Math.PI); // 0 → 1 → 0 (returns to origin)
            const jitterScale = intensity * strength * PIXEL_TO_3D * fadeOut;
            const jitterX = (Math.random() - 0.5) * jitterScale;
            const jitterY = (Math.random() - 0.5) * jitterScale;
            const jitterZ = (Math.random() - 0.5) * jitterScale;

            // Micro rotation jitter (already small)
            const rotJitterX = (Math.random() - 0.5) * 0.005 * fadeOut;
            const rotJitterY = (Math.random() - 0.5) * 0.005 * fadeOut;
            const rotJitterZ = (Math.random() - 0.5) * 0.005 * fadeOut;

            // Nervous scale variation
            const scale = 1.0 + (Math.random() - 0.5) * 0.02 * fadeOut;

            return {
                position: [jitterX, jitterY, jitterZ],
                rotation: [rotJitterX, rotJitterY, rotJitterZ],
                scale
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Wiggle Gesture
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Wiggle gesture - rapid side-to-side oscillation
 * @author Emotive Engine Team
 * @module gestures/motions/wiggle
 * @complexity ⭐⭐ Intermediate
 * @audience Motion patterns for playful animations
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a rapid wiggling motion with particles oscillating side-to-side.
 * ║ This is an ADDITIVE gesture that modifies velocity while maintaining behavior.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        Fast oscillation
 *      ← ⭐ → ⭐ ← ⭐ →
 *      (rapid side-to-side)
 *
 * USED BY:
 * - Playful excitement states
 * - Nervous energy
 * - Wiggling hello/goodbye
 * - Dance moves
 */

/**
 * Wiggle gesture configuration and implementation
 */
var wiggle = {
    name: 'wiggle',
    emoji: '〰️',
    type: 'additive', // Adds to existing motion
    description: 'Rapid side-to-side oscillation',

    // Default configuration
    config: {
        duration: 600,          // Legacy fallback
        musicalDuration: { musical: true, beats: 1 }, // 1 beat (quarter note)
        amplitude: 15,          // Wiggle distance (pixels)
        frequency: 6,           // Number of oscillations
        strength: 1.0,          // Motion intensity
        damping: 0.3,           // Velocity damping (0-1, higher = faster slowdown)
        easing: 'linear',       // Animation curve
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'wiggle',
            strength: 1.0,
            amplitude: 15,
            frequency: 6
        }
    },

    // Rhythm configuration
    rhythm: {
        enabled: true,
        syncMode: 'beat',

        // Frequency syncs to beat subdivision
        frequencySync: {
            subdivision: 'sixteenth', // Fast wiggles on 16th notes
            wigglePerBeat: 4
        },

        // Amplitude increases on beat
        amplitudeSync: {
            onBeat: 1.5,
            offBeat: 0.8,
            curve: 'bounce'
        },

        // Duration in musical time
        durationSync: {
            mode: 'beats',
            beats: 1  // Wiggle for 1 beat
        }
    },

    /**
     * Apply wiggle motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {Object} gestureData - Persistent gesture data
     * @param {Object} config - Gesture configuration
     * @param {number} progress - Gesture progress (0-1)
     * @param {number} strength - Gesture strength multiplier
     * @param {number} centerX - Orb center X (unused for wiggle)
     * @param {number} centerY - Orb center Y (unused for wiggle)
     */
    apply(particle, gestureData, config, progress, strength, centerX, centerY) {
        const amplitude = (config.amplitude || this.config.amplitude) * strength;
        const frequency = config.frequency || this.config.frequency;
        const damping = config.damping || this.config.damping;

        // Fast oscillating sine wave (side-to-side)
        const oscillation = Math.sin(progress * Math.PI * frequency);

        // Apply damping envelope (fade out towards end)
        const envelope = 1 - (progress * damping);

        // Horizontal velocity modification
        const wiggleForce = oscillation * amplitude * envelope;
        particle.vx += wiggleForce * 0.5;

        // Slight vertical component for natural feel (10% of horizontal)
        const verticalWiggle = Math.cos(progress * Math.PI * frequency * 2) * amplitude * 0.1 * envelope;
        particle.vy += verticalWiggle * 0.3;
    },

    /**
     * 3D translation for WebGL rendering
     * Uses cameraRelativePosition for horizontal shimmy relative to camera view
     */
    '3d': {
        /**
         * Evaluate 3D transform for current progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration
         * @returns {Object} Transform with cameraRelativePosition
         */
        evaluate(progress, motion) {
            const config = motion.config || {};
            const strength = motion.strength || 1.0;
            const amplitude = config.amplitude || 15; // pixels

            // Fast decay
            const decay = Math.pow(1 - progress, 0.6);
            // Rapid oscillation - left/right shimmy
            const osc = Math.sin(progress * Math.PI * 12) * decay;

            // Scale amplitude: 15px default → 0.04 horizontal shimmy
            const ampScale = (amplitude / 15) * strength;
            const horizontal = osc * 0.04 * ampScale;

            return {
                // X in camera-relative = horizontal shimmy (always side-to-side in view)
                cameraRelativePosition: [horizontal, 0, 0],
                // Slight scale pulse
                scale: 1.0 + Math.abs(osc) * 0.03,
                glowIntensity: 1.0 + Math.abs(osc) * 0.1
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Head Bob Gesture
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Head bob gesture - rhythmic vertical bobbing motion
 * @author Emotive Engine Team
 * @module gestures/motions/headBob
 * @complexity ⭐⭐ Intermediate
 * @audience Motion patterns for musical animations
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a rhythmic head bobbing motion synchronized to music beats.
 * ║ This is an ADDITIVE gesture that adds quick vertical movement.
 * ║ Like nodding along to a beat - faster and tighter than regular nod.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        Quick rhythmic bobs
 *      ↓⭐↑ ↓⭐↑
 *      (bobbing to music - spam for continuous rhythm)
 *
 * USED BY:
 * - Music synchronization
 * - Rhythmic agreement
 * - Dancing states
 * - Groove animations
 */

/**
 * Head bob gesture configuration and implementation
 */
var headBob = {
    name: 'headBob',
    emoji: '🎧',
    type: 'additive', // Adds to existing motion
    description: 'Rhythmic vertical bobbing to music',

    // Default configuration
    config: {
        duration: 600,          // Legacy fallback
        musicalDuration: { musical: true, beats: 1 }, // 1 beat duration
        amplitude: 12,          // Bob distance (pixels) - smaller than nod
        frequency: 2,           // 2 bobs per gesture - spammable for rhythm
        strength: 1.0,          // Motion intensity
        damping: 0.1,           // Minimal damping - smooth continuous motion
        easing: 'linear',       // Animation curve - steady rhythm
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'headBob',
            strength: 1.0,
            amplitude: 12,
            frequency: 2
        }
    },

    // Rhythm configuration - tight sync to beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',

        // Frequency syncs to beat subdivision
        frequencySync: {
            subdivision: 'eighth', // Quick bobs on 8th notes
            bobsPerBeat: 2
        },

        // Amplitude increases on downbeat
        amplitudeSync: {
            onBeat: 1.3,
            offBeat: 1.0,
            curve: 'pulse'
        },

        // Duration in musical time
        durationSync: {
            mode: 'beats',
            beats: 1  // Bob for 1 beat
        }
    },

    /**
     * Apply head bob motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {Object} gestureData - Persistent gesture data
     * @param {Object} config - Gesture configuration
     * @param {number} progress - Gesture progress (0-1)
     * @param {number} strength - Gesture strength multiplier
     * @param {number} centerX - Orb center X (unused for head bob)
     * @param {number} centerY - Orb center Y (unused for head bob)
     */
    apply(particle, gestureData, config, progress, strength, centerX, centerY) {
        const amplitude = (config.amplitude || this.config.amplitude) * strength;
        const frequency = config.frequency || this.config.frequency;
        const damping = config.damping || this.config.damping;

        // Quick rhythmic oscillation (vertical bobbing)
        const oscillation = Math.sin(progress * Math.PI * 2 * frequency);

        // Minimal damping - keep the energy throughout
        const envelope = 1 - (progress * damping);

        // Vertical velocity modification (primary motion)
        const bobForce = oscillation * amplitude * envelope;
        particle.vy += bobForce * 0.5;

        // Tiny horizontal component for natural feel (5% of vertical)
        const horizontalBob = Math.cos(progress * Math.PI * 2 * frequency * 1.5) * amplitude * 0.05 * envelope;
        particle.vx += horizontalBob * 0.2;
    },

    /**
     * 3D translation for WebGL rendering
     * Uses cameraRelativePosition for tidally-locked motion toward camera
     */
    '3d': {
        /**
         * Evaluate 3D transform for current progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration
         * @returns {Object} Transform with cameraRelativePosition
         */
        evaluate(progress, motion) {
            const config = motion.config || {};
            const strength = motion.strength || 1.0;
            const amplitude = config.amplitude || 12; // pixels

            // Sharp attack, smooth decay (like head bob on beat)
            const envelope = progress < 0.15
                ? progress / 0.15  // Quick attack
                : Math.pow(1 - (progress - 0.15) / 0.85, 2);  // Smooth return

            // Scale amplitude: 12px default → 0.08 forward motion
            const ampScale = (amplitude / 12) * strength;
            const forward = envelope * 0.08 * ampScale;  // Move toward camera

            return {
                // Z in camera-relative = toward camera (tidally locked!)
                cameraRelativePosition: [0, 0, forward],
                // Slight Y dip for weight feel
                position: [0, -envelope * 0.015 * ampScale, 0],
                // Scale accompaniment
                scale: 1.0 - envelope * 0.05,
                glowIntensity: 1.0 + envelope * 0.15
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Lean Gesture
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Lean gesture - tilting/leaning motion to one side
 * @author Emotive Engine Team
 * @module gestures/motions/lean
 * @complexity ⭐⭐ Intermediate
 * @audience Motion patterns for particle animations
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a leaning/tilting motion where particles shift diagonally.
 * ║ This is a BLENDING gesture that adds to existing particle motion.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *      \
 *       \⭐     <- leaning right
 *        \
 *         \
 *          \⭐  <- maximum lean
 *           \
 *            \
 *           ⭐  <- return to center
 *
 * USED BY:
 * - Curiosity emotions (leaning in to look)
 * - Interest states (tilting to examine)
 * - Playful gestures (coy head tilt)
 */

/**
 * Lean gesture configuration and implementation
 */
var lean = {
    name: 'lean',
    emoji: '↗️',
    type: 'blending', // Adds to existing motion
    description: 'Diagonal tilting motion with smooth return',

    // Default configuration
    config: {
        duration: 1200,     // Legacy fallback
        musicalDuration: { musical: true, beats: 2 }, // 2 beats
        amplitude: 10,      // Lean distance (pixels)
        frequency: 1,       // Number of lean cycles
        direction: 'right', // Lean direction: 'left' or 'right'
        strength: 0.7,      // Overall motion intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'lean',
            direction: 'right',
            strength: 0.7,
            frequency: 1
        }
    },

    // Rhythm configuration - lean syncs to musical timing
    rhythm: {
        enabled: true,
        syncMode: 'beat',         // Lean on beat
        timingSync: 'nextBeat',   // Start on next beat
        interruptible: true,      // Can interrupt mid-lean
        priority: 3,              // Lower priority
        blendable: true,          // Can blend with other effects
        crossfadePoint: 'anyBeat', // Can transition out on any beat

        // Lean intensity syncs to beat
        amplitudeSync: {
            onBeat: 1.3,      // Stronger lean on beat
            offBeat: 0.8,     // Gentler between beats
            curve: 'ease'     // Smooth curve
        },

        // Duration syncs to musical time
        durationSync: {
            mode: 'beats',
            beats: 2          // Lean for 2 beats
        },

        // Accent response for stronger emphasis
        accentResponse: {
            enabled: true,
            multiplier: 1.4   // 40% stronger on accented beats
        },

        // Pattern-specific leaning styles
        patternOverrides: {
            'waltz': {
                // 3/4 time creates elegant leaning
                durationSync: { beats: 3 },
                amplitudeSync: { onBeat: 1.5, offBeat: 0.6 }
            },
            'swing': {
                // Jazzy swing lean with character
                amplitudeSync: { onBeat: 1.6, offBeat: 0.5, curve: 'bounce' }
            }
        }
    },

    /**
     * Initialize gesture data for a particle
     * Called once when gesture starts
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     */
    initialize(particle, _motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }

        particle.gestureData.lean = {
            startX: particle.x,
            startY: particle.y,
            startVx: particle.vx,
            startVy: particle.vy,
            initialized: true
        };
    },

    /**
     * Apply lean motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, _centerX, _centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.lean?.initialized) {
            this.initialize(particle, motion);
        }

        const config = { ...this.config, ...motion };
        const strength = config.strength || this.config.strength || 1.0;

        // Apply easing for smooth motion
        const easeProgress = this.easeInOutCubic(progress);

        // Calculate lean amount
        const frequency = config.frequency || this.config.frequency;

        // Apply rhythm modulation if present
        let amplitude = config.amplitude * strength * particle.scaleFactor;
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
        }

        // Lean curve - goes to one side and returns (sine wave)
        const leanCurve = Math.sin(easeProgress * Math.PI * frequency);

        // Direction multiplier
        const directionMult = (config.direction === 'left') ? -1 : 1;

        // Apply diagonal motion (right/up or left/down)
        particle.vx += leanCurve * amplitude * 0.015 * dt * directionMult;
        particle.vy += leanCurve * amplitude * 0.01 * dt * directionMult * 0.5; // Slight vertical

        // Smooth ending - gradually reduce velocity modifications
        if (progress > 0.9) {
            const endFactor = 1 - ((progress - 0.9) * 10);
            particle.vx = particle.vx * (0.95 + endFactor * 0.05);
            particle.vy = particle.vy * (0.95 + endFactor * 0.05);
        }
    },

    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.lean) {
            delete particle.gestureData.lean;
        }
    },

    /**
     * Easing function for smooth animation
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutCubic(t) {
        return t < 0.5
            ? 4 * t * t * t
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },

    /**
     * 3D core translation
     * Maps lean motion to 3D transforms with Z-axis roll rotation
     */
    '3d': {
        /**
         * Evaluate 3D properties at given progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration
         * @returns {Object} 3D transform properties {position, rotation, scale}
         */
        evaluate(progress, motion) {
            const config = motion || {};
            const amplitudePixels = config.amplitude || 10;
            const frequency = config.frequency || 1;
            const strength = config.strength || 0.7;
            const direction = config.direction || 'right';

            // Scale pixels to 3D units
            const PIXEL_TO_3D = 0.003; // 10px = 0.03 units max, 0.021 with strength
            const amplitude = amplitudePixels * PIXEL_TO_3D * strength;

            // Apply easing
            const easeProgress = progress < 0.5
                ? 4 * progress * progress * progress
                : 1 - Math.pow(-2 * progress + 2, 3) / 2;

            // Lean curve - sine wave that returns to 0
            const leanCurve = Math.sin(easeProgress * Math.PI * frequency);

            // Direction multiplier
            const directionMult = (direction === 'left') ? -1 : 1;

            // Z-axis roll rotation (leaning left/right)
            // Max rotation: ~20 degrees (0.35 radians)
            const rollRotation = leanCurve * 0.35 * directionMult;

            // Slight X position shift for natural lean feel
            const xPosition = leanCurve * amplitude * directionMult;

            return {
                position: [xPosition, 0, 0],
                rotation: [0, 0, rollRotation],
                scale: 1.0
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Point Gesture
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Point gesture - directional pointing motion
 * @author Emotive Engine Team
 * @module gestures/motions/point
 * @complexity ⭐⭐ Intermediate
 * @audience Motion patterns for particle animations
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a pointing motion with forward momentum and directional orientation.
 * ║ This is a BLENDING gesture that adds to existing particle motion.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *       →→→
 *      ⭐→→  <- pointing forward
 *     ⭐→    <- extending
 *    ⭐      <- retracting
 *
 * USED BY:
 * - Attention-directing emotions (look there!)
 * - Emphasis states (indicating direction)
 * - Assertive gestures (pointing out)
 */

/**
 * Point gesture configuration and implementation
 */
var point = {
    name: 'point',
    emoji: '👉',
    type: 'blending', // Adds to existing motion
    description: 'Directional pointing motion with forward momentum',

    // Default configuration
    config: {
        duration: 1000,     // Legacy fallback
        musicalDuration: { musical: true, beats: 2 }, // 2 beats
        amplitude: 15,      // Point extension distance (pixels)
        direction: 'right', // Point direction: 'left', 'right', 'up', 'down'
        strength: 0.8,      // Overall motion intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'point',
            direction: 'right',
            strength: 0.8
        }
    },

    // Rhythm configuration - point syncs to musical timing
    rhythm: {
        enabled: true,
        syncMode: 'beat',         // Point on beat
        timingSync: 'nextBeat',   // Start on next beat
        interruptible: true,      // Can interrupt mid-point
        priority: 4,              // Medium priority
        blendable: true,          // Can blend with other effects
        crossfadePoint: 'anyBeat', // Can transition out on any beat

        // Point emphasis syncs to beat
        amplitudeSync: {
            onBeat: 1.5,      // Stronger point on beat
            offBeat: 0.7,     // Gentler between beats
            curve: 'ease'     // Smooth curve
        },

        // Duration syncs to musical time
        durationSync: {
            mode: 'beats',
            beats: 2          // Point for 2 beats
        },

        // Accent response for emphasis
        accentResponse: {
            enabled: true,
            multiplier: 1.6   // 60% stronger on accented beats
        },

        // Pattern-specific pointing styles
        patternOverrides: {
            'march': {
                // Strong, deliberate pointing
                amplitudeSync: { onBeat: 2.0, offBeat: 0.5, curve: 'pulse' }
            },
            'swing': {
                // Smooth jazzy pointing
                amplitudeSync: { onBeat: 1.4, offBeat: 0.8, curve: 'bounce' }
            }
        }
    },

    /**
     * Initialize gesture data for a particle
     * Called once when gesture starts
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     */
    initialize(particle, _motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }

        particle.gestureData.point = {
            startX: particle.x,
            startY: particle.y,
            startVx: particle.vx,
            startVy: particle.vy,
            initialized: true
        };
    },

    /**
     * Apply point motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, _centerX, _centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.point?.initialized) {
            this.initialize(particle, motion);
        }

        const config = { ...this.config, ...motion };
        const strength = config.strength || this.config.strength || 1.0;

        // Apply easing for smooth motion
        const easeProgress = this.easeInOutCubic(progress);

        // Apply rhythm modulation if present
        let amplitude = config.amplitude * strength * particle.scaleFactor;
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
        }

        // Point curve - extends and returns (sine wave)
        const pointCurve = Math.sin(easeProgress * Math.PI);

        // Direction vectors
        const direction = config.direction || 'right';
        let vx = 0, vy = 0;

        switch(direction) {
        case 'right':
            vx = 1;
            break;
        case 'left':
            vx = -1;
            break;
        case 'up':
            vy = -1;
            break;
        case 'down':
            vy = 1;
            break;
        }

        // Apply forward momentum
        particle.vx += pointCurve * amplitude * 0.02 * dt * vx;
        particle.vy += pointCurve * amplitude * 0.02 * dt * vy;

        // Smooth ending - gradually reduce velocity modifications
        if (progress > 0.9) {
            const endFactor = 1 - ((progress - 0.9) * 10);
            particle.vx = particle.vx * (0.95 + endFactor * 0.05);
            particle.vy = particle.vy * (0.95 + endFactor * 0.05);
        }
    },

    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.point) {
            delete particle.gestureData.point;
        }
    },

    /**
     * Easing function for smooth animation
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutCubic(t) {
        return t < 0.5
            ? 4 * t * t * t
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },

    /**
     * 3D core translation
     * Maps point motion to 3D transforms with Y-axis rotation and position
     */
    '3d': {
        /**
         * Evaluate 3D properties at given progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration
         * @returns {Object} 3D transform properties {position, rotation, scale}
         */
        evaluate(progress, motion) {
            const config = motion || {};
            const amplitudePixels = config.amplitude || 15;
            const strength = config.strength || 0.8;
            const direction = config.direction || 'right';

            // Scale pixels to 3D units
            const PIXEL_TO_3D = 0.005; // 15px = 0.075 units max, 0.06 with strength
            const amplitude = amplitudePixels * PIXEL_TO_3D * strength;

            // Apply easing
            const easeProgress = progress < 0.5
                ? 4 * progress * progress * progress
                : 1 - Math.pow(-2 * progress + 2, 3) / 2;

            // Point curve - sine wave that returns to 0
            const pointCurve = Math.sin(easeProgress * Math.PI);

            // Direction-based transformations
            let xPosition = 0;
            let yRotation = 0;

            switch(direction) {
            case 'right':
                xPosition = pointCurve * amplitude;
                yRotation = pointCurve * 0.25; // ~14 degrees
                break;
            case 'left':
                xPosition = -pointCurve * amplitude;
                yRotation = -pointCurve * 0.25;
                break;
            case 'up':
                // Point upward uses slight Y-axis tilt
                yRotation = 0;
                break;
            case 'down':
                yRotation = 0;
                break;
            }

            return {
                position: [xPosition, 0, 0],
                rotation: [0, yRotation, 0],
                scale: 1.0
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Reach Gesture
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Reach gesture - upward reaching motion
 * @author Emotive Engine Team
 * @module gestures/motions/reach
 * @complexity ⭐⭐ Intermediate
 * @audience Motion patterns for particle animations
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates an upward reaching motion with scale increase and return.
 * ║ This is a BLENDING gesture that adds to existing particle motion.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *         ⭐⭐    <- reached (scaled larger)
 *          ↑
 *          ↑
 *         ⭐     <- reaching
 *          ↑
 *          ↑
 *         ⭐     <- start
 *
 * USED BY:
 * - Hope emotions (reaching for goals)
 * - Aspiration states (striving upward)
 * - Growth gestures (expanding presence)
 */

/**
 * Reach gesture configuration and implementation
 */
var reach = {
    name: 'reach',
    emoji: '🙌',
    type: 'blending', // Adds to existing motion
    description: 'Upward reaching motion with scale increase',

    // Default configuration
    config: {
        duration: 1400,     // Legacy fallback
        musicalDuration: { musical: true, beats: 2 }, // 2 beats
        amplitude: 25,      // Reach distance (pixels)
        strength: 0.9,      // Overall motion intensity
        scaleMax: 1.05,     // Maximum scale multiplier
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'reach',
            strength: 0.9,
            scaleMax: 1.05
        }
    },

    // Rhythm configuration - reach syncs to musical timing
    rhythm: {
        enabled: true,
        syncMode: 'beat',         // Reach on beat
        timingSync: 'nextBeat',   // Start on next beat
        interruptible: true,      // Can interrupt mid-reach
        priority: 4,              // Medium priority
        blendable: true,          // Can blend with other effects
        crossfadePoint: 'anyBeat', // Can transition out on any beat

        // Reach intensity syncs to beat
        amplitudeSync: {
            onBeat: 1.4,      // Stronger reach on beat
            offBeat: 0.9,     // Gentler between beats
            curve: 'ease'     // Smooth curve
        },

        // Duration syncs to musical time
        durationSync: {
            mode: 'beats',
            beats: 2          // Reach for 2 beats
        },

        // Accent response for emphasis
        accentResponse: {
            enabled: true,
            multiplier: 1.5   // 50% stronger on accented beats
        },

        // Pattern-specific reaching styles
        patternOverrides: {
            'uplifting': {
                // Inspiring upward reach
                amplitudeSync: { onBeat: 1.8, offBeat: 0.7, curve: 'ease' },
                durationSync: { beats: 3 }
            },
            'ambient': {
                // Gentle sustained reach
                amplitudeSync: { onBeat: 1.2, offBeat: 1.0, curve: 'linear' }
            }
        }
    },

    /**
     * Initialize gesture data for a particle
     * Called once when gesture starts
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     */
    initialize(particle, _motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }

        particle.gestureData.reach = {
            startY: particle.y,
            startVy: particle.vy,
            originalSize: particle.size,
            initialized: true
        };
    },

    /**
     * Apply reach motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, _centerX, _centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.reach?.initialized) {
            this.initialize(particle, motion);
        }

        const config = { ...this.config, ...motion };
        const strength = config.strength || this.config.strength || 1.0;
        const scaleMax = config.scaleMax || this.config.scaleMax || 1.05;

        // Apply easing for smooth motion
        const easeProgress = this.easeInOutCubic(progress);

        // Apply rhythm modulation if present
        let amplitude = config.amplitude * strength * particle.scaleFactor;
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
        }

        // Reach curve - extends upward and returns (sine wave)
        const reachCurve = Math.sin(easeProgress * Math.PI);

        // Apply upward momentum
        particle.vy -= reachCurve * amplitude * 0.015 * dt;

        // Scale increases as reach extends
        const scaleMultiplier = 1.0 + (reachCurve * (scaleMax - 1.0));
        particle.size = particle.baseSize * scaleMultiplier;

        // Smooth ending - gradually reduce velocity modifications
        if (progress > 0.9) {
            const endFactor = 1 - ((progress - 0.9) * 10);
            particle.vy = particle.vy * (0.95 + endFactor * 0.05);
        }
    },

    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.reach) {
            // Reset size to original
            if (particle.gestureData.reach.originalSize) {
                particle.size = particle.gestureData.reach.originalSize;
            } else {
                particle.size = particle.baseSize;
            }
            delete particle.gestureData.reach;
        }
    },

    /**
     * Easing function for smooth animation
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutCubic(t) {
        return t < 0.5
            ? 4 * t * t * t
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },

    /**
     * 3D core translation
     * Maps reach motion to 3D transforms with Y position and scale
     */
    '3d': {
        /**
         * Evaluate 3D properties at given progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration
         * @returns {Object} 3D transform properties {position, rotation, scale}
         */
        evaluate(progress, motion) {
            const config = motion || {};
            const amplitudePixels = config.amplitude || 25;
            const strength = config.strength || 0.9;
            const scaleMax = config.scaleMax || 1.05;

            // Scale pixels to 3D units
            const PIXEL_TO_3D = 0.004; // 25px = 0.1 units max, 0.09 with strength
            const amplitude = amplitudePixels * PIXEL_TO_3D * strength;

            // Apply easing
            const easeProgress = progress < 0.5
                ? 4 * progress * progress * progress
                : 1 - Math.pow(-2 * progress + 2, 3) / 2;

            // Reach curve - sine wave that returns to 0
            const reachCurve = Math.sin(easeProgress * Math.PI);

            // Upward Y position movement
            const yPosition = reachCurve * amplitude;

            // Scale increases with reach, returns to 1.0
            const scale = 1.0 + (reachCurve * (scaleMax - 1.0));

            // Slight forward tilt as reaching up (natural body motion)
            const tiltX = reachCurve * 0.1; // ~5 degrees

            return {
                position: [0, yPosition, 0],
                rotation: [tiltX, 0, 0],
                scale
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Spin Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Spin gesture - orbital rotation around center
 * @author Emotive Engine Team
 * @module gestures/transforms/spin
 * @complexity ⭐⭐⭐ Intermediate-Advanced
 * @audience Transform patterns for complex animations
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a spinning vortex effect with particles orbiting around the center.       
 * ║ This is an OVERRIDE gesture that completely replaces particle motion.             
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ↻ Clockwise rotation
 *      · → ·
 *     ↓     ↑
 *    · ← ⭐ → ·
 *     ↑     ↓  
 *      · ← ·
 * 
 * USED BY:
 * - Dizzy/confused states
 * - Celebration spins
 * - Whirlwind effects
 * - Portal/vortex animations
 */

/**
 * Spin gesture configuration and implementation
 */
var spin = {
    name: 'spin',
    emoji: '🌀',
    type: 'override', // Completely replaces motion
    description: 'Orbital rotation around center point',
    
    // Default configuration
    config: {
        duration: 600,          // Legacy fallback
        musicalDuration: { musical: true, beats: 1 }, // 1 beat (quarter note)
        rotations: 1,           // Number of full rotations
        direction: 'random',    // 'clockwise', 'counter-clockwise', or 'random'
        radiusMultiplier: 1.0,  // Orbital radius multiplier
        spiralOut: false,       // Spiral outward while spinning
        accelerate: true,       // Speed up then slow down
        maintainDistance: true, // Keep relative distance from center
        scaleAmount: 0.1,       // Scale change during spin
        easing: 'linear',       // Animation curve type
        strength: 0.7,          // Particle motion strength
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'spin',
            strength: 0.7,
            rotations: 1,
            radius: 1.0
        }
    },
    
    // Rhythm configuration - spin as a dance move
    rhythm: {
        enabled: true,
        syncMode: 'bar',
        
        // Rotations sync to musical time
        rotationSync: {
            mode: 'bars',
            rotationsPerBar: 1,  // One spin per bar
            accelerateOnBeat: true  // Speed up on downbeats
        },
        
        // Radius changes with beat
        radiusSync: {
            subdivision: 'quarter',
            expandOnBeat: 1.2,
            contractOffBeat: 0.9,
            curve: 'bounce'
        },
        
        // Duration in musical time
        durationSync: {
            mode: 'beats',
            beats: 4  // Spin for 4 beats (1 bar)
        },
        
        // Pattern-specific spins
        patternOverrides: {
            'waltz': {
                // Elegant waltz spin
                rotationSync: { rotationsPerBar: 0.75 },
                radiusSync: { curve: 'ease' }
            },
            'swing': {
                // Jazzy swing spin
                rotationSync: { accelerateOnBeat: false },
                direction: 'alternating'  // Change direction each bar
            },
            'dubstep': {
                // Aggressive spin with wobble
                radiusSync: {
                    subdivision: 'eighth',
                    expandOnBeat: 1.5,
                    dropMultiplier: 2.0
                },
                spiralOut: true
            },
            'breakbeat': {
                // Chaotic spin patterns
                rotationSync: { mode: 'random', range: [0.5, 2] },
                direction: 'random'
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate starting position relative to center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        
        // Determine spin direction
        let direction = motion.direction || this.config.direction;
        if (direction === 'random') {
            direction = Math.random() < 0.5 ? 'clockwise' : 'counter-clockwise';
        }
        
        particle.gestureData.spin = {
            startAngle: Math.atan2(dy, dx),
            startRadius: Math.sqrt(dx * dx + dy * dy) || 30, // Min radius if at center
            originalX: particle.x,
            originalY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            direction, // Store chosen direction
            initialized: true
        };
    },
    
    /**
     * Apply spin motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.spin?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.spin;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Apply rhythm modulation if present
        let {rotations} = config;
        let {radiusMultiplier} = config;
        if (motion.rhythmModulation) {
            if (motion.rhythmModulation.rotationMultiplier) {
                rotations *= motion.rhythmModulation.rotationMultiplier;
            }
            if (motion.rhythmModulation.radiusMultiplier) {
                radiusMultiplier *= motion.rhythmModulation.radiusMultiplier;
            }
        }
        
        // Apply acceleration curve if enabled
        let speedProgress = progress;
        if (config.accelerate) {
            // Speed up for first half, slow down for second half
            if (progress < 0.5) {
                speedProgress = this.easeInQuad(progress * 2) * 0.5;
            } else {
                speedProgress = 0.5 + this.easeOutQuad((progress - 0.5) * 2) * 0.5;
            }
        }
        
        // Calculate rotation angle using stored direction
        const rotationAmount = rotations * Math.PI * 2 * strength;
        const direction = data.direction === 'counter-clockwise' ? -1 : 1;
        const currentAngle = data.startAngle + (rotationAmount * speedProgress * direction);
        
        // Calculate radius (with optional spiral)
        let currentRadius = data.startRadius;
        if (config.spiralOut) {
            currentRadius *= (1 + progress * 0.5); // Expand outward during spin
        }
        if (radiusMultiplier !== 1) {
            // Apply radius multiplier with smooth curve
            const radiusCurve = Math.sin(progress * Math.PI); // Peak at middle
            currentRadius *= (1 + (radiusMultiplier - 1) * radiusCurve);
        }
        
        // Calculate target position
        const targetX = centerX + Math.cos(currentAngle) * currentRadius;
        const targetY = centerY + Math.sin(currentAngle) * currentRadius;
        
        // For override gesture, directly set position with smooth interpolation
        const moveSpeed = 0.25; // Adjust for smoothness
        particle.x += (targetX - particle.x) * moveSpeed;
        particle.y += (targetY - particle.y) * moveSpeed;
        
        // Set velocity to match movement (for trail effects)
        particle.vx = (targetX - particle.x) * 0.5;
        particle.vy = (targetY - particle.y) * 0.5;
        
        // Smooth ending - return to original velocities
        if (progress > 0.9) {
            const endFactor = (1 - progress) * 10;
            particle.vx = particle.vx * endFactor + data.originalVx * (1 - endFactor);
            particle.vy = particle.vy * endFactor + data.originalVy * (1 - endFactor);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.spin) {
            // Restore original velocities
            const data = particle.gestureData.spin;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.spin;
        }
    },
    
    /**
     * Easing function for acceleration
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInQuad(t) {
        return t * t;
    },
    
    /**
     * Easing function for deceleration
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeOutQuad(t) {
        return t * (2 - t);
    },

    /**
     * 3D translation for WebGL rendering
     * Maps the 2D spin motion to 3D space with Y-axis rotation
     */
    '3d': {
        /**
         * Evaluate 3D transform for current progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration with particle data
         * @returns {Object} Transform with position, rotation, scale
         */
        evaluate(progress, motion) {
            const {particle} = motion;
            if (!particle || !particle.gestureData?.spin) {
                return {
                    position: [0, 0, 0],
                    rotation: [0, 0, 0],
                    scale: 1.0
                };
            }

            const data = particle.gestureData.spin;
            const config = motion.config || {};
            const strength = motion.strength || 1.0;

            // Apply acceleration curve if enabled
            let speedProgress = progress;
            if (config.accelerate) {
                if (progress < 0.5) {
                    speedProgress = (progress * progress * 4) * 0.5; // easeInQuad
                } else {
                    speedProgress = 0.5 + ((progress - 0.5) * (2 - (progress - 0.5))) * 0.5; // easeOutQuad
                }
            }

            // Calculate Y-axis rotation (spinning around vertical axis)
            // Use sin curve so rotation returns to 0 at end for smooth landing
            const rotations = config.rotations || 1;
            const rotationAmount = rotations * Math.PI * 2 * strength;
            const direction = data.direction === 'counter-clockwise' ? -1 : 1;

            // Sin curve: 0 → peak → 0 (smooth return to origin for ambient rotation blending)
            const rotationCurve = Math.sin(speedProgress * Math.PI);
            const yRotation = rotationAmount * rotationCurve * direction;

            // Scale changes during spin
            const scaleAmount = config.scaleAmount || 0.1;
            const scaleCurve = Math.sin(progress * Math.PI); // Peak at middle
            const scale = 1.0 + (scaleAmount * scaleCurve * strength);

            // Spin happens via rotation, not position movement
            return {
                position: [0, 0, 0], // Stay centered - spin via rotation
                rotation: [0, yRotation, 0], // Y-axis rotation
                scale
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Jump Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Jump gesture - squash, leap, and land animation
 * @author Emotive Engine Team
 * @module gestures/transforms/jump
 * @complexity ⭐⭐⭐ Intermediate-Advanced
 * @audience Transform patterns for complex animations
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a classic jump animation with squash & stretch principles. Particles       
 * ║ compress before jumping, stretch during flight, and squash on landing.            
 * ║ This is an OVERRIDE gesture that completely controls particle motion.             
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Phase 1: Squash    Phase 2: Jump      Phase 3: Land
 *         ⭐              ↗ ⭐ ↘              ⭐
 *         ___            /     \             ___
 *     (compressed)     (stretched)       (squashed)
 * 
 * USED BY:
 * - Joy/excitement expressions
 * - Surprise reactions
 * - Celebration animations
 * - Playful interactions
 */

/**
 * Jump gesture configuration and implementation
 */
var jump = {
    name: 'jump',
    emoji: '🦘',
    type: 'override', // Completely replaces motion
    description: 'Squash, leap, and land with classic animation principles',
    
    // Default configuration
    config: {
        duration: 800,         // Animation duration
        jumpHeight: 60,        // Maximum vertical leap distance
        squashAmount: 0.8,     // Compression ratio during squash
        stretchAmount: 1.2,    // Extension ratio during stretch
        anticipation: 0.2,     // Pre-jump preparation duration ratio
        hangTime: 0.1,         // Pause duration at jump peak
        landingImpact: true,   // Enable landing squash effect
        driftOutward: true,    // Particles spread during jump
        easing: 'quad',        // Animation curve type
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'jump',
            strength: 0.9,         // Jump motion intensity
            jumpHeight: 60,        // Particle jump height
            squash: 0.8,          // Particle compression amount
            stretch: 1.2          // Particle extension amount
        }
    },
    
    // Rhythm configuration - jump lands on beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Jump timing syncs to beat
        
        // Jump phases sync to rhythm
        phaseSync: {
            anticipation: 'eighth',    // Squash on 8th note before beat
            jump: 'beat',              // Launch on the beat
            landing: 'sixteenth'       // Land on 16th after beat
        },
        
        // Jump height modulation
        heightSync: {
            onBeat: 1.5,              // Higher jumps on strong beats
            offBeat: 0.8,             // Lower jumps on weak beats
            accent: 2.0,              // Extra high on accented beats
            curve: 'exponential'      // Sharp takeoff
        },
        
        // Squash and stretch intensity
        deformationSync: {
            squashOnBeat: 0.6,        // More squash on beat
            stretchOnBeat: 1.4,       // More stretch on beat
            timing: 'anticipatory'    // Deform before beat hits
        },
        
        // Hang time varies with tempo
        hangTimeSync: {
            mode: 'tempo',
            baseDuration: 0.1,        // Base hang at 120 BPM
            scaling: 'inverse'        // Slower tempo = longer hang
        },
        
        // Musical dynamics
        dynamics: {
            forte: { jumpHeight: 80, stretch: 1.3 },   // Big jumps on loud
            piano: { jumpHeight: 30, stretch: 1.1 }    // Small hops on soft
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, motion, centerX, _centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        particle.gestureData.jump = {
            startX: particle.x,
            startY: particle.y,
            startSize: particle.size,
            originalVx: particle.vx,
            originalVy: particle.vy,
            driftDirection: (particle.x - centerX) * 0.1, // Drift away from center
            initialized: true
        };
    },
    
    /**
     * Apply jump motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.jump?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.jump;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        const jumpHeight = config.jumpHeight * strength * particle.scaleFactor;
        const squash = config.squashAmount;
        const stretch = config.stretchAmount;
        
        // Define phase breakpoints
        const anticipationEnd = config.anticipation;
        const jumpEnd = 1 - config.anticipation * 0.5; // Leave time for landing
        
        if (progress < anticipationEnd) {
            // PHASE 1: Anticipation (squash down)
            const squashProgress = progress / anticipationEnd;
            const easedSquash = this.easeOutQuad(squashProgress);
            
            // Squash size
            particle.size = data.startSize * (1 - (1 - squash) * easedSquash);
            
            // Slightly lower position (crouch)
            particle.y = data.startY + easedSquash * 5 * particle.scaleFactor;
            
            // Stop horizontal movement during anticipation
            particle.vx = 0;
            particle.vy = 0;
            
        } else if (progress < jumpEnd) {
            // PHASE 2: Jump (arc motion with stretch)
            const jumpProgress = (progress - anticipationEnd) / (jumpEnd - anticipationEnd);
            
            // Use sine curve for smooth arc
            let jumpCurve = Math.sin(jumpProgress * Math.PI);
            
            // Add hang time at peak
            if (config.hangTime > 0 && jumpProgress > 0.4 && jumpProgress < 0.6) {
                const hangProgress = (jumpProgress - 0.4) / 0.2;
                const hangCurve = this.easeInOutCubic(hangProgress);
                jumpCurve = 0.95 + hangCurve * 0.05; // Flatten at peak
            }
            
            // Vertical position
            particle.y = data.startY - jumpCurve * jumpHeight;
            
            // Horizontal drift if enabled
            if (config.driftOutward) {
                particle.x = data.startX + jumpCurve * data.driftDirection;
            }
            
            // Stretch/squash based on velocity
            if (jumpProgress < 0.5) {
                // Going up - stretch
                const stretchProgress = jumpProgress * 2;
                particle.size = data.startSize * (squash + (stretch - squash) * stretchProgress);
            } else {
                // Coming down - return to normal then squash slightly
                const fallProgress = (jumpProgress - 0.5) * 2;
                particle.size = data.startSize * (stretch - (stretch - 1) * fallProgress * 0.8);
            }
            
            // Set velocity for motion blur/trails
            particle.vx = data.driftDirection * 0.5;
            particle.vy = -Math.cos(jumpProgress * Math.PI) * jumpHeight * 0.1;
            
        } else {
            // PHASE 3: Landing (impact squash)
            const landProgress = (progress - jumpEnd) / (1 - jumpEnd);
            const easedLand = this.easeOutBounce(landProgress);
            
            // Return to ground with bounce
            particle.y = data.startY;
            
            if (config.landingImpact) {
                // Landing squash effect
                if (landProgress < 0.3) {
                    const impactProgress = landProgress / 0.3;
                    particle.size = data.startSize * (1 - (1 - squash * 0.8) * (1 - impactProgress));
                } else {
                    // Recover from squash
                    const recoverProgress = (landProgress - 0.3) / 0.7;
                    particle.size = data.startSize * (squash * 0.8 + (1 - squash * 0.8) * recoverProgress);
                }
            } else {
                // Simple size recovery
                particle.size = data.startSize * (squash + (1 - squash) * easedLand);
            }
            
            // Gradually stop motion
            particle.vx = data.originalVx * easedLand;
            particle.vy = data.originalVy * easedLand;
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.jump) {
            const data = particle.gestureData.jump;
            // Restore original properties
            particle.size = data.startSize;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.jump;
        }
    },
    
    /**
     * Easing functions
     */
    easeOutQuad(t) {
        return t * (2 - t);
    },
    
    easeInOutCubic(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },
    
    easeOutBounce(t) {
        const n1 = 7.5625;
        const d1 = 2.75;

        if (t < 1 / d1) {
            return n1 * t * t;
        } else if (t < 2 / d1) {
            return n1 * (t -= 1.5 / d1) * t + 0.75;
        } else if (t < 2.5 / d1) {
            return n1 * (t -= 2.25 / d1) * t + 0.9375;
        } else {
            return n1 * (t -= 2.625 / d1) * t + 0.984375;
        }
    },

    /**
     * 3D translation for WebGL rendering
     * Maps the 3-phase jump animation (squash, jump, land) to 3D space
     */
    '3d': {
        /**
         * Evaluate 3D transform for current progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration with particle data
         * @returns {Object} Transform with position, rotation, scale
         */
        evaluate(progress, motion) {
            const config = motion.config || motion || {};
            const strength = motion.strength || 1.0;

            // Scale pixels to 3D units - jump should be noticeable but not off-screen
            const PIXEL_TO_3D = 0.004; // 60px = 0.24 units max
            const jumpHeightPixels = config.jumpHeight || 60;
            const jumpHeight = jumpHeightPixels * PIXEL_TO_3D * strength;

            const squash = config.squashAmount || 0.8;
            const stretch = config.stretchAmount || 1.2;

            // Define phase breakpoints
            const anticipationEnd = config.anticipation || 0.2;
            const jumpEnd = 1 - anticipationEnd * 0.5;

            let yPosition = 0;
            let scale = 1.0;
            let xRotation = 0; // Slight tilt during jump

            if (progress < anticipationEnd) {
                // PHASE 1: Anticipation (squash down)
                const squashProgress = progress / anticipationEnd;
                const easedSquash = squashProgress * (2 - squashProgress); // easeOutQuad

                scale = 1.0 - (1 - squash) * easedSquash;
                yPosition = -easedSquash * 0.02; // Slightly lower (scaled to 3D)

            } else if (progress < jumpEnd) {
                // PHASE 2: Jump (arc motion with stretch)
                const jumpProgress = (progress - anticipationEnd) / (jumpEnd - anticipationEnd);
                const jumpCurve = Math.sin(jumpProgress * Math.PI);

                yPosition = jumpCurve * jumpHeight;

                // Stretch/squash based on velocity
                if (jumpProgress < 0.5) {
                    // Going up - stretch
                    const stretchProgress = jumpProgress * 2;
                    scale = squash + (stretch - squash) * stretchProgress;
                } else {
                    // Coming down - return to normal
                    const fallProgress = (jumpProgress - 0.5) * 2;
                    scale = stretch - (stretch - 1) * fallProgress * 0.8;
                }

                // Slight forward rotation at peak
                xRotation = Math.sin(jumpProgress * Math.PI) * 0.05;

            } else {
                // PHASE 3: Landing (impact squash with bounce back)
                const landProgress = (progress - jumpEnd) / (1 - jumpEnd);

                // Small bounce back on landing
                if (landProgress < 0.5) {
                    const bounceProgress = landProgress * 2;
                    yPosition = -Math.sin(bounceProgress * Math.PI) * jumpHeight * 0.15;
                } else {
                    yPosition = 0;
                }

                if (config.landingImpact !== false) {
                    if (landProgress < 0.3) {
                        // Landing squash
                        const impactProgress = landProgress / 0.3;
                        scale = 1.0 - (1 - squash * 0.8) * (1 - impactProgress);
                    } else {
                        // Recover from squash
                        const recoverProgress = (landProgress - 0.3) / 0.7;
                        scale = squash * 0.8 + (1 - squash * 0.8) * recoverProgress;
                    }
                } else {
                    scale = squash + (1 - squash) * landProgress;
                }
            }

            return {
                position: [0, yPosition, 0], // Jump is vertical Y movement only
                rotation: [xRotation, 0, 0],
                scale
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Morph Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Morph gesture - form geometric patterns
 * @author Emotive Engine Team
 * @module gestures/transforms/morph
 * @complexity ⭐⭐⭐ Intermediate-Advanced
 * @audience Transform patterns for complex animations
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Transforms the particle cloud into geometric shapes like circles, stars,          
 * ║ hearts, or other patterns. This is an OVERRIDE gesture that moves particles       
 * ║ to specific positions to form recognizable shapes.                                
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Random Cloud      →      Star Pattern      →      Heart Pattern
 *      · · ·                    ★                         ♥♥
 *     · · · ·          →      ·   ·           →         ♥   ♥
 *      · · ·                ·   ★   ·                  ♥     ♥
 *                             ·   ·                      ♥   ♥
 *                               ★                          ♥
 * 
 * USED BY:
 * - Love emotions (heart shape)
 * - Magic/special effects (star patterns)
 * - Achievement celebrations (trophy/medal shapes)
 * - Transitions between states
 */

/**
 * Morph gesture configuration and implementation
 */
var morph = {
    name: 'morph',
    emoji: '✨',
    type: 'override', // Completely replaces motion
    description: 'Form geometric patterns and shapes',
    
    // Default configuration
    config: {
        // Musical duration - morph over 2 beats
        musicalDuration: {
            musical: true,
            beats: 2,          // Default to half a bar
            minBeats: 1,       // Minimum quarter note
            maxBeats: 8        // Maximum 2 bars
        },
        
        // Musical phases of the morph
        phases: [
            { name: 'gather', beats: 0.25 },    // Particles gather
            { name: 'form', beats: 0.75 },      // Form the shape
            { name: 'hold', beats: 0.5 },       // Hold the shape
            { name: 'dissolve', beats: 0.5 }    // Dissolve back
        ],
        
        morphType: 'fluid',     // Type of morph animation
        pattern: 'star',        // Shape to morph into
        points: 5,              // Number of points (for star/polygon)
        innerRadius: 0.4,       // Inner radius ratio (for star)
        size: 80,               // Base size of the pattern
        amplitude: 20,          // Motion amplitude
        rotation: 0,            // Rotation angle in degrees
        smooth: true,           // Smooth movement to positions
        randomizeOrder: false,  // Randomize which particles go where
        easing: 'sine',         // Animation curve type
        strength: 1.2,          // Formation strength
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'morph',
            pattern: 'star',
            strength: 1.2,
            smooth: true,
            points: 5
        }
    },
    
    // Rhythm configuration - morphs on musical phrases
    rhythm: {
        enabled: true,
        syncMode: 'phrase',  // Morph on musical phrases
        
        // Pattern changes with musical structure
        patternSync: {
            verse: 'circle',          // Simple shape for verse
            chorus: 'star',           // Complex shape for chorus
            bridge: 'heart',          // Special shape for bridge
            drop: 'explosion'         // Dramatic for drops
        },
        
        // Morph timing syncs to measures
        timingSync: {
            formationBeat: 1,         // Start forming on beat 1
            holdBeats: 2,             // Hold shape for 2 beats
            dissolveBeat: 4,          // Dissolve on beat 4
            curve: 'anticipatory'     // Ease into formation
        },
        
        // Size pulses with rhythm
        sizeSync: {
            onBeat: 1.2,              // Expand on beat
            offBeat: 0.95,            // Contract off beat
            subdivision: 'quarter',    // Pulse every quarter note
            curve: 'elastic'          // Bouncy expansion
        },
        
        // Rotation syncs to bars
        rotationSync: {
            mode: 'continuous',       // Continuous rotation
            degreesPerBar: 90,        // Rotate 90° per bar
            direction: 'clockwise'    // Rotation direction
        },
        
        // Musical dynamics affect complexity
        dynamics: {
            forte: { points: 8, size: 100 },    // Complex shapes when loud
            piano: { points: 3, size: 60 }      // Simple shapes when soft
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     * @param {EmotiveMascot} mascot - The mascot instance for core morphing
     */
    initialize(particle, motion, centerX, centerY, _mascot) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        const config = { ...this.config, ...motion };
        
        // Store original position
        const startX = particle.x;
        const startY = particle.y;
        
        // Calculate angle from center for position assignment
        const angle = Math.atan2(particle.y - centerY, particle.x - centerX);
        
        // Random rotation direction for the pattern
        const rotationDirection = Math.random() < 0.5 ? 1 : -1;
        
        // Calculate target position based on pattern
        let targetX, targetY;
        const size = config.size * particle.scaleFactor;
        const rotation = ((config.rotation || 0) * Math.PI / 180) * rotationDirection;
        
        switch (config.pattern) {
        case 'star':
            targetX = centerX;
            targetY = centerY;
            this.calculateStarPosition(particle, angle, size, config.points, config.innerRadius, rotation, centerX, centerY);
            break;
                
        case 'heart':
            this.calculateHeartPosition(particle, angle, size, rotation, centerX, centerY);
            break;
                
        case 'square':
            this.calculateSquarePosition(particle, angle, size, rotation, centerX, centerY);
            break;
                
        case 'triangle':
            this.calculateTrianglePosition(particle, angle, size, rotation, centerX, centerY);
            break;
                
        case 'circle':
        default: {
            // Simple circle pattern
            const targetRadius = size;
            targetX = centerX + Math.cos(angle + rotation) * targetRadius;
            targetY = centerY + Math.sin(angle + rotation) * targetRadius;
            break;
        }
        }
        
        particle.gestureData.morph = {
            startX,
            startY,
            targetX: particle.gestureData.morphTargetX || targetX,
            targetY: particle.gestureData.morphTargetY || targetY,
            originalVx: particle.vx,
            originalVy: particle.vy,
            rotationDirection, // Store random rotation direction
            initialized: true
        };
    },
    
    /**
     * Calculate star pattern position - mathematically correct 5-pointed star
     */
    calculateStarPosition(particle, angle, size, points, innerRadius, rotation, centerX, centerY) {
        // Create a proper 5-pointed star using mathematical formula
        // A 5-pointed star has 5 outer points and 5 inner valleys
        
        // Normalize angle to 0-2π
        const normalizedAngle = ((angle + Math.PI) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
        
        // For a 5-pointed star, we need to map to 10 positions
        // Positions 0,2,4,6,8 are outer points (tips)
        // Positions 1,3,5,7,9 are inner points (valleys)
        
        const totalPositions = 10; // Always 10 for a 5-pointed star
        const positionIndex = Math.floor((normalizedAngle / (Math.PI * 2)) * totalPositions);
        
        // Determine if this is an outer point (tip) or inner point (valley)
        const isOuterPoint = positionIndex % 2 === 0;
        const armIndex = Math.floor(positionIndex / 2);
        
        // Calculate the angle for this position
        // Outer points are at: 0°, 72°, 144°, 216°, 288°
        // Inner points are at: 36°, 108°, 180°, 252°, 324°
        let targetAngle;
        
        if (isOuterPoint) {
            // Outer point (tip of star)
            targetAngle = (armIndex * 72) * Math.PI / 180; // 72° = 360°/5
        } else {
            // Inner point (valley between arms)
            targetAngle = ((armIndex * 72) + 36) * Math.PI / 180; // 36° = 72°/2
        }
        
        // Apply rotation
        targetAngle += rotation;
        
        // Use appropriate radius
        const radius = isOuterPoint ? size : size * innerRadius;
        
        particle.gestureData.morphTargetX = centerX + Math.cos(targetAngle) * radius;
        particle.gestureData.morphTargetY = centerY + Math.sin(targetAngle) * radius;
    },
    
    /**
     * Calculate heart pattern position
     */
    calculateHeartPosition(particle, angle, size, rotation, centerX, centerY) {
        // Map angle to heart curve parameter
        const t = (angle + Math.PI) / (Math.PI * 2);
        
        // Heart parametric equations
        const scale = size * 0.05;
        const x = 16 * Math.pow(Math.sin(t * Math.PI * 2), 3);
        const y = -(13 * Math.cos(t * Math.PI * 2) - 5 * Math.cos(2 * t * Math.PI * 2) - 
                  2 * Math.cos(3 * t * Math.PI * 2) - Math.cos(4 * t * Math.PI * 2));
        
        // Scale and rotate
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        const rotX = x * cosR - y * sinR;
        const rotY = x * sinR + y * cosR;
        
        particle.gestureData.morphTargetX = centerX + rotX * scale;
        particle.gestureData.morphTargetY = centerY + rotY * scale;
    },
    
    /**
     * Calculate square pattern position
     */
    calculateSquarePosition(particle, angle, size, rotation, centerX, centerY) {
        // Determine which edge the particle should go to
        const rotatedAngle = angle + rotation;
        const normalizedAngle = ((rotatedAngle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
        
        let x, y;
        const halfSize = size;
        
        // Map to square edges
        if (normalizedAngle < Math.PI / 4 || normalizedAngle >= 7 * Math.PI / 4) {
            // Right edge
            x = halfSize;
            y = halfSize * Math.tan(normalizedAngle);
        } else if (normalizedAngle < 3 * Math.PI / 4) {
            // Top edge
            x = halfSize / Math.tan(normalizedAngle);
            y = halfSize;
        } else if (normalizedAngle < 5 * Math.PI / 4) {
            // Left edge
            x = -halfSize;
            y = -halfSize * Math.tan(normalizedAngle);
        } else {
            // Bottom edge
            x = -halfSize / Math.tan(normalizedAngle);
            y = -halfSize;
        }
        
        // Apply rotation
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        const rotX = x * cosR - y * sinR;
        const rotY = x * sinR + y * cosR;
        
        particle.gestureData.morphTargetX = centerX + rotX;
        particle.gestureData.morphTargetY = centerY + rotY;
    },
    
    /**
     * Calculate triangle pattern position
     */
    calculateTrianglePosition(particle, angle, size, rotation, centerX, centerY) {
        // Three vertices of equilateral triangle
        const vertices = [
            { x: 0, y: -size },                    // Top
            { x: -size * 0.866, y: size * 0.5 },   // Bottom left
            { x: size * 0.866, y: size * 0.5 }     // Bottom right
        ];
        
        // Determine which edge the particle should go to
        const edgeIndex = Math.floor(((angle + Math.PI) / (Math.PI * 2)) * 3) % 3;
        const nextIndex = (edgeIndex + 1) % 3;
        
        // Position along the edge
        const edgeProgress = Math.random();
        const x = vertices[edgeIndex].x + (vertices[nextIndex].x - vertices[edgeIndex].x) * edgeProgress;
        const y = vertices[edgeIndex].y + (vertices[nextIndex].y - vertices[edgeIndex].y) * edgeProgress;
        
        // Apply rotation
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        const rotX = x * cosR - y * sinR;
        const rotY = x * sinR + y * cosR;
        
        particle.gestureData.morphTargetX = centerX + rotX;
        particle.gestureData.morphTargetY = centerY + rotY;
    },
    
    /**
     * Apply morph motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.morph?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.morph;
        const config = { ...this.config, ...motion };
        
        // Calculate eased progress
        let morphProgress = progress;
        
        // Add hold time at the shape
        if (config.holdTime > 0) {
            const holdStart = 0.5 - config.holdTime / 2;
            const holdEnd = 0.5 + config.holdTime / 2;
            
            if (progress < holdStart) {
                morphProgress = progress / holdStart * 0.5;
            } else if (progress < holdEnd) {
                morphProgress = 0.5; // Hold at shape
            } else {
                morphProgress = 0.5 + (progress - holdEnd) / (1 - holdEnd) * 0.5;
            }
        }
        
        // Calculate interpolated position
        let targetX, targetY;
        
        if (morphProgress <= 0.5) {
            // Moving to shape
            const moveProgress = morphProgress * 2;
            targetX = data.startX + (data.targetX - data.startX) * this.easeOutQuad(moveProgress);
            targetY = data.startY + (data.targetY - data.startY) * this.easeOutQuad(moveProgress);
        } else {
            // Returning from shape
            const returnProgress = (morphProgress - 0.5) * 2;
            targetX = data.targetX + (data.startX - data.targetX) * this.easeInQuad(returnProgress);
            targetY = data.targetY + (data.startY - data.targetY) * this.easeInQuad(returnProgress);
        }
        
        // Apply position
        if (config.smooth) {
            // Smooth movement
            const moveSpeed = 0.2;
            particle.x += (targetX - particle.x) * moveSpeed;
            particle.y += (targetY - particle.y) * moveSpeed;
        } else {
            // Direct positioning
            particle.x = targetX;
            particle.y = targetY;
        }
        
        // Set velocity for trails
        particle.vx = (targetX - particle.x) * 0.5;
        particle.vy = (targetY - particle.y) * 0.5;
        
        // Restore original velocities at the end
        if (progress > 0.9) {
            const blendFactor = (1 - progress) * 10;
            particle.vx = particle.vx * blendFactor + data.originalVx * (1 - blendFactor);
            particle.vy = particle.vy * blendFactor + data.originalVy * (1 - blendFactor);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.morph) {
            const data = particle.gestureData.morph;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.morph;
            delete particle.gestureData.morphTargetX;
            delete particle.gestureData.morphTargetY;
        }
    },
    
    /**
     * Easing functions
     */
    easeInOutCubic(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },
    
    easeOutQuad(t) {
        return t * (2 - t);
    },
    
    easeInQuad(t) {
        return t * t;
    },

    /**
     * 3D translation for WebGL rendering
     * Creates morphing visual effect through scale, rotation, and glow modulation
     * Works independently of particle system - pure time-based transforms
     */
    '3d': {
        /**
         * Evaluate 3D transform for current progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration
         * @returns {Object} Transform with position, rotation, scale, glowIntensity, glowBoost
         */
        evaluate(progress, motion) {
            const strength = motion?.strength || 1.0;

            // Morph has two phases: formation (0-0.5) and dissolution (0.5-1)
            // Use smooth envelope that peaks at 0.5
            const envelope = Math.sin(progress * Math.PI); // 0 → 1 → 0

            // Dramatic scale transformation - expand during formation, contract during return
            // Creates visual "morphing" effect without needing particle positions
            let scaleEffect;
            if (progress <= 0.5) {
                // Formation phase: scale up smoothly
                const formProgress = progress * 2;
                const eased = formProgress * (2 - formProgress); // easeOutQuad
                scaleEffect = 1.0 + eased * 0.25 * strength;
            } else {
                // Dissolution phase: scale back down
                const dissolveProgress = (progress - 0.5) * 2;
                const eased = dissolveProgress * dissolveProgress; // easeInQuad
                scaleEffect = 1.25 * strength + (1.0 - 1.25 * strength) * eased;
                // Normalize to prevent overshooting
                scaleEffect = Math.max(1.0, scaleEffect);
            }

            // Rotation creates sense of transformation/dimensionality
            // Y-axis rotation for 3D feel, peaks at formation
            const yRotation = envelope * Math.PI * 0.3 * strength;

            // Slight Z rotation for visual interest
            const zRotation = Math.sin(progress * Math.PI * 2) * 0.1 * strength;

            // Glow intensifies during morph peak
            const glowIntensity = 1.0 + envelope * 0.4 * strength;

            // Strong glow boost at formation peak for dramatic effect
            const glowBoost = envelope * 1.5 * strength;

            return {
                position: [0, 0, 0],
                rotation: [0, yRotation, zRotation],
                scale: scaleEffect,
                glowIntensity,
                glowBoost
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Stretch Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Stretch gesture - scale particles along axes
 * @author Emotive Engine Team
 * @module gestures/transforms/stretch
 * @complexity ⭐⭐⭐ Intermediate-Advanced
 * @audience Transform patterns for complex animations
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Stretches or squashes the particle cloud along X and Y axes independently.        
 * ║ This is an OVERRIDE gesture that directly controls particle positions to          
 * ║ create elastic deformation effects.                                               
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Normal          Stretch X         Stretch Y        Squash
 *      ⭐             ← ⭐ →             ↑               ___
 *     ·⭐·           · · ⭐ · ·          ⭐              ·⭐·
 *      ⭐                                ·               ‾‾‾
 *                                        ·
 *                                        ↓
 * 
 * USED BY:
 * - Elastic animations
 * - Impact effects (squash on hit)
 * - Breathing/pulsing variations
 * - Transition effects
 */

/**
 * Stretch gesture configuration and implementation
 */
var stretch = {
    name: 'stretch',
    emoji: '↔️',
    type: 'override', // Completely replaces motion
    description: 'Scale particles along X and Y axes',
    
    // Default configuration
    config: {
        duration: 2000,        // Animation duration
        scaleX: 1.3,           // Horizontal scale factor
        scaleY: 0.9,           // Vertical scale factor
        alternate: false,      // Alternate between X and Y stretch
        elastic: true,         // Add elastic overshoot
        overshoot: 0.1,        // Elastic overshoot amount
        frequency: 1,          // Number of stretches
        easing: 'sine',        // Animation curve type
        strength: 1.0,         // Motion strength
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'stretch',
            scaleX: 1.8,       // Particle horizontal scale
            scaleY: 0.6,       // Particle vertical scale
            strength: 1.0
        },
        centerBased: true,     // Scale from center vs. origin
        preserveArea: false    // Keep total area constant
    },
    
    // Rhythm configuration - stretch pulses with rhythm
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Stretch on beats
        
        // Scale modulation with rhythm
        scaleSync: {
            onBeat: { x: 1.5, y: 0.7 },     // Stretch wide on beat
            offBeat: { x: 0.8, y: 1.3 },     // Stretch tall off beat
            subdivision: 'eighth',            // Change every 8th note
            curve: 'elastic'                 // Bouncy stretch
        },
        
        // Alternation pattern
        alternateSync: {
            pattern: 'XYXY',                 // X stretch, Y stretch pattern
            beatsPerChange: 1,               // Change axis each beat
            overlap: 0.1                      // Slight overlap in transitions
        },
        
        // Elastic overshoot on accents
        overshootSync: {
            normal: 0.1,                     // Standard overshoot
            accent: 0.3,                     // Big overshoot on accent
            downbeat: 0.2,                   // Medium on downbeat
            curve: 'spring'                  // Spring-like motion
        },
        
        // Area preservation modes
        preservationSync: {
            verse: true,                     // Maintain area in verse
            chorus: false,                   // Free deformation in chorus
            bridge: true                     // Back to preservation
        },
        
        // Musical dynamics
        dynamics: {
            forte: { scaleX: 2.0, scaleY: 0.5, overshoot: 0.4 },
            piano: { scaleX: 1.1, scaleY: 0.95, overshoot: 0.05 }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate offset from center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        
        particle.gestureData.stretch = {
            offsetX: dx,
            offsetY: dy,
            startX: particle.x,
            startY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            initialized: true
        };
    },
    
    /**
     * Apply stretch motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.stretch?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.stretch;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Calculate scale factors
        let {scaleX} = config;
        let {scaleY} = config;
        
        // Apply area preservation if enabled
        if (config.preserveArea && scaleX !== 1 && scaleY !== 1) {
            // Adjust scales to maintain area
            const targetArea = scaleX * scaleY;
            const factor = Math.sqrt(1 / targetArea);
            scaleX *= factor;
            scaleY *= factor;
        }
        
        // Handle alternating stretch
        if (config.alternate) {
            // First half: stretch X
            // Second half: stretch Y
            if (progress < 0.5) {
                const altProgress = progress * 2;
                scaleX = 1 + (scaleX - 1) * this.getElasticProgress(altProgress, config);
                scaleY = 1 + (1 / scaleX - 1) * (config.preserveArea ? 1 : 0); // Area compensation
            } else {
                const altProgress = (progress - 0.5) * 2;
                scaleX = scaleX + (1 - scaleX) * this.getElasticProgress(altProgress, config);
                scaleY = 1 + (scaleY - 1) * this.getElasticProgress(altProgress, config);
            }
        } else {
            // Apply both scales simultaneously
            const easeProgress = this.getElasticProgress(progress, config);
            scaleX = 1 + (scaleX - 1) * easeProgress * strength;
            scaleY = 1 + (scaleY - 1) * easeProgress * strength;
        }
        
        // Calculate target position
        let targetX, targetY;
        
        if (config.centerBased) {
            // Scale from center point
            targetX = centerX + data.offsetX * scaleX;
            targetY = centerY + data.offsetY * scaleY;
        } else {
            // Scale from original position
            targetX = data.startX * scaleX;
            targetY = data.startY * scaleY;
        }
        
        // Apply position
        particle.x = targetX;
        particle.y = targetY;
        
        // Set velocity based on stretch direction
        particle.vx = data.offsetX * (scaleX - 1) * strength * 0.1;
        particle.vy = data.offsetY * (scaleY - 1) * strength * 0.1;
        
        // Smooth ending
        if (progress > 0.9) {
            const endFactor = (1 - progress) * 10;
            particle.vx = particle.vx * endFactor + data.originalVx * (1 - endFactor);
            particle.vy = particle.vy * endFactor + data.originalVy * (1 - endFactor);
        }
    },
    
    /**
     * Calculate progress with optional elastic overshoot
     * @param {number} progress - Raw progress (0-1)
     * @param {Object} config - Configuration with elastic settings
     * @returns {number} Modified progress value
     */
    getElasticProgress(progress, config) {
        if (!config.elastic) {
            return this.easeInOutCubic(progress);
        }
        
        // Elastic easing with overshoot
        if (progress === 0) return 0;
        if (progress === 1) return 1;
        
        const overshoot = config.overshoot || 0.1;


        
        if (progress < 0.5) {
            // Ease in with slight pull back
            const t = progress * 2;
            return 0.5 * this.easeInElastic(t, overshoot);
        } else {
            // Ease out with overshoot
            const t = (progress - 0.5) * 2;
            return 0.5 + 0.5 * this.easeOutElastic(t, overshoot);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.stretch) {
            const data = particle.gestureData.stretch;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.stretch;
        }
    },
    
    /**
     * Easing functions
     */
    easeInOutCubic(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },
    
    easeInElastic(t, overshoot) {
        if (t === 0) return 0;
        if (t === 1) return 1;
        const p = 0.3;
        const s = p / 4;
        return -(Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - s) * (2 * Math.PI) / p)) * (1 + overshoot);
    },
    
    easeOutElastic(t, overshoot) {
        if (t === 0) return 0;
        if (t === 1) return 1;
        const p = 0.3;
        const s = p / 4;
        return Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) * (1 + overshoot) + 1;
    },

    /**
     * 3D translation for WebGL rendering
     * Maps axis-based stretching to 3D scale transformations
     */
    '3d': {
        /**
         * Evaluate 3D transform for current progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration with particle data
         * @returns {Object} Transform with position, rotation, scale
         */
        evaluate(progress, motion) {
            const {particle} = motion;
            if (!particle || !particle.gestureData?.stretch) {
                return {
                    position: [0, 0, 0],
                    rotation: [0, 0, 0],
                    scale: 1.0
                };
            }

            // const data = particle.gestureData.stretch;
            const config = motion.config || {};
            const strength = motion.strength || 1.0;

            // Calculate scale factors
            let scaleX = config.scaleX || 1.3;
            let scaleY = config.scaleY || 0.9;
            // const scaleZ = 1.0; // No Z-axis stretching by default

            // Apply area preservation if enabled
            if (config.preserveArea && scaleX !== 1 && scaleY !== 1) {
                const targetArea = scaleX * scaleY;
                const factor = Math.sqrt(1 / targetArea);
                scaleX *= factor;
                scaleY *= factor;
            }

            // Get elastic progress
            let easeProgress;
            if (!config.elastic) {
                // Simple cubic easing
                easeProgress = progress < 0.5
                    ? 4 * progress * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
            } else {
                // Elastic easing with overshoot
                const overshoot = config.overshoot || 0.1;
                if (progress < 0.5) {
                    const t = progress * 2;
                    const p = 0.3;
                    const s = p / 4;
                    easeProgress = 0.5 * (-(Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - s) * (2 * Math.PI) / p)) * (1 + overshoot));
                } else {
                    const t = (progress - 0.5) * 2;
                    const p = 0.3;
                    const s = p / 4;
                    easeProgress = 0.5 + 0.5 * (Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) * (1 + overshoot) + 1);
                }
            }

            // Fade-out envelope for smooth return to neutral at end
            // Last 20% of animation fades back to neutral
            const fadeOutStart = 0.8;
            let envelope = 1.0;
            if (progress > fadeOutStart) {
                const fadeProgress = (progress - fadeOutStart) / (1.0 - fadeOutStart);
                // Ease-out cubic for smooth deceleration
                envelope = 1.0 - (fadeProgress * fadeProgress * fadeProgress);
            }

            // Handle alternating stretch - MUCH MORE DRAMATIC
            let scaleOffset;
            if (config.alternate) {
                // Alternate between vertical and horizontal stretch
                if (progress < 0.5) {
                    // First half: stretch vertically (tall and thin)
                    const t = progress * 2; // 0 to 1
                    scaleOffset = t * 0.8; // Offset: 0.0 to 0.8
                } else {
                    // Second half: squash vertically (short and wide)
                    const t = (progress - 0.5) * 2; // 0 to 1
                    scaleOffset = 0.8 - t * 1.4; // Offset: 0.8 to -0.6
                }
            } else {
                // Single stretch direction - dramatic vertical elongation
                scaleOffset = easeProgress * 1.0 * strength; // Offset: 0.0 to 1.0
            }

            // Apply envelope to scale offset
            const finalScale = 1.0 + scaleOffset * envelope; // Fade back to 1.0

            // Add rotation wobble during stretch for more visual impact
            const wobble = Math.sin(progress * Math.PI * 4) * 0.1 * easeProgress * envelope;

            return {
                position: [0, 0, 0],
                rotation: [0, 0, wobble], // Z-axis wobble
                scale: finalScale
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Tilt Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Tilt gesture - particles gather and sway together
 * @author Emotive Engine Team
 * @module gestures/transforms/tilt
 * @complexity ⭐⭐⭐ Intermediate-Advanced
 * @audience Transform patterns for complex animations
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a cohesive tilting motion where particles first gather toward the center, 
 * ║ then tilt and sway as a unified group. Perfect for curious or questioning         
 * ║ expressions, like a head tilt.                                                    
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Phase 1: Gather    Phase 2: Tilt Left    Phase 3: Tilt Right
 *      · · ·               ↖ ⭐                    ⭐ ↗
 *     · · · ·      →      ↖ ⭐ ⭐        →      ⭐ ⭐ ↗
 *      · · ·               ↖ ⭐                    ⭐ ↗
 *    (scattered)         (tilted left)         (tilted right)
 * 
 * USED BY:
 * - Curiosity/questioning states
 * - Contemplation animations
 * - Playful head-tilt effects
 * - Character personality expressions
 */

/**
 * Tilt gesture configuration and implementation
 */
var tilt = {
    name: 'tilt',
    emoji: '🤔',
    type: 'override', // Completely replaces motion
    description: 'Gather particles then tilt as unified group',
    
    // Default configuration
    config: {
        duration: 500,         // Animation duration
        gatherPhase: 0.2,      // Gathering phase ratio
        tiltAngle: 45,         // Maximum tilt angle in degrees
        swayAmount: 80,        // Horizontal sway distance
        liftAmount: 60,        // Vertical lift distance during tilt
        frequency: 3,          // Number of tilt cycles
        homeRadius: 20,        // Gathering radius from center
        easing: 'sine',        // Animation curve type
        strength: 2.5,         // Overall motion intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'tilt',
            strength: 2.5,
            frequency: 3,
            swayAmount: 80,
            liftAmount: 60
        },
        smoothness: 0.25       // Movement smoothing factor
    },
    
    // Rhythm configuration - tilts sync to swing rhythm
    rhythm: {
        enabled: true,
        syncMode: 'swing',  // Tilt with swing feel
        
        // Tilt angle syncs to beat pattern
        angleSync: {
            onBeat: 45,                      // Full tilt on beat
            offBeat: -30,                    // Counter-tilt off beat
            swing: 15,                       // Extra tilt on swing beats
            subdivision: 'triplet',          // Triplet feel for smooth sway
            curve: 'ease-in-out'            // Smooth tilt transitions
        },
        
        // Gathering phase timing
        gatherSync: {
            beatsBefore: 0.5,                // Gather half beat before tilt
            releaseAfter: 0.25,              // Release quarter beat after
            intensity: 'dynamic'             // Gather speed varies with tempo
        },
        
        // Sway amount modulation
        swaySync: {
            verse: 60,                       // Gentle sway in verse
            chorus: 100,                     // Big sway in chorus
            bridge: 80,                      // Medium in bridge
            syncopated: true                 // Off-beat emphasis
        },
        
        // Lift coordination
        liftSync: {
            upOnTilt: true,                  // Lift when tilting
            heightOnAccent: 80,              // Higher lift on accents
            normalHeight: 40,                // Standard lift height
            curve: 'bounce'                  // Bouncy lift motion
        },
        
        // Musical expression
        dynamics: {
            forte: { tiltAngle: 60, swayAmount: 120, frequency: 4 },
            piano: { tiltAngle: 20, swayAmount: 40, frequency: 2 }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate initial position and angle
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const angle = Math.atan2(dy, dx);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Assign a role for variation (some particles lag slightly)
        const role = Math.random();
        
        // Calculate home position (where particle gathers to)
        const config = { ...this.config, ...motion };
        const homeRadius = (config.homeRadius + Math.random() * 20) * particle.scaleFactor;
        
        particle.gestureData.tilt = {
            startX: particle.x,
            startY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            angle,
            distance,
            homeRadius,
            homeX: centerX + Math.cos(angle) * homeRadius,
            homeY: centerY + Math.sin(angle) * homeRadius,
            role, // Variation factor for timing and smoothness
            initialized: true
        };
    },
    
    /**
     * Apply tilt motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.tilt?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.tilt;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        let targetX, targetY;
        
        if (progress < config.gatherPhase) {
            // PHASE 1: Gather toward center
            const gatherProgress = progress / config.gatherPhase;
            const easedGather = this.easeInOutCubic(gatherProgress);
            
            // Interpolate from start to home position
            targetX = data.startX + (data.homeX - data.startX) * easedGather;
            targetY = data.startY + (data.homeY - data.startY) * easedGather;
            
            // Apply gathering motion
            const speed = 0.6;  // Gathering speed factor
            particle.x += (targetX - particle.x) * speed;
            particle.y += (targetY - particle.y) * speed;
            
        } else {
            // PHASE 2: Tilting motion
            const tiltPhase = (progress - config.gatherPhase) / (1 - config.gatherPhase);
            const t = tiltPhase * Math.PI * config.frequency;
            const tiltProgress = Math.sin(t);
            
            // Convert tilt angle to radians
            const maxTiltRad = (config.tiltAngle * Math.PI / 180) * strength;
            
            // Calculate sway angle (oscillates left and right)
            const swayAngle = data.angle + (tiltProgress * maxTiltRad);
            
            // Add lift effect (particles rise slightly during tilt)
            const liftAmount = Math.abs(tiltProgress) * config.liftAmount * particle.scaleFactor;
            const currentRadius = data.homeRadius + liftAmount;
            
            // Calculate target position with tilt
            targetX = centerX + Math.cos(swayAngle) * currentRadius;
            targetY = centerY + Math.sin(swayAngle) * currentRadius - liftAmount * 0.3; // Add upward bias
            
            // Apply role-based variation (some particles lag)
            const smoothness = config.smoothness + data.role * 0.1;
            
            // Smooth movement to target
            particle.x += (targetX - particle.x) * smoothness;
            particle.y += (targetY - particle.y) * smoothness;
            
            // Add subtle rotation feel with velocity
            const tangentX = -Math.sin(swayAngle);
            const tangentY = Math.cos(swayAngle);
            particle.vx = tangentX * tiltProgress * 2;
            particle.vy = tangentY * tiltProgress * 2;
        }
        
        // Store current velocity for trails
        if (progress < config.gatherPhase) {
            particle.vx = (targetX - particle.x) * 0.25;
            particle.vy = (targetY - particle.y) * 0.25;
        }
        
        // Smooth ending - return to original velocities
        if (progress > 0.9) {
            const endFactor = (1 - progress) * 10;
            const returnX = data.startX + (particle.x - data.startX) * endFactor;
            const returnY = data.startY + (particle.y - data.startY) * endFactor;
            
            particle.x = returnX;
            particle.y = returnY;
            particle.vx = particle.vx * endFactor + data.originalVx * (1 - endFactor);
            particle.vy = particle.vy * endFactor + data.originalVy * (1 - endFactor);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.tilt) {
            const data = particle.gestureData.tilt;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.tilt;
        }
    },
    
    /**
     * Easing function for smooth animation
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutCubic(t) {
        return t < 0.5
            ? 4 * t * t * t
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },

    /**
     * 3D translation for WebGL rendering
     * Maps tilt swaying motion to Z-axis rotation (side-to-side head tilt)
     */
    '3d': {
        /**
         * Evaluate 3D transform for current progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration
         * @returns {Object} Transform with position, rotation, scale
         */
        evaluate(progress, motion) {
            const config = motion.config || {};
            const strength = motion.strength || 1.0;
            const gatherPhase = config.gatherPhase || 0.2;
            const frequency = config.frequency || 3;
            const tiltAngle = config.tiltAngle || 45;

            let zRotation = 0;

            if (progress >= gatherPhase) {
                // PHASE 2: Tilting motion
                const tiltPhase = (progress - gatherPhase) / (1 - gatherPhase);
                const t = tiltPhase * Math.PI * frequency;
                const tiltProgress = Math.sin(t);

                // Convert tilt angle to radians and reduce for subtle tilt
                const maxTiltRad = (tiltAngle * Math.PI / 180) * strength * 0.4; // Reduced to 40% (18°)

                // Z-axis rotation for side-to-side head tilt
                zRotation = tiltProgress * maxTiltRad;
            }

            return {
                position: [0, 0, 0], // Tilt happens via rotation, stay centered
                rotation: [0, 0, zRotation],
                scale: 1.0
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Orbital Gesture with 3D Depth
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview 3D orbital gesture - particles orbit with dynamic z-depth changes
 * @author Emotive Engine Team
 * @module gestures/transforms/orbital
 * @complexity ⭐⭐⭐ Intermediate-Advanced
 * @audience Transform patterns for complex animations
 * 
 * GESTURE TYPE:
 * type: 'override' - Takes complete control of particle motion
 * 
 * ACCEPTABLE TYPES:
 * - 'blending' : Adds motion to existing particle behavior (used in motions/)
 * - 'override' : Replaces particle motion completely (used in transforms/)
 * - 'effect'   : Visual effects without changing position (used in effects/)
 * 
 * VISUAL EFFECT:
 * Particles orbit around the center while transitioning between foreground and
 * background layers, creating a true 3D effect where particles pass behind and
 * in front of the orb.
 */

var orbital = {
    name: 'orbital',
    emoji: '🪐',
    type: 'override',
    description: 'Orbital motion around center',
    
    // Default configuration
    config: {
        speed: 0.02,              // Orbital rotation speed
        maintainRadius: true,     // Keep constant orbit radius
        elliptical: false,        // Use circular orbit
        use3D: true,              // Enable z-coordinate animation
        zPhaseOffset: 0,          // Phase offset for z-oscillation
        verticalOscillation: 0,   // Vertical movement for hula-hoop effect
        duration: 3000,           // Animation duration
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'orbital',
            strength: 1.0
        }
    },
    
    // Rhythm configuration - orbital paths sync to harmony
    rhythm: {
        enabled: true,
        syncMode: 'harmonic',  // Orbit follows harmonic intervals
        
        // Speed based on harmonic ratios
        speedSync: {
            tonic: 0.02,              // Base orbit speed
            fifth: 0.03,              // 3:2 ratio (perfect fifth)
            octave: 0.04,             // 2:1 ratio (octave)
            third: 0.025,             // 5:4 ratio (major third)
            curve: 'smooth'           // Smooth transitions
        },
        
        // Orbital layers by pitch
        radiusSync: {
            bass: 150,                // Outer orbit for low notes
            mid: 100,                 // Middle orbit for mids
            treble: 50,               // Inner orbit for highs
            scaling: 'logarithmic'    // Natural pitch scaling
        },
        
        // 3D depth syncs to chord progression
        depthSync: {
            major: { z: 1.0, phase: 0 },        // Front-facing for major
            minor: { z: -1, phase: Math.PI }, // Back-facing for minor
            diminished: { z: 0.5, phase: Math.PI/2 }, // Side angle
            augmented: { z: 0.8, phase: -Math.PI/2 }  // Other side
        },
        
        // Phase relationships
        phaseSync: {
            mode: 'harmonic',         // Particles phase-lock harmonically
            intervals: [1, 1.5, 2],   // Unison, fifth, octave
            drift: 0.05               // Slight phase drift for organic feel
        },
        
        // Musical dynamics
        dynamics: {
            forte: { speed: 0.04, maintainRadius: false }, // Chaotic orbits
            piano: { speed: 0.01, maintainRadius: true }   // Stable orbits
        }
    },
    
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const calculatedRadius = Math.sqrt(dx * dx + dy * dy);
        
        // Random direction for orbit
        const direction = Math.random() < 0.5 ? 1 : -1;
        
        // Set minimum radius to prevent center clustering - 3x larger spread
        const MIN_RADIUS = 100;
        const radius = Math.max(calculatedRadius, MIN_RADIUS + Math.random() * 180); // At least 180-360 pixels
        
        const initialAngle = calculatedRadius < 5 ? Math.random() * Math.PI * 2 : Math.atan2(dy, dx);
        particle.gestureData.orbital = {
            radius,
            targetRadius: radius, // Store target for smooth transitions
            angle: initialAngle,
            initialAngle,  // Store initial angle for relative rotation
            originalVx: particle.vx,
            originalVy: particle.vy,
            originalZ: particle.z || 0,  // Store original z-coordinate
            zPhase: Math.random() * Math.PI * 2,  // Random phase for variety
            direction  // Random orbit direction
        };
    },
    
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.orbital) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.orbital;
        const speed = (motion.speed || this.config.speed) * (motion.strength || 1);
        
        // Update angle with direction (dt is already normalized to 60fps)
        data.angle += speed * dt * data.direction;
        
        // Use the stored radius (which has minimum enforced)
        let {radius} = data;
        
        if (!motion.maintainRadius) {
            // Allow radius to vary slightly for organic motion
            radius = data.radius * (1 + Math.sin(progress * Math.PI * 2) * 0.1);
        }
        
        particle.x = centerX + Math.cos(data.angle) * radius;
        particle.y = centerY + Math.sin(data.angle) * radius;
        
        // 3D DEPTH: Animate z-coordinate for particles passing behind/in front
        if (motion.use3D !== false) {  // Default to true
            // Z oscillates as particle orbits, creating 3D effect
            // When angle is 0/2π (right side), z is positive (front)
            // When angle is π (left side), z is negative (back)
            const zAngle = data.angle + data.zPhase + (motion.zPhaseOffset || 0);
            particle.z = Math.sin(zAngle) * 0.8; // Z-depth range for layering
            
            // Add vertical oscillation for hula-hoop effect
            if (motion.verticalOscillation) {
                const verticalOffset = Math.cos(zAngle) * motion.verticalOscillation * radius * 0.1;
                particle.y += verticalOffset;
            }
        }
        
        // Set velocity to match motion
        particle.vx = -Math.sin(data.angle) * radius * speed;
        particle.vy = Math.cos(data.angle) * radius * speed;
        
        // Restore original velocity at end
        if (progress > 0.9) {
            const blendFactor = (1 - progress) * 10;
            particle.vx = particle.vx * blendFactor + data.originalVx * (1 - blendFactor);
            particle.vy = particle.vy * blendFactor + data.originalVy * (1 - blendFactor);
        }
    },
    
    cleanup(particle) {
        if (particle.gestureData?.orbital) {
            const data = particle.gestureData.orbital;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            particle.z = data.originalZ;  // Restore original z-coordinate
            delete particle.gestureData.orbital;
        }
    },

    /**
     * 3D translation for WebGL rendering
     * Circular XY motion with Z-depth oscillation (MUST read particle.z)
     */
    '3d': {
        /**
         * Evaluate 3D transform for current progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration with particle data
         * @returns {Object} Transform with position, rotation, scale
         */
        evaluate(progress, motion) {
            const {particle} = motion;
            if (!particle || !particle.gestureData?.orbital) {
                return {
                    position: [0, 0, 0],
                    rotation: [0, 0, 0],
                    scale: 1.0
                };
            }

            const data = particle.gestureData.orbital;
            motion.config || {};

            // Smooth entry/exit envelope - starts from 0, peaks at 1, returns to 0
            let envelope = 1.0;
            if (progress < 0.15) {
                // Smooth entry (first 15%)
                envelope = progress / 0.15;
                envelope = Math.sin(envelope * Math.PI * 0.5); // Ease-in
            } else if (progress > 0.85) {
                // Smooth exit (last 15%)
                envelope = (1 - progress) / 0.15;
                envelope = Math.sin(envelope * Math.PI * 0.5); // Ease-out
            }

            // RELATIVE orbital motion: circular path in XZ plane
            const orbitRadius = 0.3; // Orbit radius in 3D units

            // Calculate angle based on progress for smooth circular motion
            // Start from initial angle, complete full rotation during gesture
            const angle = data.initialAngle + (progress * Math.PI * 2 * data.direction);

            // RELATIVE circular motion (starts from 0, peaks, returns to 0)
            const xOffset = Math.cos(angle) * orbitRadius * envelope;
            const zOffset = Math.sin(angle) * orbitRadius * envelope;

            // RELATIVE rotation to face direction of motion (tangent to orbit)
            const tangentAngle = angle + Math.PI / 2;
            const yRotation = (tangentAngle - (data.initialAngle + Math.PI / 2)) * envelope;

            // READ particle.z for depth variation
            const depthZ = particle.z || 0;
            const finalZ = zOffset + (depthZ * 0.1 * envelope); // Add depth variation

            // Scale based on depth (particles further back appear smaller)
            const depthScale = 1.0 + depthZ * 0.15 * envelope;

            return {
                position: [xOffset, 0, finalZ], // RELATIVE offset from current position
                rotation: [0, yRotation, 0],    // RELATIVE rotation from current
                scale: depthScale
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Hula-Hoop Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Hula-hoop variation of orbital with vertical oscillation
 * @author Emotive Engine Team
 * @module gestures/transforms/hula
 * @complexity ⭐⭐⭐ Intermediate-Advanced
 * @audience Transform patterns for complex animations
 * 
 * VISUAL EFFECT:
 * Like a hula-hoop spinning around the orb - particles orbit horizontally while
 * oscillating vertically, creating a tilted ring effect with 3D depth.
 */

var hula = {
    name: 'hula',
    emoji: '🌀',
    type: 'override',
    description: 'Hula-hoop motion with vertical waves',
    
    // Default configuration
    config: {
        speed: 0.015,             // Rotation speed
        maintainRadius: false,     // Allow radius variation for organic feel
        elliptical: true,          // Elliptical orbit shape
        use3D: true,               // Enable 3D depth effect
        zPhaseOffset: Math.PI / 4, // Ring tilt angle
        verticalOscillation: 0.3,  // Vertical wave amount
        wobbleAmount: 0.15,        // Ring wobble intensity
        duration: 2500,            // Animation duration
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'hula',
            strength: 1.0,
            verticalOscillation: 0.3
        }
    },
    
    // Rhythm configuration - hula syncs to groove
    rhythm: {
        enabled: true,
        syncMode: 'bar',  // Full rotation per bar
        
        // Speed syncs to tempo for consistent rotation
        speedSync: {
            mode: 'tempo',
            baseSpeed: 0.015,      // Base speed at 120 BPM
            scaling: 'proportional' // Speed scales with BPM
        },
        
        // Wobble syncs to beat for rhythmic variation
        wobbleSync: {
            onBeat: 0.25,          // More wobble on beat
            offBeat: 0.1,          // Less wobble off beat
            curve: 'sine'          // Smooth transitions
        },
        
        // Vertical oscillation creates wave patterns
        verticalSync: {
            subdivision: 'quarter', // Wave every quarter note
            amplitude: 0.4,        // Wave height on beat
            phase: 'sequential'    // Waves follow rotation
        },
        
        // Musical expression
        dynamics: {
            forte: { wobbleAmount: 0.3, speed: 1.2 },  // Wilder on loud
            piano: { wobbleAmount: 0.05, speed: 0.8 }  // Gentler on soft
        }
    },
    
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const calculatedRadius = Math.sqrt(dx * dx + dy * dy);
        
        // Random direction for hula-hoop
        const direction = Math.random() < 0.5 ? 1 : -1;
        
        // Set minimum radius to prevent center clustering - 3x larger spread
        const MIN_RADIUS = 100; // Slightly larger for hula effect
        const radius = Math.max(calculatedRadius, MIN_RADIUS + Math.random() * 180); // At least 210-390 pixels
        
        const initialAngle = calculatedRadius < 5 ? Math.random() * Math.PI * 2 : Math.atan2(dy, dx);
        particle.gestureData.hula = {
            radius,
            angle: initialAngle,
            initialAngle,  // Store initial angle for relative rotation
            originalVx: particle.vx,
            originalVy: particle.vy,
            originalZ: particle.z || 0,
            zPhase: Math.random() * Math.PI * 2,
            wobblePhase: Math.random() * Math.PI * 2,
            direction  // Random hula direction
        };
    },
    
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.hula) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.hula;
        const speed = (motion.speed || this.config.speed) * (motion.strength || 1);
        
        // Smooth entry/exit transitions
        let transitionFactor = 1.0;
        if (progress < 0.1) {
            // Smooth entry (first 10%)
            transitionFactor = progress / 0.1;
            transitionFactor = Math.sin(transitionFactor * Math.PI * 0.5); // Smooth ease-in
        } else if (progress > 0.9) {
            // Smooth exit (last 10%)
            transitionFactor = (1 - progress) / 0.1;
            transitionFactor = Math.sin(transitionFactor * Math.PI * 0.5); // Smooth ease-out
        }
        
        // Update angle with direction (dt is already normalized to 60fps)
        data.angle += speed * dt * data.direction * transitionFactor;
        
        // Wobble effect - the hoop wobbles as it spins
        const wobble = Math.sin(data.angle * 2 + data.wobblePhase) * (motion.wobbleAmount || this.config.wobbleAmount) * transitionFactor;
        
        // Calculate elliptical radius with wobble and transition
        const radiusX = data.radius * (1 + wobble) * transitionFactor;
        const radiusY = data.radius * (0.7 + wobble) * transitionFactor; // Elliptical shape factor
        
        // Smoothly transition from original position to orbit position
        const targetX = centerX + Math.cos(data.angle) * radiusX;
        const targetY = centerY + Math.sin(data.angle) * radiusY;
        
        if (progress < 0.1) {
            // During entry, lerp from original position
            const dx = particle.x - centerX;
            const dy = particle.y - centerY;
            const currentRadius = Math.sqrt(dx * dx + dy * dy);
            if (currentRadius < 50) {
                // If particle is at center, move it out smoothly
                particle.x = centerX + Math.cos(data.angle) * radiusX;
                particle.y = centerY + Math.sin(data.angle) * radiusY;
            } else {
                particle.x = particle.x + (targetX - particle.x) * transitionFactor * 0.5;
                particle.y = particle.y + (targetY - particle.y) * transitionFactor * 0.5;
            }
        } else {
            particle.x = targetX;
            particle.y = targetY;
        }
        
        // 3D DEPTH with strong vertical oscillation
        const zAngle = data.angle + data.zPhase + (motion.zPhaseOffset || this.config.zPhaseOffset);
        
        // Z-coordinate for depth (behind/in front) with transition
        particle.z = Math.sin(zAngle) * 0.9 * transitionFactor;
        
        // Vertical oscillation synchronized with z-depth
        const verticalAmount = motion.verticalOscillation || this.config.verticalOscillation;
        const verticalOffset = Math.cos(zAngle * 2) * verticalAmount * data.radius * 0.2 * transitionFactor;
        particle.y += verticalOffset;
        
        // Tilt effect - particles higher when in front, lower when behind
        const tiltOffset = particle.z * data.radius * 0.1;
        particle.y -= tiltOffset;
        
        // Set velocity to match motion with smooth transitions
        const targetVx = -Math.sin(data.angle) * radiusX * speed;
        const targetVy = Math.cos(data.angle) * radiusY * speed;
        
        if (progress < 0.1) {
            // Smooth velocity transition during entry
            particle.vx = data.originalVx + (targetVx - data.originalVx) * transitionFactor;
            particle.vy = data.originalVy + (targetVy - data.originalVy) * transitionFactor;
        } else if (progress > 0.9) {
            // Smooth velocity transition during exit
            particle.vx = targetVx * transitionFactor + data.originalVx * (1 - transitionFactor);
            particle.vy = targetVy * transitionFactor + data.originalVy * (1 - transitionFactor);
            particle.z = particle.z * transitionFactor + data.originalZ * (1 - transitionFactor);
        } else {
            particle.vx = targetVx;
            particle.vy = targetVy;
        }
    },
    
    cleanup(particle) {
        if (particle.gestureData?.hula) {
            const data = particle.gestureData.hula;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            particle.z = data.originalZ;
            delete particle.gestureData.hula;
        }
    },

    /**
     * 3D translation for WebGL rendering
     * Y-axis rotation with XZ position offset for hula-hoop effect
     */
    '3d': {
        /**
         * Evaluate 3D transform for current progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration with particle data
         * @returns {Object} Transform with position, rotation, scale
         */
        evaluate(progress, motion) {
            const {particle} = motion;
            if (!particle || !particle.gestureData?.hula) {
                return {
                    position: [0, 0, 0],
                    rotation: [0, 0, 0],
                    scale: 1.0
                };
            }

            const data = particle.gestureData.hula;
            const config = motion.config || {};

            // Smooth entry/exit envelope - starts from 0, peaks at 1, returns to 0
            let envelope = 1.0;
            if (progress < 0.15) {
                // Smooth entry (first 15%)
                envelope = progress / 0.15;
                envelope = Math.sin(envelope * Math.PI * 0.5); // Ease-in
            } else if (progress > 0.85) {
                // Smooth exit (last 15%)
                envelope = (1 - progress) / 0.15;
                envelope = Math.sin(envelope * Math.PI * 0.5); // Ease-out
            }

            // Hula-hoop motion: RELATIVE circular path in XZ plane with vertical Y oscillation
            const hulaRadius = 0.25; // Hula hoop radius in 3D units

            // Calculate angle based on progress for smooth hula motion
            // Start from initial angle, rotate during gesture
            const angle = data.initialAngle + (progress * Math.PI * 2 * data.direction);

            // RELATIVE circular motion in XZ plane (starts from 0, peaks, returns to 0)
            const xOffset = Math.cos(angle) * hulaRadius * envelope;
            const zOffset = Math.sin(angle) * hulaRadius * envelope;

            // RELATIVE vertical oscillation creates the hula-hoop wave effect
            const verticalOscillation = config.verticalOscillation || 0.3;
            const yOffset = Math.sin(angle * 2 + data.wobblePhase) * verticalOscillation * envelope;

            // RELATIVE Y-axis rotation to face direction of motion
            const yRotation = (angle - data.initialAngle) * envelope;

            // Scale variation based on vertical position (larger at top/bottom of wave)
            const scaleVariation = Math.abs(Math.sin(angle)) * 0.15 * envelope;
            const verticalScale = 1.0 + scaleVariation;

            return {
                position: [xOffset, yOffset, zOffset], // RELATIVE offset from current position
                rotation: [0, yRotation, 0],           // RELATIVE rotation from current
                scale: verticalScale
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Twist Gesture
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Twist gesture - alternating rotational dance motion
 * @author Emotive Engine Team
 * @module gestures/transforms/twist
 * @complexity ⭐⭐⭐ Intermediate-Advanced
 * @audience Transform patterns for complex animations
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a twisting dance motion with alternating rotation and contraction.
 * ║ This is an OVERRIDE gesture that replaces existing particle motion.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *     ↻ ⭐ ↺      <- twist left/right
 *    ╱     ╲
 *   ⭐       ⭐    <- particles contract
 *    ╲     ╱
 *     ↺ ⭐ ↻      <- twist opposite
 *
 * USED BY:
 * - Dance gestures
 * - Playful emotions
 * - Music synchronization
 */

/**
 * Twist gesture configuration and implementation
 */
var twist = {
    name: 'twist',
    emoji: '🌀',
    type: 'override', // Replaces existing motion
    description: 'Twisting dance motion with alternating rotation',

    // Default configuration
    config: {
        duration: 1200,      // Animation duration
        rotationAngle: 45,   // Max rotation angle in degrees
        contractionFactor: 0.8, // How much to contract during twist
        twistFrequency: 2,   // Number of twist cycles
        easing: 'smooth',    // Animation curve type
        strength: 0.8,       // Overall motion intensity
        // Particle motion configuration
        particleMotion: {
            type: 'twist',
            rotationAngle: 45,
            contractionFactor: 0.8,
            twistFrequency: 2
        }
    },

    // Rhythm configuration - twist syncs to beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',
        timingSync: 'nextBeat',
        interruptible: true,
        priority: 4,
        blendable: false,  // Override gesture, no blending
        crossfadePoint: 'anyBeat',

        // Twist intensity syncs to beat
        amplitudeSync: {
            onBeat: 1.5,      // Stronger twist on beat
            offBeat: 0.7,     // Lighter between beats
            curve: 'elastic'  // Bouncy twist motion
        },

        // Pattern-specific twisting styles
        patternOverrides: {
            'funk': {
                // Funky twist with more rotation
                rotationAngle: 60,
                contractionFactor: 0.7
            },
            'disco': {
                // Classic disco twist
                twistFrequency: 3,
                rotationAngle: 50
            },
            'latin': {
                // Latin-style hip twist
                rotationAngle: 35,
                contractionFactor: 0.85,
                twistFrequency: 2.5
            }
        }
    },

    /**
     * Initialize gesture data for a particle
     */
    initialize(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }

        particle.gestureData.twist = {
            startX: particle.x,
            startY: particle.y,
            startAngle: Math.atan2(particle.y - motion.centerY, particle.x - motion.centerX),
            startDistance: Math.sqrt(
                Math.pow(particle.x - motion.centerX, 2) +
                Math.pow(particle.y - motion.centerY, 2)
            ),
            initialized: true
        };
    },

    /**
     * Apply twist motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.twist?.initialized) {
            this.initialize(particle, { ...motion, centerX, centerY });
        }

        const config = { ...this.config, ...motion };
        const data = particle.gestureData.twist;
        const strength = config.strength || this.config.strength || 1.0;

        // Calculate twist oscillation
        const twistProgress = progress * config.twistFrequency * Math.PI * 2;
        const twistAmount = Math.sin(twistProgress) * strength;

        // Apply rhythm modulation if present
        let {rotationAngle} = config;
        let {contractionFactor} = config;

        if (motion.rhythmModulation) {
            rotationAngle *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            contractionFactor = 1 - ((1 - contractionFactor) * (motion.rhythmModulation.amplitudeMultiplier || 1));
        }

        // Convert rotation to radians
        const rotationRad = (rotationAngle * Math.PI / 180) * twistAmount;

        // Calculate contraction (pull particles closer during twist)
        const currentContraction = 1 - ((1 - contractionFactor) * Math.abs(twistAmount));

        // Apply twist transformation
        const newAngle = data.startAngle + rotationRad;
        const newDistance = data.startDistance * currentContraction;

        // Calculate new position
        const targetX = centerX + Math.cos(newAngle) * newDistance;
        const targetY = centerY + Math.sin(newAngle) * newDistance;

        // Smoothly move to target position
        const moveStrength = 0.15 * strength;
        particle.x += (targetX - particle.x) * moveStrength;
        particle.y += (targetY - particle.y) * moveStrength;

        // Add some velocity for fluid motion
        particle.vx = (targetX - particle.x) * 0.05;
        particle.vy = (targetY - particle.y) * 0.05;

        // Add slight vertical bounce for more dynamic feel
        const bounceAmount = Math.sin(progress * Math.PI * 4) * 5 * strength;
        particle.y += bounceAmount * 0.1;

        // Smooth ending
        if (progress > 0.9) {
            const endFactor = 1 - ((progress - 0.9) * 10);
            particle.vx *= endFactor;
            particle.vy *= endFactor;
        }

    },

    /**
     * Clean up gesture data when complete
     */
    cleanup(particle) {
        if (particle.gestureData?.twist) {
            delete particle.gestureData.twist;
        }
    },

    /**
     * 3D translation for WebGL rendering
     * Y-axis rotation with helical XZ motion (twist combines rotation and spiral)
     */
    '3d': {
        /**
         * Evaluate 3D transform for current progress
         * @param {number} progress - Animation progress (0-1)
         * @param {Object} motion - Gesture configuration with particle data
         * @returns {Object} Transform with position, rotation, scale
         */
        evaluate(progress, motion) {
            const {particle} = motion;
            if (!particle || !particle.gestureData?.twist) {
                return {
                    position: [0, 0, 0],
                    rotation: [0, 0, 0],
                    scale: 1.0
                };
            }

            const data = particle.gestureData.twist;
            const config = motion.config || {};
            const strength = config.strength || 1.0;

            // Fade-out envelope to return to origin at end
            const returnEnvelope = progress > 0.85 ? (1 - progress) / 0.15 : 1.0; // Fade last 15%

            // Calculate twist oscillation
            const twistProgress = progress * (config.twistFrequency || 2) * Math.PI * 2;
            const twistAmount = Math.sin(twistProgress) * strength * returnEnvelope;

            // Y-axis rotation (primary twist axis)
            const rotationAngle = (config.rotationAngle || 45) * Math.PI / 180;
            const yRotation = twistAmount * rotationAngle;

            // Helical motion: X and Z rotate around center as particle twists
            const helixAngle = data.startAngle + yRotation;
            const helixRadius = (config.contractionFactor || 0.8) * data.startDistance;

            // Calculate helical XZ offset - fades to 0 at end
            // PIXEL_TO_3D converts pixel distances to 3D world coordinates
            const PIXEL_TO_3D = 0.01;
            const xOffset = Math.cos(helixAngle) * helixRadius * 0.1 * returnEnvelope * PIXEL_TO_3D;
            const zOffset = Math.sin(helixAngle) * helixRadius * 0.1 * returnEnvelope * PIXEL_TO_3D;

            // X and Z rotation for additional twist dynamics - fades to 0
            const xRotation = Math.cos(twistProgress) * 0.1 * strength * returnEnvelope;
            const zRotation = Math.sin(twistProgress * 0.5) * 0.15 * strength * returnEnvelope;

            // Scale contracts during twist - returns to 1.0 at end
            const contractionFactor = config.contractionFactor || 0.8;
            const currentContraction = 1 - ((1 - contractionFactor) * Math.abs(twistAmount));
            const scale = currentContraction;

            return {
                position: [xOffset, 0, zOffset], // Use offsets only for twist wobble, not particle pos
                rotation: [xRotation, yRotation, zRotation],
                scale
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Wave Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Wave gesture - infinity pattern flow
 * @author Emotive Engine Team
 * @module gestures/effects/wave
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a flowing wave motion with particles moving in an infinity (∞) pattern.   
 * ║ This is an OVERRIDE gesture that creates smooth, hypnotic figure-8 movements.     
 * ║ Particles phase in and out for a dreamlike effect.                                
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ∞ Infinity Pattern
 *      ↗ → ↘     ↙ ← ↖
 *     ⭐     ⭐ ⭐     ⭐
 *      ↖ ← ↙     ↘ → ↗
 *         (continuous flow)
 * 
 * USED BY:
 * - Hypnotic/mesmerizing effects
 * - Dreamy transitions
 * - Magical gestures
 * - Flow states
 */

/**
 * Wave gesture configuration and implementation
 */
var wave = {
    name: 'wave',
    emoji: '🌊',
    type: 'override', // Completely replaces motion
    description: 'Infinity pattern flow with phasing',
    
    // Default configuration
    config: {
        // Musical duration - wave flows for exactly 1 bar
        musicalDuration: {
            musical: true,
            bars: 1,           // Default to 1 bar of wave motion
            minBeats: 4,       // Minimum 1 bar
            maxBeats: 16       // Maximum 4 bars
        },
        
        // Musical phases of the wave gesture
        phases: [
            { name: 'gather', beats: 0.5 },     // Particles gather
            { name: 'rise', beats: 0.5 },       // Begin rising motion
            { name: 'waveLeft', beats: 1 },     // Wave to the left
            { name: 'waveRight', beats: 1 },    // Wave to the right
            { name: 'settle', beats: 1 }        // Settle back to center
        ],
        
        amplitude: 40,         // Infinity pattern width
        frequency: 1,          // Complete cycle count
        phaseShift: 0.3,       // Particle timing offset
        liftHeight: 20,        // Vertical movement range
        fadeInOut: true,       // Enable opacity transitions
        smoothness: 0.1,       // Motion fluidity factor
        easing: 'sine',        // Animation curve type
        strength: 1.0,         // Overall effect intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'wave',
            strength: 1.0,     // Wave motion strength
            amplitude: 50      // Pattern size
        }
    },
    
    // Rhythm configuration - flowing wave patterns synchronized to musical waves and phrases
    rhythm: {
        enabled: true,
        syncMode: 'wave',    // Flow with musical wave patterns and melodic contours
        
        // Amplitude responds to musical dynamics and melodic range
        amplitudeSync: {
            onWave: 65,           // Large waves during musical waves
            onStatic: 25,         // Small waves during static sections
            curve: 'flowing'      // Smooth, continuous transitions
        },
        
        // Frequency matches musical phrase rhythm
        frequencySync: {
            mode: 'phrase',
            slow: 0.7,            // Slower waves for slow phrases
            fast: 1.8,            // Faster waves for quick phrases
            curve: 'melodic'      // Follows melodic contour
        },
        
        // Duration automatically syncs to bars via musicalDuration config
        durationSync: {
            mode: 'bars',         // Uses bars from musicalDuration
            adaptToPhrase: true,  // Extend to complete musical phrases
            sustain: true         // Maintain wave through phrase
        },
        
        // Phase shift creates ensemble wave effects
        phaseSync: {
            enabled: true,
            multiplier: 0.5,      // Moderate phase variation
            type: 'ensemble'      // Creates group wave patterns
        },
        
        // Response to melodic contour
        melodicResponse: {
            enabled: true,
            multiplier: 1.4,      // Wave amplitude follows melody
            type: 'amplitude'     // Affects wave size
        },
        
        // Style variations for different music types
        patternOverrides: {
            'ambient': {
                // Slow, hypnotic waves
                amplitudeSync: { onWave: 80, onStatic: 40, curve: 'hypnotic' },
                frequencySync: { slow: 0.5, fast: 1.2 },
                durationSync: { minBeats: 16, maxBeats: 64 }
            },
            'ocean': {
                // Natural, oceanic wave patterns
                amplitudeSync: { onWave: 90, onStatic: 20, curve: 'natural' },
                phaseSync: { multiplier: 0.8 },
                melodicResponse: { multiplier: 1.8 }
            },
            'electronic': {
                // Precise, digital wave forms
                amplitudeSync: { onWave: 70, onStatic: 30, curve: 'digital' },
                frequencySync: { slow: 0.8, fast: 2.5, curve: 'precise' }
            },
            'orchestral': {
                // Rich, complex wave interactions
                amplitudeSync: { onWave: 75, onStatic: 35 },
                phaseSync: { multiplier: 0.7 },
                melodicResponse: { multiplier: 2.0 }
            }
        },
        
        // Musical dynamics
        dynamics: {
            forte: {
                // Powerful, sweeping waves
                amplitudeSync: { 
                    onWave: { multiplier: 1.8 },
                    onStatic: { multiplier: 1.4 }
                },
                frequencySync: { multiplier: 1.3 },
                melodicResponse: { multiplier: 2.2 }
            },
            piano: {
                // Gentle, subtle waves
                amplitudeSync: { 
                    onWave: { multiplier: 0.6 },
                    onStatic: { multiplier: 0.4 }
                },
                frequencySync: { multiplier: 0.7 },
                melodicResponse: { multiplier: 1.1 }
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate initial position relative to center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const angle = Math.atan2(dy, dx);
        const radius = Math.sqrt(dx * dx + dy * dy);
        
        // Random direction for wave motion
        const direction = Math.random() < 0.5 ? 1 : -1;
        
        particle.gestureData.wave = {
            startX: particle.x,
            startY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            baseOpacity: particle.opacity || particle.life || 1,
            angle,
            radius,
            offset: Math.random() * Math.PI * 2, // Random phase offset
            role: Math.random(), // 0-1 for variation
            direction, // Random wave direction
            initialized: true
        };
    },
    
    /**
     * Apply wave motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.wave?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.wave;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Apply easing to progress
        const easeProgress = this.easeInOutSine(progress);
        
        // Add phase shift based on particle role (creates wave effect)
        const phaseShift = data.role * config.phaseShift;
        const adjustedPhase = Math.max(0, easeProgress - phaseShift);
        
        // Calculate infinity pattern (lemniscate) with direction
        const t = adjustedPhase * Math.PI * 2 * config.frequency * data.direction + data.offset;
        
        // Scale amplitude based on distance from center
        const radiusFactor = 0.5 + (data.radius / 100) * 0.5;
        const amplitude = config.amplitude * radiusFactor * strength * particle.scaleFactor;
        
        // Infinity pattern equations
        const infinityX = Math.sin(t) * amplitude;
        const infinityY = Math.sin(t * 2) * amplitude * 0.3; // Smaller vertical component
        
        // Add vertical lift effect
        const lift = -Math.abs(Math.sin(easeProgress * Math.PI)) * config.liftHeight * particle.scaleFactor;
        
        // Calculate target position
        const targetX = centerX + infinityX;
        const targetY = centerY + infinityY + lift;
        
        // Smooth movement with role-based variation
        const smoothness = config.smoothness + data.role * 0.12;
        
        // Apply position with smoothing
        particle.x += (targetX - particle.x) * smoothness;
        particle.y += (targetY - particle.y) * smoothness;
        
        // Set velocity for trails
        particle.vx = (targetX - particle.x) * 0.3;
        particle.vy = (targetY - particle.y) * 0.3;
        
        // Apply fade effect if enabled
        if (config.fadeInOut) {
            let fadeFactor;
            
            if (adjustedPhase < 0.1) {
                // Fade in
                fadeFactor = adjustedPhase / 0.1;
            } else if (adjustedPhase > 0.9) {
                // Fade out
                fadeFactor = (1 - adjustedPhase) / 0.1;
            } else {
                // Full opacity with sine variation
                fadeFactor = 0.5 + Math.sin(adjustedPhase * Math.PI) * 0.5;
            }
            
            particle.opacity = data.baseOpacity * (0.3 + fadeFactor * 0.7);
            
            // Update life for particles that use it instead of opacity
            if (particle.life !== undefined) {
                particle.life = particle.opacity;
            }
        }
        
        // Smooth ending
        if (progress >= 0.95) {
            const endFactor = (1 - progress) * 20;
            particle.vx = particle.vx * endFactor + data.originalVx * (1 - endFactor);
            particle.vy = particle.vy * endFactor + data.originalVy * (1 - endFactor);
            
            // Restore opacity
            if (config.fadeInOut) {
                particle.opacity = data.baseOpacity * endFactor;
                if (particle.life !== undefined) {
                    particle.life = particle.opacity;
                }
            }
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.wave) {
            const data = particle.gestureData.wave;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            particle.opacity = data.baseOpacity;
            if (particle.life !== undefined) {
                particle.life = data.baseOpacity;
            }
            delete particle.gestureData.wave;
        }
    },
    
    /**
     * Sine easing for smooth wave motion
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutSine(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
    },

    /**
     * 3D core transformation for wave gesture
     * Flowing infinity pattern with graceful sway and glow modulation
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation { position: [x,y,z], rotation: [x,y,z], scale: number, glowIntensity: number, glowBoost: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const strength = motion?.strength || 1.0;
            const frequency = motion?.frequency || 1;

            // Smooth eased progress
            const easeProgress = -(Math.cos(Math.PI * progress) - 1) / 2;

            // Infinity pattern (lemniscate) - creates flowing figure-8 motion
            const t = easeProgress * Math.PI * 2 * frequency;
            const swayX = Math.sin(t) * 0.12 * strength;
            const swayY = Math.sin(t * 2) * 0.06 * strength; // Half frequency for Y creates figure-8

            // Slight forward/back motion for depth
            const swayZ = Math.sin(t) * 0.03 * strength;

            // Gentle tilt rotation following the wave
            const tiltX = Math.sin(t * 2) * 0.08 * strength;
            const tiltZ = Math.sin(t) * 0.05 * strength;

            // Scale breathes with the wave - larger at peaks
            const scale = 1.0 + Math.abs(Math.sin(easeProgress * Math.PI)) * 0.08 * strength;

            // Glow follows wave peaks - brighter at extremes
            const waveIntensity = Math.abs(Math.sin(t));
            const glowIntensity = 1.0 + waveIntensity * 0.3 * strength;

            // Glow boost pulses gently with wave motion
            const glowBoost = waveIntensity * 0.6 * strength;

            return {
                position: [swayX, swayY, swayZ],
                rotation: [tiltX, 0, tiltZ],
                scale,
                glowIntensity,
                glowBoost
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Drift Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Drift gesture - controlled floating motion
 * @author Emotive Engine Team
 * @module gestures/effects/drift
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a dreamy drifting effect where particles float outward then return home.  
 * ║ This is an OVERRIDE gesture with smooth, controlled movement and fading effects.  
 * ║ Perfect for transitions, sleepy states, or ethereal moments.                      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Start         Drift Out        Hold         Return
 *      ⭐           · · ⭐           · · ·          ⭐
 *     ⭐⭐    →    · ⭐ · ⭐    →   · · · ·    →   ⭐⭐
 *      ⭐           ⭐ · ·           · · ·          ⭐
 *   (grouped)     (spread)        (faded)      (regrouped)
 * 
 * USED BY:
 * - Sleepy/drowsy states
 * - Dreamy transitions
 * - Dispersal effects
 * - Meditation/calm states
 */

/**
 * Drift gesture configuration and implementation
 */
var drift = {
    name: 'drift',
    emoji: '☁️',
    type: 'override', // Completely replaces motion
    description: 'Controlled floating with fade effects',
    
    // Default configuration
    config: {
        duration: 800,         // Animation duration
        distance: 50,          // Maximum drift distance
        angle: 45,             // Primary drift direction
        returnToOrigin: true,  // Return to starting position
        fadeOut: false,        // Apply fade effect during drift (disabled to prevent disappearing)
        holdTime: 0.2,         // Pause duration at drift peak
        turbulence: 0.1,       // Random movement variation amount
        angleSpread: 45,       // Directional spread range
        smoothness: 0.08,      // Movement fluidity factor
        easing: 'ease',        // Animation curve type
        strength: 1.0,         // Overall drift intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'drift',
            strength: 1.0,     // Drift motion strength
            distance: 60       // Maximum drift distance
        }
    },
    
    // Rhythm configuration - ethereal drift following ambient musical textures
    rhythm: {
        enabled: true,
        syncMode: 'ambient',  // Sync to ambient musical textures
        
        // Distance varies with musical dynamics
        distanceSync: {
            quiet: 30,            // Small drift in quiet sections
            loud: 80,             // Large drift in loud sections
            crescendo: 'expand',  // Expand drift on crescendos
            diminuendo: 'contract' // Contract drift on diminuendos
        },
        
        // Angle follows harmonic progression
        angleSync: {
            major: 45,            // Upward drift in major keys
            minor: 225,           // Downward drift in minor keys
            modulation: 'smooth', // Smooth angle changes
            cadence: 'return'     // Return to center on cadences
        },
        
        // Hold time syncs to phrase length
        holdSync: {
            shortPhrase: 0.1,     // Brief hold for short phrases
            longPhrase: 0.4,      // Extended hold for long phrases
            fermata: 'sustain'    // Sustain hold on fermatas
        },
        
        // Gentle accent response
        accentResponse: {
            enabled: true,
            multiplier: 1.3,      // Subtle drift increase on accents
            type: 'distance'      // Accent affects drift distance
        },
        
        // Pattern-specific drift styles
        patternOverrides: {
            'ambient': {
                // Slow, ethereal drifting
                distanceSync: { quiet: 40, loud: 100 },
                holdSync: { shortPhrase: 0.3, longPhrase: 0.6 }
            },
            'classical': {
                // Elegant, controlled drifting
                angleSync: { major: 30, minor: 210 },
                distanceSync: { quiet: 25, loud: 60 }
            },
            'jazz': {
                // Syncopated, unpredictable drifting
                angleSync: { 
                    major: 60, 
                    minor: 240,
                    swing: true,
                    syncopated: true
                }
            },
            'new_age': {
                // Meditative, flowing drift
                distanceSync: { quiet: 35, loud: 70 },
                holdSync: { shortPhrase: 0.4, longPhrase: 0.8 },
                angleSync: { modulation: 'gradual' }
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Expansive, bold drifting
                distanceSync: { 
                    quiet: { multiplier: 1.5 },
                    loud: { multiplier: 1.8 }
                },
                holdSync: { multiplier: 1.2 },
                accentResponse: { multiplier: 1.6 }
            },
            piano: {
                // Delicate, subtle drifting
                distanceSync: { 
                    quiet: { multiplier: 0.6 },
                    loud: { multiplier: 0.8 }
                },
                holdSync: { multiplier: 0.8 },
                accentResponse: { multiplier: 1.1 }
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate drift direction
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        let driftAngle = Math.atan2(dy, dx);
        
        // Add some spread to the drift angle
        const config = { ...this.config, ...motion };
        const spreadRad = (config.angleSpread * Math.PI / 180);
        const angleOffset = (Math.random() - 0.5) * spreadRad;
        driftAngle += angleOffset;
        
        // Determine home position (closer to center)
        const homeRadius = 30 + Math.random() * 30;
        
        particle.gestureData.drift = {
            startX: particle.x,
            startY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            baseOpacity: particle.opacity || particle.life || 1,
            driftAngle,
            angleOffset,
            homeRadius: homeRadius * particle.scaleFactor,
            homeX: centerX + Math.cos(driftAngle) * homeRadius,
            homeY: centerY + Math.sin(driftAngle) * homeRadius,
            role: Math.random(), // 0-1 for timing variation
            turbulencePhase: Math.random() * Math.PI * 2,
            initialized: true
        };
    },
    
    /**
     * Apply drift motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.drift?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.drift;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Apply easing
        const easeProgress = this.easeInOutCubic(progress);
        
        // Add role-based phase shift for staggered movement
        const adjustedPhase = Math.max(0, easeProgress - data.role * 0.1);
        
        let targetX, targetY;
        let currentRadius;
        
        // Determine phase of drift
        if (!config.returnToOrigin) {
            // Simple outward drift
            const driftProgress = adjustedPhase;
            currentRadius = data.homeRadius + driftProgress * config.distance * strength * particle.scaleFactor;
            
        } else if (adjustedPhase < 0.4) {
            // Phase 1: Move to home position
            const homeProgress = adjustedPhase / 0.4;
            const easedHome = this.easeOutQuad(homeProgress);
            targetX = data.startX + (data.homeX - data.startX) * easedHome;
            targetY = data.startY + (data.homeY - data.startY) * easedHome;
            
        } else if (adjustedPhase < 0.6 + config.holdTime) {
            // Phase 2: Drift outward
            const driftPhase = (adjustedPhase - 0.4) / (0.2 + config.holdTime);
            currentRadius = data.homeRadius + 
                Math.sin(driftPhase * Math.PI * 0.5) * config.distance * strength * particle.scaleFactor;
            
        } else {
            // Phase 3: Return to origin
            const returnPhase = (adjustedPhase - 0.6 - config.holdTime) / (0.4 - config.holdTime);
            currentRadius = data.homeRadius + 
                Math.cos(returnPhase * Math.PI * 0.5) * config.distance * strength * particle.scaleFactor;
        }
        
        // Calculate position with turbulence
        if (currentRadius !== undefined) {
            // Add turbulence
            data.turbulencePhase += config.turbulence * dt;
            const turbulenceX = Math.sin(data.turbulencePhase) * config.turbulence * 10;
            const turbulenceY = Math.cos(data.turbulencePhase * 1.3) * config.turbulence * 10;
            
            const angle = data.driftAngle + data.angleOffset;
            targetX = centerX + Math.cos(angle) * currentRadius + turbulenceX;
            targetY = centerY + Math.sin(angle) * currentRadius + turbulenceY;
        }
        
        // Smooth movement with role variation
        const smoothness = config.smoothness + data.role * 0.08;
        particle.x += (targetX - particle.x) * smoothness;
        particle.y += (targetY - particle.y) * smoothness;
        
        // Set velocity for trails
        particle.vx = (targetX - particle.x) * 0.25;
        particle.vy = (targetY - particle.y) * 0.25;
        
        // Apply fade effect
        if (config.fadeOut) {
            let fadeFactor;
            
            if (progress < 0.25) {
                // Fade in
                fadeFactor = 0.3 + (progress / 0.25) * 0.7;
            } else if (progress < 0.75) {
                // Main phase with sine variation
                fadeFactor = 0.7 + Math.sin((progress - 0.25) * Math.PI / 0.5) * 0.3;
            } else {
                // Fade back
                fadeFactor = (1 - progress) * 4;
            }
            
            particle.opacity = data.baseOpacity * fadeFactor;
            if (particle.life !== undefined) {
                particle.life = particle.opacity;
            }
        }
        
        // Clean ending
        if (progress >= 0.99) {
            particle.vx = data.originalVx * 0.1;
            particle.vy = data.originalVy * 0.1;
            
            if (config.fadeOut) {
                particle.opacity = data.baseOpacity;
                if (particle.life !== undefined) {
                    particle.life = data.baseOpacity;
                }
            }
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.drift) {
            const data = particle.gestureData.drift;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            particle.opacity = data.baseOpacity;
            if (particle.life !== undefined) {
                particle.life = data.baseOpacity;
            }
            delete particle.gestureData.drift;
        }
    },
    
    /**
     * Easing functions
     */
    easeInOutCubic(t) {
        return t < 0.5
            ? 4 * t * t * t
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },

    easeOutQuad(t) {
        return t * (2 - t);
    },

    /**
     * 3D core transformation for drift gesture
     * Slow positional drift in XYZ with subtle rotation
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation { position: [x,y,z], rotation: [x,y,z], scale: number, glowIntensity: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };
            const strength = motion.strength || 1.0;

            // Slow drift in XY plane
            const angle = (config.angle || 45) * Math.PI / 180;
            const driftProgress = config.returnToOrigin
                ? (progress < 0.5 ? progress * 2 : (1 - progress) * 2)
                : progress;

            const driftX = Math.cos(angle) * driftProgress * 0.3 * strength;
            const driftY = Math.sin(angle) * driftProgress * 0.3 * strength;
            const driftZ = Math.sin(progress * Math.PI) * 0.15 * strength; // Subtle Z drift

            // Gentle rotation during drift
            const rotationY = driftProgress * 10 * strength; // Slight Y rotation

            // Minimal scale/glow change
            const scale = 1.0 + Math.sin(progress * Math.PI) * 0.03;
            const glowIntensity = 1.0 - driftProgress * 0.1; // Dim slightly during drift

            return {
                position: [driftX, driftY, driftZ],
                rotation: [0, rotationY, 0],
                scale,
                glowIntensity
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Flicker Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Flicker gesture - opacity and motion variation
 * @author Emotive Engine Team
 * @module gestures/effects/flicker
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a flickering effect with rapid opacity changes and subtle motion jitter.  
 * ║ This is a BLENDING gesture that adds visual instability, perfect for glitches,   
 * ║ electrical effects, or nervous energy.                                            
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Frame 1      Frame 2      Frame 3      Frame 4
 *      ⭐          ·⭐·         ⭐⭐⭐         ·⭐
 *    (100%)       (30%)        (120%)        (50%)
 *    normal       dimmed       bright        partial
 * 
 * USED BY:
 * - Glitch/digital effects
 * - Electrical sparks
 * - Nervous/unstable states
 * - Teleportation effects
 * - Broken/malfunctioning states
 */

/**
 * Flicker gesture configuration and implementation
 */
var flicker = {
    name: 'flicker',
    emoji: '⚡',
    type: 'blending', // Adds to existing motion
    description: 'Rapid opacity changes with motion jitter',
    
    // Default configuration
    config: {
        duration: 800,         // Animation duration
        flickerRate: 15,       // Flicker speed
        frequency: 6,          // Flicker count
        minOpacity: 0.3,       // Minimum visibility
        maxOpacity: 1.0,       // Maximum visibility
        jitterAmount: 2,       // Position wobble range
        colorShift: false,     // Enable hue variation
        strobe: false,         // Regular vs random pattern
        pulseMode: false,      // Smooth vs sharp transitions
        groupFlicker: 0.3,     // Group synchronization probability
        easing: 'linear',      // Animation curve type
        strength: 0.7,         // Overall effect intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'flicker',
            strength: 0.7,     // Particle flicker strength
            frequency: 6       // Particle flicker rate
        }
    },
    
    // Rhythm configuration - flicker syncs to subdivisions
    rhythm: {
        enabled: true,
        syncMode: 'subdivision',  // Flicker on subdivisions
        
        // Flicker rate syncs to tempo
        rateSync: {
            subdivision: 'sixteenth',  // Flicker on 16th notes
            onBeat: 30,               // Rapid flicker on beat
            offBeat: 10,              // Slower between beats
            triplet: 20,              // Medium on triplets
            curve: 'step'             // Instant changes
        },
        
        // Opacity patterns with rhythm
        opacitySync: {
            pattern: 'HLMH',          // High-Low-Medium-High
            subdivision: 'eighth',     // Pattern rate
            onAccent: 0.1,           // Nearly off on accent (dramatic)
            regular: 0.5              // Medium normally
        },
        
        // Jitter amount varies
        jitterSync: {
            onBeat: 5,                // Big jitter on beat
            offBeat: 1,               // Minimal between
            accent: 10,               // Extreme on accent
            curve: 'random'           // Chaotic motion
        },
        
        // Strobe modes
        strobeSync: {
            verse: false,             // No strobe in verse
            chorus: true,             // Strobe in chorus
            drop: 'intense',          // Intense strobe on drop
            pattern: 'XOXO'          // Strobe pattern
        },
        
        // Musical dynamics
        dynamics: {
            forte: { flickerRate: 25, jitterAmount: 5, minOpacity: 0.1 },
            piano: { flickerRate: 8, jitterAmount: 1, minOpacity: 0.5 }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     */
    initialize(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        const config = { ...this.config, ...motion };
        
        // Determine if this particle is part of a synchronized group
        const isGrouped = Math.random() < config.groupFlicker;
        
        particle.gestureData.flicker = {
            baseOpacity: particle.opacity || particle.life || 1,
            baseColor: particle.color,
            baseX: particle.x,
            baseY: particle.y,
            flickerTimer: 0,
            lastFlicker: 0,
            flickerState: true,
            isGrouped,
            groupId: isGrouped ? Math.floor(Math.random() * 3) : -1, // Assign to flicker group
            phase: Math.random() * Math.PI * 2,  // Random phase offset
            colorHue: 0,
            initialized: true
        };
    },
    
    /**
     * Apply flicker effect to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, _centerX, _centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.flicker?.initialized) {
            this.initialize(particle, motion);
        }
        
        const data = particle.gestureData.flicker;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Update flicker timer
        data.flickerTimer += dt * config.flickerRate;
        
        // Calculate opacity based on mode
        let opacityMultiplier;
        
        if (config.strobe) {
            // Strobe pattern - regular on/off
            const strobePhase = (data.flickerTimer + data.phase) % 1;
            opacityMultiplier = strobePhase < 0.5 ? 1 : config.minOpacity;
            
        } else if (config.pulseMode) {
            // Smooth pulsing
            const pulsePhase = data.flickerTimer + data.phase;
            opacityMultiplier = config.minOpacity + 
                (config.maxOpacity - config.minOpacity) * (Math.sin(pulsePhase) * 0.5 + 0.5);
            
        } else {
            // Random flicker
            if (data.flickerTimer - data.lastFlicker > 1) {
                data.lastFlicker = data.flickerTimer;
                
                // Group flicker logic
                if (data.isGrouped) {
                    // Flicker based on group timing
                    const groupPhase = Math.floor(data.flickerTimer) % 3;
                    data.flickerState = groupPhase === data.groupId;
                } else {
                    // Individual random flicker
                    data.flickerState = Math.random() > 0.3;
                }
            }
            
            // Calculate target opacity
            const targetOpacity = data.flickerState ? 
                config.maxOpacity : 
                config.minOpacity + Math.random() * 0.3;
            
            // Smooth transition for less harsh flicker
            const currentOpacity = particle.opacity / data.baseOpacity;
            opacityMultiplier = currentOpacity + (targetOpacity - currentOpacity) * 0.3;
        }
        
        // Apply opacity with strength
        const finalOpacity = data.baseOpacity * (1 + (opacityMultiplier - 1) * strength);
        particle.opacity = Math.max(0, Math.min(1, finalOpacity)); // Clamp to 0-1
        
        // Update life if used instead of opacity
        if (particle.life !== undefined) {
            particle.life = particle.opacity;
        }
        
        // Apply position jitter
        if (config.jitterAmount > 0 && opacityMultiplier > config.minOpacity) {
            const jitter = config.jitterAmount * strength * particle.scaleFactor;
            const jitterX = (Math.random() - 0.5) * jitter * opacityMultiplier;
            const jitterY = (Math.random() - 0.5) * jitter * opacityMultiplier;
            
            particle.vx += jitterX * 0.1 * dt;
            particle.vy += jitterY * 0.1 * dt;
        }
        
        // Apply color shift if enabled
        if (config.colorShift && particle.color) {
            data.colorHue += 0.01 * dt;
            const hueShift = Math.sin(data.colorHue) * 30; // ±30 degree hue shift
            particle.color = this.shiftHue(data.baseColor, hueShift * strength);
        }
        
        // Smooth fade in/out at gesture boundaries
        let fadeFactor = 1;
        if (progress < 0.1) {
            fadeFactor = progress / 0.1;  // Fade in
        } else if (progress > 0.9) {
            fadeFactor = (1 - progress) / 0.1;  // Fade out
        }
        
        particle.opacity *= fadeFactor;
        if (particle.life !== undefined) {
            particle.life = particle.opacity;
        }
        
        // Dampen velocity slightly for stability
        if (progress > 0.8) {
            particle.vx *= 0.95;
            particle.vy *= 0.95;
        }
    },
    
    /**
     * Shift the hue of a color
     * @param {string} color - Hex color string
     * @param {number} degrees - Degrees to shift hue
     * @returns {string} New hex color
     */
    shiftHue(color, degrees) {
        // Simple hue shift implementation
        // In production, use a proper color library
        if (!color || !color.startsWith('#')) return color;
        
        // Convert hex to RGB
        const hex = color.slice(1);
        const r = parseInt(hex.substr(0, 2), 16) / 255;
        const g = parseInt(hex.substr(2, 2), 16) / 255;
        const b = parseInt(hex.substr(4, 2), 16) / 255;
        
        // Simple hue rotation (approximate)
        const hueRad = degrees * Math.PI / 180;
        const cos = Math.cos(hueRad);
        const sin = Math.sin(hueRad);
        
        // Rotate around luminance axis (simplified)
        const newR = r * cos - g * sin;
        const newG = r * sin + g * cos;
        const newB = b;
        
        // Convert back to hex
        const toHex = n => {
            const val = Math.max(0, Math.min(255, Math.round(n * 255)));
            return val.toString(16).padStart(2, '0');
        };
        
        return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.flicker) {
            const data = particle.gestureData.flicker;
            particle.opacity = data.baseOpacity;
            particle.color = data.baseColor;
            if (particle.life !== undefined) {
                particle.life = data.baseOpacity;
            }
            delete particle.gestureData.flicker;
        }
    },

    /**
     * 3D core transformation for flicker gesture
     * Rapid glowIntensity modulation with minimal movement
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation { position: [x,y,z], rotation: [x,y,z], scale: number, glowIntensity: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = motion.config || {};
            const strength = motion.strength || 0.7;
            const flickerRate = config.flickerRate || 15;
            config.minOpacity || 0.3;

            // Create rapid, random flickering effect
            // Use a combination of fast oscillation and random jumps
            const time = progress * flickerRate;

            // Fast sine wave as base
            const baseSine = Math.sin(time * Math.PI * 2);

            // Add random jumps based on integer time steps
            const timeStep = Math.floor(time * 10);
            const randomJump = (Math.sin(timeStep * 123.456) + 1) * 0.5; // 0-1

            // Combine for realistic flicker
            const flickerValue = baseSine * 0.3 + randomJump * 0.7;

            // Map to normalized glow intensity range (±40% max)
            // When flickering low: dim (0.6)
            // When flickering high: bright (1.4)
            const glowIntensity = 0.6 + 0.8 * flickerValue; // Range: 0.6 to 1.4

            // Jitter increases when glow is high (electrical energy)
            const jitterAmount = config.jitterAmount || 2;
            const jitterScale = 0.003 * strength * glowIntensity;
            const jitterX = (Math.random() - 0.5) * jitterAmount * jitterScale;
            const jitterY = (Math.random() - 0.5) * jitterAmount * jitterScale;

            // Slight random rotation jitter for extra chaos
            const rotJitter = (Math.random() - 0.5) * 0.03 * strength * glowIntensity;

            // Glow boost for screen-space halo - dramatic flicker effect
            // Directly tied to flickerValue for maximum impact (0 to 1.2)
            const glowBoost = flickerValue * 1.2;

            return {
                position: [jitterX, jitterY, 0],
                rotation: [rotJitter * 0.5, 0, rotJitter],
                scale: 1.0 + (glowIntensity - 1.0) * 0.08, // More visible scale pulse
                glowIntensity,
                glowBoost
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Burst Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Burst gesture - explosive outward motion
 * @author Emotive Engine Team
 * @module gestures/effects/burst
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 */

var burst$1 = {
    name: 'burst',
    emoji: '💥',
    type: 'blending',
    description: 'Explosive outward burst from center',
    
    // Default configuration
    config: {
        decay: 0.5,      // Force reduction over time
        strength: 2.0    // Initial explosion intensity
    },
    
    // Rhythm configuration - explosive bursts on strong beats
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Burst on strong beats and accents
        
        // Strength syncs to beat intensity
        strengthSync: {
            onBeat: 3.5,          // Powerful burst on beats
            offBeat: 1.0,         // Gentle burst off-beat
            curve: 'explosion'    // Sharp attack, rapid decay
        },
        
        // Decay rate responds to tempo
        decaySync: {
            mode: 'tempo',
            fast: 0.8,            // Quick decay for fast songs
            slow: 0.3,            // Slow decay for slow songs
            curve: 'exponential'
        },
        
        // Duration matches beat timing
        durationSync: {
            mode: 'beats',
            beats: 0.5,           // Half-beat burst duration
            sustain: false        // No sustain, pure burst
        },
        
        // Strong response to accents
        accentResponse: {
            enabled: true,
            multiplier: 2.5,      // Massive burst on accents
            type: 'strength'      // Accent affects burst power
        },
        
        // Pattern-specific burst styles
        patternOverrides: {
            'rock': {
                // Heavy, aggressive bursts
                strengthSync: { onBeat: 4.0, offBeat: 1.5 },
                decaySync: { fast: 0.6, slow: 0.4 }
            },
            'electronic': {
                // Sharp, precise bursts
                strengthSync: { onBeat: 3.8, offBeat: 0.8, curve: 'sharp' },
                decaySync: { fast: 0.9, slow: 0.7 }
            },
            'jazz': {
                // Syncopated, varied bursts
                strengthSync: { 
                    onBeat: 2.8, 
                    offBeat: 1.8,  // Strong off-beat emphasis
                    swing: true 
                },
                decaySync: { fast: 0.5, slow: 0.2 }
            },
            'orchestral': {
                // Dynamic, expressive bursts
                strengthSync: { onBeat: 3.2, offBeat: 0.5 },
                accentResponse: { multiplier: 3.0 }  // Very responsive to dynamics
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Explosive, powerful bursts
                strengthSync: { 
                    onBeat: { multiplier: 2.0 },
                    offBeat: { multiplier: 1.5 }
                },
                decaySync: { multiplier: 0.7 },  // Slower decay for impact
                accentResponse: { multiplier: 3.5 }
            },
            piano: {
                // Subtle, gentle bursts
                strengthSync: { 
                    onBeat: { multiplier: 0.6 },
                    offBeat: { multiplier: 0.3 }
                },
                decaySync: { multiplier: 1.3 },  // Faster decay for gentleness
                accentResponse: { multiplier: 1.8 }
            }
        }
    },
    
    /**
     * Apply explosive burst motion to particle
     * Pushes particles radially outward with decaying force
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Calculate force decay over gesture duration
        const decay = motion.decay || this.config.decay;
        const strength = (motion.strength || this.config.strength) * (1 - progress * decay);

        // Calculate direction from center to particle
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Apply outward force if particle isn't at center
        if (distance > 1) {
            // Normalize direction and apply explosive force
            particle.vx += (dx / distance) * strength * 2 * dt;
            particle.vy += (dy / distance) * strength * 2 * dt;
        }
    },

    /**
     * 3D core transformation for burst gesture
     * Explosive "toward camera" burst with scale, glow, and camera-relative motion
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation with cameraRelativePosition
     */
    '3d': {
        evaluate(progress, motion) {
            const strength = motion.strength || 2.0;

            // Phase 1: Explosive forward burst (0-0.15)
            // Phase 2: Overshoot recoil back (0.15-0.35)
            // Phase 3: Settle with damped oscillation (0.35-1.0)
            let forward = 0, scale = 1.0, glow = 1.0, glowBoost = 0;

            if (progress < 0.15) {
                // Explosive forward burst toward camera
                const attack = progress / 0.15;
                const eased = 1 - Math.pow(1 - attack, 3); // Ease-out
                forward = eased * 0.15 * strength;  // Surge toward camera
                scale = 1.0 + eased * 0.2 * strength;
                glow = 1.0 + eased * 0.5;
                glowBoost = eased * 0.4;  // Strong initial flash
            } else if (progress < 0.35) {
                // Recoil back past origin
                const recoilT = (progress - 0.15) / 0.2;
                const bounce = Math.sin(recoilT * Math.PI);
                forward = 0.15 * (1 - recoilT * 1.5) * strength; // Go past zero
                scale = 1.0 + 0.2 * (1 - recoilT) * strength - bounce * 0.1;
                glow = 1.0 + (1 - recoilT) * 0.4;
                glowBoost = (1 - recoilT) * 0.2;
            } else {
                // Damped settle
                const settleT = (progress - 0.35) / 0.65;
                const decay = Math.pow(1 - settleT, 2);
                const ring = Math.sin(settleT * Math.PI * 2) * decay;
                forward = ring * 0.03 * strength;
                scale = 1.0 + ring * 0.05;
                glow = 1.0 + Math.abs(ring) * 0.15;
            }

            return {
                // Dramatic forward/back motion in camera-relative space
                cameraRelativePosition: [0, 0, forward],
                position: [0, 0, 0],
                rotation: [0, 0, 0],
                scale,
                glowIntensity: glow,
                glowBoost
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Directional Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Directional gesture - move particles in specific direction
 * @author Emotive Engine Team
 * @module gestures/effects/directional
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 */

var directional = {
    name: 'directional',
    emoji: '➡️',
    type: 'blending',
    description: 'Move particles in a specific direction',
    
    // Default configuration
    config: {
        angle: 0,                // Movement direction in degrees
        returnToOrigin: false,   // Whether particles return to start
        strength: 1.0           // Force intensity
    },
    
    // Rhythm configuration - directional movement following musical flow
    rhythm: {
        enabled: true,
        syncMode: 'flow',  // Follow musical flow and direction
        
        // Direction changes with musical progression
        angleSync: {
            verse: 0,             // Right movement in verses
            chorus: 90,           // Upward movement in choruses  
            bridge: 180,          // Left movement in bridges
            outro: 270,           // Downward movement in outros
            transition: 'smooth'  // Smooth direction changes
        },
        
        // Strength pulses with rhythm
        strengthSync: {
            onBeat: 1.8,          // Strong push on beats
            offBeat: 0.6,         // Gentle drift off-beat
            curve: 'wave'         // Wave-like motion curve
        },
        
        // Return motion syncs to musical sections
        returnSync: {
            enabled: true,
            onSectionChange: true, // Return on section changes
            duration: 'transition', // Use transition timing
            strength: 1.2
        },
        
        // Accent response affects direction
        accentResponse: {
            enabled: true,
            multiplier: 2.0,      // Sharp directional push on accents
            type: 'strength'      // Accent affects movement force
        },
        
        // Pattern-specific directional styles
        patternOverrides: {
            'march': {
                // Military-style directional movement
                angleSync: { verse: 0, chorus: 0 }, // Always forward
                strengthSync: { onBeat: 2.5, offBeat: 1.0 }
            },
            'waltz': {
                // Flowing, circular directional movement
                angleSync: { 
                    verse: 45, 
                    chorus: 135,
                    bridge: 225,
                    outro: 315,
                    transition: 'circular'
                }
            },
            'swing': {
                // Syncopated directional swaying
                strengthSync: { 
                    onBeat: 1.6, 
                    offBeat: 1.4,  // Strong off-beat emphasis
                    swing: true 
                }
            },
            'electronic': {
                // Sharp, precise directional cuts
                angleSync: { transition: 'instant' },
                strengthSync: { onBeat: 2.2, offBeat: 0.4, curve: 'sharp' }
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Powerful, decisive direction changes
                strengthSync: { 
                    onBeat: { multiplier: 1.6 },
                    offBeat: { multiplier: 1.2 }
                },
                angleSync: { transition: 'sharp' },
                accentResponse: { multiplier: 2.5 }
            },
            piano: {
                // Gentle, subtle directional drift
                strengthSync: { 
                    onBeat: { multiplier: 0.7 },
                    offBeat: { multiplier: 0.8 }
                },
                angleSync: { transition: 'gradual' },
                accentResponse: { multiplier: 1.4 }
            }
        }
    },
    
    /**
     * Initialize directional movement data
     * Stores particle's starting position for return motion
     */
    initialize(particle) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.directional = {
            initialX: particle.x,
            initialY: particle.y
        };
    },
    
    /**
     * Apply directional force to particle
     * Pushes particles in specified direction with optional return
     */
    apply(particle, progress, motion, dt, _centerX, _centerY) {
        if (!particle.gestureData?.directional) {
            this.initialize(particle);
        }

        // Convert angle to radians for calculation
        const angle = (motion.angle || this.config.angle) * Math.PI / 180;
        const strength = motion.strength || this.config.strength;

        // Apply directional force
        particle.vx += Math.cos(angle) * strength * 0.3 * dt;
        particle.vy += Math.sin(angle) * strength * 0.3 * dt;

        // Optional return motion in second half of gesture
        if (motion.returnToOrigin && progress > 0.5) {
            const returnProgress = (progress - 0.5) * 2;
            const data = particle.gestureData.directional;
            // Calculate return force toward initial position
            const dx = data.initialX - particle.x;
            const dy = data.initialY - particle.y;
            particle.vx += dx * returnProgress * 0.02 * dt;
            particle.vy += dy * returnProgress * 0.02 * dt;
        }
    },

    /**
     * 3D core transformation for directional gesture
     * Movement in XY plane based on specified direction
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation { position: [x,y,z], rotation: [x,y,z], scale: number, glowIntensity: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };
            const angle = (config.angle || 0) * Math.PI / 180;
            const strength = motion.strength || 1.0;

            // Directional movement in XY
            const moveProgress = config.returnToOrigin
                ? (progress < 0.5 ? progress * 2 : (1 - progress) * 2)
                : progress;

            const posX = Math.cos(angle) * moveProgress * 0.4 * strength;
            const posY = Math.sin(angle) * moveProgress * 0.4 * strength;

            return {
                position: [posX, posY, 0],
                rotation: [0, 0, 0],
                scale: 1.0,
                glowIntensity: 1.0
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Settle Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Settle gesture - gradually reduce velocity
 * @author Emotive Engine Team
 * @module gestures/effects/settle
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 */

var settle = {
    name: 'settle',
    emoji: '🍃',
    type: 'blending',
    description: 'Gradually settle particles to rest',
    
    // Default configuration
    config: {
        damping: 0.02,     // Velocity reduction rate
        threshold: 0.01    // Minimum velocity before stop
    },
    
    // Rhythm configuration - gradual settling synchronized to musical resolution
    rhythm: {
        enabled: true,
        syncMode: 'resolution', // Settle during chord resolutions and phrase endings
        
        // Damping rate responds to musical tension/release
        dampingSync: {
            onResolution: 0.035,    // Faster settling on resolution
            onTension: 0.015,       // Slower settling during tension
            curve: 'gradual'        // Smooth, natural decay
        },
        
        // Threshold adapts to dynamic level
        thresholdSync: {
            mode: 'dynamics',
            forte: 0.02,            // Higher threshold for loud music
            piano: 0.005,           // Lower threshold for quiet music
            curve: 'exponential'
        },
        
        // Duration follows musical phrase structure
        durationSync: {
            mode: 'phrase',
            minBeats: 2,            // Minimum 2-beat settling
            maxBeats: 12,           // Maximum phrase-length settling
            sustain: true           // Maintain settling through resolution
        },
        
        // Response to cadential movements
        cadenceResponse: {
            enabled: true,
            multiplier: 1.6,        // Enhanced settling on cadences
            type: 'damping'         // Affects settling rate
        },
        
        // Style variations for different music types
        patternOverrides: {
            'ambient': {
                // Slow, atmospheric settling
                dampingSync: { onResolution: 0.025, onTension: 0.008, curve: 'atmospheric' },
                durationSync: { minBeats: 8, maxBeats: 32 }
            },
            'jazz': {
                // Smooth settling with swing feel
                dampingSync: { onResolution: 0.040, onTension: 0.020 },
                cadenceResponse: { multiplier: 1.8 }
            },
            'classical': {
                // Expressive settling following harmonic rhythm
                dampingSync: { onResolution: 0.045, onTension: 0.012, curve: 'expressive' },
                cadenceResponse: { multiplier: 2.0 }
            },
            'minimalist': {
                // Very gradual, meditative settling
                dampingSync: { onResolution: 0.020, onTension: 0.005 },
                durationSync: { minBeats: 16, maxBeats: 64 }
            }
        },
        
        // Musical dynamics
        dynamics: {
            forte: {
                // Decisive, clear settling
                dampingSync: { 
                    onResolution: { multiplier: 1.4 },
                    onTension: { multiplier: 0.8 }
                },
                thresholdSync: { multiplier: 2.0 },
                cadenceResponse: { multiplier: 2.2 }
            },
            piano: {
                // Gentle, soft settling
                dampingSync: { 
                    onResolution: { multiplier: 0.7 },
                    onTension: { multiplier: 1.2 }
                },
                thresholdSync: { multiplier: 0.5 },
                cadenceResponse: { multiplier: 1.3 }
            }
        }
    },
    
    /**
     * Apply settling effect to particle
     * Gradually reduces velocity until particles come to rest
     */
    apply(particle, progress, motion, dt, _centerX, _centerY) {
        const damping = motion.damping || this.config.damping;
        const threshold = motion.threshold || this.config.threshold;

        // Apply exponential velocity damping
        particle.vx *= Math.max(0, 1 - damping * dt * 60);
        particle.vy *= Math.max(0, 1 - damping * dt * 60);

        // Stop completely when velocity falls below threshold
        if (Math.abs(particle.vx) < threshold) particle.vx = 0;
        if (Math.abs(particle.vy) < threshold) particle.vy = 0;
    },

    /**
     * 3D core transformation for settle gesture
     * Gradual return to neutral position with reduced glow
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation { position: [x,y,z], rotation: [x,y,z], scale: number, glowIntensity: number }
     */
    '3d': {
        evaluate(progress, _motion) {
            // Settle gesture: stay calm and stable at origin
            // Use eased progress for smooth transition
            const eased = 1 - Math.pow(1 - progress, 2); // Ease out quad

            // Very subtle micro-movements that diminish over time - like coming to rest
            const microMovement = (1 - eased) * 0.01;
            const posX = Math.sin(progress * Math.PI * 2) * microMovement;
            const posY = Math.cos(progress * Math.PI * 3) * microMovement * 0.5;

            // Subtle scale reduction as settling - breathes down gently
            const scale = 1.0 - eased * 0.03;

            // Glow dims slightly as we settle into calm
            const glowIntensity = 1.0 - eased * 0.15;

            return {
                position: [posX, posY, 0],
                rotation: [0, 0, 0],
                scale,
                glowIntensity
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Fade Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Fade gesture - opacity fade effect
 * @author Emotive Engine Team
 * @module gestures/effects/fade
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 */

var fade = {
    name: 'fade',
    emoji: '👻',
    type: 'blending',
    description: 'Fade particle opacity',
    
    // Default configuration
    config: {
        duration: 2000,     // 2 second duration (longer for lerping to catch up)
        fadeIn: true,       // Enable fade in effect (for fade-out-and-back)
        fadeOut: true,      // Enable fade out effect
        minOpacity: 0,      // Minimum opacity level
        maxOpacity: 1       // Maximum opacity level
    },
    
    // Rhythm configuration - fades sync to musical dynamics
    rhythm: {
        enabled: true,
        syncMode: 'dynamic',  // Fade with volume/intensity changes
        
        // Opacity modulation with beat
        opacitySync: {
            onBeat: 0.9,              // Nearly visible on beat
            offBeat: 0.3,             // Ghostly between beats
            subdivision: 'eighth',     // Check every 8th note
            curve: 'exponential'      // Sharp opacity changes
        },
        
        // Fade timing with musical structure
        fadePhaseSync: {
            verse: { fadeIn: true, fadeOut: false },    // Build in verse
            chorus: { fadeIn: false, fadeOut: false },  // Full visibility
            bridge: { fadeIn: true, fadeOut: true },    // In and out
            outro: { fadeIn: false, fadeOut: true }     // Fade to end
        },
        
        // Pulse with rhythm
        pulseSync: {
            enabled: true,
            frequency: 'quarter',     // Pulse every quarter note
            intensity: 0.2,           // Pulse depth
            onAccent: 0.4            // Deeper pulse on accents
        },
        
        // Musical dynamics
        dynamics: {
            forte: { minOpacity: 0.5, maxOpacity: 1.0 },    // More visible when loud
            piano: { minOpacity: 0.0, maxOpacity: 0.4 }     // Ghostly when quiet
        }
    },
    
    /**
     * Initialize fade data
     * Stores particle's original opacity
     */
    initialize(particle) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.fade = {
            baseOpacity: particle.opacity || particle.life || 1
        };
    },
    
    /**
     * Apply fade effect to particle
     * Smoothly transitions opacity based on configuration
     */
    apply(particle, progress, motion, _dt, _centerX, _centerY) {
        if (!particle.gestureData?.fade) {
            this.initialize(particle);
        }
        
        const data = particle.gestureData.fade;
        const config = { ...this.config, ...motion };
        
        let targetOpacity;
        if (config.fadeIn && !config.fadeOut) {
            // Fade in only - opacity increases over time
            targetOpacity = config.minOpacity + (config.maxOpacity - config.minOpacity) * progress;
        } else if (config.fadeOut && !config.fadeIn) {
            // Fade out only - opacity decreases over time
            targetOpacity = config.maxOpacity - (config.maxOpacity - config.minOpacity) * progress;
        } else {
            // Fade in then out - peak opacity at midpoint
            if (progress < 0.5) {
                targetOpacity = config.minOpacity + (config.maxOpacity - config.minOpacity) * (progress * 2);
            } else {
                targetOpacity = config.maxOpacity - (config.maxOpacity - config.minOpacity) * ((progress - 0.5) * 2);
            }
        }
        
        // Apply calculated opacity
        particle.opacity = data.baseOpacity * targetOpacity;
        // Also update life property for particles that use it
        if (particle.life !== undefined) {
            particle.life = particle.opacity;
        }
    },
    
    /**
     * Clean up fade effect
     * Restores original opacity values
     */
    cleanup(particle) {
        if (particle.gestureData?.fade) {
            particle.opacity = particle.gestureData.fade.baseOpacity;
            if (particle.life !== undefined) {
                particle.life = particle.opacity;
            }
            delete particle.gestureData.fade;
        }
    },

    /**
     * 3D core transformation for fade gesture
     * Opacity fade translates to glowIntensity multiplier
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation { position: [x,y,z], rotation: [x,y,z], scale: number, glowIntensity: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };

            let glowIntensity;
            const minOpacity = config.minOpacity ?? 0.0;
            const maxOpacity = config.maxOpacity ?? 1.0;

            if (config.fadeIn && !config.fadeOut) {
                // Fade in only - glow increases from minOpacity to maxOpacity
                glowIntensity = minOpacity + (maxOpacity - minOpacity) * progress;
            } else if (config.fadeOut && !config.fadeIn) {
                // Fade out only - glow decreases from maxOpacity to minOpacity
                glowIntensity = maxOpacity - (maxOpacity - minOpacity) * progress;
            } else {
                // Fade out then back in: maxOpacity → minOpacity → maxOpacity
                // This creates the classic "fade" effect (bright → dark → bright)
                if (progress < 0.5) {
                    glowIntensity = maxOpacity - (maxOpacity - minOpacity) * (progress * 2);
                } else {
                    glowIntensity = minOpacity + (maxOpacity - minOpacity) * ((progress - 0.5) * 2);
                }
            }

            return {
                position: [0, 0, 0],
                rotation: [0, 0, 0],
                scale: 1.0,
                glowIntensity
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Hold Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Hold gesture - freeze particles in place
 * @author Emotive Engine Team
 * @module gestures/effects/hold
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 */

var hold = {
    name: 'hold',
    emoji: '⏸️',
    type: 'override',
    description: 'Hold particles in current position',
    
    // Default configuration
    config: {
        holdStrength: 0.95,  // Position retention strength
        allowDrift: false    // Enable slight movement
    },
    
    // Rhythm configuration - synchronized pause effects following musical structure
    rhythm: {
        enabled: true,
        syncMode: 'rest',    // Hold particles during musical rests and pauses
        
        // Hold strength responds to musical silence
        holdSync: {
            onRest: 0.98,         // Very strong hold during rests
            onSound: 0.80,        // Looser hold when music plays
            curve: 'immediate'    // Instant response to silence/sound
        },
        
        // Duration matches rest length
        durationSync: {
            mode: 'rests',
            minBeats: 0.5,        // Minimum half-beat hold
            maxBeats: 8,          // Maximum 8-beat hold
            sustain: true         // Maintain hold through entire rest
        },
        
        // Response to fermatas and caesuras
        pauseResponse: {
            enabled: true,
            multiplier: 1.5,      // Stronger hold during marked pauses
            type: 'strength'      // Affects hold strength
        },
        
        // Style variations for different music types
        patternOverrides: {
            'classical': {
                // Expressive holds for dramatic pauses
                holdSync: { onRest: 0.99, onSound: 0.75, curve: 'dramatic' },
                pauseResponse: { multiplier: 2.0 }
            },
            'minimal': {
                // Extended, meditative holds
                holdSync: { onRest: 0.95, onSound: 0.85 },
                durationSync: { minBeats: 2, maxBeats: 16 }
            },
            'jazz': {
                // Subtle holds that allow for swing
                holdSync: { onRest: 0.90, onSound: 0.70 },
                allowDrift: true  // Enable slight movement for swing feel
            },
            'electronic': {
                // Precise, digital-style holds
                holdSync: { onRest: 0.99, onSound: 0.60, curve: 'digital' },
                pauseResponse: { multiplier: 1.2 }
            }
        },
        
        // Musical dynamics
        dynamics: {
            forte: {
                // Strong, definitive holds
                holdSync: { 
                    onRest: { multiplier: 1.02 },
                    onSound: { multiplier: 0.9 }
                },
                pauseResponse: { multiplier: 2.2 }
            },
            piano: {
                // Gentle, floating holds
                holdSync: { 
                    onRest: { multiplier: 0.97 },
                    onSound: { multiplier: 0.85 }
                },
                pauseResponse: { multiplier: 1.3 }
            }
        }
    },
    
    initialize(particle) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.hold = {
            holdX: particle.x,
            holdY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy
        };
    },
    
    /**
     * Apply hold effect to particle
     * Freezes or slows particle movement based on configuration
     */
    apply(particle, progress, motion, _dt, _centerX, _centerY) {
        if (!particle.gestureData?.hold) {
            this.initialize(particle);
        }
        
        const data = particle.gestureData.hold;
        const holdStrength = motion.holdStrength || this.config.holdStrength;
        
        if (motion.allowDrift) {
            // Allow slight drift with velocity damping
            particle.vx *= holdStrength;
            particle.vy *= holdStrength;
        } else {
            // Hard hold - lock to position
            particle.x += (data.holdX - particle.x) * (1 - holdStrength);
            particle.y += (data.holdY - particle.y) * (1 - holdStrength);
            particle.vx = 0;
            particle.vy = 0;
        }
        
        // Gradually restore velocity near end
        if (progress > 0.9) {
            const restoreFactor = (progress - 0.9) * 10;
            particle.vx = particle.vx * (1 - restoreFactor) + data.originalVx * restoreFactor;
            particle.vy = particle.vy * (1 - restoreFactor) + data.originalVy * restoreFactor;
        }
    },
    
    cleanup(particle) {
        if (particle.gestureData?.hold) {
            const data = particle.gestureData.hold;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.hold;
        }
    },

    /**
     * 3D core transformation for hold gesture
     * Static neutral state - no movement
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation { position: [x,y,z], rotation: [x,y,z], scale: number, glowIntensity: number }
     */
    '3d': {
        evaluate(_progress, _motion) {
            // Completely static - neutral position
            return {
                position: [0, 0, 0],
                rotation: [0, 0, 0],
                scale: 1.0,
                glowIntensity: 1.0
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Breathe Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Breathe gesture - inhale/exhale particle motion
 * @author Emotive Engine Team
 * @module gestures/effects/breathe
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 */

var breathe = {
    name: 'breathe',
    emoji: '🫁',
    type: 'blending',
    description: 'Breathing rhythm with inhale and exhale',
    
    // Default configuration
    config: {
        // Musical duration - one full breath per bar
        musicalDuration: {
            musical: true,
            bars: 1,           // Default to 1 bar breathing cycle
            minBeats: 2,       // Minimum half bar
            maxBeats: 16       // Maximum 4 bars for slow breathing
        },
        
        // Musical phases of breathing
        phases: [
            { name: 'inhale', beats: 1.5 },     // Inhale phase
            { name: 'hold_in', beats: 0.5 },    // Hold at peak
            { name: 'exhale', beats: 1.5 },     // Exhale phase
            { name: 'hold_out', beats: 0.5 }    // Hold at rest
        ],
        
        inhaleRadius: 1.5,     // Maximum expansion distance
        exhaleRadius: 0.3,     // Minimum contraction distance
        breathRate: 0.3,       // Breathing rhythm speed
        spiralStrength: 0.002, // Subtle spiral motion intensity
        scaleAmount: 0.25,     // Core size variation amount
        glowAmount: 0.4,       // Glow intensity variation
        frequency: 1,          // Number of breath cycles
        easing: 'sine',        // Smooth, natural curve type
        strength: 0.8,         // Overall motion influence
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'breathe',
            strength: 0.8,         // Particle response strength
            inhaleRadius: 1.5,     // Particle expansion limit
            exhaleRadius: 0.3      // Particle contraction limit
        }
    },
    
    // Rhythm configuration - breathing synced to musical phrases
    rhythm: {
        enabled: true,
        syncMode: 'phrase',  // Long breathing cycles across musical phrases
        
        // Breath rate syncs to musical tempo
        breathRateSync: {
            mode: 'tempo',
            bpm: 'auto',          // Match song tempo
            subdivision: 'whole', // Full breaths on whole notes
            curve: 'sine'         // Natural breathing curve
        },
        
        // Inhale/exhale expansion syncs to dynamics
        radiusSync: {
            inhale: {
                onUpbeat: 1.8,    // Deeper inhale on upbeats
                onDownbeat: 1.4,  // Standard inhale on downbeats
                curve: 'ease-in'
            },
            exhale: {
                onUpbeat: 0.2,    // Complete exhale on upbeats
                onDownbeat: 0.4,  // Gentle exhale on downbeats
                curve: 'ease-out'
            }
        },
        
        // Duration matches musical phrasing
        durationSync: {
            mode: 'phrases',
            phrases: 2,           // Breathe across 2 musical phrases
            hold: 'fermata'       // Hold breath on fermatas
        },
        
        // Respond to musical accents
        accentResponse: {
            enabled: true,
            multiplier: 1.5,      // Deeper breath on accents
            type: 'expansion'     // Accent affects radius expansion
        },
        
        // Pattern-specific breathing styles
        patternOverrides: {
            'ballad': {
                // Slow, deep breathing for emotional ballads
                breathRateSync: { subdivision: 'double-whole' },
                radiusSync: { 
                    inhale: { onUpbeat: 2.2, onDownbeat: 1.8 },
                    exhale: { onUpbeat: 0.1, onDownbeat: 0.2 }
                }
            },
            'uptempo': {
                // Quick, energetic breathing
                breathRateSync: { subdivision: 'half' },
                radiusSync: { 
                    inhale: { onUpbeat: 1.4, onDownbeat: 1.2 },
                    exhale: { onUpbeat: 0.3, onDownbeat: 0.4 }
                }
            },
            'ambient': {
                // Ethereal, floating breathing
                breathRateSync: { subdivision: 'whole', curve: 'ease' },
                radiusSync: { 
                    inhale: { onUpbeat: 1.6, onDownbeat: 1.6 },
                    exhale: { onUpbeat: 0.2, onDownbeat: 0.2 }
                }
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Powerful, deep breathing
                radiusSync: { 
                    inhale: { multiplier: 1.8 },
                    exhale: { multiplier: 0.5 }
                },
                spiralStrength: 0.004,  // More spiral motion
                scaleAmount: 0.4
            },
            piano: {
                // Gentle, subtle breathing
                radiusSync: { 
                    inhale: { multiplier: 1.2 },
                    exhale: { multiplier: 0.8 }
                },
                spiralStrength: 0.001,  // Minimal spiral
                scaleAmount: 0.1
            }
        }
    },
    
    /**
     * Initialize breathing data for a particle
     * Stores particle's starting position and relationship to center
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate particle's position relative to orb center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        
        particle.gestureData.breathe = {
            startX: particle.x,                        // Original X position
            startY: particle.y,                        // Original Y position
            angle: Math.atan2(dy, dx),                // Direction from center
            baseRadius: Math.sqrt(dx * dx + dy * dy), // Distance from center
            phaseOffset: Math.random() * 0.2 - 0.1    // Slight timing variation for organic feel
        };
    },
    
    /**
     * Apply breathing motion to particle
     * Creates expansion/contraction movement synchronized with breath rhythm
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize particle data if needed
        if (!particle.gestureData?.breathe) {
            this.initialize(particle, motion, centerX, centerY);
        }
        

        const config = { ...this.config, ...motion };
        
        // Calculate breath phase - creates smooth sine wave between exhale and inhale
        // Result oscillates smoothly between 0 (exhale) and 1 (inhale)
        const breathPhase = (Math.sin(progress * Math.PI * 2 * config.breathRate) + 1) / 2;
        
        // Define breathing boundaries relative to orb size
        // Scale boundaries based on particle's size factor for consistent appearance
        const referenceRadius = 100 * (particle.scaleFactor || 1);
        const inhaleRadius = config.inhaleRadius * referenceRadius;
        const exhaleRadius = config.exhaleRadius * referenceRadius;
        
        // Interpolate target position between exhale and inhale boundaries
        const targetRadius = exhaleRadius + (inhaleRadius - exhaleRadius) * breathPhase;
        
        // Calculate particle's current distance from center
        const currentDx = particle.x - centerX;
        const currentDy = particle.y - centerY;
        const currentRadius = Math.sqrt(currentDx * currentDx + currentDy * currentDy);
        
        // Calculate radial movement needed to reach target breathing position
        const radiusDiff = targetRadius - currentRadius;
        const moveStrength = (motion.strength || 0.8) * 0.05 * dt;
        
        // Apply radial motion (move in/out from center)
        if (currentRadius > 0) {
            // Normalize direction and apply movement
            const moveX = (currentDx / currentRadius) * radiusDiff * moveStrength;
            const moveY = (currentDy / currentRadius) * radiusDiff * moveStrength;
            
            particle.vx += moveX;
            particle.vy += moveY;
            
            // Add organic spiral motion for more natural breathing feel
            // Creates slight circular drift during expansion/contraction
            const spiralStrength = config.spiralStrength * dt * (motion.strength || 1);
            const tangentX = -currentDy / currentRadius;  // Perpendicular to radial direction
            const tangentY = currentDx / currentRadius;
            
            // Spiral motion stronger during inhale, creating expanding spiral
            particle.vx += tangentX * spiralStrength * breathPhase;
            particle.vy += tangentY * spiralStrength * breathPhase;
        }
        
        // Apply velocity damping for smooth, controlled motion
        // Prevents particles from overshooting or oscillating
        particle.vx *= 0.98;
        particle.vy *= 0.98;
    },
    
    /**
     * Clean up breathing data when gesture completes
     * Removes stored data to free memory
     */
    cleanup(particle) {
        if (particle.gestureData?.breathe) {
            delete particle.gestureData.breathe;
        }
    },

    /**
     * 3D core transformation for breathe gesture
     * Dramatic breathing with expansion/contraction and glow pulsing
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation { position: [x,y,z], rotation: [x,y,z], scale: number, glowIntensity: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = motion.config || {};
            const breathRate = config.breathRate || 0.3;

            // Breathing phase - smooth sine wave oscillation
            const breathPhase = Math.sin(progress * Math.PI * 2 * breathRate);

            // Fade-out envelope for smooth return to neutral at end
            // Last 20% of animation fades back to neutral
            const fadeOutStart = 0.8;
            let envelope = 1.0;
            if (progress > fadeOutStart) {
                const fadeProgress = (progress - fadeOutStart) / (1.0 - fadeOutStart);
                // Ease-out cubic for smooth deceleration
                envelope = 1.0 - (fadeProgress * fadeProgress * fadeProgress);
            }

            // Dramatic scale pulsing - exhale (0.7x) to inhale (1.4x)
            const scaleOffset = breathPhase * 0.35 * envelope; // Apply envelope
            const scale = 1.0 + scaleOffset; // Range: 0.65 to 1.35, fading to 1.0

            // Gentle glow pulsing - dim on exhale, bright on inhale
            // Normalized to ±20% variation around 1.0 multiplier
            // Exhale (dim): 0.8, Inhale (bright): 1.2
            const glowOffset = breathPhase * 0.2 * envelope; // Apply envelope
            const glowIntensity = 1.0 + glowOffset; // Range: 0.8 to 1.2

            // Slight Y-axis position shift - rise on inhale, lower on exhale
            const yOffset = breathPhase * 0.05 * envelope; // Apply envelope

            // Glow boost for screen-space halo - subtle pulse on inhale
            const glowBoost = Math.max(0, glowOffset * 2.0);

            return {
                position: [0, yOffset, 0],
                rotation: [0, 0, 0],
                scale,
                glowIntensity, // Use calculated multiplier (0.8 to 1.2)
                glowBoost
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Expand Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Expand gesture - particles move outward from center
 * @author Emotive Engine Team
 * @module gestures/effects/expand
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 */

var expand = {
    name: 'expand',
    emoji: '💫',
    type: 'blending',
    description: 'Radial expansion from center',
    
    // Default configuration
    config: {
        duration: 600,        // Gesture duration
        scaleAmount: 3.0,     // Core scale expansion amount
        scaleTarget: 3.0,     // Target expansion distance ratio
        glowAmount: 0.5,      // Glow intensity increase
        easing: 'back',       // Overshoot animation curve
        strength: 3.0,        // Outward push force intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'pulse',
            strength: 3.0,        // Particle push strength
            direction: 'outward', // Movement away from center
            persist: true         // Maintain expanded position
        }
    },
    
    // Rhythm configuration - expansive growth synced to musical crescendos
    rhythm: {
        enabled: true,
        syncMode: 'crescendo',  // Expand during musical crescendos
        
        // Expansion strength follows dynamics
        strengthSync: {
            pianissimo: 1.5,      // Gentle expansion in quiet sections
            fortissimo: 5.0,      // Massive expansion in loud sections
            crescendo: 'build',   // Gradual build during crescendos
            sforzando: 'burst'    // Sudden expansion on sforzandos
        },
        
        // Scale target responds to musical intensity
        scaleTargetSync: {
            verse: 2.0,           // Moderate expansion in verses
            chorus: 4.5,          // Large expansion in choruses
            climax: 6.0,          // Maximum expansion at climax
            curve: 'exponential'  // Exponential growth curve
        },
        
        // Duration matches musical phrasing
        durationSync: {
            mode: 'phrases',
            build: 1.2,           // Extended duration during builds
            release: 0.8,         // Quick expansion on releases
            sustain: 'hold'       // Hold expansion during sustains
        },
        
        // Strong accent response
        accentResponse: {
            enabled: true,
            multiplier: 2.8,      // Massive expansion on accents
            type: 'strength'      // Accent affects expansion force
        },
        
        // Pattern-specific expansion styles
        patternOverrides: {
            'orchestral': {
                // Epic, cinematic expansion
                strengthSync: { 
                    pianissimo: 2.0, 
                    fortissimo: 6.5,
                    crescendo: 'dramatic'
                },
                scaleTargetSync: { climax: 8.0 }
            },
            'rock': {
                // Aggressive, powerful expansion
                strengthSync: { 
                    pianissimo: 1.8, 
                    fortissimo: 5.5,
                    curve: 'power'
                },
                accentResponse: { multiplier: 3.2 }
            },
            'ambient': {
                // Gentle, organic expansion
                strengthSync: { 
                    pianissimo: 1.2, 
                    fortissimo: 3.5,
                    crescendo: 'organic'
                },
                durationSync: { build: 1.8, release: 1.2 }
            },
            'electronic': {
                // Sharp, controlled expansion
                strengthSync: { 
                    pianissimo: 1.6, 
                    fortissimo: 4.8,
                    curve: 'digital'
                },
                scaleTargetSync: { curve: 'linear' }
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Powerful, overwhelming expansion
                strengthSync: { 
                    pianissimo: { multiplier: 1.4 },
                    fortissimo: { multiplier: 1.8 }
                },
                scaleTargetSync: { multiplier: 1.6 },
                accentResponse: { multiplier: 3.5 }
            },
            piano: {
                // Delicate, controlled expansion
                strengthSync: { 
                    pianissimo: { multiplier: 0.8 },
                    fortissimo: { multiplier: 1.2 }
                },
                scaleTargetSync: { multiplier: 0.7 },
                accentResponse: { multiplier: 2.0 }
            }
        }
    },
    
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        particle.gestureData.expand = {
            startX: particle.x,
            startY: particle.y,
            angle: Math.atan2(dy, dx),
            baseRadius: Math.sqrt(dx * dx + dy * dy),
            initialized: true
        };
    },
    
    /**
     * Apply expansion motion to particle
     * Pushes particles outward from center with explosive force
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.expand?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.expand;
        const config = { ...this.config, ...motion };
        const strength = config.strength || 1.0;
        
        // Calculate expansion amount based on progress
        const expandFactor = 1 + (config.scaleTarget - 1) * progress * strength;
        const targetRadius = data.baseRadius * expandFactor;
        
        // Calculate target position farther from center
        const targetX = centerX + Math.cos(data.angle) * targetRadius;
        const targetY = centerY + Math.sin(data.angle) * targetRadius;
        
        // Apply strong outward push forces
        const dx = targetX - particle.x;
        const dy = targetY - particle.y;
        particle.vx += dx * 0.8 * dt;  // Strong explosive push
        particle.vy += dy * 0.8 * dt;  // Strong explosive push
        
        // Apply velocity damping for controlled motion
        particle.vx *= 0.95;
        particle.vy *= 0.95;
    },
    
    cleanup(particle) {
        if (particle.gestureData?.expand) {
            delete particle.gestureData.expand;
        }
    },

    /**
     * 3D core transformation for expand gesture
     * Gradual scale increase with growing glow
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation { position: [x,y,z], rotation: [x,y,z], scale: number, glowIntensity: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };
            const strength = config.strength || 3.0;

            // Gradual scale expansion
            const scaleAmount = config.scaleAmount || 3.0;
            const scale = 1.0 + progress * scaleAmount * (strength / 3.0);

            // Growing glow intensity (normalized to +25% max)
            // Gradual brightening from 1.0 to 1.25 during expansion
            const glowIntensity = 1.0 + progress * 0.25;

            // Glow boost for screen-space halo - grows with expansion
            const glowBoost = progress * 0.8;

            return {
                position: [0, 0, 0],
                rotation: [0, 0, 0],
                scale,
                glowIntensity,
                glowBoost
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Contract Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Contract gesture - particles move inward toward center
 * @author Emotive Engine Team
 * @module gestures/effects/contract
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 */

var contract = {
    name: 'contract',
    emoji: '🌀',
    type: 'blending',
    description: 'Radial contraction toward center',
    
    // Default configuration
    config: {
        duration: 600,        // Gesture duration
        scaleAmount: 0.2,     // Core scale reduction amount
        scaleTarget: 0.2,     // Target contraction distance ratio
        glowAmount: -0.2,     // Glow intensity reduction
        easing: 'cubic',      // Smooth acceleration curve
        strength: 2.5,        // Inward pull force intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'pulse',
            strength: 2.5,        // Particle pull strength
            direction: 'inward',  // Movement toward center
            persist: true         // Effect continues after gesture
        }
    },
    
    // Rhythm configuration - magnetic contraction synced to musical tension
    rhythm: {
        enabled: true,
        syncMode: 'tension',  // Contract during musical tension builds
        
        // Contraction strength responds to musical intensity
        strengthSync: {
            onTension: 4.0,       // Strong pull during tension
            onRelease: 1.5,       // Gentle pull during release
            curve: 'magnetic'     // Smooth magnetic pull curve
        },
        
        // Scale target changes with dynamics
        scaleTargetSync: {
            forte: 0.1,           // Tight contraction for loud sections
            piano: 0.4,           // Gentle contraction for soft sections
            crescendo: 'gradual', // Gradual tightening on crescendos
            diminuendo: 'ease'    // Easy relaxation on diminuendos
        },
        
        // Duration responds to phrase length
        durationSync: {
            mode: 'phrases',
            shortPhrase: 0.8,     // Quick contraction for short phrases  
            longPhrase: 1.5,      // Extended contraction for long phrases
            hold: 'sustain'       // Maintain contraction during holds
        },
        
        // Strong accent response
        accentResponse: {
            enabled: true,
            multiplier: 2.2,      // Sharp contraction on accents
            type: 'strength'      // Accent affects pull force
        },
        
        // Pattern-specific contraction styles
        patternOverrides: {
            'classical': {
                // Elegant, controlled contraction
                strengthSync: { onTension: 3.5, onRelease: 1.8 },
                scaleTargetSync: { forte: 0.15, piano: 0.35 }
            },
            'metal': {
                // Aggressive, tight contraction
                strengthSync: { onTension: 5.0, onRelease: 2.0, curve: 'sharp' },
                scaleTargetSync: { forte: 0.05, piano: 0.25 }
            },
            'ambient': {
                // Slow, atmospheric contraction
                strengthSync: { onTension: 2.8, onRelease: 1.2, curve: 'ease' },
                durationSync: { shortPhrase: 1.2, longPhrase: 2.0 }
            },
            'trap': {
                // Sudden, rhythmic contraction on drops
                strengthSync: { 
                    onTension: 4.5, 
                    onRelease: 1.0,
                    dropBeat: 6.0   // Massive contraction on trap drops
                },
                scaleTargetSync: { forte: 0.08, piano: 0.3 }
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Powerful, crushing contraction
                strengthSync: { 
                    onTension: { multiplier: 1.8 },
                    onRelease: { multiplier: 1.4 }
                },
                scaleTargetSync: { multiplier: 0.6 },  // Tighter contraction
                accentResponse: { multiplier: 2.8 }
            },
            piano: {
                // Gentle, subtle contraction
                strengthSync: { 
                    onTension: { multiplier: 0.7 },
                    onRelease: { multiplier: 0.8 }
                },
                scaleTargetSync: { multiplier: 1.4 },  // Looser contraction
                accentResponse: { multiplier: 1.6 }
            }
        }
    },
    
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        particle.gestureData.contract = {
            startX: particle.x,
            startY: particle.y,
            angle: Math.atan2(dy, dx),
            baseRadius: Math.sqrt(dx * dx + dy * dy),
            initialized: true
        };
    },
    
    /**
     * Apply contraction motion to particle
     * Pulls particles toward center with magnetic-like force
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.contract?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.contract;
        const config = { ...this.config, ...motion };
        const strength = config.strength || 1.0;
        
        // Calculate contraction amount based on progress
        const contractFactor = 1 - (1 - config.scaleTarget) * progress * strength;
        const targetRadius = data.baseRadius * contractFactor;
        
        // Calculate target position closer to center
        const targetX = centerX + Math.cos(data.angle) * targetRadius;
        const targetY = centerY + Math.sin(data.angle) * targetRadius;
        
        // Apply strong inward pull forces
        const dx = targetX - particle.x;
        const dy = targetY - particle.y;
        particle.vx += dx * 0.5 * dt;  // Strong magnetic pull
        particle.vy += dy * 0.5 * dt;  // Strong magnetic pull
        
        // Apply velocity damping for controlled motion
        particle.vx *= 0.95;
        particle.vy *= 0.95;
    },
    
    cleanup(particle) {
        if (particle.gestureData?.contract) {
            delete particle.gestureData.contract;
        }
    },

    /**
     * 3D core transformation for contract gesture
     * Gradual scale decrease with dimming glow
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation { position: [x,y,z], rotation: [x,y,z], scale: number, glowIntensity: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };
            const strength = config.strength || 2.5;

            // Gradual scale contraction
            const scaleTarget = config.scaleTarget || 0.2;
            const scale = 1.0 - progress * (1.0 - scaleTarget) * (strength / 2.5);

            // Dimming glow intensity (normalized to -15% max)
            // Gentle dimming from 1.0 to 0.85 during contraction
            const glowReduction = progress * 0.15;
            const glowIntensity = 1.0 - glowReduction;

            return {
                position: [0, 0, 0],
                rotation: [0, 0, 0],
                scale: Math.max(scaleTarget, scale),
                glowIntensity // Range: 1.0 to 0.85
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Flash Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Flash gesture - bright burst effect
 * @author Emotive Engine Team
 * @module gestures/effects/flash
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 */

var flash = {
    name: 'flash',
    emoji: '⚡',
    type: 'blending',
    description: 'Bright flash burst effect',
    
    // Default configuration
    config: {
        duration: 400,       // Animation duration
        glowAmount: 2.5,     // Overall brightness increase
        glowPeak: 3.0,       // Maximum intensity level
        scalePeak: 1.1,      // Size expansion at peak
        easing: 'cubic',     // Animation curve type
        strength: 1.0,       // Effect intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'burst',
            strength: 1.0,   // Burst force intensity
            decay: 0.3       // Force reduction rate
        }
    },
    
    // Rhythm configuration - flash on beats and accents
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Flash on beats
        timingSync: 'immediate',    // Flash immediately (for impact)
        interruptible: true,         // Can interrupt
        priority: 8,                 // High priority
        blendable: true,             // Can layer over other effects
        
        // Flash intensity syncs to beat strength
        intensitySync: {
            onBeat: 3.5,              // Bright flash on beat
            offBeat: 1.0,             // Dim between beats
            accent: 5.0,              // Blinding on accent
            subdivision: 'quarter',    // Flash every quarter note
            curve: 'exponential'      // Sharp flash attack
        },
        
        // Duration varies with tempo
        durationSync: {
            mode: 'tempo',
            baseDuration: 400,        // Base at 120 BPM
            scaling: 'inverse'        // Faster tempo = shorter flash
        },
        
        // Scale pulse with flash
        scaleSync: {
            onBeat: 1.2,              // Expand on beat
            offBeat: 1.0,             // Normal size off beat
            accent: 1.4,              // Big expansion on accent
            curve: 'elastic'          // Bouncy scale
        },
        
        // Strobe patterns
        strobeSync: {
            enabled: false,           // Enable for strobe effect
            pattern: 'XXOX',          // X=flash, O=dark
            subdivision: 'sixteenth'  // Strobe rate
        },
        
        // Musical dynamics
        dynamics: {
            forte: { glowPeak: 4.0, scalePeak: 1.3, duration: 300 },
            piano: { glowPeak: 2.0, scalePeak: 1.05, duration: 500 }
        }
    },
    
    initialize(particle, _motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.flash = {
            originalOpacity: particle.opacity,
            originalSize: particle.size,
            initialized: true
        };
    },
    
    /**
     * Apply flash effect to particle
     * Creates bright burst with size expansion and outward motion
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.flash?.initialized) {
            this.initialize(particle, motion);
        }
        
        const data = particle.gestureData.flash;
        const config = { ...this.config, ...motion };
        const strength = config.strength || 1.0;
        
        // Calculate flash intensity curve
        let flashIntensity;
        if (progress < 0.3) {
            // Quick rise to peak brightness
            flashIntensity = (progress / 0.3) * config.glowPeak;
        } else {
            // Gradual fade from peak
            flashIntensity = config.glowPeak * (1 - (progress - 0.3) / 0.7);
        }
        
        // Apply brightness and size changes
        particle.opacity = Math.min(1, data.originalOpacity * (1 + flashIntensity * strength));
        particle.size = data.originalSize * (1 + (config.scalePeak - 1) * flashIntensity * strength * 0.1);
        
        // Initial burst motion - particles briefly explode outward
        if (progress < 0.2) {
            const burstStrength = (1 - progress / 0.2) * strength;
            const angle = Math.atan2(particle.y - centerY, particle.x - centerX);
            particle.vx += Math.cos(angle) * burstStrength * 2 * dt;
            particle.vy += Math.sin(angle) * burstStrength * 2 * dt;
        }

        // Apply velocity decay for natural deceleration
        particle.vx *= (1 - config.particleMotion.decay * 0.1);
        particle.vy *= (1 - config.particleMotion.decay * 0.1);
    },
    
    cleanup(particle) {
        if (particle.gestureData?.flash) {
            particle.opacity = particle.gestureData.flash.originalOpacity;
            particle.size = particle.gestureData.flash.originalSize;
            delete particle.gestureData.flash;
        }
    },

    /**
     * 3D core transformation for flash gesture
     * Quick glowIntensity spike with brief scale pulse
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation { position: [x,y,z], rotation: [x,y,z], scale: number, glowIntensity: number, glowBoost: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };
            motion.strength || 1.0;

            // Quick flash intensity spike then fade (normalized to ±40% max)
            const normalizedGlowPeak = 0.4; // Max 40% brighter
            let flashValue;
            if (progress < 0.3) {
                // Quick rise to peak (0 to 1)
                flashValue = progress / 0.3;
            } else {
                // Gradual fade (1 back to 0)
                flashValue = 1 - (progress - 0.3) / 0.7;
            }

            const glowIntensity = 1.0 + flashValue * normalizedGlowPeak;

            // Brief scale pulse
            const scalePeak = config.scalePeak || 1.1;
            const scale = 1.0 + flashValue * (scalePeak - 1.0);

            // Glow boost for isolated screen-space halo effect
            // Flash gets an even stronger boost (2.0) for maximum impact
            const glowBoost = flashValue * 2.0;

            return {
                position: [0, 0, 0],
                rotation: [0, 0, 0],
                scale,
                glowIntensity,
                glowBoost
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Glow Gesture
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Glow gesture - based on pulse but focused on luminosity without movement
 * @author Emotive Engine Team
 * @module gestures/effects/glow
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a pure luminous glow effect without particle movement.
 * ║ This is a BLENDING gesture that only modifies brightness/glow.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *      Dim            Bright           Dim
 *    · · · ·         ✨ ✨ ✨         · · · ·
 *    · · ⭐ · ·   →  ✨ 🌟 ✨    →   · · ⭐ · ·
 *    · · · ·         ✨ ✨ ✨         · · · ·
 *
 * USED BY:
 * - Emphasis effects
 * - Magic/mystical states
 * - Energy charging
 */

/**
 * Glow gesture configuration and implementation
 */
var glow = {
    name: 'glow',
    emoji: '✨',
    type: 'blending', // Adds to existing motion
    description: 'Pure luminous glow without movement',

    // Default configuration
    config: {
        duration: 1500,      // Animation duration (longer than pulse for sustained glow)
        amplitude: 0,        // NO expansion distance (removed from pulse)
        frequency: 1,        // Number of glow pulses
        holdPeak: 0.3,       // Peak glow hold time (longer for sustained effect)
        easing: 'sine',      // Animation curve type
        scaleAmount: 0.1,    // Very subtle orb scale variation (reduced from pulse)
        glowAmount: 0.8,     // Strong orb glow intensity change (increased from pulse)
        strength: 0,         // NO particle motion strength (removed from pulse)
        direction: 'none',   // No movement direction
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'glow',
            strength: 0,     // No particle movement
            direction: 'none',
            frequency: 1
        }
    },

    // Rhythm configuration - glow pulses with musical phrases
    rhythm: {
        enabled: true,
        syncMode: 'phrase',  // Glow on musical phrases

        // Glow strength syncs to dynamics
        amplitudeSync: {
            onBeat: 2.0,      // Strong glow on beat
            offBeat: 1.2,     // Sustained glow off beat
            curve: 'smooth'   // Smooth transitions
        },

        // Frequency locks to phrase length
        frequencySync: {
            mode: 'phrase',
            subdivision: 'bar'
        },

        // Duration in musical time
        durationSync: {
            mode: 'bars',
            bars: 2           // Glow over 2 bars
        },

        // Stronger glow on accents
        accentResponse: {
            enabled: true,
            multiplier: 2.5   // Bright glow on accent
        },

        // Pattern-specific glow styles
        patternOverrides: {
            'ambient': {
                // Ethereal sustained glow
                amplitudeSync: { onBeat: 2.5, offBeat: 1.8 },
                durationSync: { bars: 4 }
            },
            'electronic': {
                // Pulsing neon glow
                amplitudeSync: { onBeat: 3.0, offBeat: 0.5, curve: 'sharp' },
                frequencySync: { subdivision: 'quarter' }
            }
        }
    },

    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, _motion, _centerX, _centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }

        // Store initial state (no position data needed for glow)
        particle.gestureData.glow = {
            startOpacity: particle.opacity,
            startGlow: particle.glowSizeMultiplier || 0,
            initialized: true
        };
    },

    /**
     * Apply glow effect to particle (no motion, just luminosity)
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.glow?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }


        const config = { ...this.config, ...motion };

        // Apply easing
        const easeProgress = this.easeInOutSine(progress);

        // Calculate glow pulse with peak hold
        let glowValue;
        let {frequency} = config;
        let {glowAmount} = config;

        // Apply rhythm modulation if present
        if (motion.rhythmModulation) {
            glowAmount *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            glowAmount *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }

        const rawPulse = (easeProgress * frequency * 2) % 2;

        if (config.holdPeak > 0 && rawPulse > (1 - config.holdPeak) && rawPulse < (1 + config.holdPeak)) {
            // Hold at peak glow
            glowValue = 1;
        } else {
            // Normal sine wave for glow
            glowValue = Math.sin(easeProgress * Math.PI * 2 * frequency);
        }

        // NO PARTICLE MOVEMENT - just glow effects
        // Unlike pulse, we don't calculate target positions or apply velocity

        // Apply glow fade effect at the end
        let glowMultiplier = 1;
        if (progress > 0.9) {
            const fadeFactor = 1 - ((progress - 0.9) * 10);
            glowMultiplier = (0.5 + fadeFactor * 0.5);
        }

        // Modify particle glow properties (if your system supports it)
        // This is where the actual glow effect happens
        // Note: The actual visual implementation depends on your renderer
        // Set glow intensity directly, don't multiply to prevent accumulation
        particle.glowIntensity = 1 + glowValue * glowAmount * glowMultiplier;
    },

    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.glow) {
            // Reset any glow properties
            particle.glowIntensity = 1;
            delete particle.gestureData.glow;
        }
    },

    /**
     * Sine easing for smooth glow transitions
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutSine(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
    },

    /**
     * 3D core transformation for glow gesture
     * GlowIntensity increase without movement
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation { position: [x,y,z], rotation: [x,y,z], scale: number, glowIntensity: number, glowBoost: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };
            const easeProgress = -(Math.cos(Math.PI * progress) - 1) / 2;

            // Calculate glow pulse - single rise and fall (not oscillating)
            // Use sin(progress * π) to go: 0 → 1 → 0 (single pulse)
            const glowValue = Math.sin(easeProgress * Math.PI);
            let glowAmount = config.glowAmount || 0.8;

            // Apply rhythm modulation if present
            if (motion.rhythmModulation) {
                glowAmount *= (motion.rhythmModulation.amplitudeMultiplier || 1);
                glowAmount *= (motion.rhythmModulation.accentMultiplier || 1);
            }

            // Glow adds brightness (doesn't go negative)
            // Maps 0→1→0 to 0%→+80%→0% intensity increase
            const glowIntensity = 1.0 + (glowValue * glowAmount);

            // Very subtle scale
            const scaleAmount = config.scaleAmount || 0.1;
            const scale = 1.0 + glowValue * scaleAmount * 0.5;

            // Glow boost for isolated screen-space halo effect
            // Peaks at 1.5 intensity for a dramatic, visible halo
            const glowBoost = glowValue * 1.5;

            return {
                position: [0, 0, 0],
                rotation: [0, 0, 0],
                scale,
                glowIntensity,
                glowBoost
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Peek Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Quick peek/hide motion for suspicious checking behavior
 * @author Emotive Engine Team
 * @module gestures/effects/peek
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 * 
 * GESTURE TYPE:
 * type: 'effect' - Visual effect without changing core position
 * 
 * VISUAL EFFECT:
 * Particles quickly expand outward (peeking) then contract back (hiding),
 * like peeking around a corner or quickly checking surroundings.
 */

var peek = {
    name: 'peek',
    emoji: '👀',
    type: 'effect',
    description: 'Quick peek and hide motion',
    
    // Default configuration
    config: {
        peekDistance: 40,       // How far to peek out
        peekSpeed: 0.15,        // Speed of peek motion
        holdDuration: 200,      // How long to hold peek position (ms)
        hideSpeed: 0.25,        // Speed of hiding (faster than peeking)
        stagger: true,          // Stagger particle peeks
        duration: 1500          // Total animation duration
    },
    
    // Rhythm configuration - quick glimpse movements synchronized to rhythmic accents
    rhythm: {
        enabled: true,
        syncMode: 'accent',  // Peek on rhythmic accents and syncopation
        
        // Peek distance responds to accent strength
        distanceSync: {
            onAccent: 60,         // Far peek on accents
            offAccent: 25,        // Short peek off-accent
            curve: 'quick'        // Sharp, sudden movement
        },
        
        // Speed adapts to musical tempo
        speedSync: {
            mode: 'tempo',
            fast: 0.25,           // Quick peeks for fast music
            slow: 0.10,           // Slower peeks for slow music
            hideMultiplier: 1.8   // Hide speed relative to peek speed
        },
        
        // Duration matches rhythmic subdivisions
        durationSync: {
            mode: 'subdivision',
            beats: 0.25,          // Quarter-beat peek duration
            staggerBeats: 0.125,  // Eighth-beat stagger delay
            sustain: false        // No sustain, quick action
        },
        
        // Strong response to syncopated rhythms
        syncopationResponse: {
            enabled: true,
            multiplier: 1.8,      // More dramatic peek on syncopation
            type: 'distance'      // Affects peek distance
        },
        
        // Style variations for different music types
        patternOverrides: {
            'funk': {
                // Sharp, syncopated peeks
                distanceSync: { onAccent: 70, offAccent: 35, curve: 'funky' },
                syncopationResponse: { multiplier: 2.2 }
            },
            'latin': {
                // Rhythmic, dance-like peeks
                speedSync: { fast: 0.30, slow: 0.12 },
                durationSync: { beats: 0.5, staggerBeats: 0.25 }
            },
            'breakbeat': {
                // Erratic, complex peek patterns
                distanceSync: { onAccent: 55, offAccent: 40 },
                syncopationResponse: { multiplier: 2.5 }
            },
            'classical': {
                // Subtle, expressive peeks
                distanceSync: { onAccent: 45, offAccent: 20, curve: 'elegant' },
                speedSync: { fast: 0.18, slow: 0.08 }
            }
        },
        
        // Musical dynamics
        dynamics: {
            forte: {
                // Bold, assertive peeks
                distanceSync: { 
                    onAccent: { multiplier: 1.6 },
                    offAccent: { multiplier: 1.3 }
                },
                speedSync: { multiplier: 1.4 },
                syncopationResponse: { multiplier: 2.8 }
            },
            piano: {
                // Cautious, subtle peeks
                distanceSync: { 
                    onAccent: { multiplier: 0.6 },
                    offAccent: { multiplier: 0.4 }
                },
                speedSync: { multiplier: 0.7 },
                syncopationResponse: { multiplier: 1.2 }
            }
        }
    },
    
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize peek data if needed
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        if (!particle.gestureData.peek) {
            const dx = particle.x - centerX;
            const dy = particle.y - centerY;
            const angle = Math.atan2(dy, dx);
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            particle.gestureData.peek = {
                originalX: particle.x,
                originalY: particle.y,
                peekAngle: angle,
                originalDistance: distance,
                staggerDelay: this.config.stagger ? Math.random() * 0.3 : 0,
                phase: 'waiting',  // 'waiting', 'peeking', 'holding', 'hiding'
                phaseTimer: 0,
                peekOffset: { x: 0, y: 0 }
            };
        }
        
        const data = particle.gestureData.peek;
        const {config} = this;
        
        // Adjust progress for stagger
        const adjustedProgress = Math.max(0, Math.min(1, (progress - data.staggerDelay) / (1 - data.staggerDelay)));
        
        // Determine phase based on progress
        if (adjustedProgress === 0) {
            data.phase = 'waiting';
        } else if (adjustedProgress < 0.3) {
            data.phase = 'peeking';
        } else if (adjustedProgress < 0.6) {
            data.phase = 'holding';
        } else if (adjustedProgress < 1) {
            data.phase = 'hiding';
        }
        
        // Calculate peek offset based on phase
        let targetOffset = 0;
        
        switch (data.phase) {
        case 'peeking': {
            // Smooth peek out
            const peekProgress = adjustedProgress / 0.3;
            targetOffset = this.easeOutCubic(peekProgress) * config.peekDistance;
            break;
        }
                
        case 'holding':
            // Hold at peek position
            targetOffset = config.peekDistance;
            // Add slight tremor while holding
            if (Math.random() < 0.1) {
                data.peekOffset.x += (Math.random() - 0.5) * 2;
                data.peekOffset.y += (Math.random() - 0.5) * 2;
            }
            break;
                
        case 'hiding': {
            // Quick hide back
            const hideProgress = (adjustedProgress - 0.6) / 0.4;
            targetOffset = (1 - this.easeInCubic(hideProgress)) * config.peekDistance;
            break;
        }
        }
        
        // Apply the peek offset
        if (data.phase !== 'waiting') {
            const peekX = Math.cos(data.peekAngle) * targetOffset;
            const peekY = Math.sin(data.peekAngle) * targetOffset;
            
            // Smooth transition to target position
            data.peekOffset.x += (peekX - data.peekOffset.x) * config.peekSpeed;
            data.peekOffset.y += (peekY - data.peekOffset.y) * config.peekSpeed;
            
            // Apply offset to particle
            particle.x = data.originalX + data.peekOffset.x;
            particle.y = data.originalY + data.peekOffset.y;
        }
        
        // Add opacity effect - slightly fade during peek
        if (particle.alpha !== undefined) {
            if (data.phase === 'peeking' || data.phase === 'holding') {
                particle.alpha = 0.7 + Math.random() * 0.3;  // Flickering visibility
            } else {
                particle.alpha = 1.0;
            }
        }
    },
    
    // Easing functions
    easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    },
    
    easeInCubic(t) {
        return t * t * t;
    },
    
    cleanup(particle) {
        if (particle.gestureData?.peek) {
            // Restore original position
            particle.x = particle.gestureData.peek.originalX;
            particle.y = particle.gestureData.peek.originalY;
            if (particle.alpha !== undefined) {
                particle.alpha = 1.0;
            }
            delete particle.gestureData.peek;
        }
    },

    /**
     * 3D core transformation for peek gesture
     * Quick XY position shift then return
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation { position: [x,y,z], rotation: [x,y,z], scale: number, glowIntensity: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };
            const peekDistance = (config.peekDistance || 40) * 0.01; // Scale to unit space

            let posX = 0;
            const posY = 0;
            let glowIntensity = 1.0;

            if (progress < 0.3) {
                // Peeking out
                const peekProgress = progress / 0.3;
                const eased = 1 - Math.pow(1 - peekProgress, 3); // easeOutCubic
                posX = eased * peekDistance;
            } else if (progress < 0.6) {
                // Holding peek
                posX = peekDistance;
                glowIntensity = 0.7 + Math.random() * 0.3; // Flickering
            } else {
                // Hiding back
                const hideProgress = (progress - 0.6) / 0.4;
                const eased = Math.pow(hideProgress, 3); // easeInCubic
                posX = (1 - eased) * peekDistance;
            }

            return {
                position: [posX, posY, 0],
                rotation: [0, 0, 0],
                scale: 1.0,
                glowIntensity
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Running Man Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Running Man gesture - hip-hop shuffle dance move
 * @author Emotive Engine Team
 * @module gestures/effects/runningman
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 */

var runningman = {
    name: 'runningman',
    emoji: '🏃',
    type: 'effect',
    description: 'Hip-hop running man shuffle',
    
    // Default configuration
    config: {
        duration: 2000,        // Animation duration
        slideDistance: 30,     // Horizontal slide distance
        stepHeight: 15,        // Vertical step height
        speed: 1.2,            // Animation speed multiplier
        strength: 0.8,         // Overall effect intensity
        // Particle motion configuration
        particleMotion: {
            type: 'runningman',
            strength: 0.7
        }
    },
    
    // Rhythm configuration - synchronized to beat
    rhythm: {
        enabled: true,
        syncToBeat: true,      // Snap to beat grid
        beatMultiplier: 1,     // Steps per beat
        accentBeats: [1, 3]    // Emphasized steps
    },
    
    /**
     * Apply running man motion - handled by GestureAnimator
     * This is a placeholder for the gesture system
     */
    apply(_particle, _progress, _motion, _dt, _centerX, _centerY) {
        // Motion is handled by GestureAnimator.applyRunningMan()
        return false;
    },
    
    /**
     * Blend with existing motion
     */
    blend(_particle, _progress, _motion) {
        // Allow blending with other gestures
        return false;
    },

    /**
     * 3D core transformation for running man gesture
     * Smooth jogging motion with rhythmic bounce
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation { position: [x,y,z], rotation: [x,y,z], scale: number, glowIntensity: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };
            const strength = config.strength || 0.8;

            // Match 2D: Running man - quick slide and step
            // 2D uses: slide = sin(progress * PI * 4) * 20, step = -|sin(progress * PI * 8)| * 10
            // Scale down for 3D normalized coordinates

            const slide = Math.sin(progress * Math.PI * 4) * 0.10 * strength;
            const step = Math.abs(Math.sin(progress * Math.PI * 8)) * 0.05 * strength;

            // Very subtle Z rotation - just a hint of tilt (~2 degrees = 0.035 radians)
            const rotationZ = Math.sin(progress * Math.PI * 4) * 0.035 * strength;

            // Scale squash on step (2D uses scaleY)
            const scale = 1 - Math.abs(Math.sin(progress * Math.PI * 8)) * 0.035 * strength;

            // Glow on step
            const glowIntensity = 1.0 + Math.abs(Math.sin(progress * Math.PI * 8)) * 0.25;
            const glowBoost = Math.max(0, Math.abs(Math.sin(progress * Math.PI * 8))) * 0.35;

            return {
                position: [slide, step, 0],  // Screen-space: X = slide, Y = step up
                rotation: [0, 0, rotationZ],  // Z rotation = screen tilt
                scale,
                glowIntensity,
                glowBoost
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Charleston Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Charleston gesture - classic hip-hop shuffle with modern twist
 * @author Emotive Engine Team
 * @module gestures/effects/charleston
 * @complexity ⭐⭐ Intermediate
 * @audience Good examples for creating custom gesture effects
 */

var charleston = {
    name: 'charleston',
    emoji: '🕺',
    type: 'effect',
    description: 'Hip-hop Charleston shuffle with crisscross',
    
    // Default configuration
    config: {
        duration: 2500,        // Animation duration
        kickDistance: 35,      // Kick extension distance
        swivelRange: 40,       // Hip swivel range
        bounceHeight: 12,      // Vertical bounce
        strength: 0.9,         // Overall effect intensity
        // Particle motion configuration
        particleMotion: {
            type: 'charleston',
            strength: 0.8
        }
    },
    
    // Rhythm configuration - tight sync with beat
    rhythm: {
        enabled: true,
        syncToBeat: true,      // Lock to beat grid
        beatMultiplier: 2,     // Double-time feel
        accentBeats: [1, 2.5, 3, 4.5]  // Syncopated accents
    },
    
    /**
     * Apply charleston motion - handled by GestureAnimator
     * This is a placeholder for the gesture system
     */
    apply(_particle, _progress, _motion, _dt, _centerX, _centerY) {
        // Motion is handled by GestureAnimator.applyCharleston()
        return false;
    },
    
    /**
     * Blend with existing motion
     */
    blend(_particle, _progress, _motion) {
        // Allow blending with other gestures
        return false;
    },

    /**
     * 3D core transformation for charleston gesture
     * Smooth dance move with gentle swaying and bounce
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @returns {Object} 3D transformation { position: [x,y,z], rotation: [x,y,z], scale: number, glowIntensity: number }
     */
    '3d': {
        evaluate(progress, motion) {
            const config = { ...this.config, ...motion };
            const strength = config.strength || 0.9;

            // Match 2D: Charleston - crisscross kicks with hop
            // 2D uses: kick = sin(progress * PI * 8) * 25, hop = -|sin(progress * PI * 8)| * 10
            // Scale down for 3D normalized coordinates (divide by ~200 for screen-to-world)

            const kick = Math.sin(progress * Math.PI * 8) * 0.12 * strength;
            const hop = Math.abs(Math.sin(progress * Math.PI * 8)) * 0.05 * strength;

            // Very subtle Z rotation - just a hint of tilt (~3 degrees = 0.05 radians)
            const rotationZ = Math.sin(progress * Math.PI * 8) * 0.05 * strength;

            // Scale squash on hop (2D uses scaleY, we use uniform scale)
            const scale = 1 - Math.abs(Math.sin(progress * Math.PI * 8)) * 0.04 * strength;

            // Glow on kick peaks
            const glowIntensity = 1.0 + Math.abs(Math.sin(progress * Math.PI * 8)) * 0.3;
            const glowBoost = Math.max(0, Math.abs(Math.sin(progress * Math.PI * 8))) * 0.4;

            return {
                position: [kick, hop, 0],  // Screen-space: X = left/right, Y = up/down
                rotation: [0, 0, rotationZ],  // Z rotation = screen tilt
                scale,
                glowIntensity,
                glowBoost
            };
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Gesture Registry
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Central registry for all gesture animations with plugin support
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module gestures
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Control center for all gestures with full plugin adapter integration.             
 * ║ • Three gesture types: blending (motions), override (transforms), effects        
 * ║ • Core gestures loaded synchronously at startup                                   
 * ║ • Plugin gestures registered dynamically via adapter                              
 * ║ • Value-agnostic configurations for easy tuning                                   
 * ║                                                                                    
 * ║ TO ADD A PLUGIN GESTURE:                                                          
 * ║ Use pluginAdapter.registerPluginGesture() from your plugin                        
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ PLACEHOLDER GESTURES FOR NEW ANIMATIONS
// └─────────────────────────────────────────────────────────────────────────────────────
// These are handled by GestureAnimator but need registry entries for rhythm system
const createPlaceholderGesture = (name, emoji = '✨') => ({
    name,
    emoji,
    type: 'blending', // Use blending type so they don't interfere
    description: `${name} animation`,
    config: {
        duration: 1000, // Legacy fallback only
        musicalDuration: { musical: true, beats: 2 } // Default: 2 beats
    },
    rhythm: {
        enabled: true,
        syncMode: 'beat',
        timingSync: 'nextBeat',
        durationSync: { mode: 'beats', beats: 2 }, // Musical duration
        interruptible: true,
        priority: 3,
        blendable: true,
        crossfadePoint: 'anyBeat',
        maxQueue: 3
    },
    apply: (_particle, _progress, _params) => {
        // No-op - handled by GestureAnimator
        return false;
    },
    blend: (_particle, _progress, _params) => {
        // No-op - handled by GestureAnimator
        return false;
    }
});

// Sparkle gesture - bright twinkling bursts of light
const sparkle = {
    name: 'sparkle',
    emoji: '✨',
    type: 'blending',
    description: 'Bright twinkling sparkle bursts',
    config: {
        duration: 800,
        musicalDuration: { musical: true, beats: 2 }
    },
    rhythm: {
        enabled: true,
        syncMode: 'beat',
        timingSync: 'nextBeat',
        durationSync: { mode: 'beats', beats: 2 },
        interruptible: true,
        priority: 5,
        blendable: true
    },
    apply: (_particle, _progress, _params) => false,
    blend: (_particle, _progress, _params) => false,
    '3d': {
        evaluate(progress, motion) {
            const strength = motion?.strength || 1.0;

            // Create rapid sparkle bursts - multiple quick flashes
            // Use high-frequency sine waves with sharp peaks
            const sparkle1 = Math.pow(Math.max(0, Math.sin(progress * Math.PI * 6)), 3);
            const sparkle2 = Math.pow(Math.max(0, Math.sin(progress * Math.PI * 8 + 1)), 3);
            const sparkle3 = Math.pow(Math.max(0, Math.sin(progress * Math.PI * 10 + 2)), 3);

            // Combine for twinkling effect - peaks are sharp and bright
            const sparkleValue = Math.max(sparkle1, sparkle2, sparkle3);

            // Envelope to fade in/out
            const envelope = Math.sin(progress * Math.PI);

            // Final sparkle intensity
            const finalSparkle = sparkleValue * envelope;

            // Strong glow pulse
            const glowIntensity = 1.0 + finalSparkle * 0.5 * strength;

            // Very strong glow boost for dramatic sparkle halo
            const glowBoost = finalSparkle * 2.0 * strength;

            // Tiny scale pulse on sparkle peaks
            const scale = 1.0 + finalSparkle * 0.08 * strength;

            return {
                position: [0, 0, 0],
                rotation: [0, 0, 0],
                scale,
                glowIntensity,
                glowBoost
            };
        }
    }
};

// Shimmer gesture - makes particles shimmer with wave effect
const shimmer = {
    name: 'shimmer',
    emoji: '🌟',
    type: 'particle',  // Particle type to affect particle behavior
    description: 'Shimmer effect with sparkling particles',
    config: {
        duration: 2000,  // Legacy fallback
        musicalDuration: { musical: true, bars: 1 }, // 1 bar (4 beats)
        particleMotion: 'radiant'  // Use radiant behavior for shimmering effect
    },
    rhythm: {
        enabled: true,
        syncType: 'beat',
        durationSync: { mode: 'bars', bars: 1 }, // Musical: 1 bar
        intensity: 0.8
    },
    override: (particle, progress, _params) => {
        // Shimmer makes particles sparkle with wave effect
        particle.shimmerEffect = true;
        particle.shimmerProgress = progress;
        return true;
    },
    blend: (_particle, _progress, _params) => {
        // Blend with other gestures
        return false;
    },
    '3d': {
        evaluate(progress, motion) {
            const strength = motion?.strength || 1.0;

            // Create shimmering wave effect - multiple overlapping sine waves
            const wave1 = Math.sin(progress * Math.PI * 4);
            const wave2 = Math.sin(progress * Math.PI * 6 + 0.5);
            const wave3 = Math.sin(progress * Math.PI * 10 + 1.0);

            // Combine waves for sparkling effect
            const shimmerValue = (wave1 * 0.4 + wave2 * 0.35 + wave3 * 0.25 + 1) / 2; // 0 to 1

            // Glow pulses with shimmer
            const glowIntensity = 1.0 + shimmerValue * 0.3 * strength;

            // Glow boost for screen-space halo - sparkles!
            const glowBoost = shimmerValue * 1.0 * strength;

            return {
                position: [0, 0, 0],
                rotation: [0, 0, 0],
                scale: 1.0 + shimmerValue * 0.05 * strength,
                glowIntensity,
                glowBoost
            };
        }
    }
};
const groove = createPlaceholderGesture('groove', '🎵');

// Rain gesture - applies doppler effect to particles
const rain = {
    name: 'rain',
    emoji: '🌧️',
    type: 'particle',  // Particle type to affect particle behavior
    description: 'Rain effect with falling particles',
    config: {
        duration: 3000,  // Legacy fallback
        musicalDuration: { musical: true, bars: 2 }, // 2 bars (8 beats)
        particleMotion: 'falling'  // Use the falling particle behavior
    },
    rhythm: {
        enabled: true,
        syncType: 'off-beat',
        durationSync: { mode: 'bars', bars: 2 }, // Musical: 2 bars
        intensity: 0.8
    },
    apply: (particle, progress, _params) => {
        // The doppler behavior is handled by the particle system
        // This just marks particles as being affected by rain
        particle.rainEffect = true;
        particle.rainProgress = progress;
        return true;
    },
    blend: (_particle, _progress, _params) => {
        // Blend with other gestures
        return false;
    }
};

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ GESTURE COLLECTIONS
// └─────────────────────────────────────────────────────────────────────────────────────
const MOTION_GESTURES = [
    bounce,
    pulse,
    shake,
    nod,
    vibrate,
    orbit,
    twitch,
    sway,
    float,
    jitter,
    // New gestures
    sparkle,
    shimmer,
    wiggle,
    groove,
    point,
    lean,
    reach,
    headBob,
    rain
];

const TRANSFORM_GESTURES = [
    spin,
    jump,
    morph,
    stretch,
    tilt,
    orbital,
    hula,
    twist
];

const EFFECT_GESTURES = [
    wave,
    drift,
    flicker,
    burst$1,
    directional,
    settle,
    fade,
    hold,
    breathe,
    expand,
    contract,
    flash,
    glow,
    peek,
    runningman,
    charleston
];

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ GESTURE REGISTRY - Fast lookup by name
// └─────────────────────────────────────────────────────────────────────────────────────
const GESTURE_REGISTRY = {};

// Build the registry from all gesture arrays - SYNCHRONOUSLY
[...MOTION_GESTURES, ...TRANSFORM_GESTURES, ...EFFECT_GESTURES].forEach(gesture => {
    GESTURE_REGISTRY[gesture.name] = gesture;
});

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ GESTURE TYPE MAPPING - Quick type lookup
// └─────────────────────────────────────────────────────────────────────────────────────
({
    blending: MOTION_GESTURES.map(g => g.name),
    override: TRANSFORM_GESTURES.map(g => g.name),
    effect: EFFECT_GESTURES.map(g => g.name)
});

/**
 * Get a gesture by name (checks both core and plugin gestures)
 * @param {string} name - Gesture name (e.g., 'bounce', 'spin')
 * @returns {Object|null} Gesture object or null if not found
 */
function getGesture(name) {
    // Check core gestures first
    if (GESTURE_REGISTRY[name]) {
        return GESTURE_REGISTRY[name];
    }
    
    // Check plugin gestures
    const pluginGesture = pluginAdapter$1.getPluginGesture(name);
    if (pluginGesture) {
        return pluginGesture;
    }
    
    return null;
}

/**
 * Check if a gesture is an override type
 * @param {string} name - Gesture name
 * @returns {boolean} True if gesture overrides existing motion
 */
function isOverrideGesture(name) {
    const gesture = getGesture(name);
    return gesture ? gesture.type === 'override' : false;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ◐ ◑ ◒ ◓  UNDERTONE MODIFIERS  ◓ ◒ ◑ ◐                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Undertone Modifiers - Subtle Emotion Variations
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module UndertoneModifiers
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Undertones add NUANCE to emotions - like being "nervously happy" or              
 * ║ "confidently angry". These modifiers STACK on top of emotion modifiers            
 * ║ to create more complex, realistic emotional expressions.                          
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎨 MULTIPLIER EFFECTS (Applied to Base Gesture)                                   
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • speed        : Animation speed (0.5=half speed, 2.0=double speed)               
 * │ • amplitude    : Movement size (0.5=smaller, 2.0=bigger)                          
 * │ • intensity    : Effect strength (0.5=subtle, 2.0=extreme)                        
 * │ • smoothness   : Animation smoothing (0.5=jerky, 1.5=very smooth)                 
 * │ • regularity   : Pattern consistency (0.5=chaotic, 1.0=regular)                   
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚡ SPECIAL EFFECTS (Boolean Flags)                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • addFlutter      : Butterfly-like motion (nervous)                               
 * │ • addMicroShake   : Tiny trembling (nervous, tired)                               
 * │ • addPower        : Strong, decisive motion (confident)                           
 * │ • addDrag         : Sluggish, heavy motion (tired)                                
 * │ • addTension      : Tight, controlled motion (intense)                            
 * │ • addSoftness     : Gentle, flowing motion (subdued)                              
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ❌ DO NOT ADD HERE (Belongs in Other Files)                                       
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ ✗ Base gesture definitions   → use gestureConfig.js                              
 * │ ✗ Emotion modifiers         → use emotionModifiers.js                            
 * │ ✗ Visual properties         → use emotionMap.js                                  
 * │ ✗ Particle behaviors        → use Particle.js                                    
 * │ ✗ State logic              → use EmotiveStateMachine.js                          
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                           ADDING NEW UNDERTONES                                   
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ 1. Create new undertone object with all base multipliers (default to 1.0)         
 * ║ 2. Add special effect flags as needed (addXXX properties)                         
 * ║ 3. Test combinations with ALL emotions for unexpected interactions                
 * ║ 4. Document the intended "feel" and use cases                                     
 * ║ 5. Add to valid undertones in ErrorBoundary.js                                    
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

const UNDERTONE_MODIFIERS = {
    // No undertone - neutral multipliers
    none: {
        speed: 1.0,
        amplitude: 1.0,
        intensity: 1.0,
        smoothness: 1.0,
        regularity: 1.0,
        '3d': {
            rotation: { speedMultiplier: 1.0, shakeMultiplier: 1.0 },
            glow: { intensityMultiplier: 1.0, pulseSpeedMultiplier: 1.0 },
            scale: { breathDepthMultiplier: 1.0, breathRateMultiplier: 1.0 },
            righting: { strengthMultiplier: 1.0 }
        }
    },

    // Clear undertone - no modification
    clear: {
        speed: 1.0,
        amplitude: 1.0,
        intensity: 1.0,
        smoothness: 1.0,
        regularity: 1.0,
        '3d': {
            rotation: { speedMultiplier: 1.0, shakeMultiplier: 1.0 },
            glow: { intensityMultiplier: 1.0, pulseSpeedMultiplier: 1.0 },
            scale: { breathDepthMultiplier: 1.0, breathRateMultiplier: 1.0 },
            righting: { strengthMultiplier: 1.0 }
        }
    },
    
    nervous: {
        speed: 1.2,        // 20% faster
        amplitude: 0.9,    // 10% smaller (contained)
        intensity: 1.1,    // 10% more intense
        smoothness: 0.7,   // 30% less smooth (fluttery)
        regularity: 0.6,   // Irregular (butterflies)
        addFlutter: true,  // Butterfly-like flutter
        addMicroShake: true, // Subtle tremor
        '3d': {
            rotation: {
                speedMultiplier: 1.5,      // Noticeably faster rotation (anxious energy)
                shakeMultiplier: 3.5,      // Very visible shake/wobble (nervous tremor)
                enableEpisodicWobble: true // Random shake bursts (at least once per rotation)
            },
            glow: {
                intensityMultiplier: 1.25, // Brighter (heightened state)
                pulseSpeedMultiplier: 2.0  // Rapid pulsing (racing heartbeat)
            },
            scale: {
                breathDepthMultiplier: 0.5, // Very shallow rapid breaths
                breathRateMultiplier: 1.8   // Much faster breathing (panic)
            },
            righting: {
                strengthMultiplier: 0.7    // Less stable (nervous wobble)
            }
        }
    },
    
    confident: {
        speed: 0.9,        // 10% slower (deliberate)
        amplitude: 1.3,    // 30% bigger (bold)
        intensity: 1.2,    // 20% more intense
        smoothness: 1.1,   // 10% smoother (controlled)
        regularity: 1.2,   // Very regular (assured)
        addPower: true,    // Strong, decisive motion
        addHold: true,     // Brief pause at peaks
        '3d': {
            rotation: {
                speedMultiplier: 0.7,      // Much slower, commanding presence
                shakeMultiplier: 0.2       // Minimal shake (rock solid control)
            },
            glow: {
                intensityMultiplier: 1.4,  // Noticeably brighter (bold presence)
                pulseSpeedMultiplier: 0.7  // Slow steady pulse (calm confidence)
            },
            scale: {
                breathDepthMultiplier: 1.5, // Deep powerful breaths
                breathRateMultiplier: 0.7   // Slow breathing (total control)
            },
            righting: {
                strengthMultiplier: 1.6    // Very stable (immovable)
            }
        }
    },
    
    tired: {
        speed: 0.7,        // 30% slower
        amplitude: 0.7,    // 30% smaller
        intensity: 0.8,    // 20% less intense
        smoothness: 1.3,   // 30% smoother (sluggish)
        regularity: 0.8,   // Slightly irregular (drowsy)
        addDroop: true,    // Downward tendency
        addPause: true,    // Occasional hesitation
        '3d': {
            rotation: {
                speedMultiplier: 0.4,      // Very slow rotation (lethargic)
                shakeMultiplier: 0.15      // Almost no shake (exhausted)
            },
            glow: {
                intensityMultiplier: 0.5,  // Noticeably dimmer (low energy)
                pulseSpeedMultiplier: 0.5  // Very slow pulse (drowsy)
            },
            scale: {
                breathDepthMultiplier: 1.3, // Deep tired sighs
                breathRateMultiplier: 0.5   // Very slow breathing (sleepy)
            },
            righting: {
                strengthMultiplier: 0.6    // Unstable (drooping, sagging)
            }
        }
    },
    
    intense: {
        speed: 1.3,        // 30% faster
        amplitude: 1.2,    // 20% bigger
        intensity: 1.4,    // 40% more intense
        smoothness: 0.6,   // 40% less smooth (sharp)
        regularity: 0.9,   // Slightly irregular
        addPulse: true,    // Pulsing intensity
        addFocus: true,    // Concentrated motion
        '3d': {
            rotation: {
                speedMultiplier: 1.6,      // Noticeably faster rotation (heightened)
                shakeMultiplier: 2.5       // Strong shake (tension)
            },
            glow: {
                intensityMultiplier: 1.8,  // Very bright (burning intensity)
                pulseSpeedMultiplier: 2.2  // Very rapid pulsing (racing)
            },
            scale: {
                breathDepthMultiplier: 1.6, // Deep intense breaths
                breathRateMultiplier: 1.8   // Rapid breathing (adrenaline)
            },
            righting: {
                strengthMultiplier: 1.3    // More stable (tense control)
            }
        }
    },
    
    subdued: {
        speed: 0.8,        // 20% slower
        amplitude: 0.8,    // 20% smaller
        intensity: 0.7,    // 30% less intense
        smoothness: 1.2,   // 20% smoother
        regularity: 1.1,   // Regular (restrained)
        addSoftness: true, // Gentle, muted motion
        addFade: true,     // Fading at edges
        '3d': {
            rotation: {
                speedMultiplier: 0.5,      // Much slower rotation (gentle)
                shakeMultiplier: 0.1       // Almost no shake (serene)
            },
            glow: {
                intensityMultiplier: 0.55, // Noticeably dimmer (muted)
                pulseSpeedMultiplier: 0.6  // Slow pulse (peaceful)
            },
            scale: {
                breathDepthMultiplier: 0.7, // Shallow controlled breaths
                breathRateMultiplier: 0.6   // Slow breathing (restrained)
            },
            righting: {
                strengthMultiplier: 1.4    // Very stable (composed stillness)
            }
        }
    }
};

/**
 * Get undertone modifier
 * @param {string} undertone - Name of the undertone
 * @returns {Object} Modifier object with default values if undertone not found
 */
function getUndertoneModifier(undertone) {
    if (!undertone || undertone === '' || undertone === 'clear') {
        return UNDERTONE_MODIFIERS.clear;
    }
    return UNDERTONE_MODIFIERS[undertone] || UNDERTONE_MODIFIERS.clear;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - 3D Color Utilities
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Color conversion and manipulation utilities for 3D rendering
 * @author Emotive Engine Team
 * @module 3d/utils/ColorUtilities
 */

/**
 * Convert hex color to RGB [0-1]
 * @param {string} hex - Hex color code (with or without #)
 * @returns {Array} RGB color [r, g, b] in [0-1] range
 */
function hexToRGB(hex) {
    // Remove # if present
    hex = hex.replace('#', '');

    // Parse
    const r = parseInt(hex.substring(0, 2), 16) / 255;
    const g = parseInt(hex.substring(2, 4), 16) / 255;
    const b = parseInt(hex.substring(4, 6), 16) / 255;

    return [r, g, b];
}

/**
 * Convert RGB [0-1] to HSL [0-360, 0-100, 0-100]
 * @param {number} r - Red component [0-1]
 * @param {number} g - Green component [0-1]
 * @param {number} b - Blue component [0-1]
 * @returns {Array} HSL color [h, s, l]
 */
function rgbToHsl$1(r, g, b) {
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const diff = max - min;
    const sum = max + min;

    let h = 0;
    let s = 0;
    const l = sum / 2;

    if (diff !== 0) {
        s = l > 0.5 ? diff / (2 - sum) : diff / sum;

        switch (max) {
        case r: h = ((g - b) / diff + (g < b ? 6 : 0)) / 6; break;
        case g: h = ((b - r) / diff + 2) / 6; break;
        case b: h = ((r - g) / diff + 4) / 6; break;
        }
    }

    return [h * 360, s * 100, l * 100];
}

/**
 * Convert HSL [0-360, 0-100, 0-100] to RGB [0-1]
 * @param {number} h - Hue [0-360]
 * @param {number} s - Saturation [0-100]
 * @param {number} l - Lightness [0-100]
 * @returns {Array} RGB color [r, g, b] in [0-1] range
 */
function hslToRgb$1(h, s, l) {
    h = h / 360;
    s = s / 100;
    l = l / 100;

    let r, g, b;

    if (s === 0) {
        r = g = b = l;
    } else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;

        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return [r, g, b];
}

/**
 * Apply undertone saturation multiplier to RGB color
 * @param {Array} rgb - RGB color [r, g, b] in [0-1]
 * @param {string|null} undertone - Undertone name
 * @returns {Array} Modified RGB color
 */
function applyUndertoneSaturation$1(rgb, undertone) {
    if (!undertone || undertone === 'clear' || undertone === 'none') {
        return rgb;
    }

    // Saturation and lightness modifiers - AMPLIFIED for 3D visibility
    const colorModifiers = {
        'intense': { saturation: 2.5, lightness: 1.3 },     // Extremely vivid + much brighter
        'confident': { saturation: 1.8, lightness: 1.15 },  // Bold saturated + brighter
        'nervous': { saturation: 1.6, lightness: 1.1 },     // Heightened + slightly brighter
        'tired': { saturation: 0.4, lightness: 0.65 },      // Very washed out + much dimmer
        'subdued': { saturation: 0.25, lightness: 0.55 }    // Ghostly desaturated + very dim
    };

    const mods = colorModifiers[undertone];
    if (!mods) return rgb;

    // Convert to HSL
    const hsl = rgbToHsl$1(rgb[0], rgb[1], rgb[2]);

    // Apply saturation multiplier
    hsl[1] = Math.min(100, hsl[1] * mods.saturation);

    // Apply lightness multiplier (makes intense brighter, subdued darker)
    hsl[2] = Math.min(100, Math.max(0, hsl[2] * mods.lightness));

    // Convert back to RGB
    return hslToRgb$1(hsl[0], hsl[1], hsl[2]);
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                     ◐ ◑ ◒ ◓  COLOR UTILS  ◓ ◒ ◑ ◐                     
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Color Utils - Color Interpolation & Manipulation
 * @author Emotive Engine Team
 * @version 2.1.0
 * @module ColorUtils
 * @complexity ⭐ Beginner-friendly
 * @audience Useful utility functions for color manipulation. Well-tested and documented.
 * @changelog 2.1.0 - Added undertone saturation modifiers for dynamic depth
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The COLOR SCIENCE module of the engine. Provides smooth color transitions         
 * ║ between emotional states using HSL interpolation for perceptually uniform         
 * ║ transitions that feel natural and emotionally resonant.                           
 * ║                                                                                    
 * ║ NEW: Undertone saturation system creates dynamic depth by adjusting saturation    
 * ║ based on emotional undertones (intense → oversaturated, subdued → desaturated)    
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎨 COLOR OPERATIONS                                                               
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Hex to RGB/HSL conversion                                                       
 * │ • RGB to Hex/HSL conversion                                                       
 * │ • HSL interpolation for smooth transitions                                        
 * │ • Color mixing and blending                                                       
 * │ • Luminance calculations                                                          
 * │ • Perceptually uniform color shifts                                               
 * │ • Undertone-based saturation adjustments                                          
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🌈 UNDERTONE SATURATION SYSTEM                                                    
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ Undertones dynamically adjust color saturation to create emotional depth:         
 * │                                                                                    
 * │ • INTENSE   : +60% saturation - Electric, vibrant, overwhelming                   
 * │ • CONFIDENT : +30% saturation - Bold, present, assertive                          
 * │ • NERVOUS   : +15% saturation - Slightly heightened, anxious energy               
 * │ • CLEAR     :   0% saturation - Normal midtone, balanced state                    
 * │ • TIRED     : -20% saturation - Washed out, fading, depleted                      
 * │ • SUBDUED   : -50% saturation - Ghostly, barely there, withdrawn                  
 * │                                                                                    
 * │ This creates a visual hierarchy where emotional intensity directly affects        
 * │ the vibrancy and presence of colors, making the mascot's state immediately        
 * │ readable through color alone.                                                     
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Converts hex color to RGB values
 * @param {string} hex - Hex color string (e.g., '#FF0000')
 * @returns {Object} RGB object with r, g, b properties
 */
function hexToRgb(hex) {
    // Remove # if present
    hex = hex.replace('#', '');
    
    // Handle 3-digit hex
    if (hex.length === 3) {
        hex = hex.split('').map(char => char + char).join('');
    }
    
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    
    return { r, g, b };
}

/**
 * Converts RGB values to hex color
 * @param {number} r - Red component (0-255)
 * @param {number} g - Green component (0-255)
 * @param {number} b - Blue component (0-255)
 * @returns {string} Hex color string
 */
function rgbToHex(r, g, b) {
    const toHex = component => {
        const hex = Math.round(Math.max(0, Math.min(255, component))).toString(16);
        return hex.length === 1 ? `0${hex}` : hex;
    };
    
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

/**
 * Converts RGB to HSL color space
 * @param {number} r - Red component (0-255)
 * @param {number} g - Green component (0-255)
 * @param {number} b - Blue component (0-255)
 * @returns {Object} HSL object with h, s, l properties
 */
function rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;
    
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2;
    let h, s;
    
    if (max === min) {
        h = s = 0; // achromatic
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        
        switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    
    return { h: h * 360, s: s * 100, l: l * 100 };
}

/**
 * Converts HSL to RGB color space
 * @param {number} h - Hue (0-360)
 * @param {number} s - Saturation (0-100)
 * @param {number} l - Lightness (0-100)
 * @returns {Object} RGB object with r, g, b properties
 */
function hslToRgb(h, s, l) {
    h /= 360;
    s /= 100;
    l /= 100;
    
    const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    };
    
    let r, g, b;
    
    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }
    
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}

/**
 * Adjusts the saturation of a color
 * @param {string} hex - Hex color
 * @param {number} factor - Saturation factor (0.5 = less saturated, 1.5 = more saturated)
 * @returns {string} Adjusted color (hex)
 */
function adjustSaturation(hex, factor) {
    const rgb = hexToRgb(hex);
    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
    
    hsl.s = Math.max(0, Math.min(100, hsl.s * factor));
    
    const adjustedRgb = hslToRgb(hsl.h, hsl.s, hsl.l);
    return rgbToHex(adjustedRgb.r, adjustedRgb.g, adjustedRgb.b);
}

/**
 * Undertone saturation modifiers for dynamic emotional depth
 * Maps undertone names to saturation adjustment factors
 */
const UNDERTONE_SATURATION = {
    intense: 1.6,    // +60% saturation - Electric, overwhelming
    confident: 1.3,  // +30% saturation - Bold, present
    nervous: 1.15,   // +15% saturation - Slightly heightened
    clear: 1.0,      // No change - Normal midtone
    tired: 0.8,      // -20% saturation - Washed out, fading
    subdued: 0.5     // -50% saturation - Ghostly, barely there
};

/**
 * Applies undertone saturation adjustment to a color
 * @param {string} hex - Base color
 * @param {string} undertone - Undertone name (intense, confident, nervous, clear, tired, subdued)
 * @returns {string} Adjusted color with undertone saturation applied
 */
function applyUndertoneSaturation(hex, undertone) {
    if (!undertone || undertone === 'clear') {
        return hex; // No adjustment for clear or missing undertone
    }
    
    const factor = UNDERTONE_SATURATION[undertone.toLowerCase()];
    if (!factor || factor === 1.0) {
        return hex;
    }
    
    return adjustSaturation(hex, factor);
}

/**
 * Applies undertone saturation to an array of colors (for particle systems)
 * @param {Array} colors - Array of colors (can be strings or objects with color property)
 * @param {string} undertone - Undertone name
 * @returns {Array} Adjusted color array with undertone saturation applied
 */
function applyUndertoneSaturationToArray(colors, undertone) {
    if (!colors || !Array.isArray(colors)) return colors;
    if (!undertone || undertone === 'clear') return colors;
    
    return colors.map(colorItem => {
        if (typeof colorItem === 'string') {
            // Simple color string
            return applyUndertoneSaturation(colorItem, undertone);
        } else if (colorItem && typeof colorItem === 'object' && colorItem.color) {
            // Weighted color object
            return {
                ...colorItem,
                color: applyUndertoneSaturation(colorItem.color, undertone)
            };
        }
        return colorItem;
    });
}

/**
 * Emotional color palette for the mascot system
 */
const EMOTIONAL_COLORS = {
    neutral: '#B0B0B0',
    joy: '#FFD700',
    sadness: '#4169E1',
    anger: '#DC143C',
    fear: '#8B008B',
    surprise: '#FF8C00',
    disgust: '#9ACD32',
    love: '#FF69B4'
};

/**
 * Gets RGB values for emotional colors (for performance)
 */
Object.fromEntries(
    Object.entries(EMOTIONAL_COLORS).map(([emotion, hex]) => {
        const rgb = hexToRgb(hex);
        return [emotion, `${rgb.r}, ${rgb.g}, ${rgb.b}`];
    })
);

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Rhythm Integration Module
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 * 
 * @fileoverview Integration layer between rhythm engine and existing subsystems
 * @author Emotive Engine Team
 * @module core/rhythmIntegration
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║ CONCEPT                                                                           
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ This module connects the rhythm engine to existing subsystems without modifying   
 * ║ their core behavior. It reads rhythm configurations from individual files and     
 * ║ applies timing modulations based on musical events.                              
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 * 
 * INTEGRATION POINTS:
 * • Particle System - Emission timing, behavior modulation
 * • Gesture System - Animation sync, duration adjustment
 * • Emotion System - Intensity mapping, transition timing
 * • Renderer - Glow pulsing, visual effects sync
 * 
 * ┌──────────────────────────────────────────────────────────────────────────────────┐
 * │  MODULAR RHYTHM FLOW                                                             │
 * │                                                                                   │
 * │  gesture.js ──┐                                                                  │
 * │  emotion.js ──┼→ [Integration] ← [Rhythm Engine]                                │
 * │  behavior.js ─┘         ↓                                                        │
 * │                   Apply Timing                                                   │
 * │                                                                                   │
 * └──────────────────────────────────────────────────────────────────────────────────┘
 */


class RhythmIntegration {
    constructor() {
        this.enabled = false;
        this.adapter = null;
        this.subsystemConfigs = new Map();
        this.activeModulations = new Map();
    }
    
    /**
     * Initialize rhythm integration
     */
    initialize() {
        this.adapter = rhythmEngine.getAdapter();
        this.enabled = true;
        
        // Subscribe to rhythm events
        this.adapter.onBeat(this.handleBeat.bind(this));
        this.adapter.onBar(this.handleBar.bind(this));
        
    }
    
    /**
     * Update BPM from detected audio
     * @param {number} newBPM - Detected BPM from audio analysis
     */
    updateBPM(newBPM) {
        if (newBPM >= 60 && newBPM <= 220) {
            // Check if rhythm was manually stopped
            if (window.rhythmManuallyStoppedForCurrentAudio) {
                return; // Don't auto-update if manually stopped
            }

            // Auto-start rhythm engine if not running
            if (!rhythmEngine.isRunning) {

                // Auto-start the rhythm engine for gesture sync
                this.start(newBPM, 'straight');

                // Trigger the rhythm sync visualizer to show BPM
                if (window.rhythmSyncVisualizer && !window.rhythmSyncVisualizer.state.active) {
                    // Rhythm integration logging removed for production
                    window.rhythmSyncVisualizer.start();
                }

                return;
            }
            
            // If running, always update BPM regardless of whether it changed
            // This ensures new tracks get their correct BPM
            rhythmEngine.setBPM(newBPM);
            
            // BPM is now shown visually through the beat histogram bars
        }
    }
    
    /**
     * Register a subsystem's rhythm configuration
     * Called when loading gestures, emotions, behaviors, etc.
     */
    registerConfig(type, name, config) {
        if (!config.rhythm || !config.rhythm.enabled) return;
        
        const key = `${type}:${name}`;
        this.subsystemConfigs.set(key, {
            type,
            name,
            rhythmConfig: config.rhythm,
            originalConfig: config
        });
        
    }
    
    /**
     * Apply rhythm modulation to a gesture
     */
    applyGestureRhythm(gesture, _particle, _progress, _dt) {
        if (!this.enabled || !gesture.rhythm?.enabled) return {};
        

        const rhythmConfig = gesture.rhythm;
        const modulation = {};
        
        // Apply amplitude sync
        if (rhythmConfig.amplitudeSync) {
            const sync = rhythmConfig.amplitudeSync;
            const beatSync = this.adapter.getBeatSync(
                sync.offBeat || 0.8,
                sync.onBeat || 1.5,
                sync.curve || 'linear'
            );
            modulation.amplitudeMultiplier = beatSync;
        }
        
        // Apply wobble sync
        if (rhythmConfig.wobbleSync) {
            const sync = rhythmConfig.wobbleSync;
            if (this.adapter.isOnSubdivision(sync.subdivision, 0.1)) {
                modulation.wobbleMultiplier = 1 + sync.intensity;
            } else {
                modulation.wobbleMultiplier = 1;
            }
        }
        
        // Apply accent response
        if (rhythmConfig.accentResponse?.enabled) {
            const accentedValue = this.adapter.getAccentedValue(
                1,
                rhythmConfig.accentResponse.multiplier || 1.5
            );
            modulation.accentMultiplier = accentedValue;
        }
        
        // Apply pattern overrides
        const currentPattern = this.adapter.getPattern();
        if (currentPattern && rhythmConfig.patternOverrides?.[currentPattern]) {
            Object.assign(modulation, rhythmConfig.patternOverrides[currentPattern]);
        }
        
        return modulation;
    }
    
    /**
     * Apply rhythm modulation to particle emission
     */
    applyParticleRhythm(emotionState, _particleSystem) {
        if (!this.enabled || !emotionState.rhythm?.enabled) return {};
        
        const timeInfo = this.adapter.getTimeInfo();
        const rhythmConfig = emotionState.rhythm;
        const modulation = {};
        
        // Particle emission sync
        if (rhythmConfig.particleEmission) {
            const emission = rhythmConfig.particleEmission;
            
            if (emission.syncMode === 'beat' && this.adapter.isOnBeat(0.1)) {
                // Emit burst on beat
                modulation.emitBurst = emission.burstSize || 3;
            } else if (emission.offBeatRate !== undefined) {
                // Reduce emission between beats
                modulation.emissionRate = emission.offBeatRate;
            }
        }
        
        // Glow sync
        if (rhythmConfig.glowSync) {
            const glow = rhythmConfig.glowSync;
            const glowIntensity = this.adapter.getBeatSync(
                glow.intensityRange[0] || 1.0,
                glow.intensityRange[1] || 2.0,
                'pulse'
            );
            modulation.glowIntensity = glowIntensity;
        }
        
        // Breathing sync
        if (rhythmConfig.breathSync?.mode === 'bars') {
            const breath = rhythmConfig.breathSync;
            const barsElapsed = timeInfo.bar % breath.barsPerBreath;
            const breathProgress = barsElapsed / breath.barsPerBreath;
            modulation.breathPhase = breathProgress * Math.PI * 2;
        }
        
        return modulation;
    }
    
    /**
     * Apply rhythm to particle behavior
     */
    applyBehaviorRhythm(behavior, _particle, _dt) {
        if (!this.enabled || !behavior.rhythm?.enabled) return {};
        
        const timeInfo = this.adapter.getTimeInfo();
        const rhythmConfig = behavior.rhythm;
        const modulation = {};
        
        // Glitch timing for glitchy behavior
        if (rhythmConfig.glitchTiming) {
            const glitch = rhythmConfig.glitchTiming;
            const isOnSubdivision = this.adapter.isOnSubdivision(glitch.subdivision, 0.05);
            
            if (isOnSubdivision && Math.random() < glitch.probability) {
                const intensity = this.adapter.isOnBeat() 
                    ? glitch.intensityOnBeat 
                    : glitch.intensityOffBeat;
                modulation.triggerGlitch = true;
                modulation.glitchIntensity = intensity;
            }
        }
        
        // Orbital rhythm
        if (rhythmConfig.orbitRhythm) {
            const orbit = rhythmConfig.orbitRhythm;
            
            if (orbit.baseSpeed === 'tempo') {
                modulation.speedMultiplier = this.adapter.getBPM() / 120; // Normalize to 120 BPM
            }
            
            if (orbit.beatAcceleration && this.adapter.isOnBeat(0.1)) {
                modulation.speedBoost = orbit.beatAcceleration;
            }
            
            if (orbit.barReset && timeInfo.beatInBar === 0) {
                modulation.resetOrbit = true;
            }
        }
        
        // Stutter sync
        if (rhythmConfig.stutterSync) {
            const stutter = rhythmConfig.stutterSync;
            const pattern = this.adapter.getPattern();
            
            if (pattern && stutter.patterns?.[pattern]) {
                const patternConfig = stutter.patterns[pattern];
                
                if (patternConfig.freezeOnDrop && timeInfo.beatInBar === 2) {
                    modulation.freeze = true;
                    modulation.freezeDuration = patternConfig.dropDuration;
                } else if (patternConfig.randomFreeze && Math.random() < patternConfig.randomFreeze) {
                    modulation.freeze = true;
                    modulation.freezeDuration = patternConfig.duration;
                }
            }
        }
        
        return modulation;
    }
    
    /**
     * Handle beat event
     */
    handleBeat(beatInfo) {
        // Store beat info for subsystems to access
        this.lastBeatInfo = beatInfo;
        
        // Could trigger specific effects here if needed
        // But mainly subsystems will query rhythm state during their update
    }
    
    /**
     * Handle bar event
     */
    handleBar(barInfo) {
        // Store bar info for subsystems to access
        this.lastBarInfo = barInfo;
    }
    
    /**
     * Get duration adjusted for musical time
     */
    getMusicalDuration(rhythmConfig, originalDuration) {
        if (!this.enabled || !rhythmConfig?.durationSync) return originalDuration;
        
        const sync = rhythmConfig.durationSync;
        
        if (sync.mode === 'bars') {
            return this.adapter.beatsToMs(sync.bars * 4); // Assuming 4/4 time
        } else if (sync.mode === 'beats') {
            return this.adapter.beatsToMs(sync.beats);
        }
        
        return originalDuration;
    }
    
    /**
     * Check if rhythm is enabled globally
     */
    isEnabled() {
        return this.enabled && this.adapter.isPlaying();
    }
    
    /**
     * Start rhythm playback
     */
    start(bpm = 120, pattern = 'straight') {
        if (bpm) rhythmEngine.setBPM(bpm);
        if (pattern) rhythmEngine.setPattern(pattern);
        rhythmEngine.start();
        this.enabled = true;
    }
    
    /**
     * Stop rhythm playback
     */
    stop() {
        rhythmEngine.stop();
        this.enabled = false;
        // Unlock BPM when stopping
        this.bpmLocked = false;
        this.lockedBPM = null;
    }
    
    /**
     * Set rhythm pattern
     */
    setPattern(pattern) {
        rhythmEngine.setPattern(pattern);
    }
    
    /**
     * Set BPM
     */
    setBPM(bpm) {
        rhythmEngine.setBPM(bpm);
        // Update the locked BPM if manually changed
        if (this.bpmLocked) {
            this.lockedBPM = bpm;
            // BPM locking logging removed for production
        }
    }
    
    /**
     * Resample BPM - unlocks detection for one update
     */
    resampleBPM() {
        // BPM resampling logging removed for production
        this.bpmLocked = false;
        this.lockedBPM = null;
    }
    
    /**
     * Set time signature from detected pattern
     */
    setTimeSignature(signature) {
        this.timeSignature = signature;
        
        // Update UI if available
        const timeSigDisplay = document.getElementById('time-sig-display');
        if (timeSigDisplay) {
            timeSigDisplay.textContent = signature;
        }
        
        // Could update rhythm patterns based on time signature here
        // For example, switch to waltz pattern for 3/4
        if (signature === '3/4' && rhythmEngine.getPattern() !== 'waltz') ;
    }
    
    /**
     * Sync to external audio
     */
    syncToAudio(audioContext, audioSource) {
        rhythmEngine.syncToAudio(audioContext, audioSource);
    }
}

// Create singleton instance
const rhythmIntegration = new RhythmIntegration();

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Emotion Cache System
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Pre-cached emotion system for instant emotion transitions
 * @author Emotive Engine Team
 * @module cache/EmotionCache
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Pre-caches all emotion states and their configurations for instant access.
 * ║ Eliminates the need to load emotion data on-demand, improving transition
 * ║ performance from ~20-50ms to <5ms.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


/**
 * EmotionCache - Pre-caches all emotion configurations for instant access
 */
class EmotionCache {
    constructor() {
        // Cache storage
        this.emotionCache = new Map();
        this.visualParamsCache = new Map();
        this.modifiersCache = new Map();
        this.transitionCache = new Map();
        
        // Performance tracking
        this.stats = {
            hits: 0,
            misses: 0,
            loadTime: 0,
            cacheSize: 0
        };
        
        // Cache configuration
        this.isInitialized = false;
        this.loadStartTime = 0;
        
        // Initialize cache
        this.initialize();
    }
    
    /**
     * Initialize the emotion cache by pre-loading all emotions
     */
    initialize() {
        this.loadStartTime = performance.now();
        
        try {
            // Get all available emotions
            const emotions = listEmotions();
            
            // Pre-cache each emotion
            emotions.forEach(emotionName => {
                this.cacheEmotion(emotionName);
            });
            
            // Pre-cache common transitions
            this.cacheCommonTransitions(emotions);
            
            this.isInitialized = true;
            this.stats.loadTime = performance.now() - this.loadStartTime;
            this.stats.cacheSize = this.emotionCache.size;

            // Removed verbose initialization log

        } catch (error) {
            console.error('[EmotionCache] Initialization failed:', error);
            this.isInitialized = false;
        }
    }
    
    /**
     * Cache a single emotion and its related data
     * @param {string} emotionName - Name of the emotion to cache
     */
    cacheEmotion(emotionName) {
        try {
            // Cache main emotion configuration
            const emotion = getEmotion(emotionName);
            if (emotion) {
                this.emotionCache.set(emotionName, emotion);
            }
            
            // Cache visual parameters (pre-evaluated)
            const visualParams = getEmotionVisualParams(emotionName);
            this.visualParamsCache.set(emotionName, visualParams);
            
            // Cache modifiers
            const modifiers = getEmotionModifiers(emotionName);
            this.modifiersCache.set(emotionName, modifiers);
            
        } catch (error) {
            console.warn(`[EmotionCache] Failed to cache emotion '${emotionName}':`, error);
        }
    }
    
    /**
     * Cache common emotion transitions
     * @param {Array<string>} emotions - List of emotion names
     */
    cacheCommonTransitions(emotions) {
        // Cache transitions between common emotion pairs
        const commonPairs = [
            ['neutral', 'joy'],
            ['neutral', 'sadness'],
            ['neutral', 'anger'],
            ['joy', 'sadness'],
            ['sadness', 'joy'],
            ['anger', 'calm'],
            ['calm', 'anger']
        ];
        
        commonPairs.forEach(([from, to]) => {
            if (emotions.includes(from) && emotions.includes(to)) {
                try {
                    const transition = getTransitionParams(from, to);
                    const key = `${from}->${to}`;
                    this.transitionCache.set(key, transition);
                } catch (error) {
                    console.warn(`[EmotionCache] Failed to cache transition '${from}->${to}':`, error);
                }
            }
        });
    }
    
    /**
     * Get cached emotion configuration
     * @param {string} emotionName - Name of the emotion
     * @returns {Object|null} Cached emotion configuration
     */
    getEmotion(emotionName) {
        if (!this.isInitialized) {
            console.warn('[EmotionCache] Cache not initialized, falling back to direct access');
            return getEmotion(emotionName);
        }
        
        const cached = this.emotionCache.get(emotionName);
        if (cached) {
            this.stats.hits++;
            return cached;
        }
        
        this.stats.misses++;
        console.warn(`[EmotionCache] Cache miss for emotion '${emotionName}', consider adding to pre-cache`);
        return getEmotion(emotionName);
    }
    
    /**
     * Get cached visual parameters
     * @param {string} emotionName - Name of the emotion
     * @returns {Object} Cached visual parameters
     */
    getVisualParams(emotionName) {
        if (!this.isInitialized) {
            return getEmotionVisualParams(emotionName);
        }
        
        const cached = this.visualParamsCache.get(emotionName);
        if (cached) {
            this.stats.hits++;
            return cached;
        }
        
        this.stats.misses++;
        return getEmotionVisualParams(emotionName);
    }
    
    /**
     * Get cached modifiers
     * @param {string} emotionName - Name of the emotion
     * @returns {Object} Cached modifiers
     */
    getModifiers(emotionName) {
        if (!this.isInitialized) {
            return getEmotionModifiers(emotionName);
        }
        
        const cached = this.modifiersCache.get(emotionName);
        if (cached) {
            this.stats.hits++;
            return cached;
        }
        
        this.stats.misses++;
        return getEmotionModifiers(emotionName);
    }
    
    /**
     * Get cached transition parameters
     * @param {string} fromEmotion - Starting emotion
     * @param {string} toEmotion - Target emotion
     * @returns {Object} Cached transition parameters
     */
    getTransitionParams(fromEmotion, toEmotion) {
        if (!this.isInitialized) {
            return getTransitionParams(fromEmotion, toEmotion);
        }
        
        const key = `${fromEmotion}->${toEmotion}`;
        const cached = this.transitionCache.get(key);
        if (cached) {
            this.stats.hits++;
            return cached;
        }
        
        this.stats.misses++;
        return getTransitionParams(fromEmotion, toEmotion);
    }
    
    /**
     * Check if emotion is cached
     * @param {string} emotionName - Name of the emotion
     * @returns {boolean} True if emotion is cached
     */
    hasEmotion(emotionName) {
        return this.emotionCache.has(emotionName);
    }
    
    /**
     * Get cache statistics
     * @returns {Object} Cache performance statistics
     */
    getStats() {
        const totalRequests = this.stats.hits + this.stats.misses;
        const hitRate = totalRequests > 0 ? (this.stats.hits / totalRequests * 100).toFixed(2) : 0;
        
        return {
            isInitialized: this.isInitialized,
            loadTime: this.stats.loadTime,
            cacheSize: this.stats.cacheSize,
            hits: this.stats.hits,
            misses: this.stats.misses,
            hitRate: `${hitRate}%`,
            emotions: this.emotionCache.size,
            visualParams: this.visualParamsCache.size,
            modifiers: this.modifiersCache.size,
            transitions: this.transitionCache.size
        };
    }
    
    /**
     * Clear all caches
     */
    clear() {
        this.emotionCache.clear();
        this.visualParamsCache.clear();
        this.modifiersCache.clear();
        this.transitionCache.clear();
        this.isInitialized = false;
        this.stats = { hits: 0, misses: 0, loadTime: 0, cacheSize: 0 };
    }
    
    /**
     * Reinitialize cache (useful for dynamic emotion loading)
     */
    reinitialize() {
        this.clear();
        this.initialize();
    }
}

// Create singleton instance
const emotionCache = new EmotionCache();

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Color Utilities
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Color selection and manipulation utilities for particles
 * @author Emotive Engine Team
 * @module particles/utils/colorUtils
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Handles weighted color selection for particles. Each emotion has a palette of     
 * ║ colors with different weights (probabilities). This creates visual variety        
 * ║ while maintaining the emotional theme.                                            
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Select a color from an array with optional weights
 * 
 * EXAMPLE INPUT:
 * [
 *   { color: '#FF69B4', weight: 30 },  // 30% chance
 *   { color: '#FFB6C1', weight: 25 },  // 25% chance
 *   { color: '#FF1493', weight: 20 },  // 20% chance
 *   '#FFC0CB',                          // Remaining weight split evenly
 *   '#C71585'                           // between unweighted colors
 * ]
 * 
 * @param {Array} colors - Array of color strings or {color, weight} objects
 * @returns {string} Selected hex color
 */
function selectWeightedColor(colors) {
    if (!colors || colors.length === 0) return '#FFFFFF';
    
    // Parse colors and weights
    let totalExplicitWeight = 0;
    let unweightedCount = 0;
    const parsedColors = [];
    
    for (const item of colors) {
        if (typeof item === 'string') {
            // Simple string color - will get default weight
            parsedColors.push({ color: item, weight: null });
            unweightedCount++;
        } else if (item && typeof item === 'object' && item.color) {
            // Object with color and optional weight
            parsedColors.push({ color: item.color, weight: item.weight || null });
            if (item.weight) {
                totalExplicitWeight += item.weight;
            } else {
                unweightedCount++;
            }
        }
    }
    
    // Calculate weight for unweighted colors
    // If weights total 75, and there are 2 unweighted colors, each gets 12.5
    const remainingWeight = Math.max(0, 100 - totalExplicitWeight);
    const defaultWeight = unweightedCount > 0 ? remainingWeight / unweightedCount : 0;
    
    // Build cumulative probability table for efficient selection
    const probTable = [];
    let cumulative = 0;
    
    for (const item of parsedColors) {
        const weight = item.weight !== null ? item.weight : defaultWeight;
        cumulative += weight;
        probTable.push({ color: item.color, threshold: cumulative });
    }
    
    // Select based on random value
    const random = Math.random() * cumulative;
    for (const entry of probTable) {
        if (random <= entry.threshold) {
            return entry.color;
        }
    }
    
    // Fallback to last color (shouldn't happen but safety first)
    return parsedColors[parsedColors.length - 1].color;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Ambient Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Gentle upward drift behavior for neutral emotional state
 * @author Emotive Engine Team
 * @module particles/behaviors/ambient
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a calm, peaceful atmosphere with particles gently drifting upward         
 * ║ like smoke or steam. This is the default behavior for neutral emotional states.   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ↑  ↑  ↑
 *       ·  ·  ·    ← particles drift straight up
 *      ·  ·  ·  
 *     ·  ⭐  ·     ← orb center
 *      ·  ·  ·
 *       ·  ·  ·
 * 
 * USED BY EMOTIONS:
 * - neutral (default calm state)
 * 
 * RECIPE TO MODIFY:
 * - Increase upwardSpeed for faster rising (more energy)
 * - Decrease friction for longer-lasting momentum
 * - Add waviness for side-to-side motion (currently disabled)
 */


/**
 * Initialize ambient behavior for a particle
 * Sets up initial velocities and behavior-specific data
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeAmbient(particle) {
    // Start with gentle upward movement
    particle.vx = 0;  // NO horizontal drift
    particle.vy = -0.04 - Math.random() * 0.02;  // Slower upward movement
    particle.lifeDecay = 0.002;  // Even slower fade - particles last ~8 seconds
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        // Languid upward drift
        upwardSpeed: 0.0005,      // Very slow continuous upward drift
        waviness: 0,              // NO side-to-side (set to 0.5-2 for wave motion)
        friction: 0.998           // Even more gradual slowdown
    };
}

/**
 * Update ambient behavior each frame
 * Applies gentle upward drift with air resistance
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X (unused but kept for consistency)
 * @param {number} centerY - Orb center Y (unused but kept for consistency)
 */
function updateAmbient(particle, dt, _centerX, _centerY) {
    const data = particle.behaviorData;
    
    // Apply friction to y velocity only (frame-rate independent)
    // Use exponential decay: friction^dt where dt is normalized to 60fps
    particle.vy *= Math.pow(data.friction, dt);
    
    // Add continuous upward drift
    particle.vy -= data.upwardSpeed * dt;
    
    // NO horizontal movement or waviness (zen-like straight up)
    particle.vx = 0;
}

// Export behavior definition for registry
var ambient = {
    name: 'ambient',
    emoji: '☁️',
    description: 'Gentle upward drift like smoke',
    initialize: initializeAmbient,
    update: updateAmbient
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Particle Physics Configuration
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Physics constants for particle behavior
 * @author Emotive Engine Team
 * @module particles/config/physics
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Core physics values that control how particles move and interact with the world.  
 * ║ Modify these with caution as they affect all particle behaviors globally.         
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ PHYSICS CONSTANTS - Core physics values (modify with caution)
// └─────────────────────────────────────────────────────────────────────────────────────
const PHYSICS = {
    // Math constants
    TWO_PI: Math.PI * 2};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Orbiting Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Romantic orbiting behavior for love emotional state
 * @author Emotive Engine Team
 * @module particles/behaviors/orbiting
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a romantic atmosphere with particles orbiting the orb like fireflies      
 * ║ dancing at a valentine's day party. Features individual blinking and sparkles.    
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ✨     ✨
 *      💕  ╭───╮  💕    ← particles orbit & sparkle
 *    ✨   │  ⭐  │   ✨   ← orb center
 *      💕  ╰───╯  💕
 *        ✨     ✨
 * 
 * USED BY EMOTIONS:
 * - love (romantic valentine vibes)
 * 
 * RECIPE TO MODIFY:
 * - Increase angularVelocity for faster spinning
 * - Increase floatAmount for more vertical movement
 * - Adjust blinkSpeed for different firefly effects
 * - Increase baseRadius for wider orbits
 */


/**
 * Initialize orbiting behavior for a particle
 * Creates valentine fireflies with individual timing
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeOrbiting(particle) {
    // Individual fade timing - each particle has its own lifespan
    particle.lifeDecay = 0.001 + Math.random() * 0.002;  // Variable decay (0.001-0.003)
    
    // Use emotion colors if provided - glittery valentine palette
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    // Check if this is a lighter/sparkle color (light pinks)
    particle.isSparkle = particle.color === '#FFE4E1' || 
                        particle.color === '#FFCCCB' || 
                        particle.color === '#FFC0CB';
    
    // Particles orbit at various distances for depth
    const orbRadius = (particle.scaleFactor || 1) * 40; // Approximate orb size
    const depthLayer = Math.random();
    const baseRadius = orbRadius * (1.3 + depthLayer * 0.9); // 1.3x to 2.2x orb radius
    
    // Glitter firefly properties - each with unique timing
    particle.blinkPhase = Math.random() * PHYSICS.TWO_PI; // Random starting phase
    particle.blinkSpeed = 0.3 + Math.random() * 1.2; // Varied blink speeds (0.3-1.5)
    particle.blinkIntensity = 0.6 + Math.random() * 0.4; // How bright the blink gets
    
    // Individual fade properties
    particle.fadePhase = Math.random() * PHYSICS.TWO_PI; // Random fade starting phase
    particle.fadeSpeed = 0.1 + Math.random() * 0.3; // Different fade speeds
    particle.minOpacity = 0.2 + Math.random() * 0.2; // Min brightness varies (0.2-0.4)
    particle.maxOpacity = 0.8 + Math.random() * 0.2; // Max brightness varies (0.8-1.0)
    
    // Sparkles have different properties
    if (particle.isSparkle) {
        particle.blinkSpeed *= 2; // Sparkles blink faster
        particle.blinkIntensity = 1.0; // Full intensity sparkles
        particle.minOpacity = 0; // Can fade to nothing
        particle.maxOpacity = 1.0; // Can be fully bright
    }
    
    particle.behaviorData = {
        angle: Math.random() * PHYSICS.TWO_PI,
        radius: baseRadius,
        baseRadius,
        angularVelocity: 0.0008 + Math.random() * 0.0017,  // Varied rotation speeds
        swayAmount: 3 + Math.random() * 7,  // Gentle floating sway
        swaySpeed: 0.2 + Math.random() * 0.5,  // Varied sway rhythm
        floatOffset: Math.random() * PHYSICS.TWO_PI,  // Random vertical float phase
        floatSpeed: 0.3 + Math.random() * 0.7,  // Varied vertical floating speed
        floatAmount: 2 + Math.random() * 6,  // How much they float up/down
        twinklePhase: Math.random() * PHYSICS.TWO_PI,  // Individual twinkle timing
        twinkleSpeed: 2 + Math.random() * 3  // Fast twinkle for glitter effect
    };
}

/**
 * Update orbiting behavior each frame
 * Creates romantic firefly dance with sparkles
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X position
 * @param {number} centerY - Orb center Y position
 */
function updateOrbiting(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;

    // Slow romantic rotation around the orb
    data.angle += data.angularVelocity * dt;

    // Gentle swaying motion
    const swayOffset = Math.sin(data.angle * data.swaySpeed) * data.swayAmount;

    // Radius changes for breathing effect
    const radiusPulse = Math.sin(data.angle * 1.5) * 6;

    // Use data.radius if it exists (can be modified by gestures), otherwise use baseRadius
    const currentRadius = (data.radius || data.baseRadius) + radiusPulse + swayOffset * 0.2;

    // Calculate desired orbital position
    const targetX = centerX + Math.cos(data.angle) * currentRadius;
    const targetY = centerY + Math.sin(data.angle) * currentRadius;

    // Add gentle vertical floating (like fireflies)
    data.floatOffset += data.floatSpeed * dt * 0.001;
    const verticalFloat = Math.sin(data.floatOffset) * data.floatAmount;

    // Smoothly move towards target position instead of directly setting it
    // This allows gestures to temporarily offset particles
    const smoothingFactor = 0.1; // How quickly particles return to orbit
    particle.vx = (targetX - particle.x) * smoothingFactor;
    particle.vy = (targetY + verticalFloat - particle.y) * smoothingFactor;
    
    // Update individual fade phase
    particle.fadePhase += particle.fadeSpeed * dt * 0.001;
    
    // Calculate individual particle fade (independent timing)
    const fadeValue = Math.sin(particle.fadePhase) * 0.5 + 0.5; // 0 to 1
    const fadeOpacity = particle.minOpacity + (particle.maxOpacity - particle.minOpacity) * fadeValue;
    
    // Firefly blinking effect
    particle.blinkPhase += particle.blinkSpeed * dt * 0.002;
    
    // Create a complex glitter blink with multiple harmonics
    let blinkValue;
    if (particle.isSparkle) {
        // Sparkles have sharp, dramatic twinkles
        data.twinklePhase += data.twinkleSpeed * dt * 0.001;
        const twinkle = Math.pow(Math.sin(data.twinklePhase), 16); // Sharp peaks
        const shimmer = Math.sin(particle.blinkPhase * 5) * 0.2;
        blinkValue = twinkle * 0.7 + shimmer + 0.1;
    } else {
        // Regular particles have smoother, firefly-like pulses
        blinkValue = Math.sin(particle.blinkPhase) * 0.4 + 
                    Math.sin(particle.blinkPhase * 3) * 0.3 +
                    Math.sin(particle.blinkPhase * 7) * 0.2 +
                    Math.sin(particle.blinkPhase * 11) * 0.1; // Added harmonic
    }
    
    // Map to 0-1 range with intensity control
    const normalizedBlink = (blinkValue + 1) * 0.5; // Convert from -1,1 to 0,1
    const blink = 0.2 + normalizedBlink * particle.blinkIntensity * 0.8;
    
    // Combine individual fade with blink effect
    particle.opacity = particle.baseOpacity * fadeOpacity * blink;
    
    // Sparkles pulse size more dramatically
    if (particle.isSparkle) {
        particle.size = particle.baseSize * (0.5 + normalizedBlink * 1.0); // 50-150% size
    } else {
        particle.size = particle.baseSize * (0.8 + normalizedBlink * 0.3); // 80-110% size
    }
    
    // Add subtle color shift for sparkles (shimmer effect)
    if (particle.isSparkle) {
        // Light pink sparkles can shift to white at peak brightness
        if (normalizedBlink > 0.85) {
            particle.tempColor = '#FFFFFF'; // Flash white at peak for extra sparkle
        } else {
            particle.tempColor = particle.color;
        }
    }
}

// Export behavior definition for registry
var orbiting = {
    name: 'orbiting',
    emoji: '💕',
    description: 'Romantic firefly dance around the orb',
    initialize: initializeOrbiting,
    update: updateOrbiting
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Rising Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Buoyant upward movement for joyful states
 * @author Emotive Engine Team
 * @module particles/behaviors/rising
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a buoyant, uplifting atmosphere with particles rising like bubbles        
 * ║ or balloons. Slight horizontal drift adds organic movement.                       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *      ↗  ↑  ↖
 *     ·  ·  ·    ← particles rise with drift
 *    ·  ·  ·  
 *   ·  ⭐  ·     ← orb center
 *    ·  ·  ·
 *     ·  ·  ·
 * 
 * USED BY EMOTIONS:
 * - joy (subtle happiness)
 * - optimism
 * 
 * RECIPE TO MODIFY:
 * - Increase buoyancy for faster rising (like helium balloons)
 * - Increase driftAmount for more side-to-side movement
 * - Decrease air resistance for longer-lasting momentum
 */


/**
 * Initialize rising behavior for a particle
 * Sets up buoyant upward movement with gentle drift
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeRising(particle) {
    particle.vx = (Math.random() - 0.5) * 0.02;  // Even slower horizontal drift
    particle.vy = -0.05 - Math.random() * 0.03;   // Much slower upward movement
    particle.lifeDecay = 0.002;                   // Very slow decay
    particle.baseOpacity = 0.7 + Math.random() * 0.3;  // More opaque (70-100%)
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        buoyancy: 0.001,      // Even gentler upward force
        driftAmount: 0.005    // Minimal drift
    };
}

/**
 * Update rising behavior each frame
 * Applies buoyancy and gentle drift
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X (unused)
 * @param {number} centerY - Orb center Y (unused)
 */
function updateRising(particle, dt, _centerX, _centerY) {
    const data = particle.behaviorData;
    
    // Add buoyancy (upward force)
    particle.vy -= data.buoyancy * dt;
    
    // Add horizontal drift
    particle.vx += (Math.random() - 0.5) * data.driftAmount * dt;
    
    // Apply air resistance (frame-independent)
    particle.vx *= Math.pow(0.995, dt);
    particle.vy *= Math.pow(0.998, dt);
}

// Export behavior definition for registry
var rising = {
    name: 'rising',
    emoji: '🎈',
    description: 'Buoyant upward movement like balloons',
    initialize: initializeRising,
    update: updateRising
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Falling Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Heavy downward drift for sad emotional states
 * @author Emotive Engine Team
 * @module particles/behaviors/falling
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a melancholic atmosphere with particles slowly falling like tears         
 * ║ or autumn leaves. Heavy, weighted movement conveys sadness.                       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *     ·  ·  ·
 *    ·  ·  ·  
 *   ·  ⭐  ·     ← orb center
 *    ·  ·  ·
 *     ·  ·  ·    ← particles fall slowly
 *      ↓  ↓  ↓
 * 
 * USED BY EMOTIONS:
 * - sadness (melancholy, grief)
 * - disappointment
 * - tired
 * 
 * RECIPE TO MODIFY:
 * - Increase gravity for heavier falling (more weight)
 * - Decrease drag for faster falling (less air resistance)
 * - Add horizontal drift for leaf-like falling
 */


/**
 * Initialize falling behavior for a particle
 * Sets up slow, heavy downward movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeFalling(particle) {
    // Exact copy of ambient but falling DOWN instead of up
    particle.vx = 0;  // NO horizontal drift
    particle.vy = 0.04 + Math.random() * 0.02;  // Same speed as ambient but downward (positive = down)
    particle.lifeDecay = 0.002;  // Same as ambient

    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }

    // Generate random 3D direction for uniform sphere distribution
    // This is used by the 3D translator for positioning
    const u1 = Math.random();
    const u2 = Math.random();
    const theta = u1 * Math.PI * 2;
    const cosPhi = 2.0 * u2 - 1.0;
    const sinPhi = Math.sqrt(1.0 - cosPhi * cosPhi);

    particle.behaviorData = {
        downwardSpeed: 0.0005,  // Same as ambient's upwardSpeed
        friction: 0.998,        // Same as ambient
        // 3D direction for translator (uniform sphere distribution)
        fallingDir: {
            x: sinPhi * Math.cos(theta),
            y: cosPhi,
            z: sinPhi * Math.sin(theta)
        },
        // Random orbit distance (0.7x to 1.1x core radius, actual value set by translator)
        orbitDistanceRatio: 0.7 + Math.random() * 0.4
    };
}

/**
 * Update falling behavior each frame
 * Mirror of ambient but falling DOWN instead of rising up
 *
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X (unused)
 * @param {number} centerY - Orb center Y (unused)
 */
function updateFalling(particle, dt, _centerX, _centerY) {
    const data = particle.behaviorData;

    // Apply friction to y velocity only (frame-rate independent)
    // Use exponential decay: friction^dt where dt is normalized to 60fps
    particle.vy *= Math.pow(data.friction, dt);

    // Add continuous downward drift (opposite of ambient's upward)
    particle.vy += data.downwardSpeed * dt;

    // NO horizontal movement (zen-like straight down, like ambient goes straight up)
    particle.vx = 0;
}

// Export behavior definition for registry
var falling = {
    name: 'falling',
    emoji: '💧',
    description: 'Heavy downward drift like tears',
    initialize: initializeFalling,
    update: updateFalling
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Playground Configuration 🎮
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Safe values for experimentation and tweaking
 * @author Emotive Engine Team
 * @module particles/config/playground
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                            🎮 PLAYGROUND VALUES                                   
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ SAFE TO MODIFY! These values are designed for experimentation.                    
 * ║ Change them to create new visual effects and behaviors.                           
 * ║                                                                                    
 * ║ TIP: After changing values, refresh your browser to see the effects!              
 * ║ TIP: Set window.DEBUG_PARTICLES = true in console to visualize changes            
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

const PLAYGROUND = {
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ POPCORN BEHAVIOR - Joy particles that pop!
    // └─────────────────────────────────────────────────────────────────────────────────
    popcorn: {
        POP_DELAY_MAX: 2000,   // 🎯 Slowest pop (ms) - Try: 1000-5000
        POP_FORCE_MIN: 3,      // 🎯 Weakest pop - Try: 1-5
        POP_FORCE_MAX: 8,      // 🎯 Strongest pop - Try: 5-15
        BOUNCE_HEIGHT: 0.7     // 🎯 Bounce energy retained - Try: 0.3-0.9
    }};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Popcorn Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Spontaneous popping with bounces for joyful celebration
 * @author Emotive Engine Team
 * @module particles/behaviors/popcorn
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a celebratory atmosphere with particles that wait, then POP! and bounce   
 * ║ around with gravity. Perfect for pure joy and celebration moments.                
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *     Stage 1: Wait      Stage 2: POP!       Stage 3: Bounce
 *         ·                  💥 ↗             ↘ 
 *        ···                ↖ 💥 ↗              ↓
 *       ·⭐·                  💥                 🎊 ← bounce!
 *        ···                ↙ 💥 ↘              ↑
 *         ·                  💥 ↓               ↗
 * 
 * USED BY EMOTIONS:
 * - joy (celebration, happiness, excitement)
 * 
 * RECIPE TO MODIFY:
 * - Decrease popDelay for faster popping (more energetic)
 * - Increase popStrength for bigger pops
 * - Adjust gravity for different bounce physics
 * - Increase maxBounces for longer bouncing
 */


/**
 * Initialize popcorn behavior for a particle
 * Sets up kernel waiting to pop
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializePopcorn(particle) {
    // Start with little to no movement (kernel waiting to pop)
    particle.vx = (Math.random() - 0.5) * 0.1;
    particle.vy = (Math.random() - 0.5) * 0.1;
    // Faster, more varied decay for dynamic disappearing
    particle.lifeDecay = 0.008 + Math.random() * 0.012; // Random between 0.008-0.020
    
    // Use emotion colors if provided, otherwise default popcorn colors
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    } else {
        // Default popcorn colors (buttery whites and yellows)
        const colors = ['#FFFFFF', '#FFFACD', '#FFF8DC', '#FFFFE0', '#FAFAD2'];
        particle.color = selectWeightedColor(colors);
    }
    
    // Vary sizes more dramatically - some big fluffy pieces, some small
    particle.size = (Math.random() < 0.3) ? 
        (8 + Math.random() * 4) * particle.scaleFactor * particle.particleSizeMultiplier : // 30% big
        (2 + Math.random() * 4) * particle.scaleFactor * particle.particleSizeMultiplier;  // 70% small
    particle.baseSize = particle.size;
    
    // Less glow, more solid popcorn look
    particle.hasGlow = Math.random() < 0.2; // Only 20% have glow
    particle.glowSizeMultiplier = particle.hasGlow ? 1.2 : 0;
    
    particle.behaviorData = {
        // Popcorn popping mechanics
        popDelay: Math.random() * PLAYGROUND.popcorn.POP_DELAY_MAX,
        hasPopped: false,
        popStrength: PLAYGROUND.popcorn.POP_FORCE_MIN + 
                    Math.random() * (PLAYGROUND.popcorn.POP_FORCE_MAX - PLAYGROUND.popcorn.POP_FORCE_MIN),
        
        // Physics after popping
        gravity: 0.098,                    // Gravity strength
        bounceDamping: PLAYGROUND.popcorn.BOUNCE_HEIGHT,
        bounceCount: 0,
        maxBounces: 2 + Math.floor(Math.random() * 2), // 2-3 bounces
        
        // Visual flair
        spinRate: (Math.random() - 0.5) * 10, // Rotation speed (for future use)
        lifetime: 0                           // Track time since spawn
    };
}

/**
 * Update popcorn behavior each frame
 * Handles waiting, popping, and bouncing phases
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X position
 * @param {number} centerY - Orb center Y position
 */
function updatePopcorn(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    data.lifetime += dt * 16.67; // Convert to milliseconds
    
    // Check if it's time to pop
    if (!data.hasPopped && data.lifetime > data.popDelay) {
        // POP! Sudden burst of velocity in all directions for celebration
        data.hasPopped = true;
        const popAngle = Math.random() * Math.PI * 2; // Full 360 degree spread
        particle.vx = Math.cos(popAngle) * data.popStrength * 1.5; // Extra horizontal spread
        particle.vy = Math.sin(popAngle) * data.popStrength - 0.3; // Slight upward bias for joy
        
        // Expand size when popping for dramatic effect
        particle.size = particle.baseSize * 1.25;
    }
    
    if (data.hasPopped) {
        // Apply gravity
        particle.vy += data.gravity * dt;
        
        // Check for ground bounce
        const groundLevel = centerY + 100 * particle.scaleFactor; // Below the orb
        if (particle.y > groundLevel && data.bounceCount < data.maxBounces) {
            particle.y = groundLevel;
            particle.vy = -Math.abs(particle.vy) * data.bounceDamping; // Bounce up with damping
            particle.vx *= 0.9; // Reduce horizontal speed on bounce
            data.bounceCount++;
            
            // Shrink slightly with each bounce
            particle.size = particle.baseSize * (1.5 - data.bounceCount * 0.1);
        }
        
        // Fade dramatically after final bounce
        if (data.bounceCount >= data.maxBounces) {
            particle.lifeDecay = 0.03 + Math.random() * 0.02; // Very fast fade
            particle.size *= 0.95; // Also shrink rapidly
        }
        
        // Dynamic fading based on velocity - slower particles fade faster
        const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        if (speed < 0.5) {
            particle.lifeDecay *= 1.5; // 50% faster fade when moving slowly
        }
    }
}

// Export behavior definition for registry
var popcorn = {
    name: 'popcorn',
    emoji: '🍿',
    description: 'Spontaneous popping with gravity and bounces',
    initialize: initializePopcorn,
    update: updatePopcorn
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Burst Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Explosive expansion for surprise and suspicion states
 * @author Emotive Engine Team
 * @module particles/behaviors/burst
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates dramatic expansion effects. For surprise: fast burst then sudden stop.    
 * ║ For suspicion: controlled, watchful expansion. Particles shoot out from center.   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *   Surprise:                  Suspicion:
 *       💥→                        •→
 *     ↗ 💥 ↘                    ↗ • ↘
 *   ← ⭐ →    STOP!          ← ⭐ →    (controlled)
 *     ↙ 💥 ↖                    ↙ • ↖
 *       💥←                        •←
 * 
 * USED BY EMOTIONS:
 * - surprise (dramatic burst then stop)
 * - suspicion (controlled, watchful expansion)
 * 
 * RECIPE TO MODIFY:
 * - Increase speed for more dramatic burst
 * - Adjust friction for different deceleration
 * - Change stopTime for surprise effect timing
 */


/**
 * Initialize burst behavior for a particle
 * Sets up explosive outward movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeBurst(particle) {
    // Check emotion type for behavior variation
    const isSuspicion = particle.emotion === 'suspicion';
    const isSurprise = particle.emotion === 'surprise';
    const isGlitch = particle.emotion === 'glitch';
    
    // Random direction for burst
    const angle = Math.random() * PHYSICS.TWO_PI;
    
    // Speed based on emotion
    const speed = isSuspicion ? 
        (1.0 + Math.random() * 0.8) :      // Controlled burst for suspicion (1-1.8)
        (isSurprise ? 
            (7.0 + Math.random() * 5.0) :  // Much faster burst for surprise (7-12)
            (isGlitch ?
                (2.0 + Math.random() * 1.5) : // Moderate burst for glitch (2-3.5)
                (3.5 + Math.random() * 2.5)));  // Normal burst for others (3.5-6)
    
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    
    // Lifespan based on emotion
    particle.lifeDecay = isSuspicion ? 
        0.010 : 
        (isSurprise ? 0.006 + Math.random() * 0.008 : 
            (isGlitch ? 0.012 : 0.015));
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    // Make suspicion particles more visible
    if (isSuspicion) {
        particle.size = (6 + Math.random() * 4) * 
                       (particle.scaleFactor || 1) * 
                       (particle.particleSizeMultiplier || 1);
        particle.baseSize = particle.size;
        particle.opacity = 1.0;  // Full opacity for visibility
        particle.baseOpacity = particle.opacity;
    }
    
    particle.behaviorData = {
        isSuspicion,
        isSurprise,
        isGlitch,
        age: 0,
        fadeStart: isSuspicion ? 0.3 : 0.2,  // When to start fading
        // Glitch wiggle properties
        glitchPhase: Math.random() * Math.PI * 2,
        glitchIntensity: isGlitch ? 0.3 : 0,
        glitchFrequency: isGlitch ? 0.1 : 0
    };
}

/**
 * Update burst behavior each frame
 * Handles explosive expansion with emotion-specific variations
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X (unused)
 * @param {number} centerY - Orb center Y (unused)
 */
function updateBurst(particle, dt, _centerX, _centerY) {
    const data = particle.behaviorData;
    
    // Surprise particles: burst out then STOP suddenly
    if (data.isSurprise) {
        // Track age for timing the stop
        data.age += dt * 0.016; // Convert to seconds
        
        if (data.age < 0.15) {
            // First 0.15 seconds: maintain high speed
            const friction = 0.98;
            particle.vx *= Math.pow(friction, dt);
            particle.vy *= Math.pow(friction, dt);
        } else if (data.age < 0.25) {
            // 0.15-0.25 seconds: SUDDEN STOP!
            const friction = 0.85; // Heavy braking
            particle.vx *= Math.pow(friction, dt);
            particle.vy *= Math.pow(friction, dt);
        } else {
            // After stop: float gently
            const friction = 0.99;
            particle.vx *= Math.pow(friction, dt);
            particle.vy *= Math.pow(friction, dt);
            // Tiny random drift
            particle.vx += (Math.random() - 0.5) * 0.01 * dt;
            particle.vy += (Math.random() - 0.5) * 0.01 * dt;
        }
    } else {
        // Normal burst behavior for other emotions
        const friction = data.isSuspicion ? 0.99 : (data.isGlitch ? 0.97 : 0.95);
        particle.vx *= Math.pow(friction, dt);
        particle.vy *= Math.pow(friction, dt);
    }
    
    // For suspicion, add a subtle scanning motion
    if (data.isSuspicion) {
        // Add a very subtle side-to-side drift
        const time = Date.now() * 0.001;
        particle.vx += Math.sin(time * 2 + particle.id) * 0.01 * dt;
    }
    
    // For glitch, add wiggle effect
    if (data.isGlitch) {
        data.age += dt * 0.016; // Track age for glitch timing
        
        // Update glitch phase
        data.glitchPhase += data.glitchFrequency * dt;
        
        // Add wiggle to velocity
        const wiggleX = Math.sin(data.glitchPhase) * data.glitchIntensity * dt;
        const wiggleY = Math.cos(data.glitchPhase * 1.3) * data.glitchIntensity * dt;
        
        particle.vx += wiggleX;
        particle.vy += wiggleY;
        
        // Occasionally add random glitch bursts
        if (Math.random() < 0.02) { // 2% chance per frame
            const burstAngle = Math.random() * Math.PI * 2;
            const burstSpeed = 0.5 + Math.random() * 0.5;
            particle.vx += Math.cos(burstAngle) * burstSpeed;
            particle.vy += Math.sin(burstAngle) * burstSpeed;
        }
    }
}

// Export behavior definition for registry
var burst = {
    name: 'burst',
    emoji: '💥',
    description: 'Explosive expansion from center',
    initialize: initializeBurst,
    update: updateBurst
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Aggressive Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Sharp, chaotic movement for angry emotional states
 * @author Emotive Engine Team
 * @module particles/behaviors/aggressive
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates an intense, volatile atmosphere with particles moving erratically.        
 * ║ Sharp jitters and sudden bursts of movement convey anger and frustration.         
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *      ⚡→    ←⚡
 *        ↘  ↙       ← erratic, sharp movements
 *    ⚡← ⭐ →⚡      ← orb center (shaking)
 *        ↗  ↖
 *      ⚡←    →⚡
 * 
 * USED BY EMOTIONS:
 * - anger (rage, fury)
 * - frustration
 * - irritation
 * 
 * RECIPE TO MODIFY:
 * - Increase jitter for more chaotic movement
 * - Increase acceleration for more violent bursts
 * - Decrease speedDecay for longer-lasting energy
 */


/**
 * Initialize aggressive behavior for a particle
 * Sets up chaotic, sharp movement patterns
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeAggressive(particle) {
    const angle = Math.random() * PHYSICS.TWO_PI;
    const speed = 1.5 + Math.random() * 2;
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.lifeDecay = 0.015;
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        acceleration: 0.05,
        jitter: 0.3,
        speedDecay: 0.95
    };
}

/**
 * Update aggressive behavior each frame
 * Applies jitter and random acceleration bursts
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X (unused)
 * @param {number} centerY - Orb center Y (unused)
 */
function updateAggressive(particle, dt, _centerX, _centerY) {
    const data = particle.behaviorData;
    
    // Add jitter to movement
    particle.vx += (Math.random() - 0.5) * data.jitter * dt;
    particle.vy += (Math.random() - 0.5) * data.jitter * dt;
    
    // Apply speed decay (frame-independent)
    particle.vx *= Math.pow(data.speedDecay, dt);
    particle.vy *= Math.pow(data.speedDecay, dt);
    
    // Occasionally add burst of acceleration
    // Scale probability with frame time
    if (Math.random() < Math.min(0.05 * dt, 0.5)) {
        const angle = Math.random() * PHYSICS.TWO_PI;
        particle.vx += Math.cos(angle) * data.acceleration;
        particle.vy += Math.sin(angle) * data.acceleration;
    }
}

// Export behavior definition for registry
var aggressive = {
    name: 'aggressive',
    emoji: '⚡',
    description: 'Sharp, chaotic movement with violent bursts',
    initialize: initializeAggressive,
    update: updateAggressive
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Scattering Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Particles fleeing from center for fear states
 * @author Emotive Engine Team
 * @module particles/behaviors/scattering
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates an anxious atmosphere with particles frantically fleeing from the center. 
 * ║ Conveys fear, panic, and the desire to escape.                                    
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    ← · · · →
 *    ↖       ↗       ← particles flee outward
 *  · · ⭐ · ·       ← orb center (source of fear)
 *    ↙       ↘
 *    ← · · · →
 * 
 * USED BY EMOTIONS:
 * - fear (panic, anxiety)
 * - startled
 * - nervous
 * 
 * RECIPE TO MODIFY:
 * - Increase fleeSpeed for more frantic escape
 * - Increase panicFactor for more erratic fleeing
 * - Add jitter for nervous shaking while fleeing
 */


/**
 * Initialize scattering behavior for a particle
 * Sets up fleeing movement away from center
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeScattering(particle) {
    // Will be set relative to center in update
    particle.vx = 0;
    particle.vy = 0;
    particle.lifeDecay = 0.008;  // Live longer to spread further
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        fleeSpeed: 2.0,     // Much faster fleeing
        panicFactor: 1.2,   // More panicked movement
        initialized: false
    };
}

/**
 * Update scattering behavior each frame
 * Particles flee away from center with panic
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X position
 * @param {number} centerY - Orb center Y position
 */
function updateScattering(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // Initialize flee direction if not done
    if (!data.initialized) {
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
            particle.vx = (dx / distance) * data.fleeSpeed;
            particle.vy = (dy / distance) * data.fleeSpeed;
        } else {
            // If at center, pick random direction
            const angle = Math.random() * PHYSICS.TWO_PI;
            particle.vx = Math.cos(angle) * data.fleeSpeed;
            particle.vy = Math.sin(angle) * data.fleeSpeed;
        }
        data.initialized = true;
    }
    
    // Continue fleeing with panic factor
    const dx = particle.x - centerX;
    const dy = particle.y - centerY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance > 0) {
        // Add acceleration away from center
        particle.vx += (dx / distance) * data.panicFactor * 0.01 * dt;
        particle.vy += (dy / distance) * data.panicFactor * 0.01 * dt;
    }
    
    // Add nervous jitter
    particle.vx += (Math.random() - 0.5) * 0.1 * dt;
    particle.vy += (Math.random() - 0.5) * 0.1 * dt;
    
    // Apply friction
    particle.vx *= Math.pow(0.98, dt);
    particle.vy *= Math.pow(0.98, dt);
}

// Export behavior definition for registry
var scattering = {
    name: 'scattering',
    emoji: '😨',
    description: 'Particles flee from center in panic',
    initialize: initializeScattering,
    update: updateScattering
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Repelling Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Particles pushed away from center for aversion states
 * @author Emotive Engine Team
 * @module particles/behaviors/repelling
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a space of rejection with particles being pushed away from the center,    
 * ║ maintaining a minimum distance. Conveys disgust, rejection, and boundaries.       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    ← - - - →
 *    ↖       ↗       ← particles pushed away
 *  - - (  ) - -      ← empty zone around center
 *    ↙       ↘       ← minimum distance maintained
 *    ← - - - →
 * 
 * USED BY EMOTIONS:
 * - disgust (keeping things at bay)
 * - contempt
 * - aversion
 * 
 * RECIPE TO MODIFY:
 * - Increase repelStrength for stronger push
 * - Increase minDistance for larger empty zone
 * - Adjust damping for smoother/rougher motion
 */


/**
 * Initialize repelling behavior for a particle
 * Sets up repulsion from center
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeRepelling(particle) {
    particle.vx = 0;
    particle.vy = 0;
    particle.lifeDecay = 0.01; // Moderate life
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        repelStrength: 0.8,      // How strongly to push away
        minDistance: 50,         // Minimum distance from center
        initialized: false       // Track if initial repel has been applied
    };
}

/**
 * Update repelling behavior - particles maintain distance from center
 * 
 * Used for: DISGUST emotion (keeping unpleasant things away)
 * Visual effect: Particles are pushed away from center and maintain a 
 *                minimum distance, creating an empty zone
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (canvas center)
 * @param {number} centerY - Y coordinate of the orb's center (canvas center)
 */
function updateRepelling(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // STEP 1: Calculate distance from center
    // dx/dy = distance from center to particle (can be negative)
    const dx = particle.x - centerX;
    const dy = particle.y - centerY;
    // dist = straight-line distance using Pythagorean theorem
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // STEP 2: Apply repelling force if too close to center
    // This ensures particles maintain minimum distance
    if (!data.initialized || distance < data.minDistance) {
        if (distance > 0) {
            // Calculate repel force (stronger when closer)
            // Math.max(distance, 5) prevents division by very small numbers
            const repelForce = data.repelStrength / Math.max(distance, 5);
            
            // Apply force in direction away from center
            // dx/distance = unit vector component pointing away
            // Multiply by dt for frame-rate independence
            particle.vx += (dx / distance) * repelForce * dt;
            particle.vy += (dy / distance) * repelForce * dt;
        }
        data.initialized = true;
    }
    
    // STEP 3: Apply gentle damping to smooth motion
    // This prevents infinite acceleration and creates natural deceleration
    // Math.pow ensures frame-rate independence
    particle.vx *= Math.pow(0.99, dt);
    particle.vy *= Math.pow(0.99, dt);
}

// Export behavior definition for registry
var repelling = {
    name: 'repelling',
    emoji: '🚫',
    description: 'Particles pushed away from center, maintaining distance',
    initialize: initializeRepelling,
    update: updateRepelling
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Connecting Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Chaotic particles drawn to center for social connection states
 * @author Emotive Engine Team
 * @module particles/behaviors/connecting
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates an energetic social atmosphere with particles moving chaotically but       
 * ║ staying connected to the center. Like a lively party or bustling community.       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    ↗↘ ↖↙ ↗↘
 *   ↙ ↗ ↘ ↖ ↙       ← chaotic but connected
 *  ↘ ↖ ⭐ ↗ ↙       ← drawn to center
 *   ↗ ↙ ↖ ↘ ↗       ← higher energy than ambient
 *    ↙↖ ↗↘ ↙↖
 * 
 * USED BY EMOTIONS:
 * - curiosity (social exploration)
 * - playfulness
 * - engagement
 * 
 * RECIPE TO MODIFY:
 * - Increase attractionForce for stronger pull to center
 * - Increase chaosFactor for more erratic movement
 * - Decrease friction for more energetic motion
 */


/**
 * Initialize connecting behavior for a particle
 * Sets up chaotic but connected movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeConnecting(particle) {
    // Original Emotive connecting: speed 2-7, higher chaos
    const angle = Math.random() * PHYSICS.TWO_PI;
    const speed = 2 + Math.random() * 5; // Faster than ambient
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.lifeDecay = 0.012; // Shorter life for more dynamic feel
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        // Higher attraction and chaos for connecting state
        attractionForce: 0.008,  // Stronger pull (original)
        chaosFactor: 1.0,        // Higher chaos (original)
        friction: 0.95          // Less friction than ambient
    };
}

/**
 * Update connecting behavior - chaotic movement with center attraction
 * 
 * Used for: CURIOSITY/SOCIAL emotions (engaged, exploring, connecting)
 * Visual effect: Particles move chaotically but are drawn back to center,
 *                creating a bustling, connected atmosphere
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (canvas center)
 * @param {number} centerY - Y coordinate of the orb's center (canvas center)
 */
function updateConnecting(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // STEP 1: Apply friction to slow particles gradually
    // This prevents infinite acceleration
    // Math.pow ensures frame-rate independence
    particle.vx *= Math.pow(data.friction, dt);
    particle.vy *= Math.pow(data.friction, dt);
    
    // STEP 2: Apply attraction force towards center
    // (centerX - this.x) gives direction vector to center
    // Multiplied by attractionForce to control strength
    const attractX = (centerX - particle.x) * data.attractionForce;
    const attractY = (centerY - particle.y) * data.attractionForce;
    
    // STEP 3: Add chaos for erratic movement
    // (Math.random() - 0.5) gives random value between -0.5 and 0.5
    // Multiplied by chaosFactor for intensity
    const chaosX = (Math.random() - 0.5) * data.chaosFactor;
    const chaosY = (Math.random() - 0.5) * data.chaosFactor;
    
    // STEP 4: Combine forces
    // Attraction keeps particles connected to center
    // Chaos makes movement unpredictable and lively
    particle.vx += attractX + chaosX;
    particle.vy += attractY + chaosY;
}

// Export behavior definition for registry
var connecting = {
    name: 'connecting',
    emoji: '🔗',
    description: 'Chaotic movement with center attraction for social states',
    initialize: initializeConnecting,
    update: updateConnecting
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Resting Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Ultra-slow movement for deeply relaxed states
 * @author Emotive Engine Team
 * @module particles/behaviors/resting
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates an atmosphere of deep calm and rest. Particles barely move, creating      
 * ║ a meditative, peaceful environment. Like watching dust motes in sunlight.         
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ·
 *       · ·         ← barely moving
 *      · · ·        ← vertical drift only
 *     · ⭐ ·        ← no horizontal motion
 *      · · ·        
 *       · ·         
 *        ·
 * 
 * USED BY EMOTIONS:
 * - sleepy (deep rest)
 * - meditative
 * - tranquil
 * 
 * RECIPE TO MODIFY:
 * - Decrease upwardSpeed for even slower movement
 * - Increase lifeDecay for shorter-lived particles
 * - Add tiny horizontal drift for slight variation
 */


/**
 * Initialize resting behavior for a particle
 * Sets up minimal movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeResting(particle) {
    particle.vx = 0;  // NO horizontal movement
    particle.vy = -0.01;  // Tiniest upward drift
    particle.lifeDecay = 0.001;  // Very slow fade - particles last 10+ seconds
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        upwardSpeed: 0.00002,  // Barely perceptible upward drift
        friction: 0.999       // Almost no friction (preserve any motion)
    };
}

/**
 * Update resting behavior - ultra-slow vertical drift
 * 
 * Used for: SLEEPY/MEDITATIVE emotions (deep rest, tranquility)
 * Visual effect: Particles drift upward so slowly they appear almost still,
 *                creating a deeply peaceful atmosphere
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (unused)
 * @param {number} centerY - Y coordinate of the orb's center (unused)
 */
function updateResting(particle, dt, _centerX, _centerY) {
    const data = particle.behaviorData;
    
    // STEP 1: Apply friction to vertical velocity only
    // This creates a very gentle deceleration
    // Math.pow ensures frame-rate independence
    particle.vy *= Math.pow(data.friction, dt);
    
    // STEP 2: Add tiny continuous upward drift
    // Negative value because canvas Y increases downward
    // Multiplied by dt for frame-rate independence
    particle.vy -= data.upwardSpeed * dt;
    
    // STEP 3: Enforce NO horizontal movement
    // This creates the characteristic vertical-only drift
    // Essential for the peaceful, non-chaotic feel
    particle.vx = 0;
}

// Export behavior definition for registry
var resting = {
    name: 'resting',
    emoji: '😴',
    description: 'Ultra-slow vertical drift for deep rest states',
    initialize: initializeResting,
    update: updateResting
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Radiant Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Particles radiating outward like sun rays for euphoric states
 * @author Emotive Engine Team
 * @module particles/behaviors/radiant
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a euphoric atmosphere with particles bursting outward like sunbeams,      
 * ║ with shimmering and twinkling effects. Perfect for moments of pure joy and hope.  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ☀️
 *    ✨  ↗  ✨       ← particles radiate outward
 *  ✨ ↖ ⭐ ↗ ✨     ← orb center (like the sun)
 *    ✨  ↘  ✨       ← with shimmer effect
 *        ☀️
 * 
 * USED BY EMOTIONS:
 * - euphoria (first day of spring, sunrise vibes)
 * - elation
 * - triumph
 * 
 * RECIPE TO MODIFY:
 * - Increase radialSpeed for faster radiation
 * - Increase shimmerSpeed for faster twinkling
 * - Adjust friction for longer/shorter rays
 */


/**
 * Initialize radiant behavior for a particle
 * Sets up sunburst radiation pattern
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeRadiant(particle) {
    // Particles burst outward from center like sunbeams
    const angle = Math.random() * PHYSICS.TWO_PI;
    const speed = 0.8 + Math.random() * 0.4; // Moderate to fast speed
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.lifeDecay = 0.006; // Moderate life - last ~8-10 seconds
    
    // Use emotion colors if provided, otherwise default sunrise colors
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    } else {
        // Default golden sunrise colors
        const colors = ['#FFD700', '#FFB347', '#FFA500', '#FF69B4'];
        particle.color = selectWeightedColor(colors);
    }
    
    // More particles have glow for radiant effect
    particle.hasGlow = Math.random() < 0.7; // 70% chance of glow
    particle.glowSizeMultiplier = particle.hasGlow ? (1.5 + Math.random() * 0.5) : 0;
    
    particle.behaviorData = {
        // Continuous outward radiation
        radialSpeed: 0.02,        // Constant outward acceleration
        shimmer: Math.random() * PHYSICS.TWO_PI, // Initial shimmer phase
        shimmerSpeed: 0.1,        // Shimmer oscillation speed
        friction: 0.99            // Very light friction for long rays
    };
}

/**
 * Update radiant behavior - particles radiate outward like sun rays
 * 
 * Used for: EUPHORIA emotion (first day of spring, sunrise vibes)
 * Visual effect: Particles burst outward from center like sunbeams, with a 
 *                shimmering/twinkling effect as they travel
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (canvas center)
 * @param {number} centerY - Y coordinate of the orb's center (canvas center)
 */
function updateRadiant(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // STEP 1: Calculate this particle's direction from the orb center
    // dx/dy = distance from center to particle (can be negative)
    const dx = particle.x - centerX;
    const dy = particle.y - centerY;
    // dist = straight-line distance using Pythagorean theorem
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    // STEP 2: Push particle outward from center (like sun rays)
    if (dist > 0) {
        // Convert dx/dy into a unit vector (length = 1) pointing away from center
        // This gives us pure direction without magnitude
        const dirX = dx / dist;
        const dirY = dy / dist;
        
        // Add velocity in the outward direction
        // radialSpeed controls how fast particles shoot outward
        // Multiply by dt to make movement frame-rate independent
        particle.vx += dirX * data.radialSpeed * dt;
        particle.vy += dirY * data.radialSpeed * dt;
    }
    
    // STEP 3: Create shimmering effect (particles twinkle as they radiate)
    // Increment shimmer phase over time (shimmerSpeed controls twinkle rate)
    data.shimmer += data.shimmerSpeed * dt;
    // Create sine wave oscillation (-1 to 1)
    const shimmerEffect = Math.sin(data.shimmer);
    // Make particle size pulse: baseSize ± 20%
    particle.size = particle.baseSize * (1 + shimmerEffect * 0.2);
    // Make particle opacity pulse: baseOpacity ± 30%
    particle.opacity = particle.baseOpacity * (1 + shimmerEffect * 0.3);
    
    // STEP 4: Apply friction to slow particles over time
    // This prevents infinite acceleration and creates natural deceleration
    particle.vx *= Math.pow(data.friction, dt);
    particle.vy *= Math.pow(data.friction, dt);
}

// Export behavior definition for registry
var radiant = {
    name: 'radiant',
    emoji: '☀️',
    description: 'Particles radiate outward like sunbeams',
    initialize: initializeRadiant,
    update: updateRadiant
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Ascending Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Slow, steady upward float for zen and meditative states
 * @author Emotive Engine Team
 * @module particles/behaviors/ascending
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a zen atmosphere with particles rising like incense smoke. Slow, steady,  
 * ║ and ethereal movement that gradually fades as particles ascend.                   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ↑
 *       ~~~        ← gentle wave motion
 *        ↑
 *       ~~~        ← like incense smoke
 *        ↑
 *      ⭐⭐⭐      ← orb center
 *        
 * 
 * USED BY EMOTIONS:
 * - zen (deep meditation)
 * - contemplative
 * - spiritual
 * 
 * RECIPE TO MODIFY:
 * - Decrease ascensionSpeed for slower rise
 * - Increase waveFactor for more horizontal drift
 * - Adjust fadeStartDistance to control when fade begins
 */


/**
 * Initialize ascending behavior for a particle
 * Sets up slow, steady upward movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeAscending(particle) {
    // Very slow, steady upward movement
    particle.vx = (Math.random() - 0.5) * 0.02;  // Minimal horizontal drift
    particle.vy = -0.03 - Math.random() * 0.02;  // Slow upward movement (0.03-0.05)
    particle.lifeDecay = 0.0008;  // Very long-lived particles (30+ seconds)
    
    // Larger, more ethereal particles for zen
    particle.size = (6 + Math.random() * 6) * 
        (particle.scaleFactor || 1) * 
        (particle.particleSizeMultiplier || 1) * 
        1.33;  // 1.33x larger for zen (reduced from 2x)
    particle.baseSize = particle.size;
    particle.baseOpacity = 0.2 + Math.random() * 0.2;  // Very translucent (20-40%)
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        // Continuous gentle upward drift
        ascensionSpeed: 0.0003,      // Very gentle continuous upward
        waveFactor: 0.5,             // Subtle horizontal wave motion
        waveFrequency: 0.001,        // Very slow wave oscillation
        friction: 0.998,             // Almost no slowdown
        fadeStartDistance: 100       // Start fading after rising 100px
    };
}

/**
 * Update ascending behavior - slow upward float like incense
 * 
 * Used for: ZEN/CONTEMPLATIVE emotions (meditation, spirituality)
 * Visual effect: Particles rise slowly and steadily with subtle wave motion,
 *                gradually fading as they ascend like incense smoke
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (unused)
 * @param {number} centerY - Y coordinate of the orb's center (unused)
 */
function updateAscending(particle, dt, _centerX, _centerY) {
    const data = particle.behaviorData;
    
    // Validate data exists
    if (!data) {
        initializeAscending(particle);
        return;
    }
    
    // STEP 1: Apply friction to velocities
    // Very light friction to maintain smooth motion
    // Math.pow ensures frame-rate independence
    particle.vx *= Math.pow(data.friction, dt);
    particle.vy *= Math.pow(data.friction, dt);
    
    // STEP 2: Add continuous upward ascension
    // Negative because canvas Y increases downward
    // Multiplied by dt for frame-rate independence
    particle.vy -= data.ascensionSpeed * dt;
    
    // STEP 3: Add subtle wave motion for organic feel
    // Creates the characteristic incense smoke waviness
    // Age gives us time-based oscillation
    const waveOffset = Math.sin(particle.age * data.waveFrequency * 1000) * data.waveFactor;
    particle.vx += waveOffset * 0.001 * dt;
    
    // STEP 4: Track initial Y position for fade calculation
    if (particle.initialY === undefined) {
        particle.initialY = particle.y;
    }
    
    // STEP 5: Calculate distance traveled upward
    const distanceTraveled = particle.initialY - particle.y;
    
    // STEP 6: Start fading after traveling fadeStartDistance pixels
    // This creates the incense smoke dissipation effect
    if (distanceTraveled > data.fadeStartDistance) {
        const fadeProgress = (distanceTraveled - data.fadeStartDistance) / 100;
        const fadeFactor = Math.max(0, 1 - fadeProgress);
        particle.baseOpacity *= 0.995;  // Gradual fade
        
        // Accelerate life decay as particle fades
        if (fadeFactor < 0.5) {
            particle.lifeDecay *= 1.02;
        }
    }
    
    // STEP 7: Dampen excessive horizontal movement
    // Keeps the ascension primarily vertical
    if (Math.abs(particle.vx) > 0.05) {
        particle.vx *= Math.pow(0.95, dt);
    }
    
    // STEP 8: Cap upward velocity for consistency
    // Prevents particles from accelerating too much
    if (particle.vy < -0.1) {
        particle.vy = -0.1;
    }
}

// Export behavior definition for registry
var ascending = {
    name: 'ascending',
    emoji: '🧘',
    description: 'Slow steady upward float like incense smoke',
    initialize: initializeAscending,
    update: updateAscending
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Erratic Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Nervous, jittery movement for anxious states
 * @author Emotive Engine Team
 * @module particles/behaviors/erratic
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a nervous, unstable atmosphere with particles jittering and changing       
 * ║ direction unpredictably. Conveys anxiety, nervousness, and instability.           
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    ↗↙↖  ↘↗
 *   ↙ ↗↘  ↖↙       ← unpredictable changes
 *  ↘↖ ⭐ ↗↙        ← jittery movement
 *   ↗ ↙↖  ↘↗       ← nervous energy
 *    ↙↗↘  ↖↙
 * 
 * USED BY EMOTIONS:
 * - nervous (anxiety, jitters)
 * - unstable
 * - agitated
 * 
 * RECIPE TO MODIFY:
 * - Increase jitterStrength for more shaking
 * - Increase directionChangeRate for more frequent changes
 * - Increase speedVariation for more erratic speed changes
 */


/**
 * Initialize erratic behavior for a particle
 * Sets up nervous, jittery movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeErratic(particle) {
    // Random, chaotic initial direction
    const angle = Math.random() * PHYSICS.TWO_PI;
    const speed = 0.1 + Math.random() * 0.15;
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.lifeDecay = 0.004;  // Shorter lived due to nervous energy
    
    particle.size = (2 + Math.random() * 4) * 
        (particle.scaleFactor || 1) * 
        (particle.particleSizeMultiplier || 1);  // Varied sizes scaled
    particle.baseSize = particle.size;
    particle.baseOpacity = 0.4 + Math.random() * 0.3;  // More visible
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        jitterStrength: 0.02,        // Random direction changes
        directionChangeRate: 0.1,    // How often to change direction
        speedVariation: 0.3,         // Speed changes randomly
        spinRate: 0.05 + Math.random() * 0.1  // Particles spin
    };
}

/**
 * Update erratic behavior - nervous, jittery movement
 * 
 * Used for: NERVOUS/ANXIOUS emotions (anxiety, instability, agitation)
 * Visual effect: Particles jitter nervously, changing direction and speed
 *                unpredictably, creating an unstable atmosphere
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (unused)
 * @param {number} centerY - Y coordinate of the orb's center (unused)
 */
function updateErratic(particle, dt) {
    const data = particle.behaviorData;
    
    // STEP 1: Add constant jitter to movement
    // Creates the nervous shaking effect
    // (Math.random() - 0.5) gives values between -0.5 and 0.5
    // Multiplied by jitterStrength and dt for controlled chaos
    particle.vx += (Math.random() - 0.5) * data.jitterStrength * dt;
    particle.vy += (Math.random() - 0.5) * data.jitterStrength * dt;
    
    // STEP 2: Randomly change direction occasionally
    // Creates unpredictable movement patterns
    // Math.min ensures probability doesn't exceed reasonable bounds
    if (Math.random() < Math.min(data.directionChangeRate * dt, 0.5)) {
        // Pick new random direction
        const newAngle = Math.random() * PHYSICS.TWO_PI;
        const currentSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        
        // Apply new direction while maintaining similar speed
        particle.vx = Math.cos(newAngle) * currentSpeed;
        particle.vy = Math.sin(newAngle) * currentSpeed;
    }
    
    // STEP 3: Vary the speed randomly
    // Creates erratic acceleration/deceleration
    const speedMultiplier = 1 + (Math.random() - 0.5) * data.speedVariation * dt;
    particle.vx *= speedMultiplier;
    particle.vy *= speedMultiplier;
    
    // STEP 4: Apply spin to particle size
    // Makes particles appear to rotate/vibrate
    const spinPhase = particle.age * data.spinRate * 1000;
    particle.size = particle.baseSize * (1 + Math.sin(spinPhase) * 0.2);
    
    // STEP 5: Fluctuate opacity nervously
    // Creates a flickering effect
    particle.opacity = particle.baseOpacity * (0.8 + Math.random() * 0.4);
    
    // STEP 6: Apply damping to prevent infinite acceleration
    // Keeps movement bounded
    particle.vx *= Math.pow(0.98, dt);
    particle.vy *= Math.pow(0.98, dt);
    
    // STEP 7: Cap maximum velocity
    // Prevents particles from moving too fast
    const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
    if (speed > 0.5) {
        particle.vx = (particle.vx / speed) * 0.5;
        particle.vy = (particle.vy / speed) * 0.5;
    }
}

// Export behavior definition for registry
var erratic = {
    name: 'erratic',
    emoji: '😰',
    description: 'Nervous jittery movement for anxious states',
    initialize: initializeErratic,
    update: updateErratic
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Cautious Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Slow, careful movement with pauses for suspicious states
 * @author Emotive Engine Team
 * @module particles/behaviors/cautious
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a watchful, suspicious atmosphere with particles moving slowly and         
 * ║ pausing frequently, as if carefully observing. Like being on guard.               
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    · → · STOP
 *   STOP ← ·        ← move, then pause
 *    · ⭐ ·         ← watching center
 *   · STOP →        ← pause, then move
 *    STOP · ← ·
 * 
 * USED BY EMOTIONS:
 * - suspicion (watchful, guarded)
 * - uncertainty
 * - wariness
 * 
 * RECIPE TO MODIFY:
 * - Increase pauseDuration for longer stops
 * - Decrease moveDuration for shorter movements
 * - Adjust watchRadius to control patrol area
 */


/**
 * Initialize cautious behavior for a particle
 * Sets up slow, deliberate movement patterns
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeCautious(particle) {
    // Particles move very slowly and deliberately
    const angle = Math.random() * PHYSICS.TWO_PI;
    const speed = 0.02 + Math.random() * 0.03; // Very slow: 0.02-0.05 units/frame
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.lifeDecay = 0.001;  // Very long-lived for visibility
    particle.life = 1.0;  // Ensure full life
    
    particle.size = (4 + Math.random() * 4) * 
        (particle.scaleFactor || 1) * 
        (particle.particleSizeMultiplier || 1);
    particle.baseSize = particle.size;
    particle.baseOpacity = 0.8 + Math.random() * 0.2;  // Very visible (80-100%)
    particle.opacity = particle.baseOpacity;
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        pauseTimer: Math.random() * 2,      // Start with random pause offset
        pauseDuration: 0.5 + Math.random() * 0.5,  // Pause for 0.5-1s
        moveDuration: 1 + Math.random() * 0.5,     // Move for 1-1.5s
        isMoving: Math.random() > 0.5,             // Randomly start moving or paused
        moveTimer: 0,
        originalVx: particle.vx,
        originalVy: particle.vy,
        watchRadius: 50 + Math.random() * 30       // Stay within 50-80 units of core
    };
}

/**
 * Update cautious behavior - slow movement with frequent pauses
 * 
 * Used for: SUSPICION/UNCERTAINTY emotions (watchful, guarded, wary)
 * Visual effect: Particles move slowly and deliberately, pausing frequently
 *                as if carefully observing their surroundings
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center
 * @param {number} centerY - Y coordinate of the orb's center
 */
function updateCautious(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // STEP 1: Update movement timer
    // Tracks how long we've been in current state (moving or paused)
    data.moveTimer += dt;
    
    // STEP 2: Switch between moving and pausing states
    if (data.isMoving) {
        // Currently moving - check if time to pause
        if (data.moveTimer > data.moveDuration) {
            data.isMoving = false;
            data.moveTimer = 0;
            // Stop movement during pause (watchful stillness)
            particle.vx = 0;
            particle.vy = 0;
        } else {
            // Continue moving at cautious speed
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
        }
    } else {
        // Currently paused - check if time to move
        if (data.moveTimer > data.pauseDuration) {
            data.isMoving = true;
            data.moveTimer = 0;
            // Pick a new careful direction
            const angle = Math.random() * PHYSICS.TWO_PI;
            const speed = 0.02 + Math.random() * 0.03;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed;
            // Store for next movement phase
            data.originalVx = particle.vx;
            data.originalVy = particle.vy;
        }
    }
    
    // STEP 3: Keep particles within watch radius of core
    // They're suspicious, so they don't stray too far
    const dx = particle.x - centerX;
    const dy = particle.y - centerY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist > data.watchRadius) {
        // Pull back towards core slowly (maintaining caution)
        const pullStrength = 0.02;
        particle.vx -= (dx / dist) * pullStrength * dt;
        particle.vy -= (dy / dist) * pullStrength * dt;
    }
    
    // STEP 4: Apply very light damping
    // Keeps movement controlled and deliberate
    particle.vx *= Math.pow(0.995, dt);
    particle.vy *= Math.pow(0.995, dt);
    
    // STEP 5: Subtle opacity flicker during pauses
    // Creates a watchful "blinking" effect
    if (!data.isMoving) {
        particle.opacity = particle.baseOpacity * (0.9 + Math.sin(particle.age * 5) * 0.1);
    } else {
        particle.opacity = particle.baseOpacity;
    }
}

// Export behavior definition for registry
var cautious = {
    name: 'cautious',
    emoji: '🤨',
    description: 'Slow careful movement with watchful pauses',
    initialize: initializeCautious,
    update: updateCautious
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Surveillance Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Searchlight scanning behavior for suspicious/paranoid states
 * @author Emotive Engine Team
 * @module particles/behaviors/surveillance
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║ CONCEPT                                                                           
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Particles act like searchlights or surveillance cameras, slowly scanning back     
 * ║ and forth in arcs, pausing at edges, occasionally darting to new positions.       
 * ║ Creates a paranoid, watchful atmosphere with deliberate, searching movements.     
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 * 
 * BEHAVIOR PATTERN:
 * • Slow horizontal scanning arcs (like searchlights)
 * • Pause at scan extremes (checking corners)
 * • Occasional quick darts to new positions (alert response)
 * • Some particles patrol perimeter (edge surveillance)
 * • Random freezing in place (listening/watching)
 * 
 * ┌──────────────────────────────────────────────────────────────────────────────────┐
 * │  VISUAL: Searchlight Scanning                                                    │
 * │                                                                                   │
 * │     ←─────────────→  (slow scan)                                                │
 * │    •               •                                                             │
 * │                                                                                   │
 * │   pause...     ...pause                                                         │
 * │                                                                                   │
 * │     DART! ──→ • (quick repositioning)                                          │
 * └──────────────────────────────────────────────────────────────────────────────────┘
 */


var surveillance = {
    name: 'surveillance',
    emoji: '👁️',
    description: 'Searchlight scanning with paranoid watchfulness',
    
    /**
     * Initialize particle state for surveillance behavior
     */
    initialize(particle, _config) {
        // Set particle color from emotion palette
        if (particle.emotionColors && particle.emotionColors.length > 0) {
            particle.color = selectWeightedColor(particle.emotionColors);
        }
        
        particle.behaviorState = {
            // Scanning properties
            scanAngle: Math.random() * Math.PI - Math.PI/2,  // Current scan angle
            scanDirection: Math.random() < 0.5 ? 1 : -1,      // Scan direction
            scanSpeed: 0.3 + Math.random() * 0.2,             // Individual scan rate
            scanRange: Math.PI/3 + Math.random() * Math.PI/4, // Scan arc size
            scanCenter: Math.random() * Math.PI * 2,          // Center of scan arc
            pauseTimer: 0,                                     // Pause at edges
            pauseDuration: 500 + Math.random() * 500,         // How long to pause
            
            // Movement states
            mode: 'scanning',  // 'scanning', 'darting', 'frozen', 'patrolling'
            modeTimer: 0,
            nextModeChange: 2000 + Math.random() * 3000,
            
            // Dart properties
            dartTarget: { x: 0, y: 0 },
            dartSpeed: 0,
            
            // Patrol properties
            patrolRadius: 150 + Math.random() * 100,
            patrolAngle: Math.random() * Math.PI * 2,
            
            // Threat response
            alertLevel: 0,
            lastPosition: { x: particle.x, y: particle.y }
        };
        
        // Assign roles: 70% scanners, 20% patrollers, 10% watchers
        const role = Math.random();
        if (role < 0.7) {
            particle.behaviorState.primaryRole = 'scanner';
        } else if (role < 0.9) {
            particle.behaviorState.primaryRole = 'patroller';
            particle.behaviorState.mode = 'patrolling';
        } else {
            particle.behaviorState.primaryRole = 'watcher';
            particle.behaviorState.mode = 'frozen';
        }
    },
    
    /**
     * Update particle physics for surveillance behavior
     */
    update(particle, dt, config) {
        const state = particle.behaviorState;
        if (!state) return;
        
        // Update mode timer
        state.modeTimer += dt * 16;
        
        // Check for mode changes
        if (state.modeTimer > state.nextModeChange) {
            this.changeMode(particle, state, config);
            state.modeTimer = 0;
            state.nextModeChange = 2000 + Math.random() * 4000;
        }
        
        // Update based on current mode
        switch(state.mode) {
        case 'scanning':
            this.updateScanning(particle, dt, state, config);
            break;
        case 'darting':
            this.updateDarting(particle, dt, state, config);
            break;
        case 'frozen':
            this.updateFrozen(particle, dt, state, config);
            break;
        case 'patrolling':
            this.updatePatrolling(particle, dt, state, config);
            break;
        }
        
        // Apply slight downward drift for weight
        particle.vy += 0.05 * dt;
        
        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;
        
        // Store last position
        state.lastPosition.x = particle.x;
        state.lastPosition.y = particle.y;
    },
    
    /**
     * Scanning mode - slow searchlight sweeps
     */
    updateScanning(particle, dt, state, _config) {
        // Update scan angle
        if (state.pauseTimer > 0) {
            // Pausing at edge of scan
            state.pauseTimer -= dt * 16;
            particle.vx *= 0.9;  // Slow down during pause
            particle.vy *= 0.9;
        } else {
            // Active scanning
            state.scanAngle += state.scanDirection * state.scanSpeed * dt * 0.02;
            
            // Check scan limits and pause at edges
            if (Math.abs(state.scanAngle) > state.scanRange / 2) {
                state.scanDirection *= -1;
                state.pauseTimer = state.pauseDuration;
                state.scanAngle = Math.sign(state.scanAngle) * state.scanRange / 2;
            }
        }
        
        // Apply scanning motion
        const actualAngle = state.scanCenter + state.scanAngle;
        const speed = 0.8 + state.alertLevel * 0.5;
        particle.vx = Math.cos(actualAngle) * speed;
        particle.vy = Math.sin(actualAngle) * speed * 0.3;  // Less vertical movement
    },
    
    /**
     * Darting mode - quick repositioning
     */
    updateDarting(particle, dt, state, _config) {
        const dx = state.dartTarget.x - particle.x;
        const dy = state.dartTarget.y - particle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 5) {
            // Move toward dart target quickly
            particle.vx = (dx / distance) * state.dartSpeed;
            particle.vy = (dy / distance) * state.dartSpeed;
        } else {
            // Reached target, switch back to scanning
            state.mode = 'scanning';
            state.modeTimer = 0;
        }
    },
    
    /**
     * Frozen mode - watchful stillness
     */
    updateFrozen(particle, _dt, _state, _config) {
        // Almost no movement, just tiny vibrations
        particle.vx *= 0.95;
        particle.vy *= 0.95;
        
        // Occasional tiny twitch
        if (Math.random() < 0.01) {
            particle.vx += (Math.random() - 0.5) * 0.5;
            particle.vy += (Math.random() - 0.5) * 0.5;
        }
    },
    
    /**
     * Patrolling mode - edge surveillance
     */
    updatePatrolling(particle, dt, state, config) {
        // Patrol in a circle around the edge
        state.patrolAngle += 0.01 * dt;

        // Calculate target position relative to core center
        const coreX = config.corePosition?.x ?? config.canvasWidth / 2;
        const coreY = config.corePosition?.y ?? config.canvasHeight / 2;

        const targetX = coreX + Math.cos(state.patrolAngle) * state.patrolRadius;
        const targetY = coreY + Math.sin(state.patrolAngle) * state.patrolRadius;

        // Move toward patrol position
        const dx = targetX - particle.x;
        const dy = targetY - particle.y;

        particle.vx = dx * 0.02;
        particle.vy = dy * 0.02;
    },
    
    /**
     * Change behavior mode
     */
    changeMode(particle, state, config) {
        const rand = Math.random();

        // Get core position for relative positioning
        const coreX = config?.corePosition?.x ?? (config?.canvasWidth / 2 || particle.x);
        const coreY = config?.corePosition?.y ?? (config?.canvasHeight / 2 || particle.y);

        // Mode transition probabilities based on role
        if (state.primaryRole === 'scanner') {
            if (rand < 0.1) {
                // Dart to new position (relative to core)
                state.mode = 'darting';
                state.dartTarget = {
                    x: coreX + (Math.random() - 0.5) * 200,
                    y: coreY + (Math.random() - 0.5) * 200
                };
                state.dartSpeed = 3 + Math.random() * 2;
            } else if (rand < 0.2) {
                // Freeze and watch
                state.mode = 'frozen';
            } else {
                // Continue scanning
                state.mode = 'scanning';
            }
        } else if (state.primaryRole === 'patroller') {
            if (rand < 0.1) {
                state.mode = 'frozen';
            } else {
                state.mode = 'patrolling';
            }
        } else {
            // Watcher role
            if (rand < 0.3) {
                state.mode = 'scanning';
            } else {
                state.mode = 'frozen';
            }
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Glitchy Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Digital glitch behavior with stuttering orbits and corruption
 * @author Emotive Engine Team
 * @module particles/behaviors/glitchy
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║ CONCEPT                                                                           
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Particles orbit like in love state but with digital glitches, stutters, and      
 * ║ corruption artifacts. Creates a captivating dubstep-like visual rhythm.           
 * ║ Combines smooth orbiting with sudden position jumps and digital artifacts.        
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 * 
 * BEHAVIOR PATTERN:
 * • Base orbiting motion (like love state)
 * • Random position jumps (teleportation glitches)
 * • Stuttering/freezing (frame drops)
 * • Trail duplication (ghosting artifacts)
 * • RGB channel separation
 * • Digital noise bursts
 * 
 * ┌──────────────────────────────────────────────────────────────────────────────────┐
 * │  VISUAL: Glitched Orbiting                                                       │
 * │                                                                                   │
 * │       ░░▒▒▓▓█  ←─ Digital trail                                                 │
 * │     •  ┊  •                                                                      │
 * │   •┊  ⚡  ┊•  ←─ Glitch jump                                                    │
 * │     •  ┊  •                                                                      │
 * │       ░░▒▒▓▓█                                                                    │
 * └──────────────────────────────────────────────────────────────────────────────────┘
 */


var glitchy = {
    name: 'glitchy',
    emoji: '⚡',
    description: 'Digital glitch with stuttering orbits and corruption',
    
    // Rhythm configuration for glitchy behavior
    rhythm: {
        enabled: true,
        
        // Glitch events sync to rhythm
        glitchTiming: {
            mode: 'subdivision',     // Glitch on subdivisions
            subdivision: 'sixteenth', // 16th notes for rapid glitches
            probability: 0.3,        // 30% chance on each 16th
            intensityOnBeat: 2.0,    // Stronger glitches on beat
            intensityOffBeat: 0.5    // Weaker between beats
        },
        
        // Stutter/freeze timing
        stutterSync: {
            mode: 'pattern',         // Based on rhythm pattern
            patterns: {
                'dubstep': {
                    freezeOnDrop: true,  // Freeze on the drop (beat 3)
                    dropDuration: 100    // Freeze for 100ms
                },
                'breakbeat': {
                    randomFreeze: 0.1,   // 10% chance per beat
                    duration: 50         // Short 50ms freezes
                }
            }
        },
        
        // Orbital speed modulation
        orbitRhythm: {
            baseSpeed: 'tempo',      // Speed scales with BPM
            wobbleSync: 'eighth',    // Wobble on 8th notes
            beatAcceleration: 1.5,   // Speed boost on beat
            barReset: true           // Reset orbit angle each bar
        },
        
        // RGB split effect rhythm
        rgbSync: {
            enabled: true,
            amount: 'intensity',     // Split based on musical intensity
            direction: 'beat',        // Change split direction on beat
            maxSplit: 10             // Maximum pixel split
        },
        
        // Digital noise bursts
        noiseRhythm: {
            trigger: 'accent',       // Noise on accented beats
            duration: 50,            // 50ms noise bursts
            intensity: 'drop'        // Scale with drop intensity
        }
    },
    
    /**
     * Initialize particle state for glitchy behavior
     */
    initialize(particle, _config, _centerX, _centerY) {
        // Set particle color from emotion palette
        if (particle.emotionColors && particle.emotionColors.length > 0) {
            particle.color = selectWeightedColor(particle.emotionColors);
        }
        
        particle.behaviorState = {
            // Orbital properties (spread out from center)
            orbitAngle: Math.random() * Math.PI * 2,
            orbitRadius: 300 + Math.random() * 400,  // Dramatically increased to 300-700 for very wide spread
            orbitSpeed: 0.01 + Math.random() * 0.02,
            
            // Glitch properties
            glitchTimer: 0,
            nextGlitch: Math.random() * 500 + 100,
            isGlitching: false,
            glitchDuration: 0,
            glitchOffset: { x: 0, y: 0 },
            
            // Stutter properties
            stutterTimer: 0,
            nextStutter: Math.random() * 200 + 50,
            isFrozen: false,
            frozenPosition: { x: 0, y: 0 },
            frozenVelocity: { x: 0, y: 0 },
            
            // Trail ghost properties
            hasGhost: Math.random() < 0.3,
            ghostOffset: Math.random() * 20 + 10,
            ghostAngle: Math.random() * Math.PI * 2,
            
            // RGB separation
            rgbSplit: Math.random() < 0.4,
            rgbPhase: Math.random() * Math.PI * 2,
            
            // Digital noise
            noiseLevel: 0,
            noiseBurst: false,
            
            // Dubstep rhythm sync
            beatPhase: Math.random() * Math.PI * 2,
            beatFrequency: 0.05 + Math.random() * 0.03,
            dropIntensity: 0
        };
        
        // Special properties for glitch
        particle.lifeDecay = 0.0015; // Slower decay for trails
        particle.hasGlow = true; // Always glow for digital effect
        particle.glowSizeMultiplier = 3.0 + Math.random() * 2; // Much bigger glows for visibility
    },
    
    /**
     * Update particle physics for glitchy behavior
     */
    update(particle, dt, centerX, centerY) {
        const state = particle.behaviorState;
        if (!state) return;
        
        // centerX and centerY are passed correctly from updateBehavior
        // No need for fallbacks - they should always be provided
        
        // Update timers
        state.glitchTimer += dt * 16;
        state.stutterTimer += dt * 16;
        
        // Check for stutter/freeze
        if (state.stutterTimer > state.nextStutter) {
            if (!state.isFrozen) {
                // Start freeze
                state.isFrozen = true;
                state.frozenPosition = { x: particle.x, y: particle.y };
                state.frozenVelocity = { x: particle.vx, y: particle.vy };
                state.stutterTimer = 0;
                state.nextStutter = 20 + Math.random() * 40; // Short freeze
            } else {
                // End freeze
                state.isFrozen = false;
                state.stutterTimer = 0;
                state.nextStutter = 100 + Math.random() * 300;
                
                // Sometimes jump on unfreeze (larger jumps to maintain spread)
                if (Math.random() < 0.3) {
                    particle.x += (Math.random() - 0.5) * 60;  // Increased from 20 to 60
                    particle.y += (Math.random() - 0.5) * 60;  // Increased from 20 to 60
                }
            }
        }
        
        // Check for glitch events
        if (state.glitchTimer > state.nextGlitch && !state.isGlitching) {
            state.isGlitching = true;
            state.glitchDuration = 50 + Math.random() * 100;
            state.glitchOffset = {
                x: (Math.random() - 0.5) * 80,  // Increased from 30 to 80 for wider spread
                y: (Math.random() - 0.5) * 80   // Increased from 30 to 80 for wider spread
            };
            state.glitchTimer = 0;
            
            // Change color during glitch
            if (Math.random() < 0.5 && particle.emotionColors) {
                particle.color = selectWeightedColor(particle.emotionColors);
            }
        }
        
        // End glitch
        if (state.isGlitching && state.glitchTimer > state.glitchDuration) {
            state.isGlitching = false;
            state.glitchTimer = 0;
            state.nextGlitch = 200 + Math.random() * 800;
            state.glitchOffset = { x: 0, y: 0 };
        }
        
        // Update beat phase for dubstep rhythm
        state.beatPhase += state.beatFrequency * dt;
        const beatIntensity = Math.sin(state.beatPhase) * 0.5 + 0.5;
        
        // Calculate drop intensity (periodic bass drops)
        const dropCycle = state.beatPhase % (Math.PI * 4);
        if (dropCycle < Math.PI * 0.5) {
            state.dropIntensity = Math.min(1, state.dropIntensity + dt * 0.1);
        } else {
            state.dropIntensity = Math.max(0, state.dropIntensity - dt * 0.05);
        }
        
        if (!state.isFrozen) {
            // Update orbital position with beat modulation
            state.orbitAngle += state.orbitSpeed * dt * (1 + beatIntensity * 0.5);
            
            // Add drop wobble
            const wobbleRadius = state.orbitRadius * (1 + state.dropIntensity * 0.3 * Math.sin(state.beatPhase * 4));
            
            // Calculate target position relative to center
            let targetX = centerX + Math.cos(state.orbitAngle) * wobbleRadius;
            let targetY = centerY + Math.sin(state.orbitAngle) * wobbleRadius * 0.6; // Elliptical
            
            // Apply glitch offset (stronger effect for wider spread)
            if (state.isGlitching) {
                targetX += state.glitchOffset.x * Math.random() * 0.8;  // Increased from 0.5 to 0.8
                targetY += state.glitchOffset.y * Math.random() * 0.8;  // Increased from 0.5 to 0.8
            }
            
            // RGB split effect
            if (state.rgbSplit) {
                const splitAmount = 3 * (1 + state.dropIntensity);
                targetX += Math.sin(state.rgbPhase) * splitAmount;
                targetY += Math.cos(state.rgbPhase) * splitAmount;
                state.rgbPhase += 0.1 * dt;
            }
            
            // Digital noise bursts on drops (larger to maintain spread)
            if (state.dropIntensity > 0.8 && Math.random() < 0.1) {
                targetX += (Math.random() - 0.5) * 30;  // Increased from 10 to 30
                targetY += (Math.random() - 0.5) * 30;  // Increased from 10 to 30
            }
            
            // Minimal pull to center to allow maximum spread
            const smoothing = state.isGlitching ? 0.02 : 0.03;  // Further reduced from 0.03/0.05
            particle.vx = (targetX - particle.x) * smoothing;
            particle.vy = (targetY - particle.y) * smoothing;
            
            // Add jitter based on beat
            particle.vx += (Math.random() - 0.5) * beatIntensity * 2;
            particle.vy += (Math.random() - 0.5) * beatIntensity * 2;
            
        } else {
            // Frozen - vibrate in place
            particle.vx = (Math.random() - 0.5) * 0.5;
            particle.vy = (Math.random() - 0.5) * 0.5;
        }
        
        // Apply velocity
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;
        
        // Flicker opacity for digital effect
        if (Math.random() < 0.02) {
            particle.opacity = 0.1 + Math.random() * 0.9;
        }
        
        // Size pulsing with beat
        particle.size = particle.baseSize * (1 + beatIntensity * 0.3 + state.dropIntensity * 0.5);
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Spaz Particle Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Ultra-aggressive particle behavior with explosive spread and chaotic motion
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module particles/behaviors/spaz
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates particles that explode outward in all directions with chaotic, erratic    
 * ║ motion. Particles spawn far from center and maintain aggressive spread patterns.  
 * ║ Perfect for high-energy emotions like glitch, anger, or excitement.              
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

var spaz = {
    name: 'spaz',
    description: 'Ultra-aggressive particles with explosive spread and chaotic motion',
    
    /**
     * Initialize particle with spaz behavior
     * @param {Object} particle - Particle object to initialize
     * @param {Object} config - Configuration object
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate
     */
    initialize(particle, config, centerX, centerY) {
        // Set basic particle properties
        particle.x = centerX;
        particle.y = centerY;
        particle.life = 1.0;
        particle.size = 3 + Math.random() * 4; // Larger particles for visibility
        
        // Explosive velocity - particles shoot out in random directions
        const angle = Math.random() * Math.PI * 2;
        const speed = 200 + Math.random() * 300; // Very fast initial velocity
        particle.vx = Math.cos(angle) * speed;
        particle.vy = Math.sin(angle) * speed;
        
        // Spaz-specific state
        particle.behaviorState = {
            // Explosive properties
            explosionPhase: 0, // 0 = initial explosion, 1 = chaotic motion
            explosionTimer: 0,
            explosionDuration: 1000 + Math.random() * 2000, // 1-3 seconds
            
            // Chaotic motion properties
            chaosTimer: 0,
            nextChaosChange: 100 + Math.random() * 200, // Change direction every 100-300ms
            chaosAngle: angle,
            chaosSpeed: 50 + Math.random() * 100,
            
            // Spaz-specific effects
            spazIntensity: 0.8 + Math.random() * 0.4, // How intense the spazzing is
            zigzagPattern: Math.random() < 0.5, // Some particles zigzag
            spiralPattern: Math.random() < 0.3, // Some particles spiral
            teleportChance: 0.02, // 2% chance to teleport to random position
            
            // Visual effects
            sizePulse: true,
            sizePulseSpeed: 0.1 + Math.random() * 0.05,
            sizePulsePhase: Math.random() * Math.PI * 2,
            colorShift: Math.random() < 0.3, // Some particles shift colors
            colorShiftSpeed: 0.05 + Math.random() * 0.03
        };
        
        // Special properties for spaz
        particle.lifeDecay = 0.0008; // Slower decay for longer trails
        particle.hasGlow = true; // Always glow for maximum visibility
        particle.glowSizeMultiplier = 4.0 + Math.random() * 3; // Very large glows
        particle.glowIntensity = 1.5 + Math.random() * 0.5; // Bright glows
    },
    
    /**
     * Update particle physics for spaz behavior
     * @param {Object} particle - Particle to update
     * @param {number} dt - Delta time in milliseconds
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate
     */
    update(particle, dt, centerX, centerY) {
        const state = particle.behaviorState;
        
        // Update timers
        state.explosionTimer += dt;
        state.chaosTimer += dt;
        
        // Phase 1: Initial explosion (first 500ms)
        if (state.explosionPhase === 0 && state.explosionTimer < 500) {
            // Maintain explosive velocity with slight deceleration
            particle.vx *= 0.98;
            particle.vy *= 0.98;
            
            // Add random bursts during explosion
            if (Math.random() < 0.1) {
                particle.vx += (Math.random() - 0.5) * 100;
                particle.vy += (Math.random() - 0.5) * 100;
            }
        }
        // Phase 2: Transition to chaotic motion
        else if (state.explosionPhase === 0 && state.explosionTimer >= 500) {
            state.explosionPhase = 1;
            // Set up chaotic motion
            state.chaosAngle = Math.random() * Math.PI * 2;
            state.chaosSpeed = 30 + Math.random() * 70;
        }
        // Phase 3: Chaotic motion
        else if (state.explosionPhase === 1) {
            // Change direction periodically
            if (state.chaosTimer >= state.nextChaosChange) {
                state.chaosAngle = Math.random() * Math.PI * 2;
                state.chaosSpeed = 20 + Math.random() * 80;
                state.nextChaosChange = 50 + Math.random() * 150;
                state.chaosTimer = 0;
            }
            
            // Apply chaotic motion
            const chaosVx = Math.cos(state.chaosAngle) * state.chaosSpeed;
            const chaosVy = Math.sin(state.chaosAngle) * state.chaosSpeed;
            
            // Mix with current velocity for smooth transitions
            particle.vx = particle.vx * 0.7 + chaosVx * 0.3;
            particle.vy = particle.vy * 0.7 + chaosVy * 0.3;
            
            // Special patterns
            if (state.zigzagPattern) {
                // Zigzag motion
                const zigzagAngle = state.chaosTimer * 0.01;
                particle.vx += Math.sin(zigzagAngle) * 20;
                particle.vy += Math.cos(zigzagAngle) * 20;
            }
            
            if (state.spiralPattern) {
                // Spiral motion
                const spiralAngle = state.chaosTimer * 0.005;
                const spiralRadius = 50 + Math.sin(state.chaosTimer * 0.003) * 30;
                particle.vx += Math.cos(spiralAngle) * spiralRadius * 0.1;
                particle.vy += Math.sin(spiralAngle) * spiralRadius * 0.1;
            }
        }
        
        // Teleport effect (rare)
        if (Math.random() < state.teleportChance) {
            const teleportAngle = Math.random() * Math.PI * 2;
            const teleportDistance = 200 + Math.random() * 400;
            particle.x = centerX + Math.cos(teleportAngle) * teleportDistance;
            particle.y = centerY + Math.sin(teleportAngle) * teleportDistance;
            particle.vx = (Math.random() - 0.5) * 200;
            particle.vy = (Math.random() - 0.5) * 200;
        }
        
        // Update position
        particle.x += particle.vx * (dt / 1000);
        particle.y += particle.vy * (dt / 1000);
        
        // Size pulsing effect
        if (state.sizePulse) {
            state.sizePulsePhase += state.sizePulseSpeed * dt;
            const pulseMultiplier = 1.0 + Math.sin(state.sizePulsePhase) * 0.5;
            particle.size = (3 + Math.random() * 4) * pulseMultiplier;
        }
        
        // Color shifting effect
        if (state.colorShift) {
            state.colorShiftPhase = (state.colorShiftPhase || 0) + state.colorShiftSpeed * dt;
            // This would be handled by the renderer if color shifting is implemented
        }
        
        // Apply friction to prevent infinite acceleration
        particle.vx *= 0.995;
        particle.vy *= 0.995;
        
        // Decay life
        particle.life -= particle.lifeDecay * dt;
        
        // Reset particle if it goes too far or dies
        if (particle.life <= 0 || 
            Math.abs(particle.x - centerX) > 2000 || 
            Math.abs(particle.y - centerY) > 2000) {
            particle.life = 0;
        }
    },
    
    /**
     * Get spawn position for spaz particles
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate
     * @returns {Object} Spawn position {x, y}
     */
    getSpawnPosition(centerX, centerY) {
        // Spawn particles in a wide ring around the center
        const angle = Math.random() * Math.PI * 2;
        const radius = 100 + Math.random() * 200; // Spawn 100-300 pixels from center
        return {
            x: centerX + Math.cos(angle) * radius,
            y: centerY + Math.sin(angle) * radius
        };
    },
    
    /**
     * Get visual properties for spaz particles
     * @returns {Object} Visual properties
     */
    getVisualProperties() {
        return {
            glowColor: '#FF00AA', // Hot magenta
            glowIntensity: 2.0,
            particleColors: [
                { color: '#FF00AA', weight: 30 }, // Hot magenta
                { color: '#00FFAA', weight: 25 }, // Bright cyan-green
                { color: '#FFAA00', weight: 20 }, // Digital amber
                { color: '#AA00FF', weight: 15 }, // Purple
                { color: '#00AAFF', weight: 10 }  // Blue
            ]
        };
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Directed Particle Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Directed behavior - particles move in focused, straight paths
 * @author Emotive Engine Team
 * @module particles/behaviors/directed
 */

/**
 * DIRECTED BEHAVIOR - FOCUSED STRAIGHT PATHS
 * Used by: focused emotion
 * 
 * Particles move in deliberate, straight lines toward a target or direction,
 * representing intense concentration and focus.
 */
var directed = {
    name: 'directed',
    emoji: '🎯',
    description: 'Focused, straight-line movement toward target',
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ CONFIGURATION
    // └─────────────────────────────────────────────────────────────────────────────────
    config: {
        speed: 3.0,              // Fast movement
        acceleration: 0.15,      // Quick acceleration
        focusStrength: 0.8,      // Strong pull toward target
        randomness: 0.1,         // Minimal deviation
        edgeBuffer: 50           // Buffer from canvas edges
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ INITIALIZATION
    // └─────────────────────────────────────────────────────────────────────────────────
    initialize(particle, centerX, centerY, _canvasWidth, _canvasHeight) {
        // Set initial direction toward center
        const dx = centerX - particle.x;
        const dy = centerY - particle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
            particle.vx = (dx / distance) * this.config.speed;
            particle.vy = (dy / distance) * this.config.speed;
        } else {
            // Random initial direction if at center
            const angle = Math.random() * Math.PI * 2;
            particle.vx = Math.cos(angle) * this.config.speed;
            particle.vy = Math.sin(angle) * this.config.speed;
        }
        
        // Store target position
        particle.targetX = centerX;
        particle.targetY = centerY;
        particle.directedPhase = 0;
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ UPDATE LOOP
    // └─────────────────────────────────────────────────────────────────────────────────
    update(particle, dt, centerX, centerY, canvasWidth, canvasHeight) {
        // Update phase for variation
        particle.directedPhase += dt * 0.05;
        
        // Calculate direction to target
        const dx = particle.targetX - particle.x;
        const dy = particle.targetY - particle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 10) {
            // Move toward target with focus strength
            const targetVx = (dx / distance) * this.config.speed;
            const targetVy = (dy / distance) * this.config.speed;
            
            // Apply acceleration toward target velocity
            particle.vx += (targetVx - particle.vx) * this.config.acceleration * dt;
            particle.vy += (targetVy - particle.vy) * this.config.acceleration * dt;
            
            // Add minimal randomness for organic feel
            particle.vx += (Math.random() - 0.5) * this.config.randomness;
            particle.vy += (Math.random() - 0.5) * this.config.randomness;
        } else {
            // Near target, pick new target
            const angle = Math.random() * Math.PI * 2;
            const radius = 100 + Math.random() * 200;
            particle.targetX = centerX + Math.cos(angle) * radius;
            particle.targetY = centerY + Math.sin(angle) * radius;
            
            // Keep within canvas bounds
            particle.targetX = Math.max(this.config.edgeBuffer, 
                Math.min(canvasWidth - this.config.edgeBuffer, particle.targetX));
            particle.targetY = Math.max(this.config.edgeBuffer, 
                Math.min(canvasHeight - this.config.edgeBuffer, particle.targetY));
        }
        
        // Apply velocity
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;
        
        // Edge bouncing with dampening
        if (particle.x <= 0 || particle.x >= canvasWidth) {
            particle.vx *= -0.8;
            particle.x = Math.max(0, Math.min(canvasWidth, particle.x));
            // Pick new target after bounce
            particle.targetX = centerX + (Math.random() - 0.5) * 300;
        }
        if (particle.y <= 0 || particle.y >= canvasHeight) {
            particle.vy *= -0.8;
            particle.y = Math.max(0, Math.min(canvasHeight, particle.y));
            // Pick new target after bounce
            particle.targetY = centerY + (Math.random() - 0.5) * 300;
        }
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ VISUAL CHARACTERISTICS
    // └─────────────────────────────────────────────────────────────────────────────────
    visuals: {
        trailLength: 'medium',      // Medium trail for motion clarity
        opacity: 0.9,               // High opacity for focus
        sizeMultiplier: 1.0,        // Standard size
        blurAmount: 0.2             // Sharp, focused appearance
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Fizzy Particle Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Fizzy behavior - bubbly, effervescent particle movement
 * @author Emotive Engine Team
 * @module particles/behaviors/fizzy
 */

/**
 * FIZZY BEHAVIOR - BUBBLY EFFERVESCENCE
 * Used by: excited emotion
 * 
 * Particles bubble upward with random pops and fizz, like carbonation in soda.
 * Creates an energetic, celebratory atmosphere.
 */
var fizzy = {
    name: 'fizzy',
    emoji: '🫧',
    description: 'Bubbly, effervescent movement like carbonation',
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ CONFIGURATION
    // └─────────────────────────────────────────────────────────────────────────────────
    config: {
        baseRiseSpeed: 2.5,      // Base upward velocity
        wobbleAmplitude: 30,     // Horizontal wobble range
        wobbleFrequency: 0.15,   // Wobble oscillation speed
        popChance: 0.002,        // Chance to "pop" per frame
        popForce: 8,             // Force of pop burst
        fizziness: 0.3,          // Random velocity variation
        gravity: -0.05           // Slight upward bias
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ INITIALIZATION
    // └─────────────────────────────────────────────────────────────────────────────────
    initialize(particle, _centerX, _centerY, _canvasWidth, _canvasHeight) {
        // Start with upward velocity
        particle.vx = (Math.random() - 0.5) * 2;
        particle.vy = -this.config.baseRiseSpeed - Math.random() * 2;
        
        // Fizzy properties
        particle.wobblePhase = Math.random() * Math.PI * 2;
        particle.wobbleSpeed = this.config.wobbleFrequency * (0.8 + Math.random() * 0.4);
        particle.bubbleSize = 0.5 + Math.random() * 0.5;
        particle.popTimer = 0;
        particle.isFizzing = true;
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ UPDATE LOOP
    // └─────────────────────────────────────────────────────────────────────────────────
    update(particle, dt, centerX, centerY, canvasWidth, canvasHeight) {
        // Update wobble phase
        particle.wobblePhase += particle.wobbleSpeed * dt;
        
        // Apply wobble to horizontal movement
        const wobble = Math.sin(particle.wobblePhase) * this.config.wobbleAmplitude;
        particle.vx = wobble * 0.05 + (Math.random() - 0.5) * this.config.fizziness;
        
        // Apply upward force with variation
        particle.vy += this.config.gravity * dt;
        particle.vy += (Math.random() - 0.5) * this.config.fizziness;
        
        // Random "pop" events
        if (Math.random() < this.config.popChance) {
            // Pop! Send particle in random direction
            const popAngle = Math.random() * Math.PI * 2;
            particle.vx = Math.cos(popAngle) * this.config.popForce;
            particle.vy = Math.sin(popAngle) * this.config.popForce * 0.7; // Slightly favor horizontal
            particle.popTimer = 1; // Visual feedback timer
            
            // Resize on pop
            particle.bubbleSize = 0.3 + Math.random() * 0.7;
        }
        
        // Decay pop effect
        if (particle.popTimer > 0) {
            particle.popTimer -= dt * 0.05;
            // Slow down after pop
            particle.vx *= 0.95;
            particle.vy *= 0.95;
        }
        
        // Apply velocity
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;
        
        // Wrap around vertically (bubbles rise and restart)
        if (particle.y < -50) {
            particle.y = canvasHeight + 50;
            particle.x = centerX + (Math.random() - 0.5) * 300;
            particle.vy = -this.config.baseRiseSpeed - Math.random() * 2;
            particle.bubbleSize = 0.5 + Math.random() * 0.5;
        }
        
        // Horizontal bounds with soft bounce
        if (particle.x <= 0 || particle.x >= canvasWidth) {
            particle.vx *= -0.5;
            particle.x = Math.max(0, Math.min(canvasWidth, particle.x));
        }
        
        // Bottom boundary (bubbles can spawn from bottom)
        if (particle.y > canvasHeight + 50) {
            particle.y = canvasHeight;
            particle.vy = -this.config.baseRiseSpeed * 1.5;
        }
        
        // Update size based on bubble properties
        particle.size = particle.baseSize * particle.bubbleSize * 
                       (1 + Math.sin(particle.wobblePhase * 2) * 0.1);
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ VISUAL CHARACTERISTICS
    // └─────────────────────────────────────────────────────────────────────────────────
    visuals: {
        trailLength: 'short',       // Short trails for bubbly feel
        opacity: 0.6,               // Semi-transparent like bubbles
        sizeMultiplier: 1.2,        // Slightly larger for bubble effect
        blurAmount: 0.5,            // Soft, bubble-like appearance
        sparkle: true               // Occasional sparkle effect
    }
};

/**
 * Calm Particle Behavior
 * Particles drift peacefully with minimal, smooth movement
 */


// Behavior configuration
const config = {
    breathingPeriod: 8000};

/**
 * Initialize a particle with calm properties
 * @param {Object} particle - The particle to initialize
 */
function initializeCalm(particle) {
    // Start with faster initial burst movement
    particle.vx = (Math.random() - 0.5) * 0.5;  // Increased 5x from 0.1
    particle.vy = (Math.random() - 0.5) * 0.5;  // Increased 5x from 0.1
    particle.lifeDecay = 0.003;  // Moderate fade (particles last ~5-6 seconds)

    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }

    // Calm-specific behavior data
    particle.behaviorData = {
        orbitAngle: Math.random() * Math.PI * 2,  // Starting angle around center
        orbitRadius: 40 + Math.random() * 60,      // Distance from center (40-100 pixels)
        orbitSpeed: 0.0008 + Math.random() * 0.0006, // Faster orbit speed (4x)
        floatOffset: Math.random() * Math.PI * 2,
        breathingOffset: Math.random() * Math.PI * 2,
        lifetime: 0
    };
}

/**
 * Update calm behavior each frame
 * @param {Object} particle - The particle to update
 * @param {number} dt - Delta time
 * @param {number} centerX - Orb center X
 * @param {number} centerY - Orb center Y
 */
function updateCalm(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    if (!data) return;

    data.lifetime += dt;

    // Breathing effect (very subtle size change)
    const breathPhase = (data.lifetime + data.breathingOffset * config.breathingPeriod) / config.breathingPeriod;
    const breathIntensity = Math.sin(breathPhase * Math.PI * 2) * 0.5 + 0.5;

    // Apply subtle size pulsing
    particle.size = particle.baseSize * (0.95 + breathIntensity * 0.05);

    // Slow orbital movement around the mascot
    data.orbitAngle += data.orbitSpeed * dt;

    // Vary the orbit radius slightly over time for organic movement
    const radiusVariation = Math.sin(data.lifetime * 0.0001 + data.floatOffset) * 10;
    const currentRadius = data.orbitRadius + radiusVariation;

    // Calculate target position in orbit
    const targetX = centerX + Math.cos(data.orbitAngle) * currentRadius;
    const targetY = centerY + Math.sin(data.orbitAngle) * currentRadius;

    // Add vertical floating motion
    const floatY = Math.sin(data.lifetime * 0.0003 + data.breathingOffset) * 15;

    // Smoothly move toward orbital position
    const dx = targetX - particle.x;
    const dy = (targetY + floatY) - particle.y;

    // Faster movement toward target position
    particle.vx = dx * 0.03;  // Faster following (3x)
    particle.vy = dy * 0.03;  // Faster following (3x)

    // Add more random drift for organic feel
    particle.vx += (Math.random() - 0.5) * 0.02;  // More drift
    particle.vy += (Math.random() - 0.5) * 0.02;  // More drift

    // Apply very light friction
    particle.vx *= 0.98;
    particle.vy *= 0.98;
}

// Export behavior definition for registry
var zen = {
    name: 'zen',
    emoji: '☯️',
    description: 'Peaceful orbital movement like a hovering aura',
    initialize: initializeCalm,
    update: updateCalm
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Plugin Behavior Adapter
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Adapter for plugin-defined particle behaviors
 * @author Emotive Engine Team
 * @module particles/behaviors/plugin-adapter
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Bridges the gap between the plugin system and modular particle behaviors.         
 * ║ Allows plugins to register custom particle behaviors that integrate seamlessly    
 * ║ with the modular particle system.                                                 
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


// Registry for plugin-defined behaviors
const pluginBehaviors = new Map();

/**
 * Register a custom particle behavior from a plugin
 * @param {string} name - Unique name for the behavior
 * @param {Object} behaviorDef - Behavior definition object
 * @returns {boolean} Success status
 */
function registerPluginBehavior(name, behaviorDef) {
    if (pluginBehaviors.has(name)) ;
    
    // Validate behavior definition
    if (!behaviorDef.initialize || typeof behaviorDef.initialize !== 'function') {
        return false;
    }
    
    if (!behaviorDef.update || typeof behaviorDef.update !== 'function') {
        return false;
    }
    
    // Store the behavior
    pluginBehaviors.set(name, {
        name,
        emoji: behaviorDef.emoji || '🔌',
        description: behaviorDef.description || `Plugin behavior: ${name}`,
        initialize: behaviorDef.initialize,
        update: behaviorDef.update,
        isPlugin: true
    });
    
    return true;
}

/**
 * Unregister a plugin behavior
 * @param {string} name - Name of the behavior to remove
 * @returns {boolean} Success status
 */
function unregisterPluginBehavior(name) {
    if (pluginBehaviors.has(name)) {
        pluginBehaviors.delete(name);
        return true;
    }
    return false;
}

/**
 * Get a plugin behavior by name
 * @param {string} name - Name of the behavior
 * @returns {Object|null} Behavior definition or null
 */
function getPluginBehavior(name) {
    return pluginBehaviors.get(name) || null;
}

/**
 * Get all registered plugin behaviors
 * @returns {Array} Array of behavior names
 */
function getAllPluginBehaviors() {
    return Array.from(pluginBehaviors.keys());
}

/**
 * Create a behavior wrapper for legacy plugin particle effects
 * Converts old-style particle definitions to modular behavior format
 * @param {Object} legacyBehavior - Legacy behavior configuration
 * @returns {Object} Modular behavior definition
 */
function createLegacyAdapter(legacyBehavior) {
    return {
        name: legacyBehavior.name || 'legacy',
        emoji: '🔄',
        description: legacyBehavior.description || 'Legacy plugin behavior',
        
        initialize(particle) {
            // Apply legacy configuration
            if (legacyBehavior.size) {
                particle.size = typeof legacyBehavior.size === 'object' ?
                    legacyBehavior.size.min + Math.random() * (legacyBehavior.size.max - legacyBehavior.size.min) :
                    legacyBehavior.size;
                particle.baseSize = particle.size;
            }
            
            if (legacyBehavior.speed) {
                const speed = typeof legacyBehavior.speed === 'object' ?
                    legacyBehavior.speed.min + Math.random() * (legacyBehavior.speed.max - legacyBehavior.speed.min) :
                    legacyBehavior.speed;
                const angle = Math.random() * Math.PI * 2;
                particle.vx = Math.cos(angle) * speed;
                particle.vy = Math.sin(angle) * speed;
            }
            
            if (legacyBehavior.lifespan) {
                const lifespan = typeof legacyBehavior.lifespan === 'object' ?
                    legacyBehavior.lifespan.min + Math.random() * (legacyBehavior.lifespan.max - legacyBehavior.lifespan.min) :
                    legacyBehavior.lifespan;
                particle.lifeDecay = 1000 / lifespan; // Convert ms to decay rate
            }
            
            if (legacyBehavior.color) {
                particle.color = Array.isArray(legacyBehavior.color) ?
                    selectWeightedColor(legacyBehavior.color) :
                    legacyBehavior.color;
            }
            
            if (legacyBehavior.opacity) {
                particle.life = typeof legacyBehavior.opacity === 'object' ?
                    legacyBehavior.opacity.min + Math.random() * (legacyBehavior.opacity.max - legacyBehavior.opacity.min) :
                    legacyBehavior.opacity;
            }
            
            // Store legacy-specific data
            particle.behaviorData = {
                movementType: legacyBehavior.movementType || 'linear',
                turbulence: legacyBehavior.turbulence || 0,
                drift: legacyBehavior.drift || 0,
                acceleration: legacyBehavior.acceleration || 0,
                ...legacyBehavior.customData
            };
        },
        
        update(particle, dt, centerX, centerY) {
            const data = particle.behaviorData;
            
            // Apply movement based on type
            switch (data.movementType) {
            case 'wander':
                // Random wandering
                particle.vx += (Math.random() - 0.5) * data.turbulence * dt;
                particle.vy += (Math.random() - 0.5) * data.turbulence * dt;
                break;
                    
            case 'fall':
                // Falling with drift
                particle.vy += 0.1 * dt; // Gravity
                particle.vx += (Math.random() - 0.5) * data.drift * dt;
                break;
                    
            case 'rain':
                // Digital rain effect
                particle.vy += data.acceleration * dt;
                break;
                    
            case 'orbit': {
                // Orbital motion
                const dx = particle.x - centerX;
                const dy = particle.y - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    const angle = Math.atan2(dy, dx) + 0.02 * dt;
                    particle.x = centerX + Math.cos(angle) * dist;
                    particle.y = centerY + Math.sin(angle) * dist;
                }
                break;
            }
            }
            
            // Call custom update if provided
            if (legacyBehavior.customUpdate) {
                legacyBehavior.customUpdate(particle, dt, centerX, centerY);
            }
        }
    };
}

// Export adapter functions for plugin system integration
var pluginAdapter = {
    registerPluginBehavior,
    unregisterPluginBehavior,
    getPluginBehavior,
    getAllPluginBehaviors,
    createLegacyAdapter
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Behavior Registry
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Central registry for all particle behaviors with plugin support
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module particles/behaviors
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Control center for particle behaviors with plugin adapter integration.            
 * ║ • Each behavior defines unique particle physics and movement patterns             
 * ║ • Core behaviors loaded synchronously at startup                                  
 * ║ • Plugin behaviors registered dynamically via adapter                             
 * ║ • Value-agnostic design for easy physics tuning                                   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ BEHAVIOR COLLECTION
// └─────────────────────────────────────────────────────────────────────────────────────
const BEHAVIORS = [
    ambient,
    directed,
    fizzy,
    orbiting,
    rising,
    falling,
    popcorn,
    burst,
    aggressive,
    scattering,
    repelling,
    connecting,
    resting,
    radiant,
    ascending,
    erratic,
    cautious,
    surveillance,
    glitchy,
    spaz,
    zen
];

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ BEHAVIOR REGISTRY - Fast lookup by name
// └─────────────────────────────────────────────────────────────────────────────────────
const BEHAVIOR_REGISTRY = {};

// Build the registry from the behaviors array - SYNCHRONOUSLY
BEHAVIORS.forEach(behavior => {
    BEHAVIOR_REGISTRY[behavior.name] = behavior;
    // Debug logging removed for production
});

/**
 * Get a behavior by name (checks both core and plugin behaviors)
 * @param {string} name - Behavior name (e.g., 'ambient', 'orbiting')
 * @returns {Object|null} Behavior object or null if not found
 */
function getBehavior(name) {
    // Check core behaviors first
    if (BEHAVIOR_REGISTRY[name]) {
        return BEHAVIOR_REGISTRY[name];
    }
    // Check plugin behaviors
    const pluginBehavior = pluginAdapter.getPluginBehavior(name);
    if (pluginBehavior) {
        return pluginBehavior;
    }
    return null;
}

/**
 * Initialize a particle with a specific behavior
 * @param {Particle} particle - The particle to initialize
 * @param {string} behaviorName - Name of the behavior to apply
 * @returns {boolean} True if behavior was found and applied
 */
function initializeBehavior(particle, behaviorName) {
    const behavior = getBehavior(behaviorName);
    if (behavior && behavior.initialize) {
        behavior.initialize(particle);
        return true;
    }
    // Fallback to ambient if behavior not found
    if (behaviorName !== 'ambient') {
        console.warn(`⚠️ Behavior '${behaviorName}' not found, falling back to ambient`);
        return initializeBehavior(particle, 'ambient');
    }
    return false;
}

/**
 * Update a particle's behavior
 * @param {Particle} particle - The particle to update
 * @param {string} behaviorName - Name of the behavior
 * @param {number} dt - Delta time
 * @param {number} centerX - Orb center X
 * @param {number} centerY - Orb center Y
 * @returns {boolean} True if behavior was found and updated
 */
function updateBehavior(particle, behaviorName, dt, centerX, centerY) {
    const behavior = getBehavior(behaviorName);
    if (behavior && behavior.update) {
        behavior.update(particle, dt, centerX, centerY);
        return true;
    }
    return false;
}

/**
 * Get list of all available behaviors (core and plugin)
 * @returns {Array} Array of behavior names and descriptions
 */
function listBehaviors() {
    // Get core behaviors
    const coreBehaviors = Object.values(BEHAVIOR_REGISTRY).map(behavior => ({
        name: behavior.name,
        emoji: behavior.emoji || '🎯',
        description: behavior.description || 'No description',
        type: 'core'
    }));
    
    // Get plugin behaviors
    const pluginBehaviorNames = pluginAdapter.getAllPluginBehaviors();
    const pluginBehaviors = pluginBehaviorNames.map(name => {
        const behavior = pluginAdapter.getPluginBehavior(name);
        return {
            name: behavior.name,
            emoji: behavior.emoji || '🔌',
            description: behavior.description || 'Plugin behavior',
            type: 'plugin'
        };
    });
    
    return [...coreBehaviors, ...pluginBehaviors];
}

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ DEBUG UTILITIES
// └─────────────────────────────────────────────────────────────────────────────────────
if (typeof window !== 'undefined' && window.DEBUG_PARTICLES) {
    window.ParticleBehaviors = {
        registry: BEHAVIOR_REGISTRY,
        list: listBehaviors,
        get: getBehavior
    };
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Gesture Motion Orchestrator
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Orchestrator for modular gesture system - replaces monolithic switch
 * @author Emotive Engine Team
 * @module gestures/GestureMotion
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ This orchestrator manages gesture application using the modular gesture system.   
 * ║ It replaces the old 538-line switch statement with clean, modular lookups.        
 * ║ Drop-in replacement for the old applyGestureMotion function.                      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


/**
 * Apply gesture motion to a particle using the modular system
 * This is a drop-in replacement for the old applyGestureMotion function
 * 
 * @param {Particle} particle - The particle to animate
 * @param {number} dt - Delta time (normalized to 60fps)
 * @param {Object} motion - Gesture motion configuration
 * @param {number} progress - Gesture progress (0-1)
 * @param {number} centerX - Orb center X position
 * @param {number} centerY - Orb center Y position
 */
function applyGestureMotion(particle, dt, motion, progress, centerX, centerY) {
    // Validate inputs
    if (!motion || !motion.type || progress >= 1) {
        return;
    }
    
    // Initialize gesture data if needed
    if (!particle.gestureData) {
        particle.gestureData = {
            originalVx: particle.vx,
            originalVy: particle.vy,
            initialX: particle.x,
            initialY: particle.y,
            // For compatibility with gestures that expect these
            startAngle: Math.atan2(particle.y - centerY, particle.x - centerX),
            startRadius: Math.sqrt(Math.pow(particle.x - centerX, 2) + Math.pow(particle.y - centerY, 2))
        };
    }
    
    // Look up the gesture from registry
    const gesture = getGesture(motion.type);
    
    if (!gesture) {
        return;
    }
    
    // Apply rhythm modulation if enabled
    let rhythmModifiedMotion = motion;
    if (rhythmIntegration.isEnabled() && gesture.rhythm?.enabled) {
        const modulation = rhythmIntegration.applyGestureRhythm(gesture, particle, progress, dt);
        
        // Create modified motion with rhythm adjustments
        rhythmModifiedMotion = {
            ...motion,
            amplitude: (motion.amplitude || 1) * (modulation.amplitudeMultiplier || 1) * (modulation.accentMultiplier || 1),
            wobbleAmount: (motion.wobbleAmount || 0) * (modulation.wobbleMultiplier || 1),
            // Allow rhythm to affect other parameters as needed
            rhythmModulation: modulation
        };
    }
    
    // Apply the gesture using its modular implementation
    if (gesture.apply) {
        gesture.apply(particle, progress, rhythmModifiedMotion, dt, centerX, centerY);
    }
    
    // Handle cleanup when gesture completes
    if (progress >= 0.99 && gesture.cleanup) {
        gesture.cleanup(particle);
        // Reset gesture data for next gesture
        particle.gestureData = null;
    }
}

/**
 * Helper function to check if a gesture should override particle behavior
 * Used by Particle.js to determine update flow
 * 
 * @param {string} gestureType - The gesture type name
 * @returns {boolean} True if gesture completely overrides particle motion
 */
function isGestureOverriding(gestureType) {
    return isOverrideGesture(gestureType);
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Modular Particle System with 3D Depth
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Orchestrator for the modular particle system with z-coordinate depth
 * @author Emotive Engine Team
 * @module core/Particle-modular
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                               MODULAR ARCHITECTURE                                
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ This is a drop-in replacement for the original Particle.js                        
 * ║ Same API, but with modular architecture for easier maintenance                    
 * ║                                                                                    
 * ║ STRUCTURE:                                                                         
 * ║ - Particle class (this file) - orchestrates everything                            
 * ║ - particles/behaviors/* - behavior modules                                     
 * ║ - particles/config/* - configuration constants                                    
 * ║ - particles/utils/* - utility functions                                           
 * ║ - gestures/* - modular gesture system                                             
 * ║                                                                                    
 * ║ 3D DEPTH SYSTEM:                                                                   
 * ║ - Z-coordinate ranges from -1 (behind orb) to +1 (in front)                       
 * ║ - 1/13 particles spawn in foreground, 12/13 in background                         
 * ║ - Depth affects visual size (20% scaling based on z)                              
 * ║ - Foreground particles spawn with offset to prevent stacking                      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


/**
 * Particle class - Individual particle with behavior and rendering
 * 
 * LIFECYCLE:
 * 1. Created by ParticleSystem with position and behavior
 * 2. Initialized with behavior-specific properties
 * 3. Updated each frame (position, behavior, lifecycle)
 * 4. Rendered to canvas
 * 5. Removed when life reaches 0
 */
class Particle {
    /**
     * Creates a new particle with specific behavior and appearance
     * 
     * @param {number} x - Starting X position on canvas
     * @param {number} y - Starting Y position on canvas
     * @param {string} behavior - Behavior type (ambient, rising, falling, etc.)
     * @param {number} scaleFactor - Global scale multiplier (affects size/distance)
     * @param {number} particleSizeMultiplier - Additional size multiplier
     * @param {Array} emotionColors - Array of color options with weights
     */
    constructor(x, y, behavior = 'ambient', scaleFactor = 1, particleSizeMultiplier = 1, emotionColors = null) {
        // Position and movement (now with z-coordinate for depth)
        // 1/13 chance of being in front (z > 0), 12/13 chance of being behind (z < 0)
        const zRoll = Math.random();
        this.z = zRoll < (1/13) ? 0.5 + Math.random() * 0.5 : -1 + Math.random() * 0.9;
        
        // Add spawn offset to prevent stacking
        // Much larger offset for foreground particles to completely avoid visual stacking
        const spawnRadius = this.z > 0 ? (20 + Math.random() * 20) * scaleFactor : 3 * scaleFactor;
        const angle = Math.random() * Math.PI * 2;
        this.x = x + Math.cos(angle) * spawnRadius;
        this.y = y + Math.sin(angle) * spawnRadius;
        this.vx = 0;
        this.vy = 0;
        this.vz = 0; // For future 3D motion effects
        
        // Lifecycle
        this.life = 0.0; // Start at 0 for fade-in
        this.maxLife = 1.0;
        this.lifeDecay = 0.01; // Life lost per frame
        this.fadeInTime = 0.15; // 15% of life for fade-in
        this.fadeOutTime = 0.3; // Last 30% of life for fade-out
        this.isFadingOut = false; // Track if particle is in fade-out phase
        this.age = 0; // Track particle age for smooth fading
        
        // Visual properties - matching original Emotive scale
        this.scaleFactor = scaleFactor;
        this.particleSizeMultiplier = particleSizeMultiplier;
        this.size = (4 + Math.random() * 6) * scaleFactor * particleSizeMultiplier; // 4-10 pixels scaled
        this.baseSize = this.size;
        this.emotionColors = emotionColors; // Store emotion colors for use in behaviors
        this.color = '#ffffff';
        this.opacity = 1.0;
        
        // Glow properties - 1/3 of particles have glow with varying sizes
        this.hasGlow = Math.random() < 0.333;  // 1/3 chance of glow
        this.glowSizeMultiplier = this.hasGlow ? (1.33 + Math.random() * 0.33) : 0;  // 1.33x to 1.66x particle size
        
        // Cell shading - 1/3 of particles are cell shaded (cartoon style)
        this.isCellShaded = Math.random() < 0.333;  // 1/3 chance of cell shading
        
        // Make particles more ephemeral
        this.baseOpacity = 0.3 + Math.random() * 0.4;  // 30-70% max opacity for ethereal look
        
        // Color caching for performance with LRU eviction
        this.cachedColors = new Map(); // Cache RGBA strings
        this.maxCachedColors = 20; // Maximum cached colors per particle
        this.colorAccessOrder = []; // LRU tracking for color keys
        this.lastColor = null;
        this.lastOpacity = -1;
        
        // Behavior properties
        this.behavior = behavior;
        this.behaviorData = {}; // Behavior-specific data
        
        // Gesture properties for motion system
        this.gestureData = {
            initialX: x,
            initialY: y
        };
        
        // Initialize behavior-specific properties
        initializeBehavior(this, behavior);
    }

    /**
     * Updates particle position and behavior
     * @param {number} deltaTime - Time since last update in milliseconds
     * @param {number} centerX - Center X coordinate for behavior calculations
     * @param {number} centerY - Center Y coordinate for behavior calculations
     * @param {Object} undertoneModifier - Optional undertone modifications
     * @param {Object} gestureMotion - Optional gesture motion to apply
     * @param {number} gestureProgress - Progress of the gesture (0-1)
     * @param {Object} containmentBounds - Optional containment bounds {width, height}
     */
    update(deltaTime, centerX, centerY, _undertoneModifier = null, gestureMotion = null, gestureProgress = 0, containmentBounds = null) {
        // Cap deltaTime to prevent huge jumps
        const cappedDeltaTime = Math.min(deltaTime, 50);
        // Normalize to 60 FPS equivalent for consistent physics
        const dt = cappedDeltaTime / 16.67; // 16.67ms = 60 FPS frame time
        
        // Universal law: Gestures override state behavior based on their motion type
        // Use the modular gesture system to determine gesture behavior
        const gestureIsOverriding = gestureMotion && gestureMotion.type && gestureProgress > 0 && 
            isGestureOverriding(gestureMotion.type);
        
        if (gestureIsOverriding) {
            // Gesture completely controls particle - skip normal behavior
            this.applyGestureMotion(gestureMotion, gestureProgress, dt, centerX, centerY);
        } else if (this.gestureBehavior === 'falling') {
            // Rain gesture is active - use falling behavior instead of normal behavior
            updateBehavior(this, 'falling', dt, centerX, centerY);
        } else if (this.gestureBehavior === 'radiant') {
            // Shimmer gesture is active - use radiant behavior for shimmering effect
            updateBehavior(this, 'radiant', dt, centerX, centerY);
        } else {
            // Normal behavior update
            updateBehavior(this, this.behavior, dt, centerX, centerY);
            
            // Don't apply undertone modifications to particle motion
            // Undertones only affect color saturation and core behaviors
            
            // Apply non-overriding gesture motion if present
            if (gestureMotion && gestureProgress > 0) {
                this.applyGestureMotion(gestureMotion, gestureProgress, dt, centerX, centerY);
            }
        }
        
        // Apply velocity to position (unless gesture is directly controlling position)
        if (!gestureIsOverriding) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
        }
        
        // HARD BOUNDARY CONSTRAINTS - particles NEVER leave bounds
        // Use containment bounds if provided, otherwise use full canvas
        let boundsWidth, boundsHeight;
        if (containmentBounds) {
            // Use containment bounds (element dimensions)
            boundsWidth = containmentBounds.width;
            boundsHeight = containmentBounds.height;
        } else {
            // Get actual canvas dimensions from the DOM
            const canvas = document.getElementById('card-mascot') ||
                          document.getElementById('cherokee-guide-mascot') ||
                          document.querySelector('canvas');
            boundsWidth = canvas ? canvas.width : centerX * 2;
            boundsHeight = canvas ? canvas.height : centerY * 2;
        }
        const margin = 20;

        // Bounce off boundaries (relative to center)
        const leftBound = centerX - boundsWidth / 2 + margin;
        const rightBound = centerX + boundsWidth / 2 - margin;
        const topBound = centerY - boundsHeight / 2 + margin;
        const bottomBound = centerY + boundsHeight / 2 - margin;

        if (this.x - this.size < leftBound) {
            this.x = leftBound + this.size;
            this.vx = Math.abs(this.vx) * 0.5;
        } else if (this.x + this.size > rightBound) {
            this.x = rightBound - this.size;
            this.vx = -Math.abs(this.vx) * 0.5;
        }

        if (this.y - this.size < topBound) {
            this.y = topBound + this.size;
            this.vy = Math.abs(this.vy) * 0.5;
        } else if (this.y + this.size > bottomBound) {
            this.y = bottomBound - this.size;
            this.vy = -Math.abs(this.vy) * 0.5;
        }
        
        // Update age and life (EXACT COPY FROM ORIGINAL)
        this.age += this.lifeDecay * dt;

        // Smooth fade-in at birth
        if (this.age < this.fadeInTime) {
            this.life = this.age / this.fadeInTime;
        }
        // Full opacity in middle of life
        else if (this.age < (1.0 - this.fadeOutTime)) {
            this.life = 1.0;
        }
        // Smooth fade-out at death
        else {
            this.life = (1.0 - this.age) / this.fadeOutTime;
            this.isFadingOut = true;

            // Dynamic size reduction for popcorn during fade-out
            if (this.behavior === 'popcorn') {
                this.size = this.baseSize * (0.5 + 0.5 * this.life);
            }
        }

        this.life = Math.max(0, Math.min(1, this.life));

        // Update opacity with easing for extra smoothness
        // Falling behavior: linear opacity (no easing) for rain-like appearance
        if (this.behavior === 'falling') {
            this.opacity = this.life;
        } else {
            this.opacity = this.easeInOutCubic(this.life);
        }

        // Update size based on life for some behaviors
        if (this.behavior === 'burst' && this.behaviorData && this.life < this.behaviorData.fadeStart) {
            this.size = this.baseSize * (this.life / this.behaviorData.fadeStart);
        }
    }


    /**
     * DEPRECATED - Undertones no longer affect particle motion
     * Kept for compatibility but does nothing
     * @param {number} _dt - Normalized delta time (unused but kept for API compatibility)
     * @param {Object} _modifier - Undertone modifier settings (unused but kept for API compatibility)
     */
    applyUndertoneModifier(_dt, _modifier) {
        // Undertones no longer affect particles
        // They only affect color saturation and core behaviors
        
    }

    /**
     * Apply gesture motion to particle
     * @param {Object} motion - Gesture motion configuration
     * @param {number} progress - Gesture progress (0-1)
     * @param {number} dt - Normalized delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    applyGestureMotion(motion, progress, dt, centerX, centerY) {
        // Use the full gesture system from the original
        applyGestureMotion(this, dt, motion, progress, centerX, centerY);
    }

    /**
     * Check if particle is out of bounds
     * @param {number} width - Canvas width
     * @param {number} height - Canvas height
     * @returns {boolean} True if particle is out of bounds
     */
    isOutOfBounds(width, height) {
        const margin = 50; // Allow some margin for particles to re-enter
        return this.x < -margin || this.x > width + margin || 
               this.y < -margin || this.y > height + margin;
    }

    /**
     * Check if particle is still alive
     * @returns {boolean} True if particle life > 0
     */
    isAlive() {
        return this.life > 0;
    }

    /**
     * Set outward velocity for gesture effects
     * @param {number} angle - Direction angle in radians
     */
    setOutwardVelocity(angle) {
        if (this.behaviorData && this.behaviorData.outwardSpeed !== undefined) {
            const speed = this.behaviorData.outwardSpeed;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed + (this.behaviorData.upwardBias || 0);
        }
    }

    /**
     * Get depth-adjusted size for 3D effect
     * Particles farther away (negative z) appear smaller for depth perception
     * 
     * @returns {number} Adjusted size based on z-depth
     * 
     * DEPTH SCALING:
     * - z = -1.0: 80% size (farthest back)
     * - z =  0.0: 100% size (orb plane)
     * - z = +1.0: 120% size (closest to viewer)
     */
    getDepthAdjustedSize() {
        // Map z from [-1, 1] to scale [0.8, 1.2]
        // Negative z (behind) = smaller, positive z (front) = larger
        const depthScale = 1 + (this.z * 0.2);
        return this.size * depthScale;
    }
    
    /**
     * Get particle state for debugging
     * @returns {Object} Current particle state
     */
    getState() {
        return {
            position: { x: this.x, y: this.y, z: this.z },
            velocity: { x: this.vx, y: this.vy, z: this.vz },
            life: this.life,
            behavior: this.behavior,
            size: this.size,
            opacity: this.opacity
        };
    }


    /**
     * Reset particle for reuse from pool
     * @param {number} x - New X position
     * @param {number} y - New Y position
     * @param {string} behavior - New behavior type
     * @param {number} scaleFactor - Scale factor
     * @param {number} particleSizeMultiplier - Size multiplier
     * @param {Array} emotionColors - Emotion colors
     */
    reset(x, y, behavior = 'ambient', scaleFactor = 1, particleSizeMultiplier = 1, emotionColors = null) {
        // 1/13 chance of being in front (z > 0), 12/13 chance of being behind (z < 0)
        const zRoll = Math.random();
        this.z = zRoll < (1/13) ? 0.5 + Math.random() * 0.5 : -1 + Math.random() * 0.9;
        
        // Add spawn offset to prevent stacking
        // Much larger offset for foreground particles to completely avoid visual stacking
        const spawnRadius = this.z > 0 ? (20 + Math.random() * 20) * scaleFactor : 3 * scaleFactor;
        const angle = Math.random() * Math.PI * 2;
        this.x = x + Math.cos(angle) * spawnRadius;
        this.y = y + Math.sin(angle) * spawnRadius;
        this.vx = 0;
        this.vy = 0;
        this.vz = 0;
        this.life = 0.0;  // Start at 0 for fade-in
        this.age = 0;  // Reset age
        this.scaleFactor = scaleFactor;
        this.particleSizeMultiplier = particleSizeMultiplier;
        this.size = (4 + Math.random() * 6) * scaleFactor * particleSizeMultiplier;  // Scaled size
        this.baseSize = this.size;
        this.emotionColors = emotionColors;  // Store emotion colors
        
        // Clear cached colors for reuse
        this.cachedColors.clear();
        this.colorAccessOrder = []; // Clear LRU tracking
        this.opacity = 0.0;  // Start invisible
        this.isFadingOut = false;
        this.baseOpacity = 0.3 + Math.random() * 0.4;  // Reset base opacity
        this.color = '#ffffff';  // Reset color to white before reinitializing
        this.behavior = behavior;
        
        // Clear gesture data if it exists
        this.gestureData = null;
        
        // Reset behavior data
        if (!this.behaviorData) {
            this.behaviorData = {};
        } else {
            // Clear existing properties
            for (const key in this.behaviorData) {
                delete this.behaviorData[key];
            }
        }
        
        // Reinitialize behavior
        initializeBehavior(this, behavior);
    }

    /**
     * Get cached color string for performance
     * @param {string} hexColor - Hex color code
     * @param {number} opacity - Opacity value (0-1)
     * @returns {string} RGBA color string
     */
    getCachedColor(hexColor, opacity) {
        // Round opacity to reduce cache entries
        const roundedOpacity = Math.round(opacity * 100) / 100;
        const cacheKey = `${hexColor}_${roundedOpacity}`;

        if (!this.cachedColors.has(cacheKey)) {
            // LRU eviction: Remove oldest key when limit reached
            if (this.cachedColors.size >= this.maxCachedColors) {
                const oldestKey = this.colorAccessOrder.shift();
                this.cachedColors.delete(oldestKey);
            }

            this.cachedColors.set(cacheKey, this.hexToRgba(hexColor, roundedOpacity));
            this.colorAccessOrder.push(cacheKey);
        } else {
            // Update access order for existing key (move to end)
            const existingIndex = this.colorAccessOrder.indexOf(cacheKey);
            if (existingIndex !== -1) {
                this.colorAccessOrder.splice(existingIndex, 1);
            }
            this.colorAccessOrder.push(cacheKey);
        }

        return this.cachedColors.get(cacheKey);
    }

    /**
     * Convert hex color to RGBA string
     * @param {string} hex - Hex color code
     * @param {number} alpha - Alpha value (0-1)
     * @returns {string} RGBA color string
     */
    hexToRgba(hex, alpha) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (!result) return `rgba(255, 255, 255, ${alpha})`;
        
        return `rgba(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}, ${alpha})`;
    }

    /**
     * Cubic ease in/out function for smooth animations
     * @param {number} t - Progress value (0-1)
     * @returns {number} Eased value (0-1)
     */
    easeInOutCubic(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    /**
     * Render the particle to canvas
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {string} emotionColor - Color to use for rendering
     */
    render(ctx, emotionColor = '#ffffff') {
        if (this.life <= 0) return;
        
        // Validate position values to prevent rendering errors
        if (!isFinite(this.x) || !isFinite(this.y)) {
            return;
        }
        
        // Use sub-pixel accurate coordinates for smooth rendering
        const renderX = this.x;
        const renderY = this.y;
        
        // Ensure size is never negative
        const safeSize = Math.max(0.1, this.size);
        
        // Use the particle's own color if set, otherwise fall back to emotion color
        const particleColor = this.tempColor || this.color || emotionColor;
        
        ctx.save();
        
        if (this.isCellShaded) {
            // Cell shaded style - hard edges, no gradients
            
            // Draw outline (darker color)
            ctx.strokeStyle = this.getCachedColor(particleColor, this.opacity * 0.9);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(renderX, renderY, safeSize, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw flat color fill with discrete opacity levels
            const discreteOpacity = Math.floor(this.opacity * 3) / 3;
            ctx.fillStyle = this.getCachedColor(particleColor, discreteOpacity * (this.baseOpacity || 0.5) * 0.5);
            ctx.beginPath();
            ctx.arc(renderX, renderY, Math.max(0.1, safeSize - 1), 0, Math.PI * 2);
            ctx.fill();
            
            // Add hard-edged highlight
            if (discreteOpacity > 0.5) {
                ctx.fillStyle = this.getCachedColor('#FFFFFF', 0.3);
                ctx.beginPath();
                ctx.arc(renderX - safeSize * 0.3, renderY - safeSize * 0.3, safeSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
        } else {
            // Standard gradient style
            
            // Create radial gradient for soft particle
            const gradient = ctx.createRadialGradient(renderX, renderY, 0, renderX, renderY, safeSize);
            
            // Core is full opacity with base opacity applied
            gradient.addColorStop(0, this.getCachedColor(particleColor, this.opacity * (this.baseOpacity || 0.5)));
            // Mid fade
            gradient.addColorStop(0.5, this.getCachedColor(particleColor, this.opacity * (this.baseOpacity || 0.5) * 0.5));
            // Edge is transparent
            gradient.addColorStop(1, this.getCachedColor(particleColor, 0));
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(renderX, renderY, safeSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Add glow effect if enabled
            if (this.hasGlow && this.glowSizeMultiplier > 0) {
                const glowSize = safeSize * this.glowSizeMultiplier;
                const glowGradient = ctx.createRadialGradient(renderX, renderY, safeSize * 0.5, renderX, renderY, glowSize);

                // Make glow visible even when particles are subdued
                // Use a minimum opacity for glow to ensure visibility
                const minGlowOpacity = 0.3; // Minimum glow visibility
                const particleOpacity = Math.max(minGlowOpacity, this.opacity);

                // Scale glow intensity based on glowSizeMultiplier
                // Higher multiplier = more intense glow (especially for gesture effects)
                const glowIntensity = Math.min(1.0, this.glowSizeMultiplier / 3); // More aggressive scaling

                // Create bright, visible glow with minimum opacity thresholds
                glowGradient.addColorStop(0, this.getCachedColor(particleColor, Math.max(0.5, particleOpacity * 0.8) * glowIntensity));
                glowGradient.addColorStop(0.25, this.getCachedColor(particleColor, Math.max(0.3, particleOpacity * 0.6) * glowIntensity));
                glowGradient.addColorStop(0.5, this.getCachedColor(particleColor, Math.max(0.2, particleOpacity * 0.4) * glowIntensity));
                glowGradient.addColorStop(0.75, this.getCachedColor(particleColor, Math.max(0.1, particleOpacity * 0.2) * glowIntensity));
                glowGradient.addColorStop(1, this.getCachedColor(particleColor, 0));

                // Use additive blending for brighter glow effect
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(renderX, renderY, glowSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        ctx.restore();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Particle Pool
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Particle Pool - Object pooling for particle performance
 * @author Emotive Engine Team
 * @module core/particle/ParticlePool
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Manages the OBJECT POOL for particles. Reuses dead particles instead of
 * ║ creating new ones to prevent memory leaks and reduce GC pressure.
 * ║
 * ║ Extracted from ParticleSystem to follow Single Responsibility Principle.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔄 POOLING STRATEGY
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Lazy initialization (create particles as needed)
 * │ • Max pool size: Min(maxParticles, 50)
 * │ • Reuse dead particles before creating new
 * │ • Track pool hits/misses for optimization
 * │ • Clear references when pooling to prevent memory leaks
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class ParticlePool {
    constructor(maxParticles = 50) {
        this.poolSize = Math.min(maxParticles, 50); // Limit pool to max 50 particles
        this.pool = [];

        // Memory leak detection
        this.totalParticlesCreated = 0;
        this.totalParticlesDestroyed = 0;

        // Performance tracking
        this.poolHits = 0;
        this.poolMisses = 0;
    }

    /**
     * Gets a particle from the pool or creates a new one
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {string} behavior - Particle behavior type
     * @param {number} scaleFactor - Scale multiplier for particle sizes
     * @param {number} particleSizeMultiplier - Additional size multiplier
     * @param {Array|null} emotionColors - Array of color strings or weighted color objects
     * @param {string} emotion - Current emotion
     * @param {string|null} gestureBehavior - Gesture behavior to apply
     * @returns {Particle} Particle instance
     */
    getParticle(x, y, behavior, scaleFactor, particleSizeMultiplier, emotionColors, emotion, gestureBehavior = null) {
        let particle;

        if (this.pool.length > 0) {
            // Reuse from pool
            particle = this.pool.pop();
            particle.reset(x, y, behavior, scaleFactor, particleSizeMultiplier, emotionColors);
            this.poolHits++;
        } else {
            // Create new particle
            particle = new Particle(x, y, behavior, scaleFactor, particleSizeMultiplier, emotionColors);
            this.poolMisses++;
            this.totalParticlesCreated++;
        }

        // Set the emotion for behavior customization
        particle.emotion = emotion;

        // Apply gesture behavior if active (e.g., doppler for rain)
        if (gestureBehavior) {
            particle.gestureBehavior = gestureBehavior;
        }

        return particle;
    }

    /**
     * Returns a particle to the pool for reuse
     * @param {Particle} particle - Particle to return to pool
     */
    returnParticle(particle) {
        if (this.pool.length < this.poolSize) {
            // Clear references before pooling to prevent memory leaks
            particle.cachedGradient = null;
            particle.cachedGradientKey = null;

            // Clear behaviorData properties but keep the object
            if (particle.behaviorData) {
                for (const key in particle.behaviorData) {
                    delete particle.behaviorData[key];
                }
            }

            this.pool.push(particle);
        } else {
            // If pool is full, count as destroyed since it will be GC'd
            this.totalParticlesDestroyed++;
        }
    }

    /**
     * Refreshes the pool by removing excess particles
     */
    refreshPool() {
        const excessParticles = this.pool.length - this.poolSize;
        if (excessParticles > 0) {
            // Remove excess particles from pool
            this.pool.splice(this.poolSize);
            this.totalParticlesDestroyed += excessParticles;
        }
    }

    /**
     * Gets pool statistics for monitoring
     * @returns {object} Pool statistics
     */
    getStats() {
        return {
            poolSize: this.pool.length,
            poolHits: this.poolHits,
            poolMisses: this.poolMisses,
            totalCreated: this.totalParticlesCreated,
            totalDestroyed: this.totalParticlesDestroyed
        };
    }

    /**
     * Clears the pool and resets statistics
     */
    clear() {
        this.pool = [];
        this.poolHits = 0;
        this.poolMisses = 0;
        this.totalParticlesCreated = 0;
        this.totalParticlesDestroyed = 0;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Particle Spawner
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Particle Spawner - Manages particle spawning logic
 * @author Emotive Engine Team
 * @module core/particle/ParticleSpawner
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Manages SPAWNING LOGIC for particles. Calculates spawn positions based on
 * ║ behavior types, handles time-based spawning with accumulator, and clamps
 * ║ positions to canvas boundaries.
 * ║
 * ║ Extracted from ParticleSystem to follow Single Responsibility Principle.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎯 SPAWNING STRATEGY
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Behavior-based positioning (13 different behaviors)
 * │ • Time-based accumulator for smooth spawning
 * │ • Canvas boundary clamping with configurable margin
 * │ • Emotion-aware spawning (e.g., suspicion, surprise)
 * │ • Delta time capping to prevent spawn spikes
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class ParticleSpawner {
    constructor() {
        // TIME-BASED spawning using accumulation for smooth, consistent particle creation
        this.spawnAccumulator = 0; // Accumulates time to spawn particles
    }

    /**
     * Calculates spawn position based on behavior type
     * @param {string} behavior - Particle behavior type
     * @param {number} centerX - Center X coordinate (mascot position, may be offset)
     * @param {number} centerY - Center Y coordinate (mascot position, may be offset)
     * @param {number} canvasWidth - Actual canvas width
     * @param {number} canvasHeight - Actual canvas height
     * @param {string} emotion - Current emotion (affects some behaviors)
     * @returns {Object} Spawn position {x, y} and optional properties
     */
    getSpawnPosition(behavior, centerX, centerY, canvasWidth, canvasHeight, emotion = null) {
        // Calculate orb radius based on canvas size (matching EmotiveRenderer)
        const canvasSize = Math.min(canvasWidth, canvasHeight);
        const orbRadius = canvasSize / 12;  // Core radius
        const glowRadius = orbRadius * 2.5; // Glow extends this far

        // CONSTRAIN spawn positions to stay within canvas boundaries
        const margin = 30; // Keep spawns away from edges

        // Spawn particles outside the glow radius so they're visible
        const minSpawnRadius = glowRadius * 1.1; // 10% beyond glow edge
        // Constrain to distance from mascot to canvas edge
        const maxDistX = Math.min(centerX - margin, canvasWidth - centerX - margin);
        const maxDistY = Math.min(centerY - margin, canvasHeight - centerY - margin);
        const maxSpawnRadius = Math.min(glowRadius * 1.5, maxDistX, maxDistY);

        switch (behavior) {
        case 'ambient':
        case 'resting': {
            // Spawn at edge of glow where particles become visible
            // They'll move outward to create "emanating from center" effect
            const ambientAngle = Math.random() * Math.PI * 2;
            const ambientRadius = glowRadius * 0.9; // Just at glow edge
            return {
                x: centerX + Math.cos(ambientAngle) * ambientRadius,
                y: centerY + Math.sin(ambientAngle) * ambientRadius,
                angle: ambientAngle  // Pass angle for outward velocity
            };
        }

        case 'rising': {
            // Rising spawns below center and rises up
            const risingAngle = Math.random() * Math.PI * 2;
            const risingRadius = minSpawnRadius + Math.random() * (maxSpawnRadius - minSpawnRadius);
            return {
                x: centerX + Math.cos(risingAngle) * risingRadius,
                y: centerY + Math.sin(risingAngle) * risingRadius
            };
        }

        case 'falling': {
            // Falling (rain/tears) spawns in a circle around the orb (like ambient)
            // Then falls downward slowly like rain
            const fallingAngle = Math.random() * Math.PI * 2;
            const fallingRadius = glowRadius * 0.9; // Same as ambient - at glow edge
            return {
                x: centerX + Math.cos(fallingAngle) * fallingRadius,
                y: centerY + Math.sin(fallingAngle) * fallingRadius,
                angle: fallingAngle  // Pass angle for reference
            };
        }

        case 'aggressive': {
            // Spawn just outside the glow for aggressive burst effect
            const aggressiveAngle = Math.random() * Math.PI * 2;
            const aggressiveRadius = glowRadius + Math.random() * orbRadius;
            return {
                x: centerX + Math.cos(aggressiveAngle) * aggressiveRadius,
                y: centerY + Math.sin(aggressiveAngle) * aggressiveRadius
            };
        }

        case 'scattering':
            // Spawn at center for outward movement (scattering needs this)
            return { x: centerX, y: centerY };

        case 'burst': {
            // Spawn at edge of orb so particles are visible
            const burstAngle = Math.random() * Math.PI * 2;
            if (emotion === 'suspicion') {
                const burstRadius = orbRadius * 1.5; // Further outside for suspicion
                return {
                    x: centerX + Math.cos(burstAngle) * burstRadius,
                    y: centerY + Math.sin(burstAngle) * burstRadius
                };
            } else if (emotion === 'surprise') {
                // Surprise spawns around the orb edge for visibility
                const burstRadius = orbRadius * 1.2; // Just outside the orb
                return {
                    x: centerX + Math.cos(burstAngle) * burstRadius,
                    y: centerY + Math.sin(burstAngle) * burstRadius
                };
            } else {
                // Other emotions spawn at center
                return { x: centerX, y: centerY };
            }
        }

        case 'repelling': {
            // Spawn at edge of glow so particles are visible
            const repelAngle = Math.random() * Math.PI * 2;
            const repelRadius = glowRadius * 0.9; // Just at glow edge
            return {
                x: centerX + Math.cos(repelAngle) * repelRadius,
                y: centerY + Math.sin(repelAngle) * repelRadius
            };
        }

        case 'orbiting': {
            // Spawn at orbital distance outside the glow
            const orbitAngle = Math.random() * Math.PI * 2;
            const orbitRadius = glowRadius * 1.2 + Math.random() * glowRadius * 0.5;
            return {
                x: centerX + Math.cos(orbitAngle) * orbitRadius,
                y: centerY + Math.sin(orbitAngle) * orbitRadius
            };
        }

        case 'glitchy': {
            // Spawn glitch particles at various distances from center for wide spread
            const glitchAngle = Math.random() * Math.PI * 2;
            const glitchRadius = glowRadius * 3 + Math.random() * glowRadius * 4; // Much wider spread (3-7x glow radius)
            return {
                x: centerX + Math.cos(glitchAngle) * glitchRadius,
                y: centerY + Math.sin(glitchAngle) * glitchRadius
            };
        }

        case 'spaz': {
            // Spawn spaz particles in a wide ring around the center for explosive effect
            const spazAngle = Math.random() * Math.PI * 2;
            const spazRadius = glowRadius * 2 + Math.random() * glowRadius * 3; // Very wide spread (2-5x glow radius)
            return {
                x: centerX + Math.cos(spazAngle) * spazRadius,
                y: centerY + Math.sin(spazAngle) * spazRadius
            };
        }

        default:
            return { x: centerX, y: centerY };
        }
    }

    /**
     * Clamps a position to stay within canvas boundaries
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @param {number} canvasWidth - Canvas width
     * @param {number} canvasHeight - Canvas height
     * @param {number} margin - Distance from edges (default: 30)
     * @returns {Object} Clamped position {x, y}
     */
    clampToCanvas(x, y, canvasWidth, canvasHeight, margin = 30) {
        return {
            x: Math.max(margin, Math.min(canvasWidth - margin, x)),
            y: Math.max(margin, Math.min(canvasHeight - margin, y))
        };
    }

    /**
     * Calculates how many particles to spawn based on rate and delta time
     * Uses time-based accumulation for smooth spawning
     *
     * @param {number} particleRate - Desired particles per second
     * @param {number} deltaTime - Time since last frame in milliseconds
     * @returns {number} Number of particles to spawn this frame
     */
    calculateSpawnRate(particleRate, deltaTime) {
        // Don't spawn if rate is 0
        if (particleRate <= 0) return 0;

        // TIME-BASED SPAWNING using accumulation
        // particleRate represents desired particles per second
        // deltaTime is in milliseconds
        // Cap deltaTime to prevent huge accumulation spikes
        const cappedDeltaTime = Math.min(deltaTime, 50);
        const particlesPerSecond = particleRate;
        const particlesPerMs = particlesPerSecond / 1000;

        // Accumulate spawn time with capped delta
        this.spawnAccumulator += particlesPerMs * cappedDeltaTime;

        // Cap accumulator to prevent excessive spawning after long pauses
        this.spawnAccumulator = Math.min(this.spawnAccumulator, 3.0);

        // Calculate how many particles to spawn
        let particlesToSpawn = 0;
        while (this.spawnAccumulator >= 1.0) {
            particlesToSpawn++;
            this.spawnAccumulator -= 1.0;
        }

        return particlesToSpawn;
    }

    /**
     * Resets the spawn accumulator (for tab switches)
     */
    resetAccumulator() {
        this.spawnAccumulator = 0;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Particle Renderer
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Particle Renderer - Manages particle rendering logic
 * @author Emotive Engine Team
 * @module core/particle/ParticleRenderer
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Manages RENDERING LOGIC for particles. Handles layer-based rendering (foreground/
 * ║ background), culling, batching, and gesture effects like firefly, flicker, shimmer.
 * ║
 * ║ Extracted from ParticleSystem to follow Single Responsibility Principle.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎨 RENDERING STRATEGY
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Layer-based rendering (z < 0 background, z >= 0 foreground)
 * │ • Off-screen culling with 50px margin
 * │ • Batch optimization (minimize state changes)
 * │ • Sort by render properties (cell-shaded, glow)
 * │ • Gesture effects (firefly, flicker, shimmer, glow)
 * │ • Depth-adjusted sizing
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class ParticleRenderer {
    /**
     * Renders all particles (legacy method - renders all layers)
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {Array} particles - Array of particles to render
     * @param {string} emotionColor - Fallback color
     * @param {Object} gestureTransform - Optional gesture effects
     */
    render(ctx, particles, emotionColor = '#ffffff', gestureTransform = null) {
        const visibleParticles = [];

        // Skip dead particles only
        for (const particle of particles) {
            if (particle.life <= 0) continue;
            visibleParticles.push(particle);
        }

        // Render the particles
        this._renderParticles(ctx, visibleParticles, emotionColor, gestureTransform);
    }

    /**
     * Renders a specific layer (foreground or background)
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {Array} particles - Array of all particles
     * @param {string} emotionColor - Fallback color
     * @param {boolean} isForeground - true for foreground (z >= 0), false for background (z < 0)
     * @param {Object} gestureTransform - Optional gesture effects
     * @returns {Array} Visible particles that were rendered
     */
    renderLayer(ctx, particles, emotionColor = '#ffffff', isForeground = false, gestureTransform = null) {
        const visibleParticles = [];

        // First pass: cull off-screen, dead, and wrong-layer particles
        const margin = 50;
        const canvasWidth = ctx.canvas.width;
        const canvasHeight = ctx.canvas.height;

        for (const particle of particles) {
            // Filter by z-layer
            const particleInForeground = particle.z >= 0;
            if (particleInForeground !== isForeground) {
                continue; // Skip particles in wrong layer
            }

            // Skip off-screen particles (culling)
            if (particle.x < -margin || particle.x > canvasWidth + margin ||
                particle.y < -margin || particle.y > canvasHeight + margin) {
                continue;
            }

            // Skip dead particles
            if (particle.life <= 0) continue;

            visibleParticles.push(particle);
        }

        // Sort by render type to minimize state changes
        visibleParticles.sort((a, b) => {
            if (a.isCellShaded !== b.isCellShaded) {
                return a.isCellShaded ? -1 : 1;
            }
            if (a.hasGlow !== b.hasGlow) {
                return a.hasGlow ? -1 : 1;
            }
            return 0;
        });

        // Actually render the particles
        this._renderParticles(ctx, visibleParticles, emotionColor, gestureTransform);

        return visibleParticles;
    }

    /**
     * Internal render implementation - batch optimized rendering
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {Array} visibleParticles - Pre-filtered visible particles
     * @param {string} emotionColor - Fallback color
     * @param {Object} gestureTransform - Optional gesture effects
     */
    _renderParticles(ctx, visibleParticles, emotionColor, gestureTransform = null) {
        // Batch render with minimized state changes
        ctx.save();
        let lastFillStyle = null;

        for (const particle of visibleParticles) {
            // For cell-shaded, use original render (they need complex stroke/fill combos)
            if (particle.isCellShaded) {
                particle.render(ctx, emotionColor);
                // Reset cached values since particle.render may have changed them
                lastFillStyle = null;
            } else {
                // Batch-optimized rendering for regular particles
                const particleColor = particle.color || emotionColor;

                // Only set fillStyle if it changed
                if (particleColor !== lastFillStyle) {
                    ctx.fillStyle = particleColor;
                    lastFillStyle = particleColor;
                }

                // Validate position once
                if (!isFinite(particle.x) || !isFinite(particle.y)) continue;

                // Use depth-adjusted size if particle has the method
                const depthSize = particle.getDepthAdjustedSize ? particle.getDepthAdjustedSize() : particle.size;
                let safeSize = Math.max(0.1, depthSize);

                // Calculate firefly glow (used by multiple effects)
                let fireflyGlow = 1.0;

                // Apply firefly effect if sparkle gesture is active
                if (gestureTransform && gestureTransform.fireflyEffect) {
                    const particlePhase = (particle.x * 0.01 + particle.y * 0.01 + particle.size * 0.1) % (Math.PI * 2);
                    const time = gestureTransform.fireflyTime || (Date.now() * 0.001);
                    const intensity = gestureTransform.particleGlow || 2.0;

                    fireflyGlow = 0.3 + Math.max(0, Math.sin(time * 3 + particlePhase)) * intensity;
                }

                // Apply flicker effect if flicker gesture is active (now does particle shimmer)
                if (gestureTransform && gestureTransform.flickerEffect) {
                    const particlePhase = (particle.x * 0.02 + particle.y * 0.02) % (Math.PI * 2);
                    const time = gestureTransform.flickerTime || (Date.now() * 0.001);
                    const intensity = gestureTransform.particleGlow || 2.0;

                    fireflyGlow = 0.5 + Math.sin(time * 12 + particlePhase) * intensity * 0.5;
                }

                // Apply shimmer effect if shimmer gesture is active (subtle glow)
                if (gestureTransform && gestureTransform.shimmerEffect) {
                    const dx = particle.x - (ctx.canvas.width / 2);
                    const dy = particle.y - (ctx.canvas.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const normalizedDistance = distance / 200;

                    const time = gestureTransform.shimmerTime || (Date.now() * 0.001);
                    const wave = gestureTransform.shimmerWave || 0;
                    const intensity = gestureTransform.particleGlow || 1.2;

                    const travelingWave = Math.sin(time * 3 - normalizedDistance + wave);
                    fireflyGlow = 1 + travelingWave * 0.15 * intensity;
                }

                // Apply glow effect if glow gesture is active (radiant burst)
                if (gestureTransform && gestureTransform.glowEffect) {
                    const progress = gestureTransform.glowProgress || 0;
                    const intensity = gestureTransform.particleGlow || 2.0;

                    const dx = particle.x - (ctx.canvas.width / 2);
                    const dy = particle.y - (ctx.canvas.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const normalizedDistance = distance / 300;

                    const radiateDelay = Math.min(normalizedDistance * 0.3, 0.5);
                    const localProgress = Math.max(0, (progress - radiateDelay) / (1 - radiateDelay));
                    const localEnvelope = Math.sin(localProgress * Math.PI);

                    // Store original glow properties
                    if (!particle._originalGlow) {
                        particle._originalGlow = {
                            hasGlow: particle.hasGlow,
                            glowSizeMultiplier: particle.glowSizeMultiplier || 0
                        };
                    }

                    // Enable glow temporarily
                    particle.hasGlow = true;
                    particle.glowSizeMultiplier = Math.max(3.0, particle._originalGlow.glowSizeMultiplier) + localEnvelope * intensity * 3;

                    // Boost particle size
                    const glowSizeBoost = 1 + localEnvelope * 0.3;
                    safeSize = safeSize * glowSizeBoost;

                    // Cleanup when effect ends
                    if (progress >= 0.99 && particle._originalGlow) {
                        particle.hasGlow = particle._originalGlow.hasGlow;
                        particle.glowSizeMultiplier = particle._originalGlow.glowSizeMultiplier;
                        delete particle._originalGlow;
                    }
                }

                // Draw glow layers if needed
                if (particle.hasGlow || fireflyGlow > 1.0) {
                    const glowRadius = Math.max(0.1, safeSize * (particle.glowSizeMultiplier || 1.5) * fireflyGlow);

                    const originalCompositeOp = ctx.globalCompositeOperation;
                    ctx.globalCompositeOperation = 'screen';

                    // Outer glow
                    ctx.globalAlpha = particle.opacity * 0.15 * fireflyGlow;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, glowRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Inner glow
                    ctx.globalAlpha = particle.opacity * 0.25 * fireflyGlow;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, glowRadius * 0.6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.globalCompositeOperation = originalCompositeOp;
                }

                // Draw core
                ctx.globalAlpha = particle.opacity * (particle.baseOpacity || 0.5) * 0.6 * Math.min(2.0, fireflyGlow);
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, safeSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        ctx.restore();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                     ◐ ◑ ◒ ◓  PARTICLE SYSTEM  ◓ ◒ ◑ ◐                     
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Particle System - Orchestrator of Emotional Atmosphere with 3D Depth
 * @author Emotive Engine Team
 * @version 2.4.0
 * @module ParticleSystem
 * @changelog 2.4.0 - Added z-coordinate depth system with split rendering layers
 * @changelog 2.3.0 - Batch rendering optimization for reduced state changes
 * @changelog 2.2.0 - Added undertone saturation system for dynamic particle depth
 * @changelog 2.1.0 - Added support for passing emotion colors to individual particles
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The CONDUCTOR of particle chaos. Manages the lifecycle, behavior, and             
 * ║ performance of all particles. Uses object pooling to prevent memory leaks         
 * ║ and coordinates particles to create emotional atmospheres around the orb.         
 * ║                                                                                    
 * ║ NEW: Undertone saturation dynamically adjusts particle colors based on emotional  
 * ║ intensity, creating visual depth through saturation levels.                       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎭 SYSTEM FEATURES                                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Object pooling for performance (reuse dead particles)                           
 * │ • Time-based spawning with accumulator                                            
 * │ • Automatic cleanup every 5 seconds                                               
 * │ • Memory leak detection and prevention                                            
 * │ • Dynamic particle limits based on emotion                                        
 * │ • 13 different particle behaviors                                                 
 * │ • Undertone-based saturation adjustments for particle colors                      
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔄 OBJECT POOL STRATEGY                                                           
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Lazy initialization (create as needed)                                          
 * │ • Max pool size: 50 particles                                                     
 * │ • Reuse dead particles before creating new                                        
 * │ • Track pool hits/misses for optimization                                         
 * │ • Absolute max: 2x configured limit (prevents runaway)                            
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 📊 PERFORMANCE LIMITS                                                             
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Default max particles  : 50                                                     
 * │ • Absolute max particles : 100 (2x default)                                       
 * │ • Pool size             : Min(maxParticles, 50)                                  
 * │ • Cleanup interval      : 5000ms                                                 
 * │ • Spawn rate            : Based on emotion config                                
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                              MEMORY MANAGEMENT                                    
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Critical for preventing memory leaks:                                             
 * ║ 1. Reuse particles from pool when available                                       
 * ║ 2. Clear references when returning to pool                                        
 * ║ 3. Periodic cleanup of excess particles                                           
 * ║ 4. Track creation/destruction for leak detection                                  
 * ║ 5. Hard limits prevent runaway particle creation                                  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class ParticleSystem {
    constructor(maxParticles = 50, errorBoundary = null) {
        this.errorBoundary = errorBoundary;
        this.maxParticles = maxParticles;
        this.absoluteMaxParticles = maxParticles * 2; // Hard limit to prevent leaks

        // Active particles
        this.particles = [];

        // Object pool - now managed by ParticlePool class
        this.particlePool = new ParticlePool(maxParticles);

        // Spawner - now managed by ParticleSpawner class
        this.particleSpawner = new ParticleSpawner();

        // Renderer - now managed by ParticleRenderer class
        this.particleRenderer = new ParticleRenderer();

        // Containment bounds (null = no containment)
        this.containmentBounds = null;

        // Delegate memory/performance tracking to pool
        this.stateChangeCount = 0;
        this.lastMemoryCheck = Date.now();
        this.lastLeakedCount = 0;

        // Performance tracking
        this.particleCount = 0;

        // Cleanup timer to prevent memory buildup
        this.cleanupTimer = 0;
        this.cleanupInterval = 5000; // Clean up every 5 seconds

        // ParticleSystem initialized
    }

    // Delegate pool properties for backward compatibility
    get pool() { return this.particlePool.pool; }
    get poolSize() { return this.particlePool.poolSize; }
    get poolHits() { return this.particlePool.poolHits; }
    get poolMisses() { return this.particlePool.poolMisses; }
    get totalParticlesCreated() { return this.particlePool.totalParticlesCreated; }
    get totalParticlesDestroyed() { return this.particlePool.totalParticlesDestroyed; }

    // Delegate spawner properties for backward compatibility
    get spawnAccumulator() { return this.particleSpawner.spawnAccumulator; }
    set spawnAccumulator(value) { this.particleSpawner.spawnAccumulator = value; }

    /**
     * Gets a particle from the pool or creates a new one
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {string} behavior - Particle behavior type
     * @returns {Particle} Particle instance
     */
    getParticleFromPool(x, y, behavior) {
        return this.particlePool.getParticle(
            x, y, behavior,
            this.scaleFactor || 1,
            this.particleSizeMultiplier || 1,
            this.currentEmotionColors,
            this.currentEmotion,
            this.gestureBehavior
        );
    }

    /**
     * Returns a particle to the pool for reuse
     * @param {Particle} particle - Particle to return to pool
     */
    returnParticleToPool(particle) {
        this.particlePool.returnParticle(particle);
    }

    /**
     * Spawns particles based on emotional state and particle rate
     * NEW APPROACH: Fixed timestep - only spawn at specific intervals
     * 
     * @param {string} behavior - Particle behavior type (ambient, rising, falling, etc.)
     * @param {string} emotion - Current emotional state
     * @param {number} particleRate - Rate of particle spawning (particles per second at 60fps)
     * @param {number} centerX - X coordinate of spawn center
     * @param {number} centerY - Y coordinate of spawn center
     * @param {number} deltaTime - Time since last frame in milliseconds
     * @param {number|null} count - Force spawn this many particles (null for rate-based)
     * @param {number} minParticles - Minimum particles to maintain
     * @param {number} maxParticles - Maximum particles allowed
     * @param {number} scaleFactor - Scale multiplier for particle sizes
     * @param {number} particleSizeMultiplier - Additional size multiplier
     * @param {Array|null} emotionColors - Array of color strings or weighted color objects
     * @param {string|null} undertone - Emotional undertone for saturation adjustment
     *                                   (intense, confident, nervous, clear, tired, subdued)
     *                                   Affects particle color saturation to create depth
     */
    spawn(behavior, emotion, particleRate, centerX, centerY, deltaTime, count = null, minParticles = 0, maxParticles = 10, scaleFactor = 1, particleSizeMultiplier = 1, emotionColors = null, undertone = null) {
        this.scaleFactor = scaleFactor; // Store for particle creation
        this.particleSizeMultiplier = particleSizeMultiplier; // Store for particle sizing
        if (this.errorBoundary) {
            return this.errorBoundary.wrap(() => {
                this._spawn(behavior, emotion, particleRate, centerX, centerY, deltaTime, count, minParticles, maxParticles, emotionColors, undertone);
            }, 'particle-spawn')();
        } else {
            this._spawn(behavior, emotion, particleRate, centerX, centerY, deltaTime, count, minParticles, maxParticles, emotionColors, undertone);
        }
    }
    
    /**
     * Resets the spawn accumulator (for tab switches)
     */
    resetAccumulator() {
        this.particleSpawner.resetAccumulator();
    }

    /**
     * Internal spawn implementation - TIME-BASED accumulation for smooth spawning
     * 
     * Applies undertone saturation adjustments to particle colors before spawning.
     * The saturation system creates visual depth:
     * - Intense/Confident: Oversaturated colors appear to pop forward
     * - Clear: Normal midtone colors sit in the middle ground  
     * - Tired/Subdued: Desaturated colors recede into background
     * 
     * This creates a natural transition as particles cycle through their lifecycle,
     * with new particles spawning with current undertone saturation while existing
     * particles maintain their original colors until expiration.
     */
    _spawn(behavior, emotion, particleRate, centerX, centerY, deltaTime, count, minParticles = 0, maxParticles = 10, emotionColors = null, undertone = null) {
        // Store emotion for particle initialization
        this.currentEmotion = emotion;
        
        // Debug logging removed for production
        
        // Store base colors and undertone separately to ensure consistent application
        this.baseEmotionColors = emotionColors;
        this.currentUndertone = undertone;
        
        // Apply undertone saturation to emotion colors for all particles
        // This adjustment persists for the lifetime of each particle, creating
        // smooth visual transitions as particles naturally cycle
        this.currentEmotionColors = emotionColors && undertone ? 
            applyUndertoneSaturationToArray(emotionColors, undertone) : 
            emotionColors;
        
        // Apply rhythm modulation if enabled
        let rhythmModulatedRate = particleRate;
        if (rhythmIntegration.isEnabled()) {
            const emotionConfig = emotionCache && emotionCache.isInitialized ? 
                emotionCache.getEmotion(emotion) : getEmotion(emotion);
            if (emotionConfig) {
                const modulation = rhythmIntegration.applyParticleRhythm(emotionConfig, this);
                
                // Apply emission burst on beat
                if (modulation.emitBurst) {
                    for (let i = 0; i < modulation.emitBurst && this.particles.length < maxParticles; i++) {
                        this.spawnSingleParticle(behavior, centerX, centerY);
                    }
                }
                
                // Modulate emission rate
                if (modulation.emissionRate !== undefined) {
                    rhythmModulatedRate *= modulation.emissionRate;
                }
            }
        }
        
        
        // If specific count is provided, spawn that many
        if (count !== null) {
            for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
                this.spawnSingleParticle(behavior, centerX, centerY);
            }
            return;
        }
        
        // Skip spawning if frame rate is too low (performance optimization)
        if (this.skipSpawnThisFrame) {
            return;
        }
        
        // Always maintain minimum particles
        while (this.particles.length < minParticles && this.particles.length < this.maxParticles) {
            this.spawnSingleParticle(behavior, centerX, centerY);
        }
        
        // If we're at or above max for this emotion, don't spawn more
        if (this.particles.length >= maxParticles) {
            return;
        }
        
        // Don't spawn if rate is 0
        if (rhythmModulatedRate <= 0) return;
        
        // Calculate how many particles to spawn using ParticleSpawner
        const particlesToSpawn = this.particleSpawner.calculateSpawnRate(rhythmModulatedRate, deltaTime);

        // Spawn the calculated number of particles
        for (let i = 0; i < particlesToSpawn && this.particles.length < maxParticles; i++) {
            this.spawnSingleParticle(behavior, centerX, centerY);
        }
    }

    /**
     * Backward compatibility wrapper for getSpawnPosition
     * @deprecated Use particleSpawner.getSpawnPosition instead
     */
    getSpawnPosition(behavior, centerX, centerY, canvasWidth, canvasHeight) {
        return this.particleSpawner.getSpawnPosition(behavior, centerX, centerY, canvasWidth, canvasHeight, this.currentEmotion);
    }

    /**
     * Backward compatibility wrapper for clampToCanvas
     * @deprecated Use particleSpawner.clampToCanvas instead
     */
    clampToCanvas(x, y, canvasWidth, canvasHeight, margin = 30) {
        return this.particleSpawner.clampToCanvas(x, y, canvasWidth, canvasHeight, margin);
    }

    /**
     * Spawns a single particle with the specified behavior
     * @param {string} behavior - Particle behavior type
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate
     */
    spawnSingleParticle(behavior, centerX, centerY) {
        // Hard limit check to prevent memory leaks
        if (this.particles.length >= this.absoluteMaxParticles) {
            return;
        }

        // Calculate spawn position based on behavior using ParticleSpawner
        // Pass canvas size for proper calculation when mascot is offset
        const canvasWidth = this.canvasWidth || (centerX * 2);
        const canvasHeight = this.canvasHeight || (centerY * 2);
        const spawnPos = this.particleSpawner.getSpawnPosition(behavior, centerX, centerY, canvasWidth, canvasHeight, this.currentEmotion);

        // CLAMP spawn position to canvas boundaries
        const clampedPos = this.particleSpawner.clampToCanvas(spawnPos.x, spawnPos.y, canvasWidth, canvasHeight);
        spawnPos.x = clampedPos.x;
        spawnPos.y = clampedPos.y;
        
        // Get particle from pool
        const particle = this.getParticleFromPool(spawnPos.x, spawnPos.y, behavior);
        
        // Pass additional data for meditation_swirl
        if (behavior === 'meditation_swirl' && spawnPos.palmCenter) {
            particle.palmCenter = spawnPos.palmCenter;
            particle.swirlAngle = spawnPos.swirlAngle;
        }
        
        // Add to active particles
        this.particles.push(particle);
        this.particleCount++;
        
        // Debug logging disabled to prevent console spam
        // Only uncomment for debugging particle spawning issues
        // if (this.particleCount <= 3) {
        // }
    }


    /**
     * Updates all particles and manages lifecycle
     * @param {number} deltaTime - Time since last update in milliseconds
     * @param {number} centerX - Center X coordinate for behavior calculations
     * @param {number} centerY - Center Y coordinate for behavior calculations
     * @param {Object} gestureMotion - Optional gesture motion to apply
     * @param {number} gestureProgress - Progress of gesture (0-1)
     * @param {Object} undertoneModifier - Optional undertone modifications
     */
    update(deltaTime, centerX, centerY, gestureMotion = null, gestureProgress = 0, undertoneModifier = null) {
        if (this.errorBoundary) {
            const wrappedUpdate = this.errorBoundary.wrap(
                (dt, cx, cy, gm, gp, um) => this._update(dt, cx, cy, gm, gp, um), 
                'particle-update'
            );
            return wrappedUpdate(deltaTime, centerX, centerY, gestureMotion, gestureProgress, undertoneModifier);
        } else {
            this._update(deltaTime, centerX, centerY, gestureMotion, gestureProgress, undertoneModifier);
        }
    }

    /**
     * Internal update implementation
     */
    _update(deltaTime, centerX, centerY, gestureMotion = null, gestureProgress = 0, undertoneModifier = null) {
        // PERFORMANCE OPTIMIZATION: Skip cleanup for small particle counts
        // 50 particles don't need periodic cleanup overhead
        // Cleanup is unnecessary for such small numbers

        // PERFORMANCE OPTIMIZATION: Skip memory leak detection for small particle counts
        // 50 particles don't need memory tracking overhead
        // Memory leaks aren't a concern with such small numbers

        // PERFORMANCE OPTIMIZATION: Use simple filter instead of complex loop
        // More efficient for small particle counts
        this.particles = this.particles.filter(particle => {
            particle.update(deltaTime, centerX, centerY, undertoneModifier, gestureMotion, gestureProgress, this.containmentBounds);
            return particle.isAlive();
        });
        
        // Enforce particle limit by removing oldest if necessary
        while (this.particles.length > this.maxParticles) {
            this.removeParticle(0); // Remove oldest (first in array)
        }
    }

    /**
     * Set a temporary gesture behavior for particles
     * @param {string} behaviorName - Name of the behavior (e.g., 'doppler')
     * @param {boolean} active - Whether the behavior is active
     */
    setGestureBehavior(behaviorName, active) {
        this.gestureBehavior = active ? behaviorName : null;
        
        // Apply gesture behavior to existing particles
        if (active) {
            this.particles.forEach(particle => {
                particle.gestureBehavior = behaviorName;
            });
        } else {
            // Clear gesture behavior from particles
            this.particles.forEach(particle => {
                particle.gestureBehavior = null;
            });
        }
    }

    /**
     * Removes a particle at the specified index
     * @param {number} index - Index of particle to remove
     */
    removeParticle(index) {
        if (index >= 0 && index < this.particles.length) {
            const particle = this.particles.splice(index, 1)[0];
            // Clear any cached data before returning to pool
            particle.cachedGradient = null;
            particle.cachedGradientKey = null;
            // Don't set behaviorData to null - let reset handle it properly
            this.returnParticleToPool(particle);
            this.particleCount = Math.max(0, this.particleCount - 1);
        }
    }

    /**
     * Renders all particles to the canvas context
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {string} emotionColor - Color to use for particle rendering
     * @param {Object} gestureTransform - Optional gesture transform data
     */
    render(ctx, emotionColor = '#ffffff', gestureTransform = null) {
        if (this.errorBoundary) {
            return this.errorBoundary.wrap(() => {
                this._render(ctx, emotionColor, gestureTransform);
            }, 'particle-render')();
        } else {
            this._render(ctx, emotionColor, gestureTransform);
        }
    }
    
    /**
     * Renders particles in the background layer (behind orb)
     * Particles with z < 0 are rendered, appearing smaller based on depth
     * 
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {string} emotionColor - Color to use for particle rendering
     * 
     * LAYER DISTRIBUTION:
     * - ~92% of particles render in background (z < 0)
     * - Particles scale from 80% to 100% size based on z-depth
     */
    renderBackground(ctx, emotionColor = '#ffffff', gestureTransform = null) {
        if (this.errorBoundary) {
            return this.errorBoundary.wrap(() => {
                this._renderLayer(ctx, emotionColor, false, gestureTransform); // false = background (z < 0)
            }, 'particle-render-bg')();
        } else {
            this._renderLayer(ctx, emotionColor, false, gestureTransform);
        }
    }
    
    /**
     * Renders particles in the foreground layer (in front of orb)
     * Particles with z >= 0 are rendered, appearing larger based on depth
     * 
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {string} emotionColor - Color to use for particle rendering
     * 
     * LAYER DISTRIBUTION:
     * - ~8% of particles render in foreground (z >= 0) 
     * - Particles scale from 100% to 120% size based on z-depth
     * - Spawn with offset to prevent visual stacking
     */
    renderForeground(ctx, emotionColor = '#ffffff', gestureTransform = null) {
        if (this.errorBoundary) {
            return this.errorBoundary.wrap(() => {
                this._renderLayer(ctx, emotionColor, true, gestureTransform); // true = foreground (z >= 0)
            }, 'particle-render-fg')();
        } else {
            this._renderLayer(ctx, emotionColor, true, gestureTransform);
        }
    }

    /**
     * Internal render implementation for a specific layer
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {string} emotionColor - Color to use for particle rendering
     * @param {boolean} isForeground - true for foreground (z >= 0), false for background (z < 0)
     */
    _renderLayer(ctx, emotionColor, isForeground, gestureTransform = null) {
        // Delegate to ParticleRenderer
        this.particleRenderer.renderLayer(ctx, this.particles, emotionColor, isForeground, gestureTransform);
    }
    
    /**
     * Internal render implementation - batch optimized rendering (legacy, renders all)
     */
    _render(ctx, emotionColor, gestureTransform = null) {
        // Delegate to ParticleRenderer
        this.particleRenderer.render(ctx, this.particles, emotionColor, gestureTransform);
    }

    /**
     * Clears all particles and returns them to the pool
     */
    clear() {
        this.stateChangeCount++;
        
        // Return all particles to pool but avoid duplicates
        while (this.particles.length > 0) {
            const particle = this.particles.pop();
            // Clear cached data before returning
            if (particle.cachedColors) {
                particle.cachedColors.clear();
            }
            // Clear behaviorData properties but keep the object
            if (particle.behaviorData) {
                for (const key in particle.behaviorData) {
                    delete particle.behaviorData[key];
                }
            }
            // Only add to pool if it's not already there and pool has space
            if (this.pool.length < this.poolSize && !this.pool.includes(particle)) {
                this.pool.push(particle);
            }
        }
        
        this.particles.length = 0;
        this.particleCount = 0;
        this.spawnAccumulator = 0; // Reset accumulator when clearing
        
        // Trim pool if it's grown too large
        if (this.pool.length > this.poolSize) {
            // Actually remove excess particles from pool
            const excess = this.pool.length - this.poolSize;
            this.pool.splice(this.poolSize, excess);
        }
        
    }

    /**
     * Triggers a burst of particles for gesture effects
     * @param {number} count - Number of particles to burst
     * @param {string} behavior - Behavior type for burst particles
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate
     */
    burst(count, behavior, centerX, centerY) {
        if (this.errorBoundary) {
            return this.errorBoundary.wrap(() => {
                this._burst(count, behavior, centerX, centerY);
            }, 'particle-burst')();
        } else {
            this._burst(count, behavior, centerX, centerY);
        }
    }

    /**
     * Internal burst implementation
     */
    _burst(count, behavior, centerX, centerY) {
        const actualCount = Math.min(count, this.maxParticles - this.particles.length);
        
        for (let i = 0; i < actualCount; i++) {
            this.spawnSingleParticle(behavior, centerX, centerY);
        }
    }

    /**
     * Performs periodic cleanup to prevent memory buildup
     */
    performCleanup() {
        // Trim pool if it's grown too large
        if (this.pool.length > this.poolSize) {
            // Clear excess particles from pool
            const excess = this.pool.length - this.poolSize;
            for (let i = 0; i < excess; i++) {
                const particle = this.pool.pop();
                // Ensure all references are cleared
                if (particle) {
                    particle.cachedGradient = null;
                    particle.cachedGradientKey = null;
                    particle.behaviorData = null;
                }
            }
        }
        
        // Clear any cached data from active particles
        for (const particle of this.particles) {
            if (particle.cachedGradient && particle.life < 0.5) {
                // Clear gradient cache for fading particles
                particle.cachedGradient = null;
                particle.cachedGradientKey = null;
            }
        }
    }
    
    /**
     * Gets current particle system statistics
     * @returns {Object} Performance and state information
     */
    getStats() {
        return {
            activeParticles: this.particles.length,
            maxParticles: this.maxParticles,
            poolSize: this.pool.length,
            poolHits: this.poolHits,
            poolMisses: this.poolMisses,
            poolEfficiency: this.poolHits / Math.max(1, this.poolHits + this.poolMisses),
            spawnAccumulator: this.spawnAccumulator
        };
    }

    /**
     * Sets the maximum number of particles
     * @param {number} maxParticles - New maximum particle count
     */
    setMaxParticles(maxParticles) {
        this.originalMaxParticles = this.originalMaxParticles || this.maxParticles;
        this.maxParticles = Math.max(1, maxParticles);
        
        // Remove excess particles if new limit is lower
        while (this.particles.length > this.maxParticles) {
            this.removeParticle(0);
        }
    }
    
    /**
     * Cleans up dead particles and optimizes the pool
     */
    cleanupDeadParticles() {
        // Remove any dead particles that shouldn't be there
        const beforeCount = this.particles.length;
        this.particles = this.particles.filter(particle => particle.isAlive());
        const removed = beforeCount - this.particles.length;
        
        // Clear excess items from the pool to free memory
        if (this.pool.length > 20) {
            this.pool.length = 20;
        }
        
        return removed;
    }

    /**
     * Gets particles by behavior type for debugging
     * @param {string} behavior - Behavior type to filter by
     * @returns {Array} Particles with matching behavior
     */
    getParticlesByBehavior(behavior) {
        return this.particles.filter(particle => particle.behavior === behavior);
    }

    /**
     * Validates that all particles are in valid state
     * @returns {boolean} True if all particles are valid
     */
    validateParticles() {
        for (const particle of this.particles) {
            if (!particle.isAlive() || particle.life < 0 || particle.life > 1) {
                return false;
            }
        }
        return true;
    }

    /**
     * Forces cleanup of dead particles (for testing)
     */
    cleanup() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            if (!this.particles[i].isAlive()) {
                this.removeParticle(i);
            }
        }
    }

    /**
     * Refreshes the particle pool by discarding all pooled particles
     * Used when scale changes to ensure new particles use updated scale factor
     */
    refreshPool() {
        // Delegate to ParticlePool and clear its stats
        this.particlePool.clear();

        // Also kill all active particles so they'll be replaced with properly scaled ones
        for (const particle of this.particles) {
            particle.life = 0; // Mark as dead - they'll be filtered out on next update
        }
    }

    /**
     * Set containment bounds for particles
     * @param {Object|null} bounds - {width, height} in pixels, or null to disable containment
     */
    setContainmentBounds(bounds) {
        this.containmentBounds = bounds;
    }

    /**
     * Destroys the particle system and cleans up resources
     */
    destroy() {
        this.clear();
        this.particlePool.clear();
        // ParticleSystem destroyed
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Particle 3D Translator
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Translates 2D particle positions and behaviors to 3D world space
 * @author Emotive Engine Team
 * @module 3d/particles/Particle3DTranslator
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Bridges the gap between 2D particle system and 3D rendering:
 * ║ • Converts canvas coordinates (x, y) to 3D world space
 * ║ • Maps z-depth to actual 3D distances and orbital radii
 * ║ • Translates 2D particle behaviors to 3D vector fields
 * ║ • Handles camera-relative positioning
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * COORDINATE SYSTEM TRANSFORMATION:
 *
 * 2D Canvas Space:              3D World Space:
 * (0,0)───────► X              Y ▲
 *   │                             │
 *   │    ⭐                        │  ⭐─── X
 *   ▼                             │ /
 *   Y                             │/
 *                                 └─────► Z
 *
 * - Canvas: origin top-left, Y down
 * - World:  origin center, Y up
 * - Z-depth: -1 (far) to +1 (near) → actual radius multipliers
 */


class Particle3DTranslator {
    constructor(options = {}) {
        // Base world scale - how large is the particle field in world units
        this.worldScale = options.worldScale || 0.2;

        // Base orbital radius around the mascot core (in world units)
        // This should match the 3D core's actual radius
        this.baseRadius = options.baseRadius || 0.15;

        // Depth scale multiplier - how much z-depth affects radius
        this.depthScale = options.depthScale || 0.75;

        // Vertical scale multiplier
        this.verticalScale = options.verticalScale || 1.0;

        // 3D core radius in world units - updated each frame from Core3DManager
        // This is the actual size of the crystal/orb that particles orbit around
        this.coreRadius3D = options.coreRadius3D || 1.0;

        // Reusable vectors for performance
        this.tempVec3 = new Vector3();
        this.tempVec3_2 = new Vector3();

        // Behavior-specific translators
        this.behaviorTranslators = this._initBehaviorTranslators();

        // Current gesture data (updated each frame)
        this.currentGestureData = null;
    }

    /**
     * Update the 3D core radius (called each frame when core scale changes)
     * This ensures particles orbit at correct distance regardless of screen size
     * @param {number} radius - Core radius in world units
     */
    setCoreRadius3D(radius) {
        this.coreRadius3D = radius;
    }

    /**
     * Update gesture state for gesture-based transformations
     * Called once per frame before translating particles
     *
     * @param {Object} rotationState - {euler: [x,y,z], quaternion: THREE.Quaternion, angularVelocity: [x,y,z]}
     * @param {number} deltaTime - Time since last frame (ms)
     * @param {Object} gestureData - Active gesture data
     */
    updateRotationState(rotationState, deltaTime, gestureData = null) {
        this.rotationState = rotationState;
        this.deltaTime = deltaTime;

        // Store current gesture data for use in translation
        this.currentGestureData = gestureData;
    }


    /**
     * Initialize behavior-specific translation functions
     * Each behavior gets custom logic for 3D positioning
     * @returns {Object} Map of behavior names to translator functions
     */
    _initBehaviorTranslators() {
        return {
            ambient: this._translateAmbient.bind(this),
            orbiting: this._translateOrbiting.bind(this),
            rising: this._translateRising.bind(this),
            falling: this._translateFalling.bind(this),  // Rain-like tears falling - spawns behind crystal
            popcorn: this._translatePopcorn.bind(this),
            burst: this._translateBurst.bind(this),
            aggressive: this._translateAggressive.bind(this),
            scattering: this._translateScattering.bind(this),
            repelling: this._translateRepelling.bind(this),
            connecting: this._translateConnecting.bind(this),
            resting: this._translateResting.bind(this),
            radiant: this._translateRadiant.bind(this),
            ascending: this._translateAscending.bind(this),
            erratic: this._translateErratic.bind(this),
            cautious: this._translateCautious.bind(this),
            surveillance: this._translateSurveillance.bind(this),
            glitchy: this._translateGlitchy.bind(this),
            spaz: this._translateSpaz.bind(this),
            directed: this._translateDirected.bind(this),
            fizzy: this._translateFizzy.bind(this),
            zen: this._translateZen.bind(this),
            gravitationalAccretion: this._translateGravitationalAccretion.bind(this)
        };
    }

    /**
     * Main translation function - converts 2D particle to 3D position with gesture override
     * @param {Object} particle - 2D particle with x, y, z, behavior
     * @param {Object} corePosition - 3D mascot position {x, y, z}
     * @param {Object} canvasSize - Canvas dimensions {width, height}
     * @returns {THREE.Vector3} 3D world position
     */
    translate2DTo3D(particle, corePosition, canvasSize) {
        // Get behavior-specific translation (normal emotional state position)
        const translator = this.behaviorTranslators[particle.behavior] || this._translateDefault.bind(this);
        const basePosition = translator(particle, corePosition, canvasSize);

        // Apply gesture-specific transformations
        if (this.currentGestureData && this.currentGestureData.gestureName === 'spin') {
            return this._applySpinRotation(basePosition, corePosition, this.currentGestureData.progress);
        }

        // For other gestures (like scan), the 2D particle system handles the positioning
        // We just translate those 2D positions to 3D without additional transforms
        return basePosition;
    }

    /**
     * Apply spin rotation to particle position
     * Rotates particle around the core on Y-axis based on gesture progress
     *
     * @param {THREE.Vector3} position - Particle's base position from emotional behavior
     * @param {Object} corePosition - Mascot center {x, y, z}
     * @param {number} progress - Gesture progress (0-1)
     * @returns {THREE.Vector3} Rotated position
     */
    _applySpinRotation(position, corePosition, progress) {
        // Get position relative to core
        const relativeX = position.x - corePosition.x;
        const relativeY = position.y - corePosition.y;
        const relativeZ = position.z - corePosition.z;

        // Spin gesture rotates 360° (2π radians) around Y-axis
        // Use sin curve so rotation smoothly returns to 0 at end
        const rotationCurve = Math.sin(progress * Math.PI);
        const angle = rotationCurve * Math.PI * 2; // 0 → 2π → 0

        // Rotate around Y-axis (vertical)
        const cosAngle = Math.cos(angle);
        const sinAngle = Math.sin(angle);

        const rotatedX = relativeX * cosAngle - relativeZ * sinAngle;
        const rotatedZ = relativeX * sinAngle + relativeZ * cosAngle;

        // Return rotated position in world space
        return this.tempVec3.set(
            corePosition.x + rotatedX,
            corePosition.y + relativeY, // Y unchanged (spin on Y-axis)
            corePosition.z + rotatedZ
        );
    }

    /**
     * Convert canvas coordinates to world space (basic conversion)
     * @param {number} canvasX - Canvas X coordinate
     * @param {number} canvasY - Canvas Y coordinate
     * @param {number} canvasZ - Z-depth (-1 to 1)
     * @param {number} centerX - Canvas center X
     * @param {number} centerY - Canvas center Y
     * @param {Object} corePosition - Core 3D position
     * @returns {THREE.Vector3} World space position
     */
    _canvasToWorld(canvasX, canvasY, canvasZ, centerX, centerY, corePosition) {
        // Convert to normalized coordinates (-1 to 1)
        const normalizedX = (canvasX - centerX) / centerX;
        const normalizedY = -(canvasY - centerY) / centerY; // Flip Y axis

        // Map z-depth to radius multiplier
        // z = -1 (far) → radius 0.5x
        // z = 0 (mid) → radius 1.0x
        // z = +1 (near) → radius 1.75x
        const radiusMultiplier = 1.0 + (canvasZ * this.depthScale);

        // Calculate world position
        const worldX = normalizedX * this.worldScale * radiusMultiplier + corePosition.x;
        const worldY = normalizedY * this.worldScale * this.verticalScale * radiusMultiplier + corePosition.y;
        const worldZ = canvasZ * this.worldScale * 0.5 + corePosition.z; // Z contributes to actual depth

        return this.tempVec3.set(worldX, worldY, worldZ);
    }

    /**
     * Simple deterministic hash function for better pseudo-random distribution
     * Returns value in range [0, 1)
     */
    _hash(n) {
        const x = Math.sin(n) * 43758.5453123;
        return x - Math.floor(x);
    }

    /**
     * Generate uniform random direction on sphere (360°x360°x360°)
     * Uses spherical coordinates with deterministic seeds from particle properties
     * Caches result in behaviorData.direction3D to maintain consistent trajectory
     *
     * @param {Object} particle - Particle with properties for seeding
     * @returns {Object} Normalized 3D direction vector {x, y, z}
     */
    _getUniformDirection3D(particle) {
        const behaviorData = particle.behaviorData || {};

        // Return cached direction if already generated
        if (behaviorData.direction3D) {
            return behaviorData.direction3D;
        }

        // Use particle's properties as deterministic seeds with better hash
        // Combine multiple properties for unique seeds per particle
        const baseSeed = particle.x * 127.1 + particle.y * 311.7 + (particle.vx || 0) * 74.7 + (particle.vy || 0) * 159.3;

        // Generate two uniform random values using hash function
        const u1 = this._hash(baseSeed);
        const u2 = this._hash(baseSeed + 1.0);

        // Generate uniform spherical coordinates
        // Theta (azimuth): 0 to 2π - uniform distribution
        const theta = u1 * Math.PI * 2;

        // Phi (elevation): use arccos for uniform sphere surface distribution
        // cos(phi) uniform in [-1, 1] ensures uniform surface distribution
        const cosphi = 2.0 * u2 - 1.0; // Range: -1 to +1
        const sinPhi = Math.sqrt(1.0 - cosphi * cosphi);

        // Convert spherical to Cartesian coordinates
        const x = sinPhi * Math.cos(theta);
        const y = cosphi; // Y is up
        const z = sinPhi * Math.sin(theta);

        // Cache the direction for consistent trajectory
        behaviorData.direction3D = { x, y, z };
        return behaviorData.direction3D;
    }

    /**
     * Convert Cartesian to Spherical coordinates
     * @param {number} x - World X
     * @param {number} y - World Y
     * @param {number} z - World Z
     * @param {Object} center - Sphere center
     * @returns {Object} {radius, theta, phi}
     */
    _toSpherical(x, y, z, center) {
        const dx = x - center.x;
        const dy = y - center.y;
        const dz = z - center.z;

        const radius = Math.sqrt(dx * dx + dy * dy + dz * dz);
        const theta = Math.atan2(dz, dx); // Azimuthal angle
        const phi = Math.acos(dy / (radius || 1)); // Polar angle

        return { radius, theta, phi };
    }

    /**
     * Convert Spherical to Cartesian coordinates
     * @param {number} radius - Distance from center
     * @param {number} theta - Azimuthal angle
     * @param {number} phi - Polar angle
     * @param {Object} center - Sphere center
     * @returns {THREE.Vector3} Cartesian position
     */
    _toCartesian(radius, theta, phi, center) {
        const x = radius * Math.sin(phi) * Math.cos(theta) + center.x;
        const y = radius * Math.cos(phi) + center.y;
        const z = radius * Math.sin(phi) * Math.sin(theta) + center.z;

        return this.tempVec3_2.set(x, y, z);
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // BEHAVIOR TRANSLATORS - One function per behavior
    // ═══════════════════════════════════════════════════════════════════════════════

    /**
     * DEFAULT: Basic canvas-to-world conversion
     */
    _translateDefault(particle, corePosition, canvasSize) {
        return this._canvasToWorld(
            particle.x, particle.y, particle.z,
            canvasSize.width / 2, canvasSize.height / 2,
            corePosition
        );
    }

    /**
     * AMBIENT: Gentle floating in 360°x360°x360° sphere
     * Particles drift slowly around the mascot in all directions
     */
    _translateAmbient(particle, corePosition, canvasSize) {
        // Get uniform 3D direction
        const dir = this._getUniformDirection3D(particle);

        const centerX = canvasSize.width / 2;
        const centerY = canvasSize.height / 2;

        // Calculate normalized distance (0-1) from center in 2D
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance2D = Math.sqrt(dx * dx + dy * dy);
        const normalizedDistance = distance2D / centerX; // 0 at center, 1 at edge

        // Convert to world distance using 3D core radius
        // Neutral: particles spread out wider (0.6x to 1.2x core radius)
        const minOrbit = this.coreRadius3D * 0.6;
        const maxOrbit = this.coreRadius3D * 1.2;
        const worldDistance = minOrbit + normalizedDistance * (maxOrbit - minOrbit);

        // Add slow spiral motion based on particle age
        const spiralAngle = particle.age * 0.5;
        const spiralRadius = this.coreRadius3D * 0.03;
        const spiralX = Math.cos(spiralAngle) * spiralRadius;
        const spiralZ = Math.sin(spiralAngle) * spiralRadius;

        // Position along 3D direction with gentle drift
        return this.tempVec3.set(
            corePosition.x + dir.x * worldDistance + spiralX,
            corePosition.y + dir.y * worldDistance * this.verticalScale,
            corePosition.z + dir.z * worldDistance + spiralZ
        );
    }

    /**
     * ORBITING: Circular paths around the core in full 3D sphere
     * Each particle orbits in its own tilted plane for 360°x360°x360° coverage
     */
    _translateOrbiting(particle, corePosition, canvasSize) {
        const behaviorData = particle.behaviorData || {};

        // Get or generate unique orbital plane for this particle
        if (!behaviorData.orbitPlane) {
            const seed1 = particle.x + particle.y * 0.5;
            const seed2 = particle.x * 0.7 + particle.y;

            behaviorData.orbitPlane = {
                inclination: ((Math.sin(seed1 * 0.1) + 1) * 0.5) * Math.PI,
                rotation: ((Math.sin(seed2 * 0.1) + 1) * 0.5) * Math.PI * 2
            };
        }

        const { inclination, rotation } = behaviorData.orbitPlane;
        const angle = behaviorData.angle || 0;
        // Love: tighter orbits (0.25x base radius)
        const radius = (behaviorData.radius || 100) * 0.01 * this.baseRadius * 0.25;

        // Depth affects orbital radius
        const radiusMultiplier = 1.0 + (particle.z * this.depthScale);
        const finalRadius = radius * radiusMultiplier;

        // Calculate position in XZ plane first
        const xFlat = Math.cos(angle) * finalRadius;
        const zFlat = Math.sin(angle) * finalRadius;

        // Rotate by inclination to tilt the orbital plane
        const cosIncl = Math.cos(inclination);
        const sinIncl = Math.sin(inclination);
        const cosRot = Math.cos(rotation);
        const sinRot = Math.sin(rotation);

        // Apply 3D rotation for diverse orbital planes
        const x = xFlat * cosRot - zFlat * cosIncl * sinRot;
        const y = zFlat * sinIncl;
        const z = xFlat * sinRot + zFlat * cosIncl * cosRot;

        return this.tempVec3.set(
            corePosition.x + x,
            corePosition.y + y * this.verticalScale,
            corePosition.z + z
        );
    }

    /**
     * RISING: Upward motion with slight swirl
     */
    _translateRising(particle, corePosition, canvasSize) {
        const pos = this._canvasToWorld(
            particle.x, particle.y, particle.z,
            canvasSize.width / 2, canvasSize.height / 2,
            corePosition
        );

        // Add upward emphasis
        const riseBoost = particle.vy * -0.01; // vy is negative for upward
        pos.y += riseBoost;

        return pos;
    }

    /**
     * FALLING: Rain-like tears falling downward (Sadness)
     * Positioned EXACTLY like ambient, but falls straight down over time
     */
    _translateFalling(particle, corePosition, canvasSize) {
        // Use same uniform 3D direction as ambient (cached in behaviorData.direction3D)
        const dir = this._getUniformDirection3D(particle);

        const centerX = canvasSize.width / 2;
        const centerY = canvasSize.height / 2;

        // Calculate normalized distance (0-1) from center in 2D - SAME AS AMBIENT
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance2D = Math.sqrt(dx * dx + dy * dy);
        const normalizedDistance = distance2D / centerX;

        // Convert to world distance using 3D core radius - SAME AS AMBIENT
        const minOrbit = this.coreRadius3D * 0.6;
        const maxOrbit = this.coreRadius3D * 1.2;
        const worldDistance = minOrbit + normalizedDistance * (maxOrbit - minOrbit);

        // Calculate fall distance based on age
        // fallSpeed=0.6 means particle falls 0.6x coreRadius over its ~8 second lifetime
        const fallSpeed = 0.6;
        const fallDistance = particle.age * fallSpeed * this.coreRadius3D;

        // Position along 3D direction (like ambient) but fall straight down
        return this.tempVec3.set(
            corePosition.x + dir.x * worldDistance,
            corePosition.y + dir.y * worldDistance * this.verticalScale - fallDistance,
            corePosition.z + dir.z * worldDistance
        );
    }

    /**
     * POPCORN: Explosive bursts with uniform spherical distribution (360°x360°x360°)
     * Uses uniform sphere sampling for true omnidirectional emission
     * Particles burst outward from the soul, never appearing in front of it
     */
    _translatePopcorn(particle, corePosition, canvasSize) {
        const centerX = canvasSize.width / 2;
        const centerY = canvasSize.height / 2;
        const behaviorData = particle.behaviorData || {};

        // Get or generate uniform 3D direction
        const dir = this._getUniformDirection3D(particle);

        // Before pop, position particle at the soul surface ready to burst
        if (!behaviorData.hasPopped) {
            // Position at soul edge (0.7x core radius) - visible but not overlapping
            const waitDistance = this.coreRadius3D * 0.7;
            return this.tempVec3.set(
                corePosition.x + dir.x * waitDistance,
                corePosition.y + dir.y * waitDistance * this.verticalScale,
                corePosition.z + dir.z * waitDistance
            );
        }

        // Calculate normalized distance (0-1) from center in 2D
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance2D = Math.sqrt(dx * dx + dy * dy);
        const normalizedDistance = Math.min(distance2D / centerX, 1.5); // Cap at 1.5x

        // Convert to world distance using 3D core radius
        // Popcorn particles burst from outside the soul (1.2x) to far out (4.0x core radius)
        const minOrbit = this.coreRadius3D * 1.2;
        const maxOrbit = this.coreRadius3D * 4.0;
        const worldDistance = minOrbit + normalizedDistance * (maxOrbit - minOrbit);

        // Position particle along its 3D direction
        return this.tempVec3.set(
            corePosition.x + dir.x * worldDistance,
            corePosition.y + dir.y * worldDistance * this.verticalScale,
            corePosition.z + dir.z * worldDistance
        );
    }

    /**
     * BURST: Radial explosion from center with uniform 3D distribution
     */
    _translateBurst(particle, corePosition, canvasSize) {
        // Get uniform 3D direction
        const dir = this._getUniformDirection3D(particle);

        // Expand outward over lifetime (from core surface to 2x radius)
        const expansion = (1 - particle.life); // 0 to 1 as particle ages
        const radius = this.coreRadius3D * (1.0 + expansion * 1.0);

        // Position along 3D direction
        return this.tempVec3.set(
            corePosition.x + dir.x * radius,
            corePosition.y + dir.y * radius * this.verticalScale,
            corePosition.z + dir.z * radius
        );
    }

    /**
     * AGGRESSIVE: Fast chaotic motion bursting outward in 360°x360°x360° (Anger)
     * Anger particles explode from center with violent, erratic movement
     */
    _translateAggressive(particle, corePosition, canvasSize) {
        // Get uniform 3D direction for outward burst
        const dir = this._getUniformDirection3D(particle);

        const centerX = canvasSize.width / 2;
        const centerY = canvasSize.height / 2;

        // Calculate normalized distance (0-1) from center in 2D
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance2D = Math.sqrt(dx * dx + dy * dy);
        const normalizedDistance = distance2D / centerX;

        // Convert to world distance using 3D core radius - tight (0.3x to 0.55x)
        const minOrbit = this.coreRadius3D * 0.3;
        const maxOrbit = this.coreRadius3D * 0.55;
        const worldDistance = minOrbit + normalizedDistance * (maxOrbit - minOrbit);

        // Position along 3D direction with chaotic jitter (scaled to core size)
        const jitterScale = this.coreRadius3D * 0.04;
        const jitterX = Math.sin(particle.age * 10 + particle.x * 0.1) * jitterScale;
        const jitterY = Math.cos(particle.age * 12 + particle.y * 0.1) * jitterScale;
        const jitterZ = Math.sin(particle.age * 8 + particle.vx * 0.1) * jitterScale;

        return this.tempVec3.set(
            corePosition.x + dir.x * worldDistance + jitterX,
            corePosition.y + dir.y * worldDistance * this.verticalScale + jitterY,
            corePosition.z + dir.z * worldDistance + jitterZ
        );
    }

    /**
     * SCATTERING: Dispersing outward in all directions with uniform 3D distribution (Fear)
     */
    _translateScattering(particle, corePosition, canvasSize) {
        // Get uniform 3D direction
        const dir = this._getUniformDirection3D(particle);

        // Scatter outward based on particle age - tight (0.3x to 0.6x)
        const scatterAmount = Math.min(particle.age * 0.8, 1.0);
        const scatterRadius = this.coreRadius3D * (0.3 + scatterAmount * 0.3);

        // Position along 3D direction
        return this.tempVec3.set(
            corePosition.x + dir.x * scatterRadius,
            corePosition.y + dir.y * scatterRadius * this.verticalScale,
            corePosition.z + dir.z * scatterRadius
        );
    }

    /**
     * REPELLING: Push away from core with uniform 3D distribution (Disgust)
     */
    _translateRepelling(particle, corePosition, canvasSize) {
        // Get uniform 3D direction
        const dir = this._getUniformDirection3D(particle);

        // Repel outward based on particle age - tight around core (0.3x to 0.6x)
        const repelStrength = Math.min(particle.age * 0.6, 1.0);
        const repelRadius = this.coreRadius3D * (0.3 + repelStrength * 0.3);

        // Position along 3D direction
        return this.tempVec3.set(
            corePosition.x + dir.x * repelRadius,
            corePosition.y + dir.y * repelRadius * this.verticalScale,
            corePosition.z + dir.z * repelRadius
        );
    }

    /**
     * CONNECTING: Draw toward core (magnetic attraction)
     */
    _translateConnecting(particle, corePosition, canvasSize) {
        const pos = this._canvasToWorld(
            particle.x, particle.y, particle.z,
            canvasSize.width / 2, canvasSize.height / 2,
            corePosition
        );

        // Pull toward core based on life
        const pullStrength = (1 - particle.life) * 0.3;
        const direction = this.tempVec3_2.set(
            corePosition.x - pos.x,
            corePosition.y - pos.y,
            corePosition.z - pos.z
        ).normalize();

        pos.add(direction.multiplyScalar(pullStrength));

        return pos;
    }

    /**
     * RESTING: Minimal movement in 360°x360°x360° sphere
     * Particles float gently around the mascot with subtle breathing motion
     */
    _translateResting(particle, corePosition, canvasSize) {
        // Get uniform 3D direction
        const dir = this._getUniformDirection3D(particle);

        const centerX = canvasSize.width / 2;
        const centerY = canvasSize.height / 2;

        // Calculate normalized distance (0-1) from center in 2D
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance2D = Math.sqrt(dx * dx + dy * dy);
        const normalizedDistance = distance2D / centerX;

        // Convert to world distance using 3D core radius - tight (0.25x to 0.45x)
        const minOrbit = this.coreRadius3D * 0.25;
        const maxOrbit = this.coreRadius3D * 0.45;
        const worldDistance = minOrbit + normalizedDistance * (maxOrbit - minOrbit);

        // Add very subtle breathing motion (scaled to core size)
        const breathPhase = particle.age * 0.3;
        const breathOffset = Math.sin(breathPhase) * this.coreRadius3D * 0.01;

        // Position along 3D direction with gentle breathing
        return this.tempVec3.set(
            corePosition.x + dir.x * worldDistance,
            corePosition.y + dir.y * worldDistance * this.verticalScale + breathOffset,
            corePosition.z + dir.z * worldDistance
        );
    }

    /**
     * RADIANT: Expanding glow from center with uniform 3D distribution
     */
    _translateRadiant(particle, corePosition, canvasSize) {
        // Get uniform 3D direction
        const dir = this._getUniformDirection3D(particle);

        // Expand outward uniformly (from core to 1.8x radius)
        const expansion = 1 - particle.life; // 0 to 1 as particle ages
        const radius = this.coreRadius3D * (1.0 + expansion * 0.8);

        // Position along 3D direction
        return this.tempVec3.set(
            corePosition.x + dir.x * radius,
            corePosition.y + dir.y * radius * this.verticalScale,
            corePosition.z + dir.z * radius
        );
    }

    /**
     * ASCENDING: Spiral upward in helical path
     */
    _translateAscending(particle, corePosition, canvasSize) {
        const behaviorData = particle.behaviorData || {};

        // Helical motion parameters (scaled to core size)
        const angle = (behaviorData.spiralAngle || 0);
        const radius = (behaviorData.spiralRadius || 50) * 0.01 * this.coreRadius3D;
        const height = particle.age * this.coreRadius3D * 0.5;

        // Create helix
        const x = Math.cos(angle) * radius + corePosition.x;
        const y = height + corePosition.y;
        const z = Math.sin(angle) * radius + corePosition.z;

        return this.tempVec3.set(x, y, z);
    }

    /**
     * ERRATIC: Random jittery motion with noise
     */
    _translateErratic(particle, corePosition, canvasSize) {
        const pos = this._canvasToWorld(
            particle.x, particle.y, particle.z,
            canvasSize.width / 2, canvasSize.height / 2,
            corePosition
        );

        // Add 3D noise
        const noiseScale = 0.1;
        const time = particle.age * 10;
        pos.x += Math.sin(time * 1.1) * noiseScale;
        pos.y += Math.cos(time * 1.3) * noiseScale;
        pos.z += Math.sin(time * 1.7) * noiseScale;

        return pos;
    }

    /**
     * CAUTIOUS: Slow deliberate movement
     */
    _translateCautious(particle, corePosition, canvasSize) {
        // Similar to ambient but slower
        return this._translateAmbient(particle, corePosition, canvasSize);
    }

    /**
     * SURVEILLANCE: Tracking/scanning motion in full 3D sphere
     * Particles orbit and scan like searchlights covering all angles
     * Uses same technique as zen/ambient for consistent 3D distribution
     */
    _translateSurveillance(particle, corePosition, canvasSize) {
        // Get uniform 3D direction (uses x,y as seeds but results in sphere distribution)
        const dir = this._getUniformDirection3D(particle);

        // Surveillance particles orbit slowly in their own tilted plane
        const orbitAngle = particle.age * 0.5;
        const radius = this.coreRadius3D * 1.2;

        // Create perpendicular vector for rotation plane (same as zen)
        const up = { x: 0, y: 1, z: 0 };
        const perp = {
            x: dir.y * up.z - dir.z * up.y,
            y: dir.z * up.x - dir.x * up.z,
            z: dir.x * up.y - dir.y * up.x
        };

        // Normalize perpendicular vector
        const perpMag = Math.sqrt(perp.x * perp.x + perp.y * perp.y + perp.z * perp.z);
        if (perpMag > 0) {
            perp.x /= perpMag;
            perp.y /= perpMag;
            perp.z /= perpMag;
        }

        // Orbit in 3D plane defined by dir and perp
        const orbitX = Math.cos(orbitAngle) * dir.x + Math.sin(orbitAngle) * perp.x;
        const orbitY = Math.cos(orbitAngle) * dir.y + Math.sin(orbitAngle) * perp.y;
        const orbitZ = Math.cos(orbitAngle) * dir.z + Math.sin(orbitAngle) * perp.z;

        return this.tempVec3.set(
            corePosition.x + orbitX * radius,
            corePosition.y + orbitY * radius * this.verticalScale,
            corePosition.z + orbitZ * radius
        );
    }

    /**
     * GLITCHY: Digital artifact effect with teleportation
     */
    _translateGlitchy(particle, corePosition, canvasSize) {
        const pos = this._canvasToWorld(
            particle.x, particle.y, particle.z,
            canvasSize.width / 2, canvasSize.height / 2,
            corePosition
        );

        // Random glitch jumps
        const glitchPhase = Math.floor(particle.age * 10);
        if (glitchPhase % 3 === 0) {
            pos.x += (Math.random() - 0.5) * 0.3;
            pos.y += (Math.random() - 0.5) * 0.3;
            pos.z += (Math.random() - 0.5) * 0.3;
        }

        return pos;
    }

    /**
     * SPAZ: High-energy chaotic turbulence
     */
    _translateSpaz(particle, corePosition, canvasSize) {
        const pos = this._canvasToWorld(
            particle.x, particle.y, particle.z,
            canvasSize.width / 2, canvasSize.height / 2,
            corePosition
        );

        // Intense turbulence
        const turbulence = 0.15;
        const time = particle.age * 20;
        pos.x += Math.sin(time * 2.1) * turbulence;
        pos.y += Math.cos(time * 2.3) * turbulence;
        pos.z += Math.sin(time * 2.7) * turbulence;

        return pos;
    }

    /**
     * DIRECTED: Moves toward specific target, or emits uniformly in 360°x360°x360° if no target
     * Focused attention that can lock onto targets or scan in all directions
     */
    _translateDirected(particle, corePosition, canvasSize) {
        const behaviorData = particle.behaviorData || {};

        // If target is specified, move toward it
        if (behaviorData.targetX !== undefined && behaviorData.targetY !== undefined) {
            const targetPos = this._canvasToWorld(
                behaviorData.targetX,
                behaviorData.targetY,
                particle.z,
                canvasSize.width / 2,
                canvasSize.height / 2,
                corePosition
            );

            const currentPos = this._canvasToWorld(
                particle.x, particle.y, particle.z,
                canvasSize.width / 2, canvasSize.height / 2,
                corePosition
            );

            // Lerp toward target
            const progress = 1 - particle.life;
            return this.tempVec3.lerpVectors(currentPos, targetPos, progress);
        }

        // No target: emit uniformly in all directions like focused beams
        const dir = this._getUniformDirection3D(particle);

        const centerX = canvasSize.width / 2;
        const centerY = canvasSize.height / 2;

        // Calculate normalized distance (0-1) from center in 2D
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance2D = Math.sqrt(dx * dx + dy * dy);
        const normalizedDistance = distance2D / centerX;

        // Convert to world distance using 3D core radius
        const minOrbit = this.coreRadius3D * 1.0;
        const maxOrbit = this.coreRadius3D * 1.6;
        const worldDistance = minOrbit + normalizedDistance * (maxOrbit - minOrbit);

        // Position along 3D direction - focused beams radiating outward
        return this.tempVec3.set(
            corePosition.x + dir.x * worldDistance,
            corePosition.y + dir.y * worldDistance * this.verticalScale,
            corePosition.z + dir.z * worldDistance
        );
    }

    /**
     * FIZZY: Bubbly upward motion like champagne
     */
    _translateFizzy(particle, corePosition, canvasSize) {
        const pos = this._canvasToWorld(
            particle.x, particle.y, particle.z,
            canvasSize.width / 2, canvasSize.height / 2,
            corePosition
        );

        // Add fizzy bubble motion
        const bubbleWobble = Math.sin(particle.age * 8) * 0.05;
        pos.x += bubbleWobble;
        pos.z += Math.cos(particle.age * 8) * 0.05;

        // Emphasize upward motion
        pos.y += particle.age * 0.5;

        return pos;
    }

    /**
     * ZEN: Meditative slow drift
     */
    _translateZen(particle, corePosition, canvasSize) {
        // Get uniform 3D direction for orbital plane
        const dir = this._getUniformDirection3D(particle);

        // Zen particles orbit slowly in their own plane
        const zenAngle = particle.age * 0.2;
        const zenRadius = this.coreRadius3D * 1.4;

        // Create perpendicular vector for rotation plane
        // Use cross product to get perpendicular direction
        const up = { x: 0, y: 1, z: 0 };
        const perp = {
            x: dir.y * up.z - dir.z * up.y,
            y: dir.z * up.x - dir.x * up.z,
            z: dir.x * up.y - dir.y * up.x
        };

        // Normalize perpendicular vector
        const perpMag = Math.sqrt(perp.x * perp.x + perp.y * perp.y + perp.z * perp.z);
        if (perpMag > 0) {
            perp.x /= perpMag;
            perp.y /= perpMag;
            perp.z /= perpMag;
        }

        // Orbit in 3D plane defined by dir and perp
        const orbitX = Math.cos(zenAngle) * dir.x + Math.sin(zenAngle) * perp.x;
        const orbitY = Math.cos(zenAngle) * dir.y + Math.sin(zenAngle) * perp.y;
        const orbitZ = Math.cos(zenAngle) * dir.z + Math.sin(zenAngle) * perp.z;

        return this.tempVec3.set(
            corePosition.x + orbitX * zenRadius,
            corePosition.y + orbitY * zenRadius * this.verticalScale,
            corePosition.z + orbitZ * zenRadius
        );
    }

    /**
     * GRAVITATIONAL ACCRETION: Black hole accretion disk with spaghettification
     *
     * NASA M87* Supermassive Black Hole Physics:
     * - Keplerian orbits: tangential velocity increases as radius decreases
     * - Orbital decay: friction dissipates angular momentum, particles spiral inward
     * - Tidal stretching (spaghettification): starts at 2.5x, dramatic at 1.5x, death at 1.0x
     * - Accretion disk: particles orbit in equatorial plane with small vertical wobble
     *
     * @param {Object} particle - 2D particle with physics state
     * @param {Object} corePosition - Black hole center position
     * @param {Object} canvasSize - Canvas dimensions (unused for black hole)
     * @returns {THREE.Vector3} 3D position in accretion disk
     */
    _translateGravitationalAccretion(particle, corePosition, canvasSize) {
        const behaviorData = particle.behaviorData || {};
        const SCHWARZSCHILD_RADIUS = 0.25; // Base radius from BlackHole.js

        // Initialize orbital parameters on first call
        if (!behaviorData.orbitRadius) {
            // Spawn particles between ISCO (2.5x) and outer disk (8x)
            particle.x * 0.1 + particle.y * 0.2;
            behaviorData.orbitRadius = SCHWARZSCHILD_RADIUS * (2.5 + Math.random() * 5.5);

            // Only spawn particles in back hemisphere (away from camera on +Z axis)
            // Camera is at (0, 0, +Z) looking at origin, so particles should have negative Z
            // z = sin(angle) * radius, so negative Z means: π < angle < 2π
            // Angle range: π to 2π (180° to 360°, back half of orbit)
            behaviorData.orbitAngle = Math.PI + Math.random() * Math.PI;

            // Each particle gets slight inclination offset (thin disk, not perfectly flat)
            behaviorData.diskInclination = (Math.random() - 0.5) * 0.1; // ±5.7 degrees

            // Keplerian velocity: v ∝ 1/sqrt(r)
            behaviorData.angularVelocity = 0.5 / Math.sqrt(behaviorData.orbitRadius / SCHWARZSCHILD_RADIUS);

            // Tidal stretching factor (increases as radius decreases)
            behaviorData.tidalStretch = { x: 1.0, y: 1.0, z: 1.0 };
        }

        // Orbital decay: friction reduces angular momentum
        const decayRate = 0.0001; // Slow inward spiral
        behaviorData.orbitRadius -= decayRate * this.baseRadius;

        // Update angular velocity as radius changes (Kepler's 3rd law)
        behaviorData.angularVelocity = 0.5 / Math.sqrt(behaviorData.orbitRadius / SCHWARZSCHILD_RADIUS);

        // Advance orbital angle
        behaviorData.orbitAngle += behaviorData.angularVelocity * (this.deltaTime || 16) * 0.001;

        // Normalize angle to 0-2π range
        behaviorData.orbitAngle = behaviorData.orbitAngle % (Math.PI * 2);
        if (behaviorData.orbitAngle < 0) behaviorData.orbitAngle += Math.PI * 2;

        // Kill particles that orbit into front hemisphere (in front of black hole)
        // Camera is at +Z, so front hemisphere is when z = sin(angle) * radius > 0
        // This occurs when 0 < angle < π (0° to 180°)
        // Keep particles only in back hemisphere: π < angle < 2π (180° to 360°)
        if (behaviorData.orbitAngle < Math.PI) {
            // Particle orbited into front hemisphere - fade out and respawn
            particle.isAlive = false;
            particle.life = 0;
            return this.tempVec3.set(corePosition.x, corePosition.y, corePosition.z);
        }

        // Calculate tidal stretching (spaghettification)
        const radiusRatio = behaviorData.orbitRadius / SCHWARZSCHILD_RADIUS;

        if (radiusRatio <= 1.0) {
            // Particle crossed event horizon - mark for death
            particle.isAlive = false;
            particle.life = 0;
        } else if (radiusRatio <= 1.5) {
            // Dramatic stretching at photon sphere (1.5x)
            behaviorData.tidalStretch.x = 0.3; // Compressed horizontally
            behaviorData.tidalStretch.y = 3.0; // Stretched radially (toward black hole)
            behaviorData.tidalStretch.z = 0.3; // Compressed horizontally
        } else if (radiusRatio <= 2.5) {
            // Start stretching at ISCO (2.5x)
            const stretchFactor = (2.5 - radiusRatio) / 1.0; // 0 to 1 as we approach photon sphere
            behaviorData.tidalStretch.x = 1.0 - stretchFactor * 0.7; // Compress to 0.3
            behaviorData.tidalStretch.y = 1.0 + stretchFactor * 2.0; // Stretch to 3.0
            behaviorData.tidalStretch.z = 1.0 - stretchFactor * 0.7; // Compress to 0.3
        } else {
            // Outer disk - minimal tidal forces
            behaviorData.tidalStretch.x = 1.0;
            behaviorData.tidalStretch.y = 1.0;
            behaviorData.tidalStretch.z = 1.0;
        }

        // Position in accretion disk (equatorial plane)
        const x = Math.cos(behaviorData.orbitAngle) * behaviorData.orbitRadius;
        const z = Math.sin(behaviorData.orbitAngle) * behaviorData.orbitRadius;

        // Small vertical wobble (thin disk, not perfectly flat)
        const diskThickness = SCHWARZSCHILD_RADIUS * 0.1;
        const y = Math.sin(behaviorData.orbitAngle * 3 + particle.x) * diskThickness * Math.sin(behaviorData.diskInclination);

        // Apply tidal stretching to position (visual spaghettification effect)
        const stretchedX = x * behaviorData.tidalStretch.x;
        const stretchedY = y * behaviorData.tidalStretch.y;
        const stretchedZ = z * behaviorData.tidalStretch.z;

        // Scale to match black hole group scale (0.5 / (8 * SCHWARZSCHILD_RADIUS))
        const blackHoleScale = 0.5 / (SCHWARZSCHILD_RADIUS * 8.0);

        return this.tempVec3.set(
            corePosition.x + stretchedX * blackHoleScale,
            corePosition.y + stretchedY * blackHoleScale,
            corePosition.z + stretchedZ * blackHoleScale
        );
    }

    /**
     * Update world scale (for responsive sizing)
     * @param {number} scale - New world scale
     */
    setWorldScale(scale) {
        this.worldScale = scale;
    }

    /**
     * Update base radius (for different core sizes)
     * @param {number} radius - New base radius
     */
    setBaseRadius(radius) {
        this.baseRadius = radius;
    }

    /**
     * Clean up cached particle state data
     * Call this periodically or when particles are removed to prevent memory leaks
     * @param {Array} particles - Array of particles to clean up
     */
    cleanupParticleCaches(particles) {
        for (const particle of particles) {
            if (!particle.isAlive && particle.behaviorData) {
                // Clear cached 3D direction
                if (particle.behaviorData.direction3D) {
                    particle.behaviorData.direction3D = null;
                }
                // Clear orbital plane data
                if (particle.behaviorData.orbitPlane) {
                    particle.behaviorData.orbitPlane = null;
                }
                // Clear orbital path data
                if (particle.behaviorData.orbitPath) {
                    particle.behaviorData.orbitPath = null;
                }
                // Clear black hole accretion data
                if (particle.behaviorData.orbitRadius) {
                    particle.behaviorData.orbitRadius = null;
                    particle.behaviorData.orbitAngle = null;
                    particle.behaviorData.diskInclination = null;
                    particle.behaviorData.angularVelocity = null;
                    particle.behaviorData.tidalStretch = null;
                }
            }
        }
    }

    /**
     * Dispose of resources and clear references
     */
    dispose() {
        this.tempVec3 = null;
        this.tempVec3_2 = null;
        this.rotationState = null;
        this.currentGestureData = null;
    }
}

/**
 * CrystalSoul - Inner glowing core effect for translucent geometries
 *
 * A reusable soul/core effect that can be added to any translucent geometry
 * (crystal, diamond, heart, etc). Creates an animated glowing inclusion
 * with drifting energy and shimmer effects.
 */


// Cache for loaded inclusion geometry
let inclusionGeometryCache = null;
let inclusionGeometryLoading = null;

// Vertex shader for soul effect
const soulVertexShader = `
    varying vec3 vPosition;
    varying vec3 vNormal;

    void main() {
        vPosition = position;
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

// Fragment shader for animated energy effect
const soulFragmentShader = `
    uniform float time;
    uniform vec3 emotionColor;
    uniform float energyIntensity;
    uniform float driftEnabled;
    uniform float driftSpeed;
    uniform float crossWaveEnabled;
    uniform float crossWaveSpeed;
    uniform float ghostMode;      // 0.0 = solid, 1.0 = ghost (only visible through bloom)
    uniform float baseOpacity;    // Base opacity when not in ghost mode (default 1.0)
    uniform float phaseOffset1;   // Phase offset for primary drift (radians)
    uniform float phaseOffset2;   // Phase offset for secondary drift (radians)
    uniform float phaseOffset3;   // Phase offset for crosswave (radians)

    // Blend layer uniforms
    uniform float blendLayer1Mode;
    uniform float blendLayer1Strength;
    uniform float blendLayer1Enabled;
    uniform float blendLayer2Mode;
    uniform float blendLayer2Strength;
    uniform float blendLayer2Enabled;

    varying vec3 vPosition;
    varying vec3 vNormal;

    // Blend modes (injected from blendModesGLSL)
    ${blendModesGLSL}

    // Smooth noise function
    float noise3D(vec3 p) {
        vec3 i = floor(p);
        vec3 f = fract(p);
        f = f * f * (3.0 - 2.0 * f);
        float n = i.x + i.y * 157.0 + i.z * 113.0;
        vec4 v = fract(sin(vec4(n, n+1.0, n+157.0, n+158.0)) * 43758.5453);
        return mix(mix(v.x, v.y, f.x), mix(v.z, v.w, f.x), f.y);
    }

    void main() {
        // Drifting energy clouds - slow, ethereal movement
        // Start with zero energy - only effects add to it
        float driftEnergy = 0.0;
        float crossWaveEnergy = 0.0;

        // Spatially triangulated fire bands - each owns a 120° wedge of the geometry
        // Bands can never overlap because they're physically separated
        float angle = atan(vPosition.x, vPosition.z); // -π to π
        float normalizedAngle = (angle + 3.14159) / 6.28318; // 0 to 1

        // Determine which zone this fragment belongs to (0, 1, or 2)
        float zone = floor(normalizedAngle * 3.0);
        float zonePos = fract(normalizedAngle * 3.0); // Position within zone (0-1)

        // Time-based phase for each zone (120° offset in time)
        float phaseSpeed = 0.15;
        float t = time * phaseSpeed;
        float phase1Time = sin(t + phaseOffset1) * 0.5 + 0.5;
        float phase2Time = sin(t + phaseOffset2) * 0.5 + 0.5;
        float phase3Time = sin(t + phaseOffset3) * 0.5 + 0.5;

        // Only ONE phase affects this fragment - the one that owns this spatial zone
        float activePhase = zone < 1.0 ? phase1Time : (zone < 2.0 ? phase2Time : phase3Time);

        float primaryDrift = 0.0;
        float secondaryDrift = 0.0;

        if (driftEnabled > 0.5) {
            float t = time * driftSpeed;
            // Primary drift - moving in one direction
            float drift1 = noise3D(vPosition * 2.0 + vec3(t, t * 0.7, t * 0.3));
            float drift2 = noise3D(vPosition * 3.0 - vec3(t * 0.5, t, t * 0.8));
            // Use max instead of multiply to avoid near-zero products
            primaryDrift = max(drift1, drift2);
            primaryDrift = max(0.0, primaryDrift - 0.4) * 2.0; // Rescale after threshold

            // Secondary drift - offset in opposite direction to fill gaps
            float drift3 = noise3D(vPosition * 2.5 - vec3(t * 0.8, t * 0.4, t));
            float drift4 = noise3D(vPosition * 1.8 + vec3(t * 0.6, t * 0.9, t * 0.2));
            secondaryDrift = max(drift3, drift4);
            secondaryDrift = max(0.0, secondaryDrift - 0.4) * 2.0;

            driftEnergy = primaryDrift + secondaryDrift;
        }

        // Horizontal cross wave - thin bands sweeping across
        float rawCrossWave = 0.0;
        if (crossWaveEnabled > 0.5) {
            float t = time * crossWaveSpeed;
            float wave = sin(vPosition.x * 4.0 + vPosition.z * 2.0 - t) * 0.5 + 0.5;
            // pow(4) for thin bright bands
            rawCrossWave = pow(wave, 4.0);
            crossWaveEnergy = rawCrossWave;
        }

        // Mix the effects - normalize to prevent blowout
        // driftEnergy can be 0-2 (two drifts), rawCrossWave is 0-1
        float normalizedDrift = min(1.0, driftEnergy * 0.5);
        float normalizedWave = rawCrossWave;

        // activePhase is 0-1, remap to visibility range
        // 0.53 floor (just above 0.52 threshold), 0.58 ceiling (subtle glow)
        float remappedPhase = 0.53 + activePhase * 0.05;

        // Effects add subtle variation (max 0.05)
        float effectContrib = (normalizedDrift * 0.03) + (normalizedWave * 0.02);
        float phasedActivity = remappedPhase + effectContrib;

        // Keep unclamped for visibility threshold check (ghost mode needs full range)
        float rawEffectActivity = phasedActivity;
        // Clamp for color intensity (floor: guaranteed visible, ceiling: no blowout)
        float effectActivity = clamp(phasedActivity, 0.53, 0.60);

        // Total energy for color calculation (reduced for subtler bloom)
        float totalEnergy = 0.25 + effectActivity * 0.55; // Base glow + effect contribution

        // Edge glow - adds rim lighting
        vec3 viewDir = normalize(-vPosition);
        float edgeGlow = 1.0 - abs(dot(vNormal, viewDir));
        edgeGlow = pow(edgeGlow, 2.0) * 0.4;

        // Final color before blend layers
        vec3 coreColor = emotionColor * totalEnergy * energyIntensity;
        coreColor += emotionColor * edgeGlow * 0.3;

        // Apply blend layers to the entire soul color
        if (blendLayer1Enabled > 0.5) {
            int mode = int(blendLayer1Mode + 0.5);
            vec3 blendResult = applyBlendMode(coreColor, emotionColor * blendLayer1Strength, mode);
            coreColor = mix(coreColor, blendResult, blendLayer1Strength);
        }
        if (blendLayer2Enabled > 0.5) {
            int mode = int(blendLayer2Mode + 0.5);
            vec3 blendResult = applyBlendMode(coreColor, emotionColor * blendLayer2Strength, mode);
            coreColor = mix(coreColor, blendResult, blendLayer2Strength);
        }

        // Ghost mode: ONLY the traveling fire bands are visible
        // Everything below the threshold is completely invisible
        float alpha = baseOpacity;
        if (ghostMode > 0.01) {
            // High threshold - only the peaks of the thin bands pass through
            float threshold = 0.4 + ghostMode * 0.4; // 0.4-0.8 range
            float visibility = smoothstep(threshold, threshold + 0.05, rawEffectActivity);

            // Hard cutoff - only bright fire bands visible
            alpha = visibility * baseOpacity;

            // Discard everything that isn't a bright fire band
            if (alpha < 0.05) {
                discard;
            }

            // Boost color intensity for visible fire
            coreColor *= 1.2 + visibility * 0.6;
        }

        // Output the computed core color
        gl_FragColor = vec4(coreColor, alpha);
    }
`;

/**
 * CrystalSoul class - manages the inner glowing core
 */
class CrystalSoul {
    /**
     * Create a new CrystalSoul
     * @param {Object} options - Configuration options
     * @param {number} options.radius - Base radius for fallback geometry (default: 0.15)
     * @param {number} options.detail - Detail level for fallback geometry (default: 1)
     * @param {Object} options.renderer - ThreeRenderer instance for scene locking
     * @param {string} options.assetBasePath - Base path for assets (default: '/assets')
     */
    constructor(options = {}) {
        this.radius = options.radius || 0.15;
        this.detail = options.detail || 1;
        this.geometryType = options.geometryType || 'crystal';
        this.renderer = options.renderer || null;  // ThreeRenderer for scene locking
        this.assetBasePath = options.assetBasePath || '/assets';

        this.mesh = null;
        this.material = null;
        this.parentMesh = null;
        this.baseScale = 1.0;  // Full size by default (size=1.0)
        this._pendingParent = null;
        this._disposed = false;  // Track disposal state for async safety

        this._createMesh();
    }

    /**
     * Load the inclusion geometry from OBJ file
     * @param {string} assetBasePath - Base path for assets (default: '/assets')
     * @returns {Promise<THREE.BufferGeometry>}
     * @private
     */
    static _loadInclusionGeometry(assetBasePath = '/assets') {
        // Return cached geometry if available
        if (inclusionGeometryCache) {
            return Promise.resolve(inclusionGeometryCache.clone());
        }

        // Return existing loading promise if in progress
        if (inclusionGeometryLoading) {
            return inclusionGeometryLoading.then(geo => geo.clone());
        }

        // Start loading
        inclusionGeometryLoading = new Promise(resolve => {
            const loader = new OBJLoader();
            loader.load(
                `${assetBasePath}/models/Crystal/inclusion.obj`,
                obj => {
                    let geometry = null;
                    obj.traverse(child => {
                        if (child.isMesh && child.geometry) {
                            ({ geometry } = child);
                        }
                    });

                    if (geometry) {
                        // Center the geometry
                        geometry.computeBoundingBox();
                        const center = new Vector3();
                        geometry.boundingBox.getCenter(center);
                        geometry.translate(-center.x, -center.y, -center.z);

                        // Rotate 90 degrees around X-axis to make it vertical
                        geometry.rotateX(Math.PI / 2);

                        // Scale to unit size (will be scaled by baseScale)
                        geometry.computeBoundingBox();
                        const size = new Vector3();
                        geometry.boundingBox.getSize(size);
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = 0.3 / maxDim;  // Target ~0.3 unit radius
                        geometry.scale(scale, scale, scale);

                        geometry.computeVertexNormals();
                        inclusionGeometryCache = geometry;
                        resolve(geometry.clone());
                    } else {
                        console.warn('[🔮 SOUL] No mesh in inclusion.obj, using fallback');
                        resolve(null);
                    }
                },
                undefined,
                err => {
                    console.warn('[🔮 SOUL] Failed to load inclusion.obj:', err);
                    resolve(null);
                }
            );
        });

        return inclusionGeometryLoading;
    }

    /**
     * Create the soul mesh with shader material
     * Uses inclusion geometry if available (from cache), falls back to octahedron
     * @private
     */
    _createMesh() {
        console.log(`[CrystalSoul] _createMesh() START, inclusionGeometryCache=${!!inclusionGeometryCache}`);

        // Create material first (shared regardless of geometry)
        this.material = new ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                emotionColor: { value: new Color(1, 1, 1) },
                energyIntensity: { value: 1.5 },
                driftEnabled: { value: 1.0 },
                driftSpeed: { value: 0.5 },
                crossWaveEnabled: { value: 1.0 },
                crossWaveSpeed: { value: 0.4 },
                ghostMode: { value: 0.36 },    // 0.36 = partial ghost, 0.0 = solid, 1.0 = full ghost
                baseOpacity: { value: 1.0 },   // Base opacity when not in ghost mode
                // 3-phase offsets (radians) - default to 120° apart
                phaseOffset1: { value: 0.0 },
                phaseOffset2: { value: 2.094 },  // 2π/3 = 120°
                phaseOffset3: { value: 4.189 },  // 4π/3 = 240°
                // Blend layer uniforms - Quartz preset defaults
                blendLayer1Mode: { value: 2 },       // Color Burn
                blendLayer1Strength: { value: 2.3 },
                blendLayer1Enabled: { value: 1 },
                blendLayer2Mode: { value: 0 },       // Multiply
                blendLayer2Strength: { value: 1.0 },
                blendLayer2Enabled: { value: 1 }
            },
            vertexShader: soulVertexShader,
            fragmentShader: soulFragmentShader,
            transparent: true,
            depthWrite: true,
            depthTest: true,
            side: FrontSide
        });

        // Use cached inclusion geometry if available (preloaded by Core3DManager),
        // otherwise fall back to octahedron
        let geometry;
        if (inclusionGeometryCache) {
            geometry = inclusionGeometryCache.clone();
        } else {
            // Fallback octahedron - will be used if preloading didn't happen
            geometry = new OctahedronGeometry(this.radius, this.detail);
        }

        this.mesh = new Mesh(geometry, this.material);
        this.mesh.name = 'crystalSoul';
        this.mesh.renderOrder = 0;
        this.mesh.layers.set(2);
    }

    /**
     * Attach the soul to a parent mesh (adds to same scene, syncs position each frame)
     * @param {THREE.Mesh} parentMesh - The mesh to follow (e.g., crystal, heart)
     * @param {THREE.Scene} scene - The scene to add the soul to
     */
    attachTo(parentMesh, scene) {
        if (this._disposed) {
            return;
        }

        if (!parentMesh) {
            console.warn('[CrystalSoul] Cannot attach to null parent');
            return;
        }

        if (!this.mesh) {
            console.warn('[CrystalSoul] Cannot attach - mesh is null');
            return;
        }

        // Remove from previous parent if any
        if (this.mesh.parent) {
            this.mesh.parent.remove(this.mesh);
        }

        this.parentMesh = parentMesh;
        this._scene = scene;

        // Add to scene as separate object (not child of parentMesh)
        // This keeps soul at full scale regardless of parent's morph scale
        if (scene && !this.mesh.parent) {
            scene.add(this.mesh);
        }

        // Sync initial position
        this._syncPosition();
        this.mesh.visible = true;
    }

    /**
     * Sync soul world position/rotation to parent mesh
     * Called each frame to follow the parent
     * @private
     */
    _syncPosition() {
        if (!this.parentMesh || !this.mesh) return;

        // Copy world position from parent
        this.parentMesh.getWorldPosition(this.mesh.position);
        this.parentMesh.getWorldQuaternion(this.mesh.quaternion);
    }

    /**
     * Detach from current parent
     * Marks invisible but does NOT remove from scene (removal happens in dispose)
     * This avoids Three.js render loop race conditions
     */
    detach() {
        if (!this.mesh) return;

        // Mark invisible - DO NOT remove from scene here
        // Removal during render causes race conditions with projectObject traversal
        // The mesh will be removed properly in dispose() on next frame
        this.mesh.visible = false;
        this.parentMesh = null;
    }

    /**
     * Update the soul animation and color
     * @param {number} deltaTime - Time since last frame in ms
     * @param {Array} glowColor - RGB color array [r, g, b] (0-1 range)
     * @param {number} breathScale - Optional breathing scale multiplier
     */
    update(deltaTime, glowColor, breathScale = 1.0) {
        if (!this.material || !this.material.uniforms) return;

        // Sync position with parent mesh each frame
        this._syncPosition();

        const {uniforms} = this.material;

        // Update time for animation
        if (uniforms.time) {
            uniforms.time.value += deltaTime / 1000;
        }

        // Update emotion color
        if (uniforms.emotionColor && glowColor) {
            uniforms.emotionColor.value.setRGB(
                glowColor[0], glowColor[1], glowColor[2]
            );
        }

        // Fixed intensity matching original implementation
        if (uniforms.energyIntensity) {
            uniforms.energyIntensity.value = 0.8;
        }

        // Apply breathing scale
        if (this.mesh) {
            this.mesh.scale.setScalar(this.baseScale * breathScale);
        }
    }

    /**
     * Set the soul size
     * @param {number} size - Size value 0-1, where 0.5 is default
     */
    setSize(size) {
        if (!this.mesh) return;

        // Map size (0-1) to scale (0.05-1.0) - allows very small soul for crystal
        const scale = 0.05 + size * 0.95;
        this.baseScale = scale;
        this.mesh.scale.setScalar(scale);
    }

    /**
     * Set soul effect parameters
     * @param {Object} params - Effect parameters
     * @param {boolean} params.driftEnabled - Enable/disable drifting energy
     * @param {number} params.driftSpeed - Drift animation speed (0.1-3.0)
     * @param {boolean} params.crossWaveEnabled - Enable/disable horizontal cross wave
     * @param {number} params.crossWaveSpeed - Cross wave animation speed (0.1-3.0)
     */
    setEffects(params = {}) {
        if (!this.material || !this.material.uniforms) return;

        const {uniforms} = this.material;

        if (params.driftEnabled !== undefined && uniforms.driftEnabled) {
            uniforms.driftEnabled.value = params.driftEnabled ? 1.0 : 0.0;
        }
        if (params.driftSpeed !== undefined && uniforms.driftSpeed) {
            uniforms.driftSpeed.value = Math.max(0.1, Math.min(3.0, params.driftSpeed));
        }
        if (params.crossWaveEnabled !== undefined && uniforms.crossWaveEnabled) {
            uniforms.crossWaveEnabled.value = params.crossWaveEnabled ? 1.0 : 0.0;
        }
        if (params.crossWaveSpeed !== undefined && uniforms.crossWaveSpeed) {
            uniforms.crossWaveSpeed.value = Math.max(0.1, Math.min(3.0, params.crossWaveSpeed));
        }
        // Phase offsets (0 to 2π radians)
        if (params.phaseOffset1 !== undefined && uniforms.phaseOffset1) {
            uniforms.phaseOffset1.value = params.phaseOffset1;
        }
        if (params.phaseOffset2 !== undefined && uniforms.phaseOffset2) {
            uniforms.phaseOffset2.value = params.phaseOffset2;
        }
        if (params.phaseOffset3 !== undefined && uniforms.phaseOffset3) {
            uniforms.phaseOffset3.value = params.phaseOffset3;
        }
    }

    /**
     * Set emotion color directly
     * @param {Array} color - RGB array [r, g, b] (0-1 range)
     */
    setColor(color) {
        if (this.material && this.material.uniforms && this.material.uniforms.emotionColor) {
            this.material.uniforms.emotionColor.value.setRGB(color[0], color[1], color[2]);
        }
    }

    /**
     * Set blend layers for the soul
     * @param {Array} layers - Array of layer objects [{mode, strength, enabled}, ...]
     */
    setBlendLayers(layers) {
        if (!this.material || !this.material.uniforms) return;

        const u = this.material.uniforms;

        // Layer 1
        if (layers[0]) {
            if (u.blendLayer1Mode) u.blendLayer1Mode.value = layers[0].mode ?? 0;
            if (u.blendLayer1Strength) u.blendLayer1Strength.value = layers[0].strength ?? 0;
            if (u.blendLayer1Enabled) u.blendLayer1Enabled.value = layers[0].enabled ? 1 : 0;
        } else {
            if (u.blendLayer1Enabled) u.blendLayer1Enabled.value = 0;
        }

        // Layer 2
        if (layers[1]) {
            if (u.blendLayer2Mode) u.blendLayer2Mode.value = layers[1].mode ?? 0;
            if (u.blendLayer2Strength) u.blendLayer2Strength.value = layers[1].strength ?? 0;
            if (u.blendLayer2Enabled) u.blendLayer2Enabled.value = layers[1].enabled ? 1 : 0;
        } else {
            if (u.blendLayer2Enabled) u.blendLayer2Enabled.value = 0;
        }
    }

    /**
     * Check if soul is attached to a parent
     * @returns {boolean}
     */
    isAttached() {
        return this.parentMesh !== null && this.mesh !== null && this.mesh.parent !== null;
    }

    /**
     * Set soul visibility
     * @param {boolean} visible - Whether the soul should be visible
     */
    setVisible(visible) {
        if (this.mesh) {
            this.mesh.visible = visible;
        }
    }

    /**
     * Set ghost mode - soul is only visible through bloom when effects are active
     * @param {boolean} enabled - Whether ghost mode is enabled
     */
    setGhostMode(enabled) {
        if (this.material && this.material.uniforms && this.material.uniforms.ghostMode) {
            this.material.uniforms.ghostMode.value = enabled ? 1.0 : 0.0;
        }
    }

    /**
     * Set base opacity (only used when not in ghost mode)
     * @param {number} opacity - Opacity value 0-1
     */
    setBaseOpacity(opacity) {
        if (this.material && this.material.uniforms && this.material.uniforms.baseOpacity) {
            this.material.uniforms.baseOpacity.value = Math.max(0, Math.min(1, opacity));
        }
    }

    /**
     * Dispose of resources
     * Removes from scene SYNCHRONOUSLY to prevent Three.js projectObject crash,
     * but defers geometry disposal to next frame for safety.
     */
    dispose() {
        // Prevent double disposal
        if (this._disposed) return;

        // Set disposed flag FIRST to prevent async callbacks from running
        this._disposed = true;

        // Store references for cleanup BEFORE clearing them
        const meshToDispose = this.mesh;
        const materialToDispose = this.material;

        // CRITICAL FIX: Remove from scene SYNCHRONOUSLY
        // This prevents Three.js projectObject from encountering the mesh after
        // we've cleared our references. The previous deferred removal caused
        // race conditions when morphing away from crystal-type geometries.
        if (meshToDispose?.parent) {
            meshToDispose.parent.remove(meshToDispose);
        }

        // Mark invisible (belt and suspenders)
        if (meshToDispose) {
            meshToDispose.visible = false;
        }

        // Clear references immediately
        this.mesh = null;
        this.material = null;
        this.parentMesh = null;

        // Defer ONLY geometry disposal to next frame
        // Scene removal already happened synchronously above
        requestAnimationFrame(() => {
            if (meshToDispose?.geometry) {
                meshToDispose.geometry.dispose();
            }
            if (materialToDispose) {
                materialToDispose.dispose();
            }
        });
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Particle 3D Renderer
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Three.js-based particle renderer with custom shaders
 * @author Emotive Engine Team
 * @module 3d/particles/Particle3DRenderer
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Renders 2D particles in 3D space using Three.js:
 * ║ • Creates point sprite system with BufferGeometry
 * ║ • Custom shaders for glow and color effects
 * ║ • Efficient attribute updates for 60fps performance
 * ║ • Gesture effects (firefly glow, shimmer, flicker)
 * ║ • Frustum culling and LOD optimization
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * RENDERING STRATEGY:
 * - Use THREE.Points with BufferGeometry for instanced rendering
 * - Per-particle attributes: position, size, color, alpha, glow
 * - Custom shaders for soft glowing particles
 * - Additive blending for overlapping glow effects
 */


// Define shaders inline (avoid import issues with .glsl files)
const particleVertexShader = `
/**
 * Particle Vertex Shader - Simple 2D-style particles in 3D space
 * Matches the 2D canvas particle appearance
 */

// Per-particle attributes
attribute float size;
attribute vec3 customColor;
attribute float alpha;
attribute float glowIntensity;
attribute float style;  // 0.0 = solid/gradient, 1.0 = cell-shaded (ring with transparent center)

// Uniforms
uniform float coreScale;
uniform float viewportHeight;
uniform float pixelRatio;

// Varying to fragment shader
varying vec3 vColor;
varying float vAlpha;
varying float vGlowIntensity;
varying float vStyle;

void main() {
    // Pass attributes to fragment shader
    vColor = customColor;
    vAlpha = alpha;
    vGlowIntensity = glowIntensity;
    vStyle = style;

    // Calculate position in clip space
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

    // Calculate point size with perspective scaling
    float perspectiveScale = coreScale * (75.0 / length(mvPosition.xyz)) * (viewportHeight / 600.0) / pixelRatio;
    gl_PointSize = size * perspectiveScale;

    // Final position
    gl_Position = projectionMatrix * mvPosition;
}
`;

const particleFragmentShader = `
/**
 * Particle Fragment Shader - Solid colored circles matching 2D appearance
 * Uses premultiplied alpha for proper blending
 */

varying vec3 vColor;
varying float vAlpha;
varying float vGlowIntensity;
varying float vStyle;

void main() {
    // Distance from center (0 at center, 0.5 at edge)
    vec2 center = gl_PointCoord - vec2(0.5);
    float dist = length(center);

    // Hard circle cutoff - discard everything outside
    if (dist > 0.45) {
        discard;
    }

    vec3 finalColor = vColor;

    // Base opacity from particle (already includes baseOpacity variation)
    float alpha = vAlpha;

    // Gesture glow boost
    if (vGlowIntensity >= 2.0) {
        float gestureBoost = (vGlowIntensity - 2.0) / 13.0;
        finalColor *= (1.0 + gestureBoost * 0.5);
        alpha = min(alpha * (1.0 + gestureBoost * 0.3), 1.0);
    }

    // Cell-shaded particles are slightly more opaque
    float opacityBoost = vStyle > 0.5 ? 1.0 : 0.85;
    alpha *= opacityBoost;

    // Output with proper alpha for blending
    // Premultiply alpha for correct compositing
    gl_FragColor = vec4(finalColor * alpha, alpha);
}
`;

class Particle3DRenderer {
    constructor(maxParticles = 50, options = {}) {
        this.maxParticles = maxParticles;
        this.options = options;

        // Three.js objects
        this.geometry = null;
        this.material = null;
        this.points = null;

        // Particle attributes (typed arrays for performance)
        this.positions = null;
        this.sizes = null;
        this.colors = null;
        this.alphas = null;
        this.glowIntensities = null;
        this.depths = null;        // NEW: Depth for depth-of-field
        this.styles = null;        // NEW: Style for cell-shaded borders

        // Current particle count
        this.particleCount = 0;

        // Gesture effect state
        this.gestureEffects = {
            firefly: false,
            flicker: false,
            shimmer: false,
            glow: false,
            time: 0
        };

        // Initialize the rendering system
        this._initGeometry();
        this._initMaterial();
        this._initPoints();
    }

    /**
     * Initialize BufferGeometry with particle attributes
     */
    _initGeometry() {
        this.geometry = new BufferGeometry();

        // Allocate typed arrays (pre-allocate for max particles)
        const {maxParticles} = this;

        this.positions = new Float32Array(maxParticles * 3); // x, y, z
        this.sizes = new Float32Array(maxParticles); // size
        this.colors = new Float32Array(maxParticles * 3); // r, g, b
        this.alphas = new Float32Array(maxParticles); // alpha
        this.glowIntensities = new Float32Array(maxParticles); // glow
        this.depths = new Float32Array(maxParticles); // depth (0=near, 1=far)
        this.styles = new Float32Array(maxParticles); // style (0=solid, 1=bordered)

        // Create buffer attributes
        this.geometry.setAttribute('position', new BufferAttribute(this.positions, 3));
        this.geometry.setAttribute('size', new BufferAttribute(this.sizes, 1));
        this.geometry.setAttribute('customColor', new BufferAttribute(this.colors, 3));
        this.geometry.setAttribute('alpha', new BufferAttribute(this.alphas, 1));
        this.geometry.setAttribute('glowIntensity', new BufferAttribute(this.glowIntensities, 1));
        this.geometry.setAttribute('depth', new BufferAttribute(this.depths, 1));
        this.geometry.setAttribute('style', new BufferAttribute(this.styles, 1));

        // PERFORMANCE: Mark all frequently-updated attributes as dynamic
        // Color changes with particle lifecycle, so it must be dynamic too
        this.geometry.attributes.position.setUsage(DynamicDrawUsage);
        this.geometry.attributes.size.setUsage(DynamicDrawUsage);
        this.geometry.attributes.customColor.setUsage(DynamicDrawUsage);
        this.geometry.attributes.alpha.setUsage(DynamicDrawUsage);
        this.geometry.attributes.glowIntensity.setUsage(DynamicDrawUsage);
        this.geometry.attributes.depth.setUsage(DynamicDrawUsage);
        this.geometry.attributes.style.setUsage(DynamicDrawUsage);

        // Set initial draw range to 0 (no particles yet)
        this.geometry.setDrawRange(0, 0);
    }

    /**
     * Initialize shader material
     */
    _initMaterial() {
        this.material = new ShaderMaterial({
            uniforms: {
                coreScale: { value: 1.0 }, // Core scale multiplier (baseScale * breath * morph * blink)
                viewportHeight: { value: 600.0 }, // Viewport height for screen-size compensation
                pixelRatio: { value: 1.0 } // Device pixel ratio for consistent sizing
            },
            vertexShader: particleVertexShader,
            fragmentShader: particleFragmentShader,
            transparent: true,
            // Premultiplied alpha blending: src=One (already multiplied), dst=OneMinusSrcAlpha
            blending: CustomBlending,
            blendSrc: OneFactor,
            blendDst: OneMinusSrcAlphaFactor,
            blendSrcAlpha: OneFactor,
            blendDstAlpha: OneMinusSrcAlphaFactor,
            depthWrite: false, // Don't write to depth buffer
            depthTest: true // Test depth for proper occlusion
        });
    }

    /**
     * Initialize THREE.Points object
     */
    _initPoints() {
        this.points = new Points(this.geometry, this.material);
        // PERFORMANCE: Enable frustum culling for desktop (5-15% gain when particles off-screen)
        this.points.frustumCulled = true;
    }

    /**
     * Update particle data from 2D particle system
     * @param {Array} particles - Array of 2D particles
     * @param {Particle3DTranslator} translator - Position translator
     * @param {Object} corePosition - 3D mascot position
     * @param {Object} canvasSize - Canvas dimensions
     * @param {Object} rotationState - Mascot rotation state for orbital physics (optional)
     * @param {number} deltaTime - Time delta for physics (optional)
     * @param {Object} gestureData - Active gesture data (optional)
     * @param {number} coreScale - Final core scale to maintain particle/core size ratio (optional)
     * @param {string} geometryType - Geometry type for special rendering rules (optional)
     */
    updateParticles(particles, translator, corePosition, canvasSize, rotationState, deltaTime, gestureData, coreScale, geometryType) {
        this.particleCount = Math.min(particles.length, this.maxParticles);

        // Update core scale uniform to maintain EXACT particle/core size ratio
        if (coreScale !== undefined) {
            this.material.uniforms.coreScale.value = coreScale;
        }

        // Update viewport height for screen-size compensation
        if (canvasSize && canvasSize.height) {
            this.material.uniforms.viewportHeight.value = canvasSize.height;
        }

        // Update pixel ratio (read from renderer which has the capped value)
        if (this.options.renderer) {
            this.material.uniforms.pixelRatio.value = this.options.renderer.getPixelRatio();
        }
        // Update gesture effect time - cap at 2π to prevent indefinite accumulation
        this.gestureEffects.time += 0.016; // ~60fps
        if (this.gestureEffects.time > Math.PI * 2) {
            this.gestureEffects.time = this.gestureEffects.time % (Math.PI * 2);
        }

        // Update translator rotation state for orbital physics (with gesture info)
        if (rotationState && deltaTime) {
            translator.updateRotationState(rotationState, deltaTime, gestureData);
        }

        // Update each particle's attributes
        for (let i = 0; i < this.particleCount; i++) {
            const particle = particles[i];

            // Skip dead particles (hide them by setting alpha to 0)
            if (!particle.isAlive()) {
                this.alphas[i] = 0;
                continue;
            }

            // Translate 2D position to 3D (with orbital physics if enabled)
            const pos3D = translator.translate2DTo3D(particle, corePosition, canvasSize);

            // CRYSTAL/HEART/ROUGH: Cull particles in front of the soul
            // These geometries have a visible soul inside, particles in front block the view
            // Threshold slightly positive to allow particles at the edges
            if ((geometryType === 'crystal' || geometryType === 'heart' || geometryType === 'rough') && pos3D.z > 0.15) {
                // Hide particle by setting alpha to 0
                this.alphas[i] = 0;
                continue;
            }

            // Update position
            const posIndex = i * 3;
            this.positions[posIndex + 0] = pos3D.x;
            this.positions[posIndex + 1] = pos3D.y;
            this.positions[posIndex + 2] = pos3D.z;

            // PRIORITY 5: Size variety - use particle's stable baseSize (already has variation)
            const depthSize = particle.getDepthAdjustedSize ? particle.getDepthAdjustedSize() : particle.size;
            // Joy popcorn particles are larger (1.2x), others at normal size
            const sizeMultiplier = particle.behavior === 'popcorn' ? 1.2 : 0.85;
            this.sizes[i] = depthSize * sizeMultiplier; // Scale for point sprite size (particle.size already varies 4-10px)

            // Update color
            const color = this._parseColor(particle.color || '#ffffff');
            const colorIndex = i * 3;
            this.colors[colorIndex + 0] = color.r;
            this.colors[colorIndex + 1] = color.g;
            this.colors[colorIndex + 2] = color.b;

            // PRIORITY 5: Read baseOpacity from 2D particle (already varies 0.3-0.7)
            this.alphas[i] = particle.opacity * (particle.baseOpacity || 1.0);

            // PRIORITY 3: Enhanced glow with size multipliers (1.33x-1.66x)
            let glowIntensity = particle.hasGlow ? (particle.glowSizeMultiplier || 1.5) * 1.0 : 0;

            // Apply gesture effects (these can boost glow further)
            glowIntensity = this._applyGestureEffects(particle, glowIntensity, i);

            this.glowIntensities[i] = glowIntensity;

            // PRIORITY 1: Calculate depth for depth-of-field
            // Normalize particle.z from [-1, 1] to [0, 1] for shader
            // z=-1 (far behind) → depth=1.0 (max blur)
            // z=0 (at orb) → depth=0.5 (medium blur)
            // z=1 (far front) → depth=0.0 (sharp)
            const normalizedDepth = (1.0 - particle.z) * 0.5; // Invert and scale
            this.depths[i] = Math.max(0.0, Math.min(1.0, normalizedDepth));

            // PRIORITY 2: Read cell-shaded style from 2D particle
            // 1/3 of 2D particles have isCellShaded=true
            this.styles[i] = particle.isCellShaded ? 1.0 : 0.0;
        }

        // Mark attributes as needing update
        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.attributes.size.needsUpdate = true;
        this.geometry.attributes.customColor.needsUpdate = true;
        this.geometry.attributes.alpha.needsUpdate = true;
        this.geometry.attributes.glowIntensity.needsUpdate = true;
        this.geometry.attributes.depth.needsUpdate = true;
        this.geometry.attributes.style.needsUpdate = true;

        // Update draw range
        this.geometry.setDrawRange(0, this.particleCount);
    }

    /**
     * Apply gesture effects to particle glow
     * @param {Object} particle - 2D particle
     * @param {number} baseGlow - Base glow intensity
     * @param {number} index - Particle index
     * @returns {number} Modified glow intensity
     */
    _applyGestureEffects(particle, baseGlow, index) {
        let glow = baseGlow;

        // Firefly effect (sparkle gesture) - pulsing particles
        if (this.gestureEffects.firefly) {
            const particlePhase = (particle.x * 0.01 + particle.y * 0.01 + particle.size * 0.1) % (Math.PI * 2);
            const sineValue = (Math.sin(this.gestureEffects.time * 3 + particlePhase) + 1.0) * 0.5; // 0 to 1
            const fireflyGlow = 2.0 + sineValue * 10.0; // Range: 2.0 to 12.0
            glow = Math.max(glow, fireflyGlow);
        }

        // Flicker effect - dramatic random flickering
        if (this.gestureEffects.flicker) {
            // Create rapid, chaotic flicker
            const particlePhase = (particle.x * 0.02 + particle.y * 0.02) % (Math.PI * 2);
            const time = this.gestureEffects.time * 15; // Fast flicker rate

            // Combine fast oscillation with random jumps - normalized to 0-1
            const baseSine = (Math.sin(time + particlePhase) + 1.0) * 0.5; // 0 to 1
            const timeStep = Math.floor(time * 10 + index);
            const randomJump = (Math.sin(timeStep * 123.456) + 1.0) * 0.5; // 0 to 1

            // Random flicker - NEVER zero, always visible, range 2.0 to 12.0
            const flickerValue = baseSine * 0.3 + randomJump * 0.7; // 0 to 1
            const flickerGlow = 2.0 + flickerValue * 10.0; // Range: 2.0 to 12.0

            glow = Math.max(glow, flickerGlow);
        }

        // Shimmer effect - traveling wave of glow
        if (this.gestureEffects.shimmer) {
            const dx = particle.x - (this.gestureEffects.centerX || 0);
            const dy = particle.y - (this.gestureEffects.centerY || 0);
            const distance = Math.sqrt(dx * dx + dy * dy);
            const normalizedDistance = distance / 200;

            const wave = (Math.sin(this.gestureEffects.time * 3 - normalizedDistance) + 1.0) * 0.5; // 0 to 1
            const shimmerGlow = 2.0 + wave * 8.0; // Range: 2.0 to 10.0
            glow = Math.max(glow, shimmerGlow);
        }

        // Glow effect - dramatic pulsing radiant glow
        if (this.gestureEffects.glow) {
            const progress = this.gestureEffects.glowProgress || 0;

            // Simple pulsing glow that affects all particles
            // Peak at middle of gesture (progress = 0.5)
            const glowCurve = Math.sin(progress * Math.PI); // 0 to 1 to 0

            // Pulse from moderately bright to extremely bright
            const glowPulse = 3.0 + glowCurve * 12.0; // Range: 3.0 to 15.0

            glow = Math.max(glow, glowPulse);
        }

        return glow;
    }

    /**
     * Parse hex color to RGB object
     * @param {string} hex - Hex color code
     * @returns {Object} {r, g, b} in 0-1 range
     */
    _parseColor(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (!result) {
            return { r: 1.0, g: 1.0, b: 1.0 };
        }

        return {
            r: parseInt(result[1], 16) / 255,
            g: parseInt(result[2], 16) / 255,
            b: parseInt(result[3], 16) / 255
        };
    }

    /**
     * Set gesture effects
     * @param {Object} gestureTransform - Gesture transform data
     */
    setGestureEffects(gestureTransform) {
        if (!gestureTransform) {
            // Clear all effects
            this.gestureEffects.firefly = false;
            this.gestureEffects.flicker = false;
            this.gestureEffects.shimmer = false;
            this.gestureEffects.glow = false;
            return;
        }

        // Update effect flags
        this.gestureEffects.firefly = gestureTransform.fireflyEffect || false;
        this.gestureEffects.flicker = gestureTransform.flickerEffect || false;
        this.gestureEffects.shimmer = gestureTransform.shimmerEffect || false;
        this.gestureEffects.glow = gestureTransform.glowEffect || false;

        // Store effect parameters
        this.gestureEffects.glowProgress = gestureTransform.glowProgress;
        this.gestureEffects.centerX = gestureTransform.centerX;
        this.gestureEffects.centerY = gestureTransform.centerY;
    }

    /**
     * Get the THREE.Points object for adding to scene
     * @returns {THREE.Points} The particle system
     */
    getPoints() {
        return this.points;
    }

    /**
     * Update visibility
     * @param {boolean} visible - Whether particles should be visible
     */
    setVisible(visible) {
        this.points.visible = visible;
    }

    /**
     * Resize particle buffer capacity
     * Properly disposes old geometry before creating new one
     * @param {number} newMaxParticles - New maximum particle count
     */
    resize(newMaxParticles) {
        if (newMaxParticles === this.maxParticles) {
            return; // No change needed
        }

        // Dispose old geometry to free GPU memory
        if (this.geometry) {
            this.geometry.dispose();
        }

        // Update max particles
        this.maxParticles = newMaxParticles;

        // Recreate geometry with new size
        this._initGeometry();

        // Update points reference to new geometry
        if (this.points) {
            this.points.geometry = this.geometry;
        }
    }

    /**
     * Clean up per-particle physics state
     * Call this when particles are removed to prevent memory accumulation
     * @param {Array} particles - Current active particles array
     */
    cleanupParticleStates(particles) {
        // Remove behaviorData from dead particles to prevent memory leaks
        for (const particle of particles) {
            if (!particle.isAlive() && particle.behaviorData) {
                // Clear cached 3D direction and orbital data
                if (particle.behaviorData.direction3D) {
                    particle.behaviorData.direction3D = null;
                }
                if (particle.behaviorData.orbitPlane) {
                    particle.behaviorData.orbitPlane = null;
                }
                if (particle.behaviorData.orbitPath) {
                    particle.behaviorData.orbitPath = null;
                }
                // Clear entire behaviorData object
                particle.behaviorData = null;
            }
        }
    }

    /**
     * Cleanup resources
     */
    dispose() {
        if (this.geometry) {
            this.geometry.dispose();
        }
        if (this.material) {
            this.material.dispose();
        }
        this.positions = null;
        this.sizes = null;
        this.colors = null;
        this.alphas = null;
        this.glowIntensities = null;
        this.depths = null;
        this.styles = null;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Particle Emotion Calculator
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Calculates particle system configuration based on emotion and undertone
 * @author Emotive Engine Team
 * @module 3d/particles/ParticleEmotionCalculator
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Extracts and calculates particle configuration for 3D rendering:
 * ║ • Reads particle configs from emotion data
 * ║ • Applies undertone modifiers (behavior override, rate multipliers)
 * ║ • Handles special emotion behaviors (zen mixing)
 * ║ • Provides spawn rates and particle count limits
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * Mirrors 2D ParticleConfigCalculator for consistency across rendering systems.
 */


class ParticleEmotionCalculator {
    constructor() {
        // Cache for performance (emotion data rarely changes)
        this.cachedConfigs = new Map();
        // Cache size limit to prevent unbounded growth
        this.maxCacheSize = 100; // Support up to 100 emotion:undertone combinations
    }

    /**
     * Calculate complete particle configuration for emotion + undertone
     * @param {string} emotion - Current emotion name
     * @param {string|null} undertone - Optional undertone modifier
     * @returns {Object} Particle configuration with behavior, rates, and limits
     */
    calculate(emotion, undertone = null) {
        // Check cache first
        const cacheKey = `${emotion}:${undertone || 'none'}`;
        if (this.cachedConfigs.has(cacheKey)) {
            return this.cachedConfigs.get(cacheKey);
        }

        // Get emotion data
        const emotionData = getEmotion(emotion);
        if (!emotionData) {
            console.warn(`[ParticleEmotionCalculator] Unknown emotion: ${emotion}`);
            return this._getDefaultConfig();
        }

        // Extract base configuration
        const baseConfig = this._extractBaseConfig(emotionData, emotion);

        // Apply undertone modifiers
        const modifiedConfig = this._applyUndertoneModifiers(baseConfig, undertone);

        // Apply special emotion behaviors
        const finalConfig = this._applySpecialBehaviors(modifiedConfig, emotion);

        // Enforce cache size limit (LRU-style: remove oldest entry)
        if (this.cachedConfigs.size >= this.maxCacheSize) {
            const firstKey = this.cachedConfigs.keys().next().value;
            this.cachedConfigs.delete(firstKey);
        }

        // Cache and return
        this.cachedConfigs.set(cacheKey, finalConfig);
        return finalConfig;
    }

    /**
     * Extract base particle configuration from emotion data
     * @param {Object} emotionData - Emotion definition
     * @param {string} emotion - Emotion name
     * @returns {Object} Base particle config
     */
    _extractBaseConfig(emotionData, emotion) {
        // Particle config is in visual property for consistency with 2D
        const visual = emotionData.visual || {};

        return {
            behavior: visual.particleBehavior || 'ambient',
            rate: visual.particleRate || 1.0,
            min: visual.minParticles !== undefined ? visual.minParticles : 0,
            max: visual.maxParticles !== undefined ? visual.maxParticles : 10,
            colors: visual.particleColors || null,
            emotion
        };
    }

    /**
     * Apply undertone modifiers to particle configuration
     * @param {Object} config - Base particle config
     * @param {string|null} undertone - Undertone modifier
     * @returns {Object} Modified config
     */
    _applyUndertoneModifiers(config, undertone) {
        if (!undertone) {
            return config;
        }

        const modifier = getUndertoneModifier(undertone);
        if (!modifier || !modifier.particles) {
            return config;
        }

        const undertoneParticles = modifier.particles;
        const modified = { ...config };

        // Apply behavior override
        if (undertoneParticles.behaviorOverride) {
            modified.behavior = undertoneParticles.behaviorOverride;
        }

        // Apply rate multiplier
        if (undertoneParticles.rateMultiplier) {
            modified.rate = config.rate * undertoneParticles.rateMultiplier;
            modified.max = Math.floor(config.max * undertoneParticles.rateMultiplier);
        }

        // Apply min/max overrides
        if (undertoneParticles.minParticles !== undefined) {
            modified.min = undertoneParticles.minParticles;
        }
        if (undertoneParticles.maxParticles !== undefined) {
            modified.max = undertoneParticles.maxParticles;
        }

        return modified;
    }

    /**
     * Apply special emotion-specific behaviors
     * @param {Object} config - Modified particle config
     * @param {string} emotion - Emotion name
     * @returns {Object} Final config with special behaviors
     */
    _applySpecialBehaviors(config, emotion) {
        // Special case: zen emotion mixes falling and orbiting behaviors
        if (emotion === 'zen') {
            // Don't override behavior here - will be randomly selected per spawn
            // Mark as special for orchestrator
            return {
                ...config,
                specialBehavior: 'zen-mixing'
            };
        }

        return config;
    }

    /**
     * Select random behavior for zen emotion (called per particle spawn)
     * Zen creates a meditative mix of falling (sadness) and orbiting (love)
     * @returns {string} Particle behavior ('falling' or 'orbiting')
     */
    selectZenBehavior() {
        // 60% falling, 40% orbiting for peaceful balance
        return Math.random() < 0.6 ? 'falling' : 'orbiting';
    }

    /**
     * Get default fallback configuration
     * @returns {Object} Default particle config
     */
    _getDefaultConfig() {
        return {
            behavior: 'ambient',
            rate: 1.0,
            min: 0,
            max: 10,
            colors: null,
            emotion: 'neutral'
        };
    }

    /**
     * Clear cache (useful for hot-reloading emotion data)
     */
    clearCache() {
        this.cachedConfigs.clear();
    }

    /**
     * Get cached config count (debugging)
     * @returns {number} Number of cached configs
     */
    getCacheSize() {
        return this.cachedConfigs.size;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Gesture Data Extractor
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Extracts gesture data from active animation stack for particle system
 * @author Emotive Engine Team
 * @module 3d/particles/GestureDataExtractor
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Bridges animation system and particle system:
 * ║ • Extracts gesture data from ProceduralAnimator animation stack
 * ║ • Calculates gesture progress (0-1)
 * ║ • Builds gestureMotion object for 2D particle system
 * ║ • Handles multiple simultaneous gestures (primary + secondary)
 * ║ • Provides clean API for particle orchestrator
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

class GestureDataExtractor {
    constructor() {
        // Track previous gesture for cleanup detection
        this.previousGesture = null;
    }

    /**
     * Extract gesture data from animation stack
     * @param {Array} animations - Active animations from ProceduralAnimator
     * @param {number} currentTime - Current animation time
     * @returns {Object|null} Gesture data with motion, progress, and config
     */
    extract(animations, currentTime) {
        // No active animations
        if (!animations || animations.length === 0) {
            this.previousGesture = null;
            return null;
        }

        // Get primary gesture (first in stack)
        const primaryAnimation = animations[0];

        // Calculate progress
        const progress = this._calculateProgress(primaryAnimation, currentTime);

        // Gesture completed
        if (progress >= 1.0) {
            this.previousGesture = null;
            return null;
        }

        // Extract gesture name (need to add this to animation data)
        const gestureName = this._extractGestureName(primaryAnimation);

        if (!gestureName) {
            // Animation exists but no gesture name (emotion animation, not gesture)
            return null;
        }

        // Build gesture motion object (compatible with 2D particle system)
        const motion = this._buildGestureMotion(primaryAnimation, gestureName);

        // Track for cleanup detection
        this.previousGesture = gestureName;

        return {
            motion,
            progress,
            config: primaryAnimation.config || {},
            gestureName,
            animation: primaryAnimation
        };
    }

    /**
     * Calculate gesture progress (0-1)
     * @param {Object} animation - Animation object
     * @param {number} currentTime - Current time in ms
     * @returns {number} Progress from 0.0 to 1.0
     */
    _calculateProgress(animation, currentTime) {
        const elapsed = currentTime - animation.startTime;
        const progress = elapsed / animation.duration;
        return Math.max(0, Math.min(1, progress)); // Clamp to 0-1
    }

    /**
     * Extract gesture name from animation object
     * @param {Object} animation - Animation object
     * @returns {string|null} Gesture name or null
     */
    _extractGestureName(animation) {
        // Check multiple possible locations for gesture name
        return animation.gestureName ||
               animation.name ||
               animation.config?.gestureName ||
               null;
    }

    /**
     * Build gestureMotion object for particle system
     * @param {Object} animation - Animation object
     * @param {string} gestureName - Gesture name
     * @returns {Object} Gesture motion configuration
     */
    _buildGestureMotion(animation, gestureName) {
        const config = animation.config || {};

        return {
            type: gestureName,
            amplitude: config.amplitude || 1.0,
            strength: config.strength || 1.0,
            wobbleAmount: config.wobbleAmount || 0,
            duration: animation.duration
        };
    }

    /**
     * Check if gesture has changed since last frame
     * @param {Object} gestureData - Current gesture data
     * @returns {boolean} True if gesture changed
     */
    hasGestureChanged(gestureData) {
        if (!gestureData && !this.previousGesture) {
            return false; // No gesture before or now
        }

        if (!gestureData && this.previousGesture) {
            return true; // Gesture ended
        }

        if (gestureData && !this.previousGesture) {
            return true; // Gesture started
        }

        // Check if gesture name changed
        return gestureData.gestureName !== this.previousGesture;
    }

    /**
     * Extract all active gestures (primary + secondary)
     * @param {Array} animations - Active animations
     * @param {number} currentTime - Current time
     * @returns {Array} Array of gesture data objects
     */
    extractAll(animations, currentTime) {
        if (!animations || animations.length === 0) {
            return [];
        }

        const gestures = [];

        for (const animation of animations) {
            const progress = this._calculateProgress(animation, currentTime);

            if (progress >= 1.0) {
                continue; // Skip completed
            }

            const gestureName = this._extractGestureName(animation);

            if (!gestureName) {
                continue; // Skip non-gesture animations
            }

            const motion = this._buildGestureMotion(animation, gestureName);

            gestures.push({
                motion,
                progress,
                config: animation.config || {},
                gestureName,
                animation
            });
        }

        return gestures;
    }

    /**
     * Reset state (useful for cleanup)
     */
    reset() {
        this.previousGesture = null;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Particle Effects Builder
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Builds visual effect transforms for particle rendering based on gestures
 * @author Emotive Engine Team
 * @module 3d/particles/ParticleEffectsBuilder
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Maps gesture types to particle visual effects:
 * ║ • Firefly effect: Pulsing glow based on position + time (sparkle, twinkle)
 * ║ • Flicker effect: Rapid shimmer at 12Hz frequency
 * ║ • Shimmer effect: Traveling wave from center
 * ║ • Glow effect: Radiant burst with distance-based delay
 * ║ • Extensible architecture for future effects
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL EFFECTS MAPPING:
 * - sparkle → firefly (pulsing glow)
 * - twinkle → firefly (pulsing glow)
 * - flicker → flicker (rapid shimmer)
 * - shimmer → shimmer (traveling wave)
 * - glow → glow (radiant burst)
 */

class ParticleEffectsBuilder {
    constructor() {
        // Map gesture names to effect builder methods
        this.effectMap = {
            // Firefly effect (pulsing glow)
            'sparkle': this.buildFireflyEffect.bind(this),
            'twinkle': this.buildFireflyEffect.bind(this),

            // Flicker effect (rapid shimmer)
            'flicker': this.buildFlickerEffect.bind(this),

            // Shimmer effect (traveling wave)
            'shimmer': this.buildShimmerEffect.bind(this),

            // Glow effect (radiant burst)
            'glow': this.buildGlowEffect.bind(this),

            // Burst effect (explosion glow)
            'burst': this.buildGlowEffect.bind(this),

            // Flash effect (instant brightness)
            'flash': this.buildFlickerEffect.bind(this)
        };
    }

    /**
     * Build effect transform from gesture data
     * @param {Object} gestureData - Gesture data from GestureDataExtractor
     * @param {number} centerX - Canvas center X
     * @param {number} centerY - Canvas center Y
     * @returns {Object|null} Effect transform for particle renderer
     */
    build(gestureData, centerX, centerY) {
        if (!gestureData || !gestureData.motion) {
            return null;
        }

        const {gestureName} = gestureData;
        const builder = this.effectMap[gestureName];

        if (!builder) {
            // No visual effect for this gesture (motion-only gesture)
            return null;
        }

        // Build the effect
        return builder(gestureData, centerX, centerY);
    }

    /**
     * Build firefly effect (pulsing glow based on particle position)
     * Used by: sparkle, twinkle gestures
     * @param {Object} gestureData - Gesture data
     * @param {number} centerX - Canvas center X
     * @param {number} centerY - Canvas center Y
     * @returns {Object} Firefly effect transform
     */
    buildFireflyEffect(gestureData, centerX, centerY) {
        const config = gestureData.config || {};

        return {
            fireflyEffect: true,
            fireflyTime: Date.now() * 0.001, // Convert to seconds
            particleGlow: config.particleGlow || 2.0,
            centerX,
            centerY
        };
    }

    /**
     * Build flicker effect (rapid shimmer at 12Hz)
     * Used by: flicker, flash gestures
     * @param {Object} gestureData - Gesture data
     * @param {number} centerX - Canvas center X
     * @param {number} centerY - Canvas center Y
     * @returns {Object} Flicker effect transform
     */
    buildFlickerEffect(gestureData, centerX, centerY) {
        const config = gestureData.config || {};

        return {
            flickerEffect: true,
            flickerTime: Date.now() * 0.001,
            particleGlow: config.particleGlow || 2.0,
            centerX,
            centerY
        };
    }

    /**
     * Build shimmer effect (traveling wave from center)
     * Used by: shimmer gesture
     * @param {Object} gestureData - Gesture data
     * @param {number} centerX - Canvas center X
     * @param {number} centerY - Canvas center Y
     * @returns {Object} Shimmer effect transform
     */
    buildShimmerEffect(gestureData, centerX, centerY) {
        const config = gestureData.config || {};
        const progress = gestureData.progress || 0;

        return {
            shimmerEffect: true,
            shimmerTime: Date.now() * 0.001,
            shimmerWave: progress * Math.PI * 2, // Wave phase based on progress
            particleGlow: config.particleGlow || 1.2,
            centerX,
            centerY
        };
    }

    /**
     * Build glow effect (radiant burst with distance-based delay)
     * Used by: glow, burst gestures
     * @param {Object} gestureData - Gesture data
     * @param {number} centerX - Canvas center X
     * @param {number} centerY - Canvas center Y
     * @returns {Object} Glow effect transform
     */
    buildGlowEffect(gestureData, centerX, centerY) {
        const config = gestureData.config || {};
        const progress = gestureData.progress || 0;

        return {
            glowEffect: true,
            glowProgress: progress,
            particleGlow: config.particleGlow || 2.0,
            centerX,
            centerY
        };
    }

    /**
     * Register a custom effect builder
     * Allows extending with new effects without modifying this file
     * @param {string} gestureName - Gesture name to map
     * @param {Function} builderFn - Builder function (gestureData, centerX, centerY) => transform
     */
    registerEffect(gestureName, builderFn) {
        this.effectMap[gestureName] = builderFn.bind(this);
    }

    /**
     * Check if gesture has a visual effect
     * @param {string} gestureName - Gesture name
     * @returns {boolean} True if gesture has effect
     */
    hasEffect(gestureName) {
        return !!this.effectMap[gestureName];
    }

    /**
     * Get all registered effect gesture names
     * @returns {Array} Array of gesture names
     */
    getEffectGestures() {
        return Object.keys(this.effectMap);
    }

    /**
     * Build multiple effects from multiple gestures (for blending)
     * @param {Array} gestureDataArray - Array of gesture data
     * @param {number} centerX - Canvas center X
     * @param {number} centerY - Canvas center Y
     * @returns {Array} Array of effect transforms
     */
    buildAll(gestureDataArray, centerX, centerY) {
        if (!gestureDataArray || gestureDataArray.length === 0) {
            return [];
        }

        const effects = [];

        for (const gestureData of gestureDataArray) {
            const effect = this.build(gestureData, centerX, centerY);
            if (effect) {
                effects.push(effect);
            }
        }

        return effects;
    }

    /**
     * Merge multiple effects into single transform (for multi-gesture scenarios)
     * @param {Array} effects - Array of effect transforms
     * @returns {Object|null} Merged effect transform
     */
    mergeEffects(effects) {
        if (!effects || effects.length === 0) {
            return null;
        }

        if (effects.length === 1) {
            return effects[0];
        }

        // Merge multiple effects (priority: last effect wins for conflicts)
        const merged = {};

        for (const effect of effects) {
            Object.assign(merged, effect);
        }

        return merged;
    }

    /**
     * Dispose of resources and clear references
     */
    destroy() {
        this.effectMap = null;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Particle 3D Orchestrator
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Orchestrates 3D particle system with emotion, gesture, and visual effects
 * @author Emotive Engine Team
 * @module 3d/particles/Particle3DOrchestrator
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Central coordinator for 3D particle system:
 * ║ • Coordinates emotion calculator, gesture extractor, effects builder
 * ║ • Manages particle spawning based on emotion/undertone
 * ║ • Updates particle physics with gesture motion
 * ║ • Applies visual effects to particle renderer
 * ║ • Provides clean API for Core3DManager
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ARCHITECTURE:
 *   Core3DManager
 *        ↓
 *   Particle3DOrchestrator (this class)
 *        ↓
 *   ┌────────────────┬──────────────────┬──────────────────┐
 *   ↓                ↓                  ↓                  ↓
 * EmotionCalc  GestureExtract  EffectsBuilder  ParticleSystem
 *                                                          ↓
 *                                              ┌───────────┴──────────┐
 *                                              ↓                      ↓
 *                                      Translator              Renderer
 */


class Particle3DOrchestrator {
    constructor(particleSystem, translator, renderer) {
        // Core particle components
        this.particleSystem = particleSystem;
        this.translator = translator;
        this.renderer = renderer;

        // Specialized calculators/extractors
        this.emotionCalculator = new ParticleEmotionCalculator();
        this.gestureExtractor = new GestureDataExtractor();
        this.effectsBuilder = new ParticleEffectsBuilder();

        // Current state cache
        this.currentEmotion = null;
        this.currentUndertone = null;
        this.currentConfig = null;
    }

    /**
     * Main update method - called by Core3DManager each frame
     * @param {number} deltaTime - Time since last frame (ms)
     * @param {string} emotion - Current emotion
     * @param {string|null} undertone - Current undertone
     * @param {Array} activeAnimations - Active gesture animations
     * @param {number} currentTime - Animation time
     * @param {Object} corePosition - 3D mascot position {x, y, z}
     * @param {Object} canvasSize - Canvas dimensions {width, height}
     * @param {Object} rotationState - Mascot rotation state {euler, quaternion, angularVelocity}
     * @param {number} coreScale - Final core scale (baseScale * breath * morph * blink)
     * @param {number} coreRadius3D - Actual 3D core radius in world units (for particle orbit distance)
     */
    update(deltaTime, emotion, undertone, activeAnimations, currentTime, corePosition, canvasSize, rotationState, coreScale, coreRadius3D) {
        // Update translator with current 3D core radius for screen-size-independent orbits
        if (coreRadius3D !== undefined) {
            this.translator.setCoreRadius3D(coreRadius3D);
        }
        // Step 1: Calculate emotion-based particle configuration
        const emotionConfig = this._updateEmotionConfig(emotion, undertone);

        // Step 2: Extract gesture data from animations
        const gestureData = this.gestureExtractor.extract(activeAnimations, currentTime);

        // Step 3: Spawn particles based on emotion config
        this._spawnParticles(emotionConfig, deltaTime, canvasSize);

        // Step 4: Update particle physics with gesture motion
        this._updatePhysics(emotionConfig, gestureData, deltaTime, canvasSize, undertone);

        // Step 5: Update rendering with visual effects and orbital physics
        this._updateRendering(gestureData, corePosition, canvasSize, rotationState, deltaTime, coreScale);
    }

    /**
     * Update emotion configuration (with caching)
     * @param {string} emotion - Current emotion
     * @param {string|null} undertone - Current undertone
     * @returns {Object} Particle configuration
     */
    _updateEmotionConfig(emotion, undertone) {
        // Check if emotion/undertone changed
        if (this.currentEmotion !== emotion || this.currentUndertone !== undertone) {
            this.currentEmotion = emotion;
            this.currentUndertone = undertone;

            // Recalculate config
            this.currentConfig = this.emotionCalculator.calculate(emotion, undertone);

            // Clear particles on emotion change for clean transition
            this.particleSystem.clear();
        }

        return this.currentConfig;
    }

    /**
     * Spawn particles based on emotion configuration
     * @param {Object} config - Emotion particle config
     * @param {number} deltaTime - Time delta
     * @param {Object} canvasSize - Canvas dimensions
     */
    _spawnParticles(config, deltaTime, canvasSize) {
        const centerX = canvasSize.width / 2;
        const centerY = canvasSize.height / 2;

        // Handle special behaviors (zen mixing)
        let spawnBehavior = config.behavior;
        if (config.specialBehavior === 'zen-mixing') {
            spawnBehavior = this.emotionCalculator.selectZenBehavior();
        }

        // Spawn particles using 2D particle system
        this.particleSystem.spawn(
            spawnBehavior,
            config.emotion,
            config.rate,
            centerX,
            centerY,
            deltaTime,
            null, // count (null for rate-based spawning)
            config.min,
            config.max,
            1.0, // scaleFactor
            1.0, // particleSizeMultiplier
            config.colors, // emotionColors
            this.currentUndertone
        );
    }

    /**
     * Update particle physics with gesture motion
     * @param {Object} config - Emotion config
     * @param {Object} gestureData - Gesture data
     * @param {number} deltaTime - Time delta in SECONDS (will be converted to milliseconds)
     * @param {Object} canvasSize - Canvas dimensions
     * @param {string|null} undertone - Current undertone
     */
    _updatePhysics(config, gestureData, deltaTime, canvasSize, undertone) {
        const centerX = canvasSize.width / 2;
        const centerY = canvasSize.height / 2;

        // Build undertone modifier for particle update
        const undertoneModifier = undertone ? { undertone } : null;

        // Update particle physics with gesture motion
        this.particleSystem.update(
            deltaTime, // deltaTime in milliseconds
            centerX,
            centerY,
            gestureData ? gestureData.motion : null, // gestureMotion
            gestureData ? gestureData.progress : 0,  // gestureProgress
            undertoneModifier
        );
    }

    /**
     * Update rendering with 3D translation and visual effects
     * @param {Object} gestureData - Gesture data
     * @param {Object} corePosition - 3D mascot position
     * @param {Object} canvasSize - Canvas dimensions
     * @param {Object} rotationState - Mascot rotation state for orbital physics
     * @param {number} deltaTime - Time delta for physics
     * @param {number} coreScale - Final core scale for size ratio
     */
    _updateRendering(gestureData, corePosition, canvasSize, rotationState, deltaTime, coreScale) {
        const centerX = canvasSize.width / 2;
        const centerY = canvasSize.height / 2;

        // Build visual effects transform
        const effectsTransform = gestureData
            ? this.effectsBuilder.build(gestureData, centerX, centerY)
            : null;

        // Update 3D particle renderer with rotation state for orbital physics
        this.renderer.updateParticles(
            this.particleSystem.particles,
            this.translator,
            corePosition,
            canvasSize,
            rotationState,
            deltaTime,
            gestureData,  // Pass gesture data to detect spin gestures
            coreScale,    // Pass core scale to maintain particle/core size ratio
            this.geometryType // Pass geometry type for special rendering rules (e.g., black hole culling)
        );

        // Apply gesture visual effects
        this.renderer.setGestureEffects(effectsTransform);
    }

    /**
     * Set emotion explicitly (called when emotion changes)
     * @param {string} emotion - New emotion
     * @param {string|null} undertone - New undertone
     */
    setEmotion(emotion, undertone = null) {
        // Force recalculation on next update
        this.currentEmotion = null;
        this.currentUndertone = null;
    }

    /**
     * Set geometry type for special rendering rules
     * @param {string} geometryType - Geometry type (e.g., 'blackHole', 'crystal')
     */
    setGeometryType(geometryType) {
        this.geometryType = geometryType;
    }

    /**
     * Clear all particles
     */
    clear() {
        this.particleSystem.clear();
    }

    /**
     * Enable/disable particles
     * @param {boolean} enabled - Whether particles are enabled
     */
    setEnabled(enabled) {
        this.renderer.setVisible(enabled);
        if (!enabled) {
            this.clear();
        }
    }

    /**
     * Get current particle count
     * @returns {number} Number of active particles
     */
    getParticleCount() {
        return this.particleSystem.particles.length;
    }

    /**
     * Get current emotion config (for debugging)
     * @returns {Object} Current particle configuration
     */
    getCurrentConfig() {
        return this.currentConfig;
    }

    /**
     * Register custom particle effect
     * @param {string} gestureName - Gesture name
     * @param {Function} builderFn - Effect builder function
     */
    registerEffect(gestureName, builderFn) {
        this.effectsBuilder.registerEffect(gestureName, builderFn);
    }

    /**
     * Cleanup resources
     */
    destroy() {
        this.particleSystem.destroy();
        this.renderer.dispose();
        if (this.translator) {
            this.translator.dispose?.();
            this.translator = null;
        }
        this.emotionCalculator.clearCache();
        this.emotionCalculator = null;
        this.gestureExtractor.reset();
        this.gestureExtractor = null;
        if (this.effectsBuilder) {
            this.effectsBuilder.destroy?.();
            this.effectsBuilder = null;
        }
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Physically-Based Subsurface Scattering
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview BSSRDF-based subsurface scattering for translucent materials
 * @author Emotive Engine Team
 * @module 3d/shaders/utils/subsurfaceScattering
 *
 * Implements Disney/Pixar's Burley normalized diffusion model for realistic SSS.
 * Supports materials like jade, wax, skin, marble, etc.
 *
 * Key features:
 * - Thickness estimation from local geometry
 * - Beer's Law color absorption (wavelength-dependent)
 * - Burley normalized diffusion profile
 * - Curvature-based scattering intensity
 * - Material presets for common translucent materials
 */

/**
 * GLSL code for physically-based subsurface scattering
 * Include this in your fragment shader
 */
const sssGLSL = `
// ═══════════════════════════════════════════════════════════════════════════
// PHYSICALLY-BASED SUBSURFACE SCATTERING
// Based on Disney's Burley Normalized Diffusion (2015)
// ═══════════════════════════════════════════════════════════════════════════

// SSS Uniforms - declare these in your shader
// uniform float sssStrength;           // Overall SSS intensity (0-1)
// uniform vec3 sssAbsorption;          // Absorption coefficients per RGB channel
// uniform vec3 sssScatterDistance;     // Mean free path / scatter radius per RGB
// uniform float sssThicknessBias;      // Thickness offset (0-1)
// uniform float sssThicknessScale;     // Thickness multiplier
// uniform float sssCurvatureScale;     // How much curvature affects SSS
// uniform float sssAmbient;            // Ambient SSS contribution
// uniform vec3 sssLightDir;            // Primary light direction for SSS
// uniform vec3 sssLightColor;          // Light color for SSS

/**
 * Estimate local thickness from geometry
 * Uses the relationship between view angle and surface normal
 * Combined with a simple depth approximation
 *
 * @param normal - Surface normal in view space
 * @param viewDir - View direction
 * @param position - Vertex position (for depth-based estimation)
 * @param thicknessBias - Base thickness value
 * @param thicknessScale - Thickness multiplier
 * @return Estimated thickness (0-1)
 */
float estimateThickness(vec3 normal, vec3 viewDir, vec3 position, float thicknessBias, float thicknessScale) {
    // Method 1: View-dependent thickness
    // Surfaces facing away from viewer are "thicker" (light travels further)
    float viewThickness = 1.0 - abs(dot(normal, viewDir));

    // Method 2: Position-based depth (simple spherical assumption)
    // Objects are thinner at edges, thicker in center
    float posDepth = 1.0 - length(position) * 0.5;
    posDepth = clamp(posDepth, 0.0, 1.0);

    // Method 3: Curvature hint from normal variation
    // High-frequency normal changes indicate thin areas (edges, details)
    // This is approximated by the gradient of the normal
    float curvatureHint = length(fwidth(normal)) * 10.0;
    curvatureHint = 1.0 - clamp(curvatureHint, 0.0, 1.0);

    // Combine methods with weighting
    float thickness = viewThickness * 0.4 + posDepth * 0.4 + curvatureHint * 0.2;

    // Apply bias and scale
    thickness = thicknessBias + thickness * thicknessScale;

    return clamp(thickness, 0.01, 1.0);
}

/**
 * Beer's Law absorption - light attenuates exponentially through material
 * Different wavelengths absorb at different rates, creating color shifts
 *
 * @param thickness - Distance light travels through material
 * @param absorption - Absorption coefficients per RGB (higher = more absorbed)
 * @return Transmittance per RGB channel (0-1)
 */
vec3 beersLawAbsorption(float thickness, vec3 absorption) {
    // Beer-Lambert Law: T = e^(-σ * d)
    // Where σ is absorption coefficient, d is distance
    return exp(-absorption * thickness * 4.0);
}

/**
 * Burley Normalized Diffusion Profile
 * Disney's approximation of the full BSSRDF, energy-conserving
 *
 * R(r) = A * s * (e^(-s*r) + e^(-s*r/3)) / (8πr)
 *
 * @param radius - Distance from entry point (normalized)
 * @param scatterDist - Mean free path / diffusion length
 * @return Diffusion weight at this radius
 */
float burleyDiffusionProfile(float radius, float scatterDist) {
    // Prevent division by zero
    float r = max(radius, 0.001);
    float s = 1.0 / max(scatterDist, 0.001);

    // Burley's two-term approximation
    float term1 = exp(-s * r);
    float term2 = exp(-s * r / 3.0);

    // Normalized profile (simplified, without 8πr for real-time)
    float profile = (term1 + term2) * s * 0.25;

    return profile;
}

/**
 * Christensen-Burley Normalized Diffusion
 * Improved version with better energy conservation
 *
 * @param radius - Distance from entry point
 * @param A - Surface albedo
 * @param d - Diffusion length (mean free path)
 * @return RGB diffusion weights
 */
vec3 christensenBurleyDiffusion(float radius, vec3 A, vec3 d) {
    vec3 result = vec3(0.0);

    // Per-channel diffusion (different scatter distances for RGB)
    for (int i = 0; i < 3; i++) {
        float s = 1.9 - A[i] + 3.5 * (A[i] - 0.8) * (A[i] - 0.8);
        s = 1.0 / (s * max(d[i], 0.001));

        float r = max(radius, 0.001);

        // Two-exponential fit
        float profile = s * (exp(-s * r) + exp(-s * r / 3.0)) / (8.0 * 3.14159 * r);

        result[i] = profile;
    }

    return result;
}

/**
 * Calculate curvature factor for SSS intensity
 * SSS is more visible on curved surfaces (fingers, ears, edges)
 *
 * @param normal - Surface normal
 * @return Curvature factor (higher = more curved)
 */
float calculateCurvature(vec3 normal) {
    // Use screen-space derivatives to estimate curvature
    vec3 dx = dFdx(normal);
    vec3 dy = dFdy(normal);

    // Curvature magnitude
    float curvature = length(dx) + length(dy);

    // Normalize to useful range
    return clamp(curvature * 5.0, 0.0, 1.0);
}

/**
 * Full physically-based SSS calculation
 * Combines all components for realistic translucent materials
 *
 * @param normal - Surface normal (view space)
 * @param viewDir - View direction
 * @param position - Vertex position
 * @param lightDir - Light direction
 * @param lightColor - Light color
 * @param baseColor - Material base/albedo color
 * @param sssStrength - Overall SSS strength
 * @param absorption - Absorption coefficients RGB (inverted: higher = MORE of that color)
 * @param scatterDist - Scatter distance RGB (higher = more scatter)
 * @param thicknessBias - Base thickness
 * @param thicknessScale - Thickness multiplier
 * @param curvatureScale - Curvature influence
 * @param ambient - Ambient SSS contribution
 * @return Final SSS color contribution
 */
vec3 calculatePhysicalSSS(
    vec3 normal,
    vec3 viewDir,
    vec3 position,
    vec3 lightDir,
    vec3 lightColor,
    vec3 baseColor,
    float sssStrength,
    vec3 absorption,
    vec3 scatterDist,
    float thicknessBias,
    float thicknessScale,
    float curvatureScale,
    float ambient
) {
    if (sssStrength < 0.001) {
        return vec3(0.0);
    }

    // ─────────────────────────────────────────────────────────────────────
    // THICKNESS ESTIMATION
    // ─────────────────────────────────────────────────────────────────────
    float thickness = estimateThickness(normal, viewDir, position, thicknessBias, thicknessScale);

    // ─────────────────────────────────────────────────────────────────────
    // ABSORPTION COLOR (Beer's Law with artist-friendly values)
    // Creates the characteristic color of translucent materials
    // absorption values: high value = MORE of that color passes through (transmitted)
    // This is inverted from physics but intuitive: jade has high green absorption
    // ─────────────────────────────────────────────────────────────────────
    // Use absorption directly as transmittance - higher = more of that color shows
    // Normalize to prevent any channel from dominating
    float maxAbsorption = max(absorption.r, max(absorption.g, absorption.b));
    vec3 normalizedTransmit = absorption / max(maxAbsorption, 0.001);

    // Apply thickness-based falloff - thin areas show more color
    float thicknessFactor = 1.0 - thickness * 0.3;
    vec3 colorShift = normalizedTransmit * thicknessFactor;

    // Ensure minimum color presence
    colorShift = max(colorShift, vec3(0.15));

    // ─────────────────────────────────────────────────────────────────────
    // SCATTER INTENSITY
    // How much light scatters based on material properties
    // ─────────────────────────────────────────────────────────────────────
    // Higher scatter distance = more light gets through, but keep it subtle
    vec3 scatterIntensity = scatterDist * 0.8;
    scatterIntensity = clamp(scatterIntensity, vec3(0.1), vec3(1.0));

    // ─────────────────────────────────────────────────────────────────────
    // LIGHTING TERMS - Boosted for visibility
    // ─────────────────────────────────────────────────────────────────────

    // Back-lighting: light passing through from behind (strongest SSS cue)
    float NdotL = dot(normal, lightDir);
    float backLight = max(0.0, -NdotL);
    backLight = pow(backLight, 1.2) * 1.5;  // Boosted

    // Wrap lighting: soft diffuse that wraps around
    float wrapLight = (NdotL + 1.0) * 0.5;  // Full wrap, 0-1 range
    wrapLight = wrapLight * wrapLight;

    // View-dependent translucency (looking through thin parts)
    float VdotL = dot(viewDir, -lightDir);
    float translucency = pow(max(0.0, VdotL), 1.5) * 1.2;  // Boosted

    // Edge glow (fresnel-like SSS at silhouettes)
    float edgeGlow = pow(1.0 - abs(dot(normal, viewDir)), 2.0);

    // ─────────────────────────────────────────────────────────────────────
    // THICKNESS-BASED TRANSMISSION
    // Thin areas let more light through
    // ─────────────────────────────────────────────────────────────────────
    float thinTransmission = 1.0 - thickness * 0.5;
    thinTransmission = max(thinTransmission, 0.3);

    // ─────────────────────────────────────────────────────────────────────
    // CURVATURE ENHANCEMENT
    // ─────────────────────────────────────────────────────────────────────
    float curvature = calculateCurvature(normal);
    float curvatureFactor = 1.0 + curvature * curvatureScale;

    // ─────────────────────────────────────────────────────────────────────
    // COMBINE ALL TERMS
    // ─────────────────────────────────────────────────────────────────────

    // Total light contribution (more additive for visibility)
    float totalLight = backLight + translucency * 0.8 + wrapLight * 0.4 + edgeGlow * 0.5;
    totalLight *= curvatureFactor * thinTransmission;

    // Base SSS color - colorShift IS the tint (e.g., green for jade)
    // Don't multiply by baseColor to avoid washing out with emotionColor
    vec3 sssColor = colorShift * scatterIntensity;

    // Ambient SSS (always visible, gives material its translucent look)
    vec3 ambientSSS = sssColor * ambient;

    // Direct SSS from lighting - subtle contribution
    vec3 directSSS = sssColor * lightColor * totalLight * 0.5;

    // Final combination
    vec3 finalSSS = directSSS + ambientSSS;

    // Apply overall strength (linear, no boost to prevent blowout)
    return finalSSS * sssStrength;
}

/**
 * Simplified SSS for performance-critical scenarios
 * Uses pre-computed approximations
 *
 * @param normal - Surface normal
 * @param viewDir - View direction
 * @param lightDir - Light direction
 * @param thickness - Pre-computed or approximated thickness
 * @param baseColor - Material color
 * @param scatterColor - Scatter tint color
 * @param strength - SSS strength
 * @return SSS color contribution
 */
vec3 calculateSimpleSSS(
    vec3 normal,
    vec3 viewDir,
    vec3 lightDir,
    float thickness,
    vec3 baseColor,
    vec3 scatterColor,
    float strength
) {
    if (strength < 0.001) {
        return vec3(0.0);
    }

    // Back-lighting
    float backLight = pow(max(0.0, dot(viewDir, -lightDir)), 2.0);

    // Transmittance (simplified Beer's law)
    float transmit = exp(-thickness * 2.0);

    // Edge enhancement
    float edge = pow(1.0 - abs(dot(normal, viewDir)), 2.0);

    // Combine
    float sssIntensity = (backLight * transmit + edge * 0.3) * strength;

    return mix(baseColor, scatterColor, 0.5) * sssIntensity;
}
`;

/**
 * Material presets for gemstones
 * All presets designed for NEAR-BLACK shadows in thick areas
 *
 * Absorption: Higher value = MORE of that color passes through (inverted from physics)
 * ScatterDistance: Higher = more scatter/glow
 */
const SSS_PRESETS = {
    // Quartz - clear/white crystal, near-black depth
    // Reference: Clear quartz with deep black shadows and brilliant facet highlights
    quartz: {
        sssStrength: 0.8,
        sssAbsorption: [2.8, 2.9, 3.0],        // Slight cool tint, mostly neutral
        sssScatterDistance: [0.2, 0.2, 0.25],  // Tight scatter for sharp internal look
        sssThicknessBias: 0.60,                // Dark core
        sssThicknessScale: 1.8,                // Strong thick/thin contrast
        sssCurvatureScale: 3.0,                // Sharp edge definition
        sssAmbient: 0.12,                      // Very low ambient for deep shadows
        // Crystal appearance - maximum clarity
        frostiness: 0.15,                      // Very clear, almost no frost
        innerGlowStrength: 0.20,               // Minimal soul
        fresnelIntensity: 1.5,                 // Bright edge sparkle
        causticIntensity: 1.2                  // Boosted caustics for internal structure
    },

    // Emerald - deep vivid green with near-black core
    // Reference: Cut emerald with dark center and bright green edges
    emerald: {
        sssStrength: 2.0,
        sssAbsorption: [0.05, 4.0, 0.1],       // Pure vivid green, near-zero red/blue
        sssScatterDistance: [0.1, 0.5, 0.1],   // Tight scatter, green dominant
        sssThicknessBias: 0.65,                // Dark core
        sssThicknessScale: 1.8,                // Strong thick/thin contrast
        sssCurvatureScale: 3.0,                // Sharp edge definition
        sssAmbient: 0.10,                      // Very low ambient for deep shadows
        // Crystal appearance - sharp gemstone look
        frostiness: 0.20,                      // Very clear
        innerGlowStrength: 0.15,               // Minimal soul for gem clarity
        fresnelIntensity: 1.2,                 // Bright edges
        emotionColorBleed: 0.35                // Allow soul emotion color to tint the gem
    },

    // Ruby - deep red gemstone with wine/burgundy depth
    // Reference: Pigeon blood ruby - deep wine core, cherry red thin areas
    ruby: {
        sssStrength: 1.8,                      // Boosted for richer saturation
        sssAbsorption: [4.0, 0.03, 0.08],      // Higher red, near-zero green/blue for purer red
        sssScatterDistance: [0.4, 0.04, 0.08], // More red scatter, minimal other colors
        sssThicknessBias: 0.65,                // Darker core like other gemstones
        sssThicknessScale: 1.9,                // More contrast thick/thin
        sssCurvatureScale: 2.5,                // Sharper edge definition
        sssAmbient: 0.08,                      // Lower ambient for deeper shadows
        // Crystal appearance - rich gem brilliance
        frostiness: 0.12,                      // Very clear for glossy look
        innerGlowStrength: 0.12,               // Subtle internal glow
        fresnelIntensity: 1.2,                 // Brighter edges like other gems
        causticIntensity: 1.15,                // Enhanced caustics for ruby
        emotionColorBleed: 0.35                // Allow soul emotion color to tint the gem
    },

    // Sapphire - deep vivid blue gemstone with near-black shadows
    // Reference: Ceylon blue sapphire with dark center and bright blue edges
    sapphire: {
        sssStrength: 2.2,
        sssAbsorption: [0.15, 0.4, 4.0],       // Deep blue: very high blue, low red/green
        sssScatterDistance: [0.1, 0.15, 0.5],  // Blue scatter dominant
        sssThicknessBias: 0.65,                // Dark core
        sssThicknessScale: 1.8,                // Strong thick/thin contrast
        sssCurvatureScale: 3.0,                // Sharp edge definition
        sssAmbient: 0.10,                      // Very low ambient for deep shadows
        // Crystal appearance - sharp gemstone look
        frostiness: 0.18,                      // Very clear
        innerGlowStrength: 0.15,               // Minimal soul
        fresnelIntensity: 1.3,                 // Bright edges
        emotionColorBleed: 0.35                // Allow soul emotion color to tint the gem
    },

    // Amethyst - deep violet gemstone with near-black shadows
    // Reference: Rich purple with deep black shadows and bright pink/white facet highlights
    amethyst: {
        sssStrength: 2.5,
        sssAbsorption: [3.0, 0.05, 4.5],       // Deep violet: high red+blue, very low green
        sssScatterDistance: [0.4, 0.05, 0.5],  // Red and blue scatter, no green
        sssThicknessBias: 0.70,                // Very dark core
        sssThicknessScale: 2.0,                // Maximum thick/thin contrast
        sssCurvatureScale: 3.0,                // Sharp edge definition
        sssAmbient: 0.08,                      // Very low ambient for deep shadows
        // Crystal appearance - dark gemstone with bright highlights
        frostiness: 0.18,                      // Very clear, minimal frost
        innerGlowStrength: 0.12,               // Minimal soul
        fresnelIntensity: 1.4,                 // Bright edges for facet sparkle
        emotionColorBleed: 0.35                // Allow soul emotion color to tint the gem
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Crystal Shader with Soul Inside
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Frosted crystal shader with inner glowing soul effect
 * @author Emotive Engine Team
 * @module 3d/shaders/crystalWithSoul
 *
 * Creates a semi-transparent frosted crystal shell that allows an inner "soul"
 * (glowing core) to show through with diffusion. The soul color is driven by
 * emotional state.
 *
 * Visual characteristics based on reference image:
 * - Frosted/milky translucency (not clear glass)
 * - Strong fresnel effect at edges
 * - Inner glow diffuses through the crystal body
 * - Subtle surface texture variation
 */


/**
 * Vertex shader for frosted crystal
 */
const crystalVertexShader = `
varying vec3 vPosition;
varying vec3 vNormal;
varying vec3 vViewPosition;
varying vec2 vUv;

void main() {
    vUv = uv;
    vPosition = position;
    vNormal = normalize(normalMatrix * normal);

    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    vViewPosition = -mvPosition.xyz;

    gl_Position = projectionMatrix * mvPosition;
}
`;

/**
 * Fragment shader for frosted crystal with soul glow
 * Creates a milky/frosted appearance with inner glow diffusion
 */
const crystalFragmentShader = `
uniform float time;
uniform vec3 emotionColor;
uniform float glowIntensity;
uniform float opacity;

// Crystal appearance controls
uniform float frostiness;        // 0 = clear glass, 1 = fully frosted (default: 0.7)
uniform float fresnelPower;      // Edge brightness falloff (default: 3.0)
uniform float fresnelIntensity;  // Edge brightness strength (default: 1.2)
uniform float innerGlowStrength; // How much inner soul shows through (default: 0.8)
uniform float surfaceRoughness;  // Surface texture variation (default: 0.3)

// Enhanced lighting controls
uniform float shadowDarkness;     // How dark shadows can get (0-1, default: 0.4)
uniform float specularIntensity;  // Edge highlight brightness (default: 0.8)
uniform float specularPower;      // Specular falloff sharpness (default: 32.0)
uniform float transmissionContrast; // Thin/thick brightness ratio (default: 1.5)
uniform float minBrightness;      // Minimum brightness floor (default: 0.05)

// Noise scale controls
uniform float surfaceNoiseScale;  // Scale of surface frost pattern (default: 1.5)
uniform float noiseFrequency;     // Frequency of hash noise pattern (default: 1.0)

// Internal caustics - light pooling inside the gem
uniform float causticIntensity;   // Brightness of internal caustics (default: 0.4)
uniform float causticScale;       // Scale of caustic pattern (default: 3.0)
uniform float causticSpeed;       // Animation speed of caustics (default: 0.15)

// Texture
uniform sampler2D crystalTexture;
uniform float textureStrength;    // How much texture affects appearance (default: 0.5)

// Soul refraction - samples soul rendered to texture with optical distortion
uniform sampler2D soulTexture;    // Soul mesh rendered to texture
uniform vec2 resolution;          // Screen resolution for UV calculation
uniform vec2 soulTextureSize;     // Soul render target size (may differ from screen)
uniform vec2 soulScreenCenter;    // Soul center projected to screen UV (0-1 range)
uniform float refractionIndex;    // Index of refraction (1.5 glass, 2.4 diamond)
uniform float refractionStrength; // Distortion magnitude (0.1-0.5)

// Physically-based subsurface scattering
uniform float sssStrength;            // Overall SSS intensity (0-1)
uniform vec3 sssAbsorption;           // Absorption coefficients per RGB channel
uniform vec3 sssScatterDistance;      // Mean free path / scatter radius per RGB
uniform float sssThicknessBias;       // Thickness offset (0-1)
uniform float sssThicknessScale;      // Thickness multiplier
uniform float sssCurvatureScale;      // How much curvature affects SSS
uniform float sssAmbient;             // Ambient SSS contribution
uniform vec3 sssLightDir;             // Primary light direction for SSS
uniform vec3 sssLightColor;           // Light color for SSS

// Emotion color bleed - how much soul color tints the gem material
uniform float emotionColorBleed;      // 0 = gem color only, 1 = full emotion tint (default: 0.0)

// Component-specific blend layers
// Shell layers - affect the frosted crystal shell
uniform float shellLayer1Mode;
uniform float shellLayer1Strength;
uniform float shellLayer1Enabled;
uniform float shellLayer2Mode;
uniform float shellLayer2Strength;
uniform float shellLayer2Enabled;

// Soul layers - affect the inner glowing soul color
uniform float soulLayer1Mode;
uniform float soulLayer1Strength;
uniform float soulLayer1Enabled;
uniform float soulLayer2Mode;
uniform float soulLayer2Strength;
uniform float soulLayer2Enabled;

// Rim layers - affect the fresnel rim glow
uniform float rimLayer1Mode;
uniform float rimLayer1Strength;
uniform float rimLayer1Enabled;
uniform float rimLayer2Mode;
uniform float rimLayer2Strength;
uniform float rimLayer2Enabled;

// SSS layers - affect subsurface scattering contribution
uniform float sssLayer1Mode;
uniform float sssLayer1Strength;
uniform float sssLayer1Enabled;
uniform float sssLayer2Mode;
uniform float sssLayer2Strength;
uniform float sssLayer2Enabled;

varying vec3 vPosition;
varying vec3 vNormal;
varying vec3 vViewPosition;
varying vec2 vUv;

// ═══════════════════════════════════════════════════════════════════════════
// NOISE FUNCTIONS for surface variation and frosted effect
// ═══════════════════════════════════════════════════════════════════════════

// Simple 3D noise for frosted surface
float hash(vec3 p) {
    p = p * noiseFrequency;  // Apply frequency control
    p = fract(p * vec3(443.8975, 397.2973, 491.1871));
    p += dot(p.zxy, p.yxz + 19.19);
    return fract(p.x * p.y * p.z);
}

float noise3D(vec3 p) {
    vec3 i = floor(p);
    vec3 f = fract(p);
    f = f * f * (3.0 - 2.0 * f); // Smoothstep

    float n = mix(
        mix(
            mix(hash(i), hash(i + vec3(1, 0, 0)), f.x),
            mix(hash(i + vec3(0, 1, 0)), hash(i + vec3(1, 1, 0)), f.x),
            f.y
        ),
        mix(
            mix(hash(i + vec3(0, 0, 1)), hash(i + vec3(1, 0, 1)), f.x),
            mix(hash(i + vec3(0, 1, 1)), hash(i + vec3(1, 1, 1)), f.x),
            f.y
        ),
        f.z
    );
    return n;
}

// Fractal Brownian Motion for natural-looking frosted texture
float fbm(vec3 p) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;

    for (int i = 0; i < 3; i++) {
        value += amplitude * noise3D(p * frequency);
        frequency *= 2.0;
        amplitude *= 0.5;
    }
    return value;
}

// ═══════════════════════════════════════════════════════════════════════════
// BLEND MODES (from universal library)
// ═══════════════════════════════════════════════════════════════════════════
${blendModesGLSL}

// ═══════════════════════════════════════════════════════════════════════════
// ENHANCED LIGHTING FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════

// Calculate ambient occlusion from geometry
float calculateAO(vec3 normal, vec3 viewDir, vec3 position) {
    // Faces pointing away from view are in shadow
    float viewAO = max(0.0, dot(normal, viewDir));

    // Use light direction for directional shadow instead of gravity
    // This creates shadows on the side away from light
    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.8)); // Match sssLightDir default
    float lightAO = dot(normal, lightDir) * 0.5 + 0.5;

    // Combine AO factors - no gravity term
    return viewAO * 0.5 + lightAO * 0.5;
}

// Calculate specular highlights on facet edges
float calculateFacetSpecular(vec3 normal, vec3 viewDir, vec3 lightDir, float power) {
    // Detect facet edges from normal discontinuities
    float edgeDetect = length(fwidth(normal)) * 15.0;
    edgeDetect = smoothstep(0.1, 0.5, edgeDetect);

    // Standard Blinn-Phong specular
    vec3 halfVec = normalize(lightDir + viewDir);
    float specular = pow(max(0.0, dot(normal, halfVec)), power);

    // Boost specular on edges
    specular += edgeDetect * 0.5;

    return specular;
}

// Calculate "fire" - intense sparkle points that real gems exhibit
// These are concentrated, view-dependent highlights from light dispersion
float calculateFire(vec3 normal, vec3 viewDir, vec3 lightDir) {
    // Primary fire highlight - VERY sharp falloff for pinpoint sparkles
    vec3 reflectDir = reflect(-lightDir, normal);
    float fire1 = pow(max(0.0, dot(reflectDir, viewDir)), 512.0);

    // Secondary fire from different light angle (simulates environment)
    vec3 lightDir2 = normalize(vec3(-0.3, 0.8, 0.5));
    vec3 reflectDir2 = reflect(-lightDir2, normal);
    float fire2 = pow(max(0.0, dot(reflectDir2, viewDir)), 384.0);

    // Third fire point for more sparkle
    vec3 lightDir3 = normalize(vec3(0.7, 0.4, -0.6));
    vec3 reflectDir3 = reflect(-lightDir3, normal);
    float fire3 = pow(max(0.0, dot(reflectDir3, viewDir)), 256.0);

    // Combine fire points - only keep the brightest peaks
    float fire = fire1 + fire2 * 0.7 + fire3 * 0.5;

    // Facet edges catch more fire
    float edgeFactor = length(fwidth(normal)) * 20.0;
    fire *= (1.0 + edgeFactor * 2.0);

    return fire;
}

// Calculate bright lines along facet edges where bevels catch light
float calculateFacetEdgeLines(vec3 normal, vec3 viewDir, vec3 lightDir) {
    // Detect edges from normal discontinuities
    float edgeMag = length(fwidth(normal));

    // Sharp threshold to create distinct lines
    float edgeLine = smoothstep(0.02, 0.08, edgeMag);

    // Modulate by light angle - edges facing light are brighter
    float lightFacing = max(0.0, dot(normal, lightDir));
    edgeLine *= (0.3 + lightFacing * 0.7);

    // View-dependent - edges perpendicular to view are more visible
    float viewPerp = 1.0 - abs(dot(normal, viewDir));
    edgeLine *= (0.5 + viewPerp * 0.5);

    return edgeLine;
}

// Calculate light transmission based on thickness
float calculateTransmission(vec3 position, vec3 normal, vec3 viewDir, float contrast) {
    // Thickness estimation - edges are thin, center is thick
    float distFromCenter = length(position);
    float thickness = smoothstep(0.0, 0.6, distFromCenter);

    // View angle affects perceived thickness
    float viewThickness = 1.0 - abs(dot(normal, viewDir));
    thickness = mix(thickness, viewThickness, 0.5);

    // Thin areas transmit more light (brighter), thick areas are darker
    float transmission = 1.0 - thickness * contrast * 0.5;

    return clamp(transmission, 0.3, 1.5);
}

// ═══════════════════════════════════════════════════════════════════════════
// PHYSICALLY-BASED SUBSURFACE SCATTERING
// ═══════════════════════════════════════════════════════════════════════════
${sssGLSL}

void main() {
    vec3 normal = normalize(vNormal);
    vec3 viewDir = normalize(vViewPosition);

    // ═══════════════════════════════════════════════════════════════════════
    // FRESNEL EFFECT - Colored rim at edges (cyan-tinted)
    // ═══════════════════════════════════════════════════════════════════════
    float fresnel = pow(1.0 - abs(dot(normal, viewDir)), fresnelPower);
    fresnel *= fresnelIntensity;

    // ═══════════════════════════════════════════════════════════════════════
    // AMBIENT OCCLUSION - Dark shadows for depth
    // ═══════════════════════════════════════════════════════════════════════
    float ao = calculateAO(normal, viewDir, vPosition);
    float shadowFactor = mix(1.0, ao, shadowDarkness);

    // ═══════════════════════════════════════════════════════════════════════
    // SPECULAR HIGHLIGHTS - Bright catches on facet edges
    // ═══════════════════════════════════════════════════════════════════════
    vec3 lightDir = normalize(sssLightDir);
    float specular = calculateFacetSpecular(normal, viewDir, lightDir, specularPower);
    specular *= specularIntensity;

    // ═══════════════════════════════════════════════════════════════════════
    // LIGHT TRANSMISSION - Thin areas glow, thick areas darken
    // ═══════════════════════════════════════════════════════════════════════
    float transmission = calculateTransmission(vPosition, normal, viewDir, transmissionContrast);

    // ═══════════════════════════════════════════════════════════════════════
    // TEXTURE SAMPLING - Crystal surface detail from UV-mapped texture
    // ═══════════════════════════════════════════════════════════════════════
    vec4 texColor = texture2D(crystalTexture, vUv);
    float texValue = (texColor.r + texColor.g + texColor.b) / 3.0;  // Grayscale

    // ═══════════════════════════════════════════════════════════════════════
    // FROSTED SURFACE - Subtle cloudy variation (not opaque white!)
    // ═══════════════════════════════════════════════════════════════════════
    float surfaceNoise = fbm(vPosition * surfaceNoiseScale + time * 0.02);
    surfaceNoise = surfaceNoise * surfaceRoughness;

    // ═══════════════════════════════════════════════════════════════════════
    // INNER SOUL GLOW - The glowing core visible through the crystal
    // ═══════════════════════════════════════════════════════════════════════

    // Animated internal glow - subtle pulsing
    float glowPulse = sin(time * 0.5) * 0.15 + 0.85;

    // Core glow - strongest in center, fades toward edges with sharper falloff
    float distFromCenter = length(vPosition);
    float coreGlow = exp(-distFromCenter * 2.5) * glowPulse;

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL CAUSTICS - Light refraction pools inside the gem
    // Creates bright concentrated spots that shift with viewing angle
    // Real caustics form where refracted light rays converge inside the gem
    // Now with CHROMATIC ABERRATION - different wavelengths refract differently
    // ═══════════════════════════════════════════════════════════════════════

    // Refract view direction through gem surface with different IOR per wavelength
    // Red refracts less (higher IOR ratio), blue refracts more (lower IOR ratio)
    // Chromatic separation is REDUCED for colored gems to avoid color contamination
    // Quartz (low sssStrength) gets full rainbow, colored gems get subtle dispersion
    float chromaticStrength = 1.0 - clamp((sssStrength - 0.5) * 0.8, 0.0, 0.8);
    float iorR = mix(0.57, 0.70, chromaticStrength); // Red - approaches green for colored gems
    float iorB = mix(0.57, 0.44, chromaticStrength); // Blue - approaches green for colored gems
    vec3 refractDirR = refract(-viewDir, normal, iorR);
    vec3 refractDirG = refract(-viewDir, normal, 0.57); // Green - always medium
    vec3 refractDirB = refract(-viewDir, normal, iorB);

    // Animated drift
    float causticTime = time * causticSpeed;
    vec3 drift = vec3(causticTime * 0.3, causticTime * 0.2, causticTime * 0.1);

    // Sample positions for each color channel
    // Offset is also reduced for colored gems to minimize chromatic contamination
    float spatialOffset = mix(1.0, 3.0, chromaticStrength);
    vec3 causticPosR = vPosition * causticScale + refractDirR * spatialOffset + drift;
    vec3 causticPosG = vPosition * causticScale + refractDirG * spatialOffset + drift;
    vec3 causticPosB = vPosition * causticScale + refractDirB * spatialOffset + drift;

    // Create caustic pattern for each channel
    // Red channel
    float waveR1 = sin(causticPosR.x * 2.0 + causticPosR.y * 1.5 + causticPosR.z);
    float waveR2 = sin(causticPosR.y * 2.3 - causticPosR.x * 1.2 + causticPosR.z * 1.8);
    float waveR3 = sin(causticPosR.z * 1.9 + causticPosR.x * 0.8 - causticPosR.y * 1.4);
    float interferenceR = (waveR1 + waveR2 + waveR3) / 3.0;
    float causticR = smoothstep(0.3, 0.8, interferenceR);

    // Green channel
    float waveG1 = sin(causticPosG.x * 2.0 + causticPosG.y * 1.5 + causticPosG.z);
    float waveG2 = sin(causticPosG.y * 2.3 - causticPosG.x * 1.2 + causticPosG.z * 1.8);
    float waveG3 = sin(causticPosG.z * 1.9 + causticPosG.x * 0.8 - causticPosG.y * 1.4);
    float interferenceG = (waveG1 + waveG2 + waveG3) / 3.0;
    float causticG = smoothstep(0.3, 0.8, interferenceG);

    // Blue channel
    float waveB1 = sin(causticPosB.x * 2.0 + causticPosB.y * 1.5 + causticPosB.z);
    float waveB2 = sin(causticPosB.y * 2.3 - causticPosB.x * 1.2 + causticPosB.z * 1.8);
    float waveB3 = sin(causticPosB.z * 1.9 + causticPosB.x * 0.8 - causticPosB.y * 1.4);
    float interferenceB = (waveB1 + waveB2 + waveB3) / 3.0;
    float causticB = smoothstep(0.3, 0.8, interferenceB);

    // Combine into RGB caustic with chromatic separation
    vec3 causticRGB = vec3(causticR, causticG, causticB);

    // Add noise variation to break up uniformity
    float noiseVar = noise3D(causticPosG * 0.5);
    causticRGB *= (0.7 + noiseVar * 0.6);

    // Clamp caustic peaks to prevent hot spot blobs
    // This keeps caustics subtle and distributed rather than concentrated
    causticRGB = min(causticRGB, vec3(0.6));

    // Caustics are MORE visible in thick areas (center) where light has more
    // material to refract through and pool
    float thickness = abs(dot(normal, viewDir)); // 1 at center, 0 at edges
    causticRGB *= (0.3 + thickness * 0.7);

    // Apply intensity control
    causticRGB *= causticIntensity;

    // Boost caustic visibility for colored gems to compensate for reduced chromatic spread
    // Colored gems (high sssStrength) have suppressed chromatic aberration, so boost their
    // monochromatic caustics to maintain internal "life" and sparkle
    float causticBoost = 1.0 + clamp((sssStrength - 0.5) * 0.8, 0.0, 0.6);
    causticRGB *= causticBoost;

    // Also keep a scalar caustic for compatibility
    float caustic = (causticRGB.r + causticRGB.g + causticRGB.b) / 3.0;

    // Animation pattern (0-1 range) - core glow + caustic hot spots
    float animationPattern = coreGlow * 0.7 + caustic * 0.3;

    // Soul intensity controls overall brightness with more dramatic falloff
    // Brighter near core, darker at edges
    float baseLevel = 0.1;  // Lower base for more contrast
    float patternContrast = 0.9;  // Higher contrast for more variation
    float soulIntensity = (baseLevel + animationPattern * patternContrast) * innerGlowStrength;

    // Apply transmission to soul - thin areas glow brighter
    soulIntensity *= transmission;

    // Soul color from emotion
    // NOTE: emotionColor is pre-normalized by normalizeColorLuminance() in Core3DManager
    // This ensures consistent perceived brightness across all emotions (yellow won't wash out, blue stays visible)
    // Reduced intensity to prevent blowout - soul should be visible but not white
    float glowCurve = sqrt(innerGlowStrength * glowIntensity) * 0.5;
    vec3 soulColor = emotionColor * soulIntensity * glowCurve;
    // Clamp soul color to prevent blowout
    soulColor = min(soulColor, vec3(0.8));

    // ═══════════════════════════════════════════════════════════════════════
    // REFRACTED SOUL SAMPLING - True optical lensing through crystal
    // The soul is rendered to a texture, then sampled with refraction distortion
    // This creates the effect of looking at the soul through a crystal lens
    // ═══════════════════════════════════════════════════════════════════════

    // ═══════════════════════════════════════════════════════════════════
    // REFRACTED SOUL SAMPLING
    // Sample the soul texture with physical refraction distortion
    // Creates the "looking through glass" lensing effect
    // ═══════════════════════════════════════════════════════════════════
    vec3 refractedSoulColor = vec3(0.0);
    float refractedSoulAlpha = 0.0;

    if (soulTextureSize.x > 0.0 && soulScreenCenter.x >= 0.0) {
        // Fragment's screen UV position
        vec2 fragUV = gl_FragCoord.xy / soulTextureSize;

        // Calculate refraction offset using Snell's law
        float ior = refractionIndex;
        vec3 refractedDir = refract(-viewDir, normal, 1.0 / ior);

        // Apply refraction distortion toward the soul center
        // This creates the magnifying glass effect - bending light toward center
        vec2 refractionOffset = refractedDir.xy * refractionStrength * 0.1;

        // Sample at fragment position with refraction offset
        // The soul texture contains the soul rendered at its actual screen position
        vec2 soulUV = fragUV + refractionOffset;

        // Clamp to valid UV range
        soulUV = clamp(soulUV, 0.0, 1.0);

        // Sample the soul texture
        vec4 soulSample = texture2D(soulTexture, soulUV);

        // Store for later use in final composition
        refractedSoulColor = soulSample.rgb;
        refractedSoulAlpha = soulSample.a;

        // Also blend into soulColor for existing pipeline
        soulColor = mix(soulColor, soulSample.rgb, soulSample.a * 0.5);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SOUL BLEND LAYERS - Apply before combining with shell
    // ═══════════════════════════════════════════════════════════════════════
    if (soulLayer1Enabled > 0.5) {
        int mode = int(soulLayer1Mode + 0.5);
        vec3 blendResult = applyBlendMode(soulColor, emotionColor * soulLayer1Strength, mode);
        soulColor = mix(soulColor, blendResult, soulLayer1Strength);
    }
    if (soulLayer2Enabled > 0.5) {
        int mode = int(soulLayer2Mode + 0.5);
        vec3 blendResult = applyBlendMode(soulColor, emotionColor * soulLayer2Strength, mode);
        soulColor = mix(soulColor, blendResult, soulLayer2Strength);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FROSTED SHELL - Milky white layer with INTERNAL lighting model
    // Lit from inside: thin edges bright, thick center dark
    // ═══════════════════════════════════════════════════════════════════════

    // Frosted glass base - will be modulated by thickness
    // Lower base values allow for darker thick areas while maintaining bright edges
    vec3 frostBase = vec3(0.45, 0.48, 0.55) * frostiness;

    // THICKNESS-BASED DARKNESS (internal lighting model)
    // Face-on facets are THICK (light travels far through) = DARK
    // Edge-on facets are THIN (light escapes easily) = BRIGHT
    float edgeThinness = 1.0 - abs(dot(normal, viewDir));  // 1 at edges, 0 facing camera

    // Apply curve to make face-on areas darker more aggressively
    float thinness = pow(edgeThinness, 0.7);  // Push more area toward dark

    // Thickness multiplier: thin edges=bright (1.0), thick face-on=dark (0.01 for near-black)
    float thicknessMultiplier = 0.01 + thinness * 0.99;
    frostBase *= thicknessMultiplier;

    // Surface variation adds subtle texture
    frostBase += vec3(surfaceNoise * 0.03);

    // Specular highlights on facet edges (external light catch)
    float facetHighlight = pow(max(0.0, dot(normal, normalize(vec3(0.5, 1.0, 0.8)))), 16.0);
    frostBase += vec3(facetHighlight * 0.2);

    // SOUL BLEED - Inner glow illuminates the shell from inside
    // Use gentler falloff so color reaches the shell surface
    float soulBleed = exp(-distFromCenter * 1.2) * innerGlowStrength;
    // Stronger color contribution - tint the frost with emotion color
    frostBase = mix(frostBase, frostBase + emotionColor * 0.4, soulBleed);

    // ═══════════════════════════════════════════════════════════════════════
    // SHELL BLEND LAYERS - Apply to frosted shell
    // ═══════════════════════════════════════════════════════════════════════
    if (shellLayer1Enabled > 0.5) {
        int mode = int(shellLayer1Mode + 0.5);
        vec3 blendResult = applyBlendMode(frostBase, emotionColor * shellLayer1Strength, mode);
        frostBase = mix(frostBase, blendResult, shellLayer1Strength);
    }
    if (shellLayer2Enabled > 0.5) {
        int mode = int(shellLayer2Mode + 0.5);
        vec3 blendResult = applyBlendMode(frostBase, emotionColor * shellLayer2Strength, mode);
        frostBase = mix(frostBase, blendResult, shellLayer2Strength);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FRESNEL RIM - Bright emotion-colored edge glow
    // ═══════════════════════════════════════════════════════════════════════
    vec3 rimColor = mix(vec3(0.5, 0.9, 1.0), emotionColor, 0.6);
    vec3 rimGlow = rimColor * fresnel * 1.2;

    // ═══════════════════════════════════════════════════════════════════════
    // RIM BLEND LAYERS - Apply to fresnel rim glow
    // ═══════════════════════════════════════════════════════════════════════
    if (rimLayer1Enabled > 0.5) {
        int mode = int(rimLayer1Mode + 0.5);
        vec3 blendResult = applyBlendMode(rimGlow, emotionColor * rimLayer1Strength, mode);
        rimGlow = mix(rimGlow, blendResult, rimLayer1Strength);
    }
    if (rimLayer2Enabled > 0.5) {
        int mode = int(rimLayer2Mode + 0.5);
        vec3 blendResult = applyBlendMode(rimGlow, emotionColor * rimLayer2Strength, mode);
        rimGlow = mix(rimGlow, blendResult, rimLayer2Strength);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PHYSICALLY-BASED SUBSURFACE SCATTERING
    // Uses BSSRDF with Beer's Law absorption and Burley diffusion profile
    // ═══════════════════════════════════════════════════════════════════════
    vec3 sss = calculatePhysicalSSS(
        normal,
        viewDir,
        vPosition,
        normalize(sssLightDir),
        sssLightColor,
        emotionColor,
        sssStrength,
        sssAbsorption,
        sssScatterDistance,
        sssThicknessBias,
        sssThicknessScale,
        sssCurvatureScale,
        sssAmbient
    );

    // ═══════════════════════════════════════════════════════════════════════
    // SSS BLEND LAYERS - Apply to subsurface scattering contribution
    // ═══════════════════════════════════════════════════════════════════════
    if (sssLayer1Enabled > 0.5) {
        int mode = int(sssLayer1Mode + 0.5);
        vec3 blendResult = applyBlendMode(sss, emotionColor * sssLayer1Strength, mode);
        sss = mix(sss, blendResult, sssLayer1Strength);
    }
    if (sssLayer2Enabled > 0.5) {
        int mode = int(sssLayer2Mode + 0.5);
        vec3 blendResult = applyBlendMode(sss, emotionColor * sssLayer2Strength, mode);
        sss = mix(sss, blendResult, sssLayer2Strength);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMBINE - Frosted shell base + soul glow (soul adds to shell, doesn't replace)
    // ═══════════════════════════════════════════════════════════════════════

    // Start with shell as base - preserves dark shadows
    vec3 finalColor = frostBase;

    // Add soul glow on top (additive, not replacement) - concentrated in center
    // Soul should illuminate dark areas but not wash out entirely
    float soulBlendFactor = soulIntensity * 0.6;
    finalColor += soulColor * soulBlendFactor;

    // Apply texture - blend based on texture brightness and strength
    vec3 texContribution = texColor.rgb * textureStrength;
    finalColor = mix(finalColor, finalColor + texContribution, textureStrength);

    // Apply SSS material color - PRESERVE BRIGHTNESS, only change HUE
    // The sssAbsorption values define the material color hue
    // But thickness-based darkness must be preserved for gemstone look
    if (sssStrength > 0.01) {
        // Get current brightness (this includes thickness darkening)
        float currentLum = dot(finalColor, vec3(0.299, 0.587, 0.114));

        // Normalize absorption to get hue direction (0-1 range)
        vec3 absorption = sssAbsorption;
        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);
        vec3 hue = absorption / max(maxAbs, 0.001);

        // Create material color that PRESERVES current brightness
        // This keeps dark areas dark while tinting them with the gem color
        float hueLum = dot(hue, vec3(0.299, 0.587, 0.114));
        vec3 materialColor = hue * currentLum / max(hueLum, 0.001);

        // Clamp to prevent blowout on bright areas
        materialColor = min(materialColor, vec3(1.0));

        // Add subtle variation from SSS lighting calculation
        float sssLum = dot(sss, vec3(0.299, 0.587, 0.114));
        materialColor *= (0.9 + sssLum * 0.2);

        // Replace crystal color with material color
        float replaceAmount = sssStrength * 0.7;
        finalColor = mix(finalColor, materialColor, replaceAmount);
    }

    // Add rim glow, tinted toward material color
    if (sssStrength > 0.01) {
        vec3 absorption = sssAbsorption;
        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);
        vec3 hue = absorption / max(maxAbs, 0.001);
        // Stronger tint for colored gems - use gem hue directly
        float rimTintStrength = clamp(sssStrength * 0.6, 0.0, 0.95);
        vec3 tintedRim = rimGlow * mix(vec3(1.0), hue * 1.2, rimTintStrength);
        // Cap rim to prevent bloom
        tintedRim = min(tintedRim, vec3(0.5));
        finalColor += tintedRim;
    } else {
        finalColor += rimGlow;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPECULAR HIGHLIGHTS - Add bright hot spots
    // Tinted by gem color for colored gems to prevent white bloom
    // ═══════════════════════════════════════════════════════════════════════
    vec3 specularColor = vec3(1.0, 0.98, 0.95); // Warm white highlights for clear gems
    float specularIntensityMod = 1.0;

    if (sssStrength > 0.5) {
        // Tint specular by gem color to prevent white bloom
        vec3 absorption = sssAbsorption;
        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);
        vec3 gemHue = absorption / max(maxAbs, 0.001);
        float colorStrength = clamp((sssStrength - 0.5) * 0.5, 0.0, 1.0);
        // Use gem hue for specular color
        specularColor = mix(specularColor, gemHue * 1.3, colorStrength);
        // Also reduce specular intensity for colored gems
        specularIntensityMod = mix(1.0, 0.4, colorStrength);
    }

    vec3 specularContrib = specularColor * specular * transmission * specularIntensityMod;
    specularContrib = min(specularContrib, vec3(0.5)); // Cap specular to prevent bloom
    finalColor += specularContrib;

    // ═══════════════════════════════════════════════════════════════════════
    // FACET EDGE LINES - Bright catches along beveled edges
    // ═══════════════════════════════════════════════════════════════════════
    float edgeLines = calculateFacetEdgeLines(normal, viewDir, lightDir);
    finalColor += vec3(edgeLines * 0.15) * transmission;

    // ═══════════════════════════════════════════════════════════════════════
    // SATURATION BOOST AT THIN EDGES
    // Real gems have MORE saturated color at thin edges where light escapes
    // ═══════════════════════════════════════════════════════════════════════
    if (sssStrength > 0.01) {
        // thinness: 1 at edges, 0 facing camera
        float satBoost = thinness * 0.4; // Up to 40% saturation boost at edges

        // Get current color's saturation
        float maxC = max(max(finalColor.r, finalColor.g), finalColor.b);
        float minC = min(min(finalColor.r, finalColor.g), finalColor.b);
        float currentSat = maxC > 0.001 ? (maxC - minC) / maxC : 0.0;

        // Boost saturation at thin areas
        if (maxC > 0.001 && currentSat > 0.01) {
            // Calculate luminance
            float lum = dot(finalColor, vec3(0.299, 0.587, 0.114));
            // Increase saturation by moving away from gray toward the color
            vec3 gray = vec3(lum);
            float newSat = min(currentSat + satBoost, 1.0);
            float satRatio = currentSat > 0.001 ? newSat / currentSat : 1.0;
            finalColor = gray + (finalColor - gray) * satRatio;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FINAL THICKNESS APPLICATION - Apply AFTER all additive terms
    // This ensures thick areas stay dark even with glow added
    // ═══════════════════════════════════════════════════════════════════════
    // thicknessMultiplier: 0.15 in thick center, 1.0 at thin edges
    finalColor *= thicknessMultiplier;

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL CAUSTICS - Bright spots from light concentration inside gem
    // Now with chromatic aberration for rainbow dispersion effect
    // Applied AFTER thickness darkening so they punch through dark areas
    // ═══════════════════════════════════════════════════════════════════════
    if (causticIntensity > 0.01) {
        // Get material hue for tinting caustics
        vec3 causticTint = vec3(1.0); // Default white
        float causticTintStrength = 0.4; // Default for clear gems
        if (sssStrength > 0.5) {
            vec3 absorption = sssAbsorption;
            float maxAbs = max(max(absorption.r, absorption.g), absorption.b);
            vec3 hue = absorption / max(maxAbs, 0.001);
            // Stronger tint for colored gems to prevent white bloom
            causticTintStrength = clamp((sssStrength - 0.5) * 0.8 + 0.4, 0.4, 0.9);
            causticTint = mix(vec3(1.0), hue * 1.2, causticTintStrength);
        }
        // Add RGB caustic with chromatic aberration
        // Reduce raw RGB blend for colored gems
        float rawBlend = mix(0.3, 0.1, clamp((sssStrength - 0.5) * 0.5, 0.0, 1.0));
        vec3 causticFinal = causticRGB * causticTint + causticRGB * rawBlend;
        causticFinal = min(causticFinal, vec3(0.4)); // Cap to prevent bloom
        finalColor += causticFinal;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FIRE - Intense sparkle points from light dispersion in facets
    // The "fire" effect that makes gems sparkle brilliantly
    // ═══════════════════════════════════════════════════════════════════════
    float fire = calculateFire(normal, viewDir, lightDir);

    // Tint fire by gem color - colored gems should have tinted highlights
    // Pure white fire only for quartz/clear gems (low sssStrength)
    vec3 fireColor = vec3(1.0, 0.99, 0.97); // Base warm white
    float fireIntensity = 0.3; // Base intensity for clear gems
    float fireClamp = 1.5; // Max fire value for clear gems

    if (sssStrength > 0.5) {
        // Get gem hue from absorption - this IS the gem's color
        vec3 absorption = sssAbsorption;
        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);
        vec3 gemHue = absorption / max(maxAbs, 0.001);

        // For colored gems, fire should BE the gem color, not white
        // The more colored the gem (higher sssStrength), the more the fire matches the gem
        float colorStrength = clamp((sssStrength - 0.5) * 0.5, 0.0, 1.0);

        // Use gem hue directly as fire color - NOT mixed with white
        // This ensures fire can never bloom to white
        fireColor = gemHue * 1.2; // Slight brightness boost but stay saturated

        // Reduce fire intensity AND clamp for colored gems to prevent bloom washout
        // Colored gems should have subtle, saturated fire, not bright white spots
        fireIntensity = mix(0.3, 0.08, colorStrength); // Much lower for colored gems
        fireClamp = mix(1.5, 0.5, colorStrength); // Much lower clamp for colored gems
    }

    // Apply fire clamp BEFORE multiplying by color
    fire = min(fire, fireClamp);

    // Calculate fire contribution and clamp to prevent any channel from blooming
    vec3 fireContribution = fireColor * fire * fireIntensity;
    fireContribution = min(fireContribution, vec3(0.4)); // Hard cap on fire brightness
    finalColor += fireContribution;

    // Ensure minimum brightness - allow near-black for gemstones
    // minBrightness of 0.01 allows true darks while preventing total black
    finalColor = max(finalColor, vec3(minBrightness));

    // ═══════════════════════════════════════════════════════════════════════
    // ALPHA - More opaque for visibility
    // ═══════════════════════════════════════════════════════════════════════

    // Higher base opacity
    float baseAlpha = 0.6 + frostiness * 0.25;

    // Fresnel makes edges solid
    float rimAlpha = fresnel * 0.3;

    // Soul glow adds opacity
    float glowAlpha = soulIntensity * 0.15;

    float finalAlpha = min(baseAlpha + rimAlpha + glowAlpha, 0.95) * opacity;

    // ═══════════════════════════════════════════════════════════════════════
    // REFRACTED SOUL - Add the soul visible through the crystal
    // This is the actual soul mesh rendered to texture and sampled with refraction
    // ═══════════════════════════════════════════════════════════════════════
    if (refractedSoulAlpha > 0.01) {
        // The soul should glow through the crystal, tinted by the crystal's color
        // Use additive blending so the soul illuminates the crystal from within
        vec3 soulGlow = refractedSoulColor * refractedSoulAlpha;

        // Tint the soul by the crystal's SSS color for colored gems
        // emotionColorBleed controls how much pure emotion color comes through
        // 0 = fully tinted by gem color, 1 = pure emotion color
        if (sssStrength > 0.01) {
            vec3 absorption = sssAbsorption;
            float maxAbs = max(max(absorption.r, absorption.g), absorption.b);
            vec3 gemHue = absorption / max(maxAbs, 0.001);
            float tintAmount = sssStrength * 0.5 * (1.0 - emotionColorBleed);
            soulGlow *= mix(vec3(1.0), gemHue, tintAmount);
        }

        // Add soul glow to final color
        finalColor += soulGlow * 0.8;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EMOTION COLOR BLEED - Additional inner glow from soul emotion
    // Adds pure emotion color as light shining through the gem from the soul
    // ═══════════════════════════════════════════════════════════════════════
    if (emotionColorBleed > 0.001 && sssStrength > 0.01) {
        // Inner glow based on thickness - thinner areas show more soul light
        float innerGlow = 1.0 - abs(dot(normal, viewDir)); // Edges are thin
        innerGlow = pow(innerGlow, 1.5) * emotionColorBleed;

        // Also add glow near the core
        float coreProximity = exp(-distFromCenter * 2.0);
        innerGlow += coreProximity * emotionColorBleed * 0.5;

        // Add pure emotion color as inner light
        finalColor += emotionColor * innerGlow * 0.4;
    }

    gl_FragColor = vec4(finalColor, finalAlpha);
}
`;

/**
 * Get crystal shaders
 * @returns {Object} { vertexShader, fragmentShader }
 */
function getCrystalShaders() {
    return {
        vertexShader: crystalVertexShader,
        fragmentShader: crystalFragmentShader
    };
}

/**
 * Default crystal uniform values
 * These create the frosted appearance matching the reference image
 */
const CRYSTAL_DEFAULT_UNIFORMS = {
    time: 0,
    glowIntensity: 1.0,
    opacity: 1.0,

    // Crystal appearance (tuned for crystal.obj)
    frostiness: 0.55,           // Frosted translucency (slightly less opaque)
    fresnelPower: 2.8,          // Edge brightness falloff (slightly sharper)
    fresnelIntensity: 0.35,     // Edge brightness strength (more visible rim)
    innerGlowStrength: 0.55,    // How much soul shows through (boosted)
    surfaceRoughness: 0.12,     // Surface texture variation (subtler)

    // Enhanced lighting
    shadowDarkness: 0.60,       // How dark shadows can get (0-1) - strong shadows
    specularIntensity: 0.9,     // Edge highlight brightness
    specularPower: 28.0,        // Specular falloff sharpness
    transmissionContrast: 1.0,  // Thin/thick brightness ratio
    minBrightness: 0.005,       // Minimum brightness floor (near-black for gemstones)

    // Noise scales
    surfaceNoiseScale: 1.50,    // Scale of surface frost pattern
    noiseFrequency: 1.33,       // Frequency of hash noise pattern

    // Internal caustics
    causticIntensity: 0.8,      // Brightness of internal caustic hot spots
    causticScale: 2.0,          // Scale of caustic pattern
    causticSpeed: 0.12,         // Animation speed of caustics

    // Texture
    textureStrength: 0.55,      // How much texture affects appearance

    // Soul refraction - optical lensing of inner soul through crystal
    refractionIndex: 1.5,       // Index of refraction (1.5 glass, 2.4 diamond)
    refractionStrength: 0.5,    // Distortion magnitude - higher for more pronounced lensing
    resolution: [1920, 1080],   // Screen resolution (updated at runtime)
    soulTextureSize: [1920, 1080], // Soul render target size (updated at runtime)
    soulScreenCenter: [0.5, 0.5],  // Soul center in screen UV (updated at runtime)

    // Physically-based subsurface scattering (crystal preset as default)
    sssStrength: 0.65,                      // Overall SSS intensity (boosted)
    sssAbsorption: [2.4, 2.5, 2.8],         // Absorption coefficients RGB (crystal - cool blue tint)
    sssScatterDistance: [0.35, 0.4, 0.45],  // Mean free path / scatter radius RGB (increased)
    sssThicknessBias: 0.18,                 // Base thickness value
    sssThicknessScale: 0.60,                // Thickness multiplier
    sssCurvatureScale: 1.80,                // Curvature influence on SSS
    sssAmbient: 0.30,                       // Ambient SSS contribution (boosted for visibility)
    sssLightDir: [0.5, 1.0, 0.8],           // Primary light direction
    sssLightColor: [1.0, 0.98, 0.95],       // Light color (warm white)

    // Component-specific blend layers (all disabled by default)
    // Shell layers - affect frosted crystal shell
    shellLayer1Mode: 0,
    shellLayer1Strength: 0.0,
    shellLayer1Enabled: 0,
    shellLayer2Mode: 0,
    shellLayer2Strength: 0.0,
    shellLayer2Enabled: 0,

    // Soul layers - affect inner glowing soul
    soulLayer1Mode: 0,
    soulLayer1Strength: 0.0,
    soulLayer1Enabled: 0,
    soulLayer2Mode: 0,
    soulLayer2Strength: 0.0,
    soulLayer2Enabled: 0,

    // Rim layers - affect fresnel rim glow
    rimLayer1Mode: 0,
    rimLayer1Strength: 0.0,
    rimLayer1Enabled: 0,
    rimLayer2Mode: 0,
    rimLayer2Strength: 0.0,
    rimLayer2Enabled: 0,

    // SSS layers - affect subsurface scattering
    sssLayer1Mode: 0,
    sssLayer1Strength: 0.0,
    sssLayer1Enabled: 0,
    sssLayer2Mode: 0,
    sssLayer2Strength: 0.0,
    sssLayer2Enabled: 0
};

/**
 * Material Factory - Creates geometry-specific materials
 */


function createCustomMaterial(geometryType, geometryConfig, options = {}) {
    const { glowColor = [1.0, 1.0, 0.95], glowIntensity = 1.0, materialVariant = null, emotionData = null, assetBasePath = '/assets' } = options;

    if (geometryConfig.material === 'custom') {
        return createCustomTypeMaterial(geometryType, glowColor, glowIntensity, materialVariant, emotionData, assetBasePath);
    }

    if (geometryConfig.material === 'emissive') {
        return createEmissiveMaterial(geometryType, glowColor, glowIntensity, materialVariant, emotionData, assetBasePath);
    }

    return null;
}

function createCustomTypeMaterial(geometryType, glowColor, glowIntensity, materialVariant, _emotionData, assetBasePath) {
    const textureLoader = new TextureLoader();

    switch (geometryType) {
    case 'moon':
        return createMoonMaterial(textureLoader, glowColor, glowIntensity, materialVariant, assetBasePath);
    case 'crystal':
        // Uses quartz SSS preset for clear crystal appearance
        return createCrystalMaterial(glowColor, glowIntensity, 'crystal', { sssPreset: 'quartz' }, assetBasePath);
    case 'rough':
        // Custom crystal appearance for rough stone, uses crystal SSS preset
        return createCrystalMaterial(glowColor, glowIntensity, 'rough', {
            frostiness: 0.05,
            innerGlowStrength: 0.0,
            fresnelIntensity: 1.6
        }, assetBasePath);
    case 'heart':
        // Custom crystal appearance for heart - tuned for flat geometry
        return createCrystalMaterial(glowColor, glowIntensity, 'heart', {
            frostiness: 0.475,
            innerGlowStrength: 0.117,
            fresnelIntensity: 1.206
        }, assetBasePath);
    case 'star':
        // Star crystal with citrine SSS preset
        return createCrystalMaterial(glowColor, glowIntensity, 'star', { sssPreset: 'citrine' }, assetBasePath);
    default:
        console.warn('Unknown custom material type:', geometryType);
        return null;
    }
}

function createEmissiveMaterial(geometryType, glowColor, glowIntensity, materialVariant, emotionData, assetBasePath) {
    const textureLoader = new TextureLoader();

    switch (geometryType) {
    case 'sun':
        return createSunMaterialWrapper(textureLoader, glowColor, glowIntensity, materialVariant, emotionData, assetBasePath);
    default:
        console.warn('Unknown emissive material type:', geometryType);
        return null;
    }
}

function createCrystalMaterial(glowColor, glowIntensity, textureType = 'crystal', overrides = {}, assetBasePath = '/assets') {

    const { vertexShader, fragmentShader } = getCrystalShaders();

    // Load texture based on geometry type
    let crystalTexture = null;
    if (textureType) {
        const textureLoader = new TextureLoader();
        const texturePaths = {
            crystal: `${assetBasePath}/textures/Crystal/crystal.png`,
            rough: `${assetBasePath}/textures/Crystal/rough.png`,
            heart: `${assetBasePath}/textures/Crystal/heart.png`,
            star: `${assetBasePath}/textures/Crystal/star.png`
        };
        const texturePath = texturePaths[textureType] || texturePaths.crystal;
        crystalTexture = textureLoader.load(texturePath,
            undefined,
            err => console.warn(`💎 ${textureType} texture failed to load:`, err)
        );
    }

    // Get SSS preset if specified, otherwise use defaults
    const sssPreset = overrides.sssPreset ? SSS_PRESETS[overrides.sssPreset] : null;

    const material = new ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            emotionColor: { value: new Color(glowColor[0], glowColor[1], glowColor[2]) },
            glowIntensity: { value: glowIntensity },
            opacity: { value: 1.0 },
            frostiness: { value: overrides.frostiness ?? CRYSTAL_DEFAULT_UNIFORMS.frostiness },
            fresnelPower: { value: overrides.fresnelPower ?? CRYSTAL_DEFAULT_UNIFORMS.fresnelPower },
            fresnelIntensity: { value: overrides.fresnelIntensity ?? CRYSTAL_DEFAULT_UNIFORMS.fresnelIntensity },
            innerGlowStrength: { value: overrides.innerGlowStrength ?? CRYSTAL_DEFAULT_UNIFORMS.innerGlowStrength },
            surfaceRoughness: { value: CRYSTAL_DEFAULT_UNIFORMS.surfaceRoughness },
            // Enhanced lighting uniforms
            shadowDarkness: { value: overrides.shadowDarkness ?? CRYSTAL_DEFAULT_UNIFORMS.shadowDarkness },
            specularIntensity: { value: overrides.specularIntensity ?? CRYSTAL_DEFAULT_UNIFORMS.specularIntensity },
            specularPower: { value: overrides.specularPower ?? CRYSTAL_DEFAULT_UNIFORMS.specularPower },
            transmissionContrast: { value: overrides.transmissionContrast ?? CRYSTAL_DEFAULT_UNIFORMS.transmissionContrast },
            minBrightness: { value: overrides.minBrightness ?? CRYSTAL_DEFAULT_UNIFORMS.minBrightness },
            surfaceNoiseScale: { value: CRYSTAL_DEFAULT_UNIFORMS.surfaceNoiseScale },
            noiseFrequency: { value: CRYSTAL_DEFAULT_UNIFORMS.noiseFrequency },
            // Internal caustics
            causticIntensity: { value: overrides.causticIntensity ?? CRYSTAL_DEFAULT_UNIFORMS.causticIntensity },
            causticScale: { value: overrides.causticScale ?? CRYSTAL_DEFAULT_UNIFORMS.causticScale },
            causticSpeed: { value: overrides.causticSpeed ?? CRYSTAL_DEFAULT_UNIFORMS.causticSpeed },
            crystalTexture: { value: crystalTexture },
            // Heart texture slightly more transparent than crystal
            textureStrength: { value: textureType === 'heart' ? 0.35 : (textureType ? CRYSTAL_DEFAULT_UNIFORMS.textureStrength : 0.0) },
            // Soul refraction - samples soul texture with optical distortion
            soulTexture: { value: null }, // Set by ThreeRenderer at render time
            resolution: { value: new Vector2(
                CRYSTAL_DEFAULT_UNIFORMS.resolution[0],
                CRYSTAL_DEFAULT_UNIFORMS.resolution[1]
            ) },
            soulTextureSize: { value: new Vector2(
                CRYSTAL_DEFAULT_UNIFORMS.soulTextureSize[0],
                CRYSTAL_DEFAULT_UNIFORMS.soulTextureSize[1]
            ) },
            soulScreenCenter: { value: new Vector2(
                CRYSTAL_DEFAULT_UNIFORMS.soulScreenCenter[0],
                CRYSTAL_DEFAULT_UNIFORMS.soulScreenCenter[1]
            ) },
            refractionIndex: { value: overrides.refractionIndex ?? CRYSTAL_DEFAULT_UNIFORMS.refractionIndex },
            refractionStrength: { value: overrides.refractionStrength ?? CRYSTAL_DEFAULT_UNIFORMS.refractionStrength },
            // Physically-based subsurface scattering
            sssStrength: { value: overrides.sssStrength ?? sssPreset?.sssStrength ?? CRYSTAL_DEFAULT_UNIFORMS.sssStrength },
            sssAbsorption: { value: new Vector3(
                ...(overrides.sssAbsorption ?? sssPreset?.sssAbsorption ?? CRYSTAL_DEFAULT_UNIFORMS.sssAbsorption)
            ) },
            sssScatterDistance: { value: new Vector3(
                ...(overrides.sssScatterDistance ?? sssPreset?.sssScatterDistance ?? CRYSTAL_DEFAULT_UNIFORMS.sssScatterDistance)
            ) },
            sssThicknessBias: { value: overrides.sssThicknessBias ?? sssPreset?.sssThicknessBias ?? CRYSTAL_DEFAULT_UNIFORMS.sssThicknessBias },
            sssThicknessScale: { value: overrides.sssThicknessScale ?? sssPreset?.sssThicknessScale ?? CRYSTAL_DEFAULT_UNIFORMS.sssThicknessScale },
            sssCurvatureScale: { value: overrides.sssCurvatureScale ?? sssPreset?.sssCurvatureScale ?? CRYSTAL_DEFAULT_UNIFORMS.sssCurvatureScale },
            sssAmbient: { value: overrides.sssAmbient ?? sssPreset?.sssAmbient ?? CRYSTAL_DEFAULT_UNIFORMS.sssAmbient },
            sssLightDir: { value: new Vector3(...(overrides.sssLightDir ?? CRYSTAL_DEFAULT_UNIFORMS.sssLightDir)) },
            sssLightColor: { value: new Vector3(...(overrides.sssLightColor ?? CRYSTAL_DEFAULT_UNIFORMS.sssLightColor)) },
            // Emotion color bleed - how much soul color tints the gem
            emotionColorBleed: { value: overrides.emotionColorBleed ?? sssPreset?.emotionColorBleed ?? 0.0 },
            // Component-specific blend layers
            // Shell layers
            shellLayer1Mode: { value: CRYSTAL_DEFAULT_UNIFORMS.shellLayer1Mode },
            shellLayer1Strength: { value: CRYSTAL_DEFAULT_UNIFORMS.shellLayer1Strength },
            shellLayer1Enabled: { value: CRYSTAL_DEFAULT_UNIFORMS.shellLayer1Enabled },
            shellLayer2Mode: { value: CRYSTAL_DEFAULT_UNIFORMS.shellLayer2Mode },
            shellLayer2Strength: { value: CRYSTAL_DEFAULT_UNIFORMS.shellLayer2Strength },
            shellLayer2Enabled: { value: CRYSTAL_DEFAULT_UNIFORMS.shellLayer2Enabled },
            // Soul layers
            soulLayer1Mode: { value: CRYSTAL_DEFAULT_UNIFORMS.soulLayer1Mode },
            soulLayer1Strength: { value: CRYSTAL_DEFAULT_UNIFORMS.soulLayer1Strength },
            soulLayer1Enabled: { value: CRYSTAL_DEFAULT_UNIFORMS.soulLayer1Enabled },
            soulLayer2Mode: { value: CRYSTAL_DEFAULT_UNIFORMS.soulLayer2Mode },
            soulLayer2Strength: { value: CRYSTAL_DEFAULT_UNIFORMS.soulLayer2Strength },
            soulLayer2Enabled: { value: CRYSTAL_DEFAULT_UNIFORMS.soulLayer2Enabled },
            // Rim layers
            rimLayer1Mode: { value: CRYSTAL_DEFAULT_UNIFORMS.rimLayer1Mode },
            rimLayer1Strength: { value: CRYSTAL_DEFAULT_UNIFORMS.rimLayer1Strength },
            rimLayer1Enabled: { value: CRYSTAL_DEFAULT_UNIFORMS.rimLayer1Enabled },
            rimLayer2Mode: { value: CRYSTAL_DEFAULT_UNIFORMS.rimLayer2Mode },
            rimLayer2Strength: { value: CRYSTAL_DEFAULT_UNIFORMS.rimLayer2Strength },
            rimLayer2Enabled: { value: CRYSTAL_DEFAULT_UNIFORMS.rimLayer2Enabled },
            // SSS layers
            sssLayer1Mode: { value: CRYSTAL_DEFAULT_UNIFORMS.sssLayer1Mode },
            sssLayer1Strength: { value: CRYSTAL_DEFAULT_UNIFORMS.sssLayer1Strength },
            sssLayer1Enabled: { value: CRYSTAL_DEFAULT_UNIFORMS.sssLayer1Enabled },
            sssLayer2Mode: { value: CRYSTAL_DEFAULT_UNIFORMS.sssLayer2Mode },
            sssLayer2Strength: { value: CRYSTAL_DEFAULT_UNIFORMS.sssLayer2Strength },
            sssLayer2Enabled: { value: CRYSTAL_DEFAULT_UNIFORMS.sssLayer2Enabled }
        },
        vertexShader,
        fragmentShader,
        transparent: true,
        side: DoubleSide,
        depthWrite: false,  // Don't write depth so inner soul can render through
        blending: NormalBlending
    });


    return { material, type: 'crystal' };
}

function createMoonMaterial(textureLoader, glowColor, glowIntensity, materialVariant = null, assetBasePath = '/assets') {
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const resolution = isMobile ? '2k' : '4k';

    if (materialVariant === 'multiplexer') {
        const material = createMoonMultiplexerMaterial(textureLoader, {
            resolution,
            glowColor: new Color(glowColor[0], glowColor[1], glowColor[2]),
            glowIntensity,
            assetBasePath
        });
        return { material, type: 'moon-multiplexer' };
    }

    const material = createMoonShadowMaterial(textureLoader, {
        resolution,
        glowColor: new Color(glowColor[0], glowColor[1], glowColor[2]),
        glowIntensity,
        moonPhase: 'full',
        assetBasePath
    });

    return { material, type: 'moon' };
}

function createSunMaterialWrapper(textureLoader, glowColor, glowIntensity, materialVariant = null, _emotionData = null, assetBasePath = '/assets') {
    const material = createSunMaterial(textureLoader, {
        glowColor,
        glowIntensity,
        resolution: '4k',
        materialVariant,
        assetBasePath
    });
    return { material, type: 'sun' };
}

function disposeCustomMaterial(customMaterial) {
    if (!customMaterial) return;
    if (customMaterial.map) customMaterial.map.dispose();
    if (customMaterial.normalMap) customMaterial.normalMap.dispose();
    if (customMaterial.emissiveMap) customMaterial.emissiveMap.dispose();
    if (customMaterial.roughnessMap) customMaterial.roughnessMap.dispose();
    if (customMaterial.metalnessMap) customMaterial.metalnessMap.dispose();
}

/**
 * GeometryStateManager - Reset Shader States During Morphs
 *
 * Provides reset functions for each geometry type to clear shader uniforms
 * to their default values when morphing away. This prevents visual remnants
 * from bleeding between geometries (e.g., blood moon effects on crystal).
 *
 * Architecture:
 * - Each geometry has its own reset function
 * - Reset functions clear uniforms to defaults (don't dispose materials)
 * - Called during the "shrink" phase of morph before geometry swap
 */


/**
 * Reset moon material to default state
 * Clears: moon phase, blood moon effects, eclipse states, blend layers
 *
 * @param {THREE.ShaderMaterial} material - Moon shader material
 */
function resetMoon(material) {
    if (!material || !material.uniforms) {
        return;
    }

    const u = material.uniforms;

    // Moon phase - reset to full moon
    if (u.shadowOffset) {
        u.shadowOffset.value.set(MOON_PHASES['full'].x, MOON_PHASES['full'].y);
    }
    if (u.shadowCoverage) {
        u.shadowCoverage.value = 0.5;
    }
    if (u.shadowSoftness) {
        u.shadowSoftness.value = 0.05;
    }

    // Blood moon / lunar eclipse effects
    if (u.eclipseProgress) {
        u.eclipseProgress.value = 0.0;
    }
    if (u.eclipseIntensity) {
        u.eclipseIntensity.value = 0.0;
    }
    if (u.bloodMoonColor) {
        u.bloodMoonColor.value = [0.85, 0.18, 0.08];
    }
    if (u.emissiveStrength) {
        u.emissiveStrength.value = 0.39;
    }
    if (u.eclipseShadowPos) {
        u.eclipseShadowPos.value = [-2, 0.0];
    }
    if (u.eclipseShadowRadius) {
        u.eclipseShadowRadius.value = 1.2;
    }
    if (u.shadowDarkness) {
        u.shadowDarkness.value = 0.53;
    }

    // Eclipse color grading
    if (u.eclipseShadowColor) {
        u.eclipseShadowColor.value = [1.00, 0.58, 0.00];
    }
    if (u.eclipseMidtoneColor) {
        u.eclipseMidtoneColor.value = [0.71, 0.43, 0.03];
    }
    if (u.eclipseHighlightColor) {
        u.eclipseHighlightColor.value = [1.00, 0.28, 0.10];
    }
    if (u.eclipseGlowColor) {
        u.eclipseGlowColor.value = [0.09, 0.09, 0.09];
    }
    if (u.eclipseBrightnessModel) {
        u.eclipseBrightnessModel.value = 0.0;
    }

    // Blend layers - reset to calibrated defaults
    if (u.layer1Mode) u.layer1Mode.value = 9.0;  // Vivid Light
    if (u.layer1Strength) u.layer1Strength.value = 0.322;
    if (u.layer1Enabled) u.layer1Enabled.value = 1.0;

    if (u.layer2Mode) u.layer2Mode.value = 0.0;  // Multiply
    if (u.layer2Strength) u.layer2Strength.value = 2.785;
    if (u.layer2Enabled) u.layer2Enabled.value = 1.0;

    if (u.layer3Mode) u.layer3Mode.value = 7.0;  // Overlay
    if (u.layer3Strength) u.layer3Strength.value = 0.199;
    if (u.layer3Enabled) u.layer3Enabled.value = 1.0;

    if (u.layer4Mode) u.layer4Mode.value = 0.0;
    if (u.layer4Strength) u.layer4Strength.value = 0.0;
    if (u.layer4Enabled) u.layer4Enabled.value = 0.0;

    // Reset opacity to full
    if (u.opacity) {
        u.opacity.value = 1.0;
    }

}

/**
 * Reset sun material to default state
 * Clears: solar eclipse state, shadow position, blend layers
 *
 * @param {THREE.ShaderMaterial} material - Sun shader material
 */
function resetSun(material) {
    if (!material || !material.uniforms) {
        return;
    }

    const u = material.uniforms;

    // Solar eclipse - reset to no eclipse
    if (u.eclipseProgress) {
        u.eclipseProgress.value = 0.0;
    }
    if (u.eclipseShadowPos) {
        u.eclipseShadowPos.value = [-2, 0.0];  // Off-screen
    }
    if (u.eclipseShadowRadius) {
        u.eclipseShadowRadius.value = 0.882;
    }
    if (u.shadowDarkness) {
        u.shadowDarkness.value = 1.0;  // Sun shadow is always 100%
    }

    // Standard shadow (legacy/fallback)
    if (u.shadowOffset) {
        u.shadowOffset.value.set(200.0, 0.0);  // Far off-screen
    }
    if (u.shadowCoverage) {
        u.shadowCoverage.value = 0.5;
    }
    if (u.shadowSoftness) {
        u.shadowSoftness.value = 0.1;
    }

    // Blend layers - reset to sun defaults
    if (u.layer1Mode) u.layer1Mode.value = 0.0;  // Multiply
    if (u.layer1Strength) u.layer1Strength.value = 0.230;
    if (u.layer1Enabled) u.layer1Enabled.value = 1.0;

    if (u.layer2Mode) u.layer2Mode.value = 0.0;
    if (u.layer2Strength) u.layer2Strength.value = 0.0;
    if (u.layer2Enabled) u.layer2Enabled.value = 0.0;

    if (u.layer3Mode) u.layer3Mode.value = 0.0;
    if (u.layer3Strength) u.layer3Strength.value = 0.0;
    if (u.layer3Enabled) u.layer3Enabled.value = 0.0;

    if (u.layer4Mode) u.layer4Mode.value = 0.0;
    if (u.layer4Strength) u.layer4Strength.value = 0.0;
    if (u.layer4Enabled) u.layer4Enabled.value = 0.0;

    // Reset emissive intensity to default
    if (u.emissiveIntensity) {
        u.emissiveIntensity.value = 4.0;
    }

    // Reset opacity to full
    if (u.opacity) {
        u.opacity.value = 1.0;
    }

    // Reset time (prevents odd animation state on return)
    if (u.time) {
        u.time.value = 0;
    }

}

/**
 * Reset crystal material to default state
 * Clears: blend layers, frostiness, glow settings
 *
 * @param {THREE.ShaderMaterial} material - Crystal shader material
 */
function resetCrystal(material) {
    if (!material || !material.uniforms) {
        return;
    }

    const u = material.uniforms;
    const defaults = CRYSTAL_DEFAULT_UNIFORMS;

    // Crystal appearance
    if (u.frostiness) u.frostiness.value = defaults.frostiness;
    if (u.fresnelPower) u.fresnelPower.value = defaults.fresnelPower;
    if (u.fresnelIntensity) u.fresnelIntensity.value = defaults.fresnelIntensity;
    if (u.innerGlowStrength) u.innerGlowStrength.value = defaults.innerGlowStrength;
    if (u.surfaceRoughness) u.surfaceRoughness.value = defaults.surfaceRoughness;

    // Noise scales
    if (u.surfaceNoiseScale) u.surfaceNoiseScale.value = defaults.surfaceNoiseScale;
    if (u.noiseFrequency) u.noiseFrequency.value = defaults.noiseFrequency;

    // Internal caustics
    if (u.causticIntensity) u.causticIntensity.value = defaults.causticIntensity;
    if (u.causticScale) u.causticScale.value = defaults.causticScale;
    if (u.causticSpeed) u.causticSpeed.value = defaults.causticSpeed;

    // Texture
    if (u.textureStrength) u.textureStrength.value = defaults.textureStrength;

    // Blend layers
    if (u.layer1Mode) u.layer1Mode.value = defaults.layer1Mode;
    if (u.layer1Strength) u.layer1Strength.value = defaults.layer1Strength;
    if (u.layer1Enabled) u.layer1Enabled.value = defaults.layer1Enabled;

    if (u.layer2Mode) u.layer2Mode.value = defaults.layer2Mode;
    if (u.layer2Strength) u.layer2Strength.value = defaults.layer2Strength;
    if (u.layer2Enabled) u.layer2Enabled.value = defaults.layer2Enabled;

    if (u.layer3Mode) u.layer3Mode.value = defaults.layer3Mode;
    if (u.layer3Strength) u.layer3Strength.value = defaults.layer3Strength;
    if (u.layer3Enabled) u.layer3Enabled.value = defaults.layer3Enabled;

    if (u.layer4Mode) u.layer4Mode.value = defaults.layer4Mode;
    if (u.layer4Strength) u.layer4Strength.value = defaults.layer4Strength;
    if (u.layer4Enabled) u.layer4Enabled.value = defaults.layer4Enabled;

    // Glow (preserve emotion color, just reset intensity)
    if (u.glowIntensity) u.glowIntensity.value = defaults.glowIntensity;

    // Reset opacity to full
    if (u.opacity) u.opacity.value = defaults.opacity;

    // Reset time
    if (u.time) u.time.value = defaults.time;

}

/**
 * Reset material state based on geometry type
 * Dispatcher function that calls the appropriate reset function
 *
 * @param {string} geometryType - The geometry type ('moon', 'sun', 'crystal')
 * @param {THREE.ShaderMaterial} material - The material to reset
 */
function resetGeometryState(geometryType, material) {
    switch (geometryType) {
    case 'moon':
        resetMoon(material);
        break;
    case 'sun':
        resetSun(material);
        break;
    case 'crystal':
    case 'diamond':
        resetCrystal(material);
        break;
    }
}

/**
 * GeometryCache - Asset Caching for Geometry Morphing
 *
 * Caches heavy assets (geometries, textures, materials) to avoid
 * reloading during morph transitions. Assets are loaded once and
 * reused on subsequent morphs.
 */


/**
 * Cache storage for geometry assets
 * Structure: { geometryType: { geometry, material, loaded: boolean } }
 */
const cache = new Map();

/**
 * Preload assets for a geometry type
 * @param {string} geometryType - The geometry type to preload (e.g., 'crystal', 'moon', 'sun')
 * @param {Object} options - Material creation options
 * @returns {Promise<Object>} - Cached assets { geometry, material }
 */
async function preload(geometryType, options = {}) {
    // Return cached if already loaded
    if (cache.has(geometryType)) {
        const cached = cache.get(geometryType);
        if (cached.loaded) {
            return cached;
        }
    }

    const config = THREE_GEOMETRIES[geometryType];
    if (!config) {
        console.warn(`[GeometryCache] Unknown geometry type: ${geometryType}`);
        return null;
    }

    // Start loading
    const entry = {
        geometry: null,
        material: null,
        materialType: null,
        config,
        loaded: false
    };

    // Load geometry (may be async for OBJ models like crystal)
    if (config.geometryLoader) {
        entry.geometry = await config.geometryLoader(options.assetBasePath);
    } else {
        entry.geometry = config.geometry;
    }

    // Create material if needed
    if (config.material === 'custom' || config.material === 'emissive') {
        const materialResult = createCustomMaterial(geometryType, config, {
            glowColor: options.glowColor || [1.0, 1.0, 0.95],
            glowIntensity: options.glowIntensity || 1.0,
            materialVariant: options.materialVariant,
            emotionData: options.emotionData,
            assetBasePath: options.assetBasePath
        });

        if (materialResult) {
            entry.material = materialResult.material;
            entry.materialType = materialResult.type;
        }
    }

    entry.loaded = true;
    cache.set(geometryType, entry);

    return entry;
}

/**
 * Get cached assets for a geometry type
 * @param {string} geometryType - The geometry type
 * @returns {Object|null} - Cached assets or null if not loaded
 */
function get(geometryType) {
    const entry = cache.get(geometryType);
    if (entry && entry.loaded) {
        return entry;
    }
    return null;
}

/**
 * Check if a geometry type is cached
 * @param {string} geometryType - The geometry type
 * @returns {boolean}
 */
function has(geometryType) {
    const entry = cache.get(geometryType);
    return entry && entry.loaded;
}

/**
 * Update material options for a cached geometry (e.g., when emotion changes)
 * Does NOT recreate the material - just updates uniforms
 * @param {string} geometryType - The geometry type
 * @param {Object} options - New material options
 */
function updateMaterialOptions(geometryType, options) {
    const entry = cache.get(geometryType);
    if (!entry || !entry.material) {
        return;
    }

    // Update uniforms directly on cached material
    const {uniforms} = entry.material;
    if (uniforms) {
        if (options.glowColor && uniforms.glowColor) {
            uniforms.glowColor.value.set(...options.glowColor);
        }
        if (options.glowIntensity !== undefined && uniforms.glowIntensity) {
            uniforms.glowIntensity.value = options.glowIntensity;
        }
    }
}

/**
 * Preload all supported geometry types
 * Call during app initialization for instant morphs
 * @param {Object} options - Material creation options
 * @returns {Promise<void>}
 */
async function preloadAll(options = {}) {
    const types = ['crystal', 'rough', 'heart', 'moon', 'sun'];

    await Promise.all(types.map(type => preload(type, options)));

}

/**
 * Clear cache and dispose all assets
 * Call on app shutdown to free GPU memory
 */
function dispose() {
    for (const [type, entry] of cache.entries()) {
        if (entry.material) {
            disposeCustomMaterial(entry.material);
            entry.material.dispose();
        }
        // Note: Don't dispose shared geometries from THREE_GEOMETRIES
    }
    cache.clear();
}

/**
 * Get cache status for debugging
 * @returns {Object} - Cache status
 */
function getStatus() {
    const status = {};
    for (const [type, entry] of cache.entries()) {
        status[type] = {
            loaded: entry.loaded,
            hasGeometry: !!entry.geometry,
            hasMaterial: !!entry.material,
            materialType: entry.materialType
        };
    }
    return status;
}

var GeometryCache = {
    preload,
    preloadAll,
    get,
    has,
    updateMaterialOptions,
    dispose,
    getStatus
};

/**
 * AnimationManager - Gesture animation orchestration for 3D mascot
 *
 * Manages gesture playback, virtual particle pools, and animation lifecycle.
 * Extracted from Core3DManager to improve separation of concerns.
 *
 * @module 3d/managers/AnimationManager
 */


/**
 * Maximum number of concurrent animations to prevent memory issues
 */
const MAX_ACTIVE_ANIMATIONS = 10;

/**
 * Default pool size for virtual particles
 */
const DEFAULT_POOL_SIZE = 5;

class AnimationManager {
    /**
     * Create animation manager
     * @param {ProceduralAnimator} animator - The procedural animator instance
     * @param {GestureBlender} gestureBlender - The gesture blender for combining animations
     */
    constructor(animator, gestureBlender) {
        this.animator = animator;
        this.gestureBlender = gestureBlender;

        // Virtual particle pool for gesture animations (prevents closure memory leaks)
        this.virtualParticlePool = this._createVirtualParticlePool(DEFAULT_POOL_SIZE);
        this.nextPoolIndex = 0;
    }

    /**
     * Create reusable virtual particle object pool
     * @param {number} size - Pool size
     * @returns {Array} Array of reusable particle objects
     * @private
     */
    _createVirtualParticlePool(size) {
        const pool = [];
        for (let i = 0; i < size; i++) {
            pool.push({
                x: 0,
                y: 0,
                vx: 0,
                vy: 0,
                size: 1,
                baseSize: 1,
                opacity: 1,
                scaleFactor: 1,
                gestureData: null
            });
        }
        return pool;
    }

    /**
     * Get next virtual particle from pool (round-robin)
     * @returns {Object} Reusable virtual particle object
     */
    getVirtualParticleFromPool() {
        const particle = this.virtualParticlePool[this.nextPoolIndex];
        this.nextPoolIndex = (this.nextPoolIndex + 1) % this.virtualParticlePool.length;
        // Reset particle state
        particle.x = 0;
        particle.y = 0;
        particle.vx = 0;
        particle.vy = 0;
        particle.size = 1;
        particle.baseSize = 1;
        particle.opacity = 1;
        particle.scaleFactor = 1;
        particle.gestureData = null;
        return particle;
    }

    /**
     * Play gesture animation using 2D gesture data translated to 3D
     * Falls back to procedural 3D-only gestures (like accent gestures) if not in 2D registry
     * @param {string} gestureName - Name of the gesture to play
     * @param {Object} callbacks - Callback functions
     * @param {Function} callbacks.onUpdate - Called with (props, progress) during animation
     * @param {Function} callbacks.onComplete - Called when animation completes
     * @returns {boolean} True if gesture was started successfully
     */
    playGesture(gestureName, callbacks = {}) {
        // First try the 2D gesture registry
        const gesture2D = getGesture(gestureName);

        // If not in 2D registry, check for 3D-only procedural gestures (e.g., accent gestures)
        if (!gesture2D) {
            const proceduralGesture = this.animator.createGestureAnimation(gestureName);
            if (proceduralGesture && proceduralGesture.evaluate) {
                // Use the procedural gesture directly
                return this._playProceduralGesture(gestureName, proceduralGesture, callbacks);
            }
            // Truly unknown gesture
            console.warn(`Unknown gesture: ${gestureName}`);
            return false;
        }

        // Get reusable virtual particle from pool (prevent closure memory leaks)
        const virtualParticle = this.getVirtualParticleFromPool();

        // Get gesture config for duration
        const config = gesture2D.config || {};
        const duration = config.musicalDuration?.musical
            ? (config.musicalDuration.beats || 2) * 500  // Assume 120 BPM (500ms per beat)
            : (config.duration || 800);

        // Start time-based animation
        const startTime = this.animator.time;

        // Enforce animation array size limit (prevent unbounded growth memory leak)
        if (this.animator.animations.length >= MAX_ACTIVE_ANIMATIONS) {
            // Remove oldest animation (FIFO cleanup)
            const removed = this.animator.animations.shift();
            console.warn(`Animation limit reached (${MAX_ACTIVE_ANIMATIONS}), removed oldest: ${removed.gestureName || 'unknown'}`);
        }

        // Create persistent gesture data object for this gesture instance
        const gestureData = { initialized: false };

        // Add to animator's active animations
        this.animator.animations.push({
            gestureName, // Store gesture name for particle system
            duration,
            startTime,
            config, // Store config for particle system
            evaluate: t => {
                // Reset virtual particle to center each frame
                virtualParticle.x = 0;
                virtualParticle.y = 0;
                virtualParticle.vx = 0;
                virtualParticle.vy = 0;
                virtualParticle.size = 1;
                virtualParticle.opacity = 1;

                // All gestures now have native 3D implementations
                // Apply gesture to virtual particle if needed
                if (gesture2D.apply) {
                    gesture2D.apply(virtualParticle, gestureData, config, t, 1.0, 0, 0);
                }

                // Call gesture's 3D evaluate function with particle data
                const motion = {
                    ...config,
                    particle: virtualParticle,
                    config,
                    strength: config.strength || 1.0
                };

                // Safety check: if gesture doesn't have 3D implementation, return neutral transform
                if (!gesture2D['3d'] || !gesture2D['3d'].evaluate) {
                    return {
                        position: [0, 0, 0],
                        rotation: [0, 0, 0],
                        scale: 1.0
                    };
                }

                // Call with gesture2D as context so 'this.config' works
                return gesture2D['3d'].evaluate.call(gesture2D, t, motion);
            },
            callbacks: {
                onUpdate: callbacks.onUpdate || null,
                onComplete: () => {
                    // Clean up gesture
                    if (gesture2D.cleanup) {
                        gesture2D.cleanup(virtualParticle);
                    }
                    // Call user callback
                    if (callbacks.onComplete) {
                        callbacks.onComplete();
                    }
                }
            }
        });

        return true;
    }

    /**
     * Play a procedural gesture (3D-only, not in 2D registry)
     * Used for accent gestures like pop, punch, swell, swagger, dip, flare
     * @private
     * @param {string} gestureName - Name of the gesture
     * @param {Object} proceduralGesture - Gesture definition from ProceduralAnimator
     * @param {Object} callbacks - Callback functions
     * @returns {boolean} True if gesture was started successfully
     */
    _playProceduralGesture(gestureName, proceduralGesture, callbacks = {}) {
        // Get duration from procedural gesture (in seconds, convert to ms)
        const durationSec = proceduralGesture.duration || 0.5;
        const duration = durationSec * 1000;

        // Start time
        const startTime = this.animator.time;

        // Enforce animation array size limit
        if (this.animator.animations.length >= MAX_ACTIVE_ANIMATIONS) {
            const removed = this.animator.animations.shift();
            console.warn(`Animation limit reached (${MAX_ACTIVE_ANIMATIONS}), removed oldest: ${removed.gestureName || 'unknown'}`);
        }

        // Add to animator's active animations
        // Procedural gestures have isAccent flag for proper groove blending
        this.animator.animations.push({
            gestureName,
            duration,
            startTime,
            isAccent: proceduralGesture.isAccent || false,  // Pass isAccent flag for GestureBlender
            evaluate: proceduralGesture.evaluate,
            callbacks: {
                onUpdate: callbacks.onUpdate || null,
                onComplete: callbacks.onComplete || null
            }
        });

        return true;
    }

    /**
     * Update animations for current frame
     * @param {number} deltaTime - Time since last frame in seconds
     */
    update(deltaTime) {
        this.animator.update(deltaTime);
    }

    /**
     * Blend all active animations
     * @param {THREE.Quaternion} baseQuaternion - Base rotation quaternion
     * @param {number} baseScale - Base scale value
     * @param {number} baseGlowIntensity - Base glow intensity
     * @returns {Object} Blended animation state
     */
    blend(baseQuaternion, baseScale, baseGlowIntensity) {
        return this.gestureBlender.blend(
            this.animator.animations,
            this.animator.time,
            baseQuaternion,
            baseScale,
            baseGlowIntensity
        );
    }

    /**
     * Check if any animations are active
     * @returns {boolean} True if animations are playing
     */
    hasActiveAnimations() {
        return this.animator.animations.length > 0;
    }

    /**
     * Get count of active animations
     * @returns {number} Number of active animations
     */
    getActiveAnimationCount() {
        return this.animator.animations.length;
    }

    /**
     * Get current animator time
     * @returns {number} Current animation time
     */
    getTime() {
        return this.animator.time;
    }

    /**
     * Get active animations array (for external systems like particle translator)
     * @returns {Array} Active animations
     */
    getActiveAnimations() {
        return this.animator.animations;
    }

    /**
     * Stop all animations
     */
    stopAll() {
        this.animator.stopAll();
    }

    /**
     * Play emotion animation
     * @param {string} emotion - Emotion name
     */
    playEmotion(emotion) {
        this.animator.playEmotion(emotion);
    }

    /**
     * Clean up and dispose resources
     */
    dispose() {
        this.stopAll();

        if (this.virtualParticlePool) {
            this.virtualParticlePool.length = 0;
            this.virtualParticlePool = null;
        }

        this.animator = null;
        this.gestureBlender = null;
        this.tempEuler = null;
        this.gestureQuaternion = null;
    }
}

/**
 * Eclipse Type Configurations
 *
 * Defines parameters for different types of solar eclipses.
 * Each eclipse type has specific shadow coverage, corona configuration,
 * and Bailey's Beads characteristics.
 */

const ECLIPSE_TYPES = {
    OFF: 'off',
    ANNULAR: 'annular',
    TOTAL: 'total'
};

const ECLIPSE_CONFIG = {
    [ECLIPSE_TYPES.OFF]: {
        shadowCoverage: 0.0,
        coronaIntensity: 1.0,        // Base corona intensity
        coronaRaysEnabled: false,     // No rays when no eclipse
        baileyBeadsEnabled: false,
        baileyBeadsCount: 0,
        baileyBeadsSize: 0.0
    },

    [ECLIPSE_TYPES.ANNULAR]: {
        shadowCoverage: 0.950,       // Smaller shadow - leaves prominent "ring of fire"
        coronaIntensity: 0.8,        // Slightly reduced corona (moon blocks some)
        coronaRaysEnabled: false,     // No dramatic rays for annular
        baileyBeadsEnabled: true,
        baileyBeadsCount: 12,        // More beads for annular
        baileyBeadsSize: 0.015       // Smaller beads
    },

    [ECLIPSE_TYPES.TOTAL]: {
        shadowCoverage: 1.019,       // Larger shadow - complete coverage
        coronaIntensity: 4.0,        // Dramatic corona effect visible
        coronaRaysEnabled: true,      // Enable dramatic rays for total eclipse
        baileyBeadsEnabled: true,
        baileyBeadsCount: 6,         // Fewer beads for total
        baileyBeadsSize: 0.025       // Larger, more dramatic beads
    }
};

/**
 * Get configuration for a specific eclipse type
 * @param {string} eclipseType - Eclipse type from ECLIPSE_TYPES
 * @returns {Object} Eclipse configuration
 */
function getEclipseConfig(eclipseType) {
    return ECLIPSE_CONFIG[eclipseType] || ECLIPSE_CONFIG[ECLIPSE_TYPES.OFF];
}

/**
 * Bailey's Beads Effect for Solar Eclipses
 *
 * Creates brilliant points of light around the moon's limb during partial phases
 * of a total solar eclipse, caused by sunlight streaming through lunar valleys.
 *
 * This effect appears:
 * - Just before totality (last few beads visible)
 * - Just after totality (first beads reappearing)
 * - Creates the famous "diamond ring" effect when only one bead remains
 */


class BaileysBeads {
    /**
     * Create Bailey's Beads effect
     * @param {THREE.Scene} scene - Three.js scene
     * @param {number} sunRadius - Radius of the sun
     */
    constructor(scene, sunRadius) {
        this.scene = scene;
        this.sunRadius = sunRadius;
        this.heroBeadCount = 3; // Rule of thirds: 3 hero beads
        this.supportBeadCount = 15; // Supporting beads clustered around heroes
        this.beadCount = this.heroBeadCount + this.supportBeadCount; // Total: 18 beads
        this.beads = [];
        this.visible = false;

        // Reusable temp vectors to avoid per-frame allocations (performance optimization)
        this._directionToCamera = new Vector3();
        this._up = new Vector3(0, 1, 0);
        this._right = new Vector3();
        this._upVector = new Vector3();
        this._beadOffset = new Vector3();
        this._tempColor = new Color(); // Temp color for reuse

        // Track shared texture for disposal
        this.sharedTexture = null;

        // Create bead sprite instances
        this.createBeads();
    }

    /**
     * Create individual bead sprites with chromatic aberration
     * @private
     */
    createBeads() {
        // Create a shared texture for all beads (bright point with glow)
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        // Draw a radial gradient for the bead glow
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
        gradient.addColorStop(0.1, 'rgba(255, 255, 255, 0.9)');
        gradient.addColorStop(0.3, 'rgba(255, 240, 200, 0.6)');
        gradient.addColorStop(0.6, 'rgba(255, 220, 150, 0.2)');
        gradient.addColorStop(1.0, 'rgba(255, 200, 100, 0.0)');

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);

        const texture = new CanvasTexture(canvas);
        texture.needsUpdate = true;

        // Store texture for disposal
        this.sharedTexture = texture;

        // Create beads at fixed angular positions around the limb
        // These simulate lunar valleys at specific locations
        const valleys = this.generateLunarValleys();

        for (let i = 0; i < this.beadCount; i++) {
            // Create RGB channel group for chromatic aberration effect
            const beadGroup = new Group();

            // Red channel sprite (slight offset outward)
            const redMaterial = new SpriteMaterial({
                map: texture.clone(),
                blending: AdditiveBlending,
                transparent: true,
                depthWrite: false,
                opacity: 0,
                color: this._tempColor.setRGB(1.0, 0.3, 0.3) // Red-tinted (reuse temp color)
            });
            const redSprite = new Sprite(redMaterial);
            redSprite.scale.set(0.08, 0.08, 1);
            beadGroup.add(redSprite);

            // Green channel sprite (center, brightest)
            const greenMaterial = new SpriteMaterial({
                map: texture.clone(),
                blending: AdditiveBlending,
                transparent: true,
                depthWrite: false,
                opacity: 0,
                color: this._tempColor.setRGB(0.8, 1.0, 0.8) // Slight green tint (reuse temp color)
            });
            const greenSprite = new Sprite(greenMaterial);
            greenSprite.scale.set(0.08, 0.08, 1);
            beadGroup.add(greenSprite);

            // Blue channel sprite (slight offset inward)
            const blueMaterial = new SpriteMaterial({
                map: texture,
                blending: AdditiveBlending,
                transparent: true,
                depthWrite: false,
                opacity: 0,
                color: this._tempColor.setRGB(0.3, 0.5, 1.0) // Blue-tinted (reuse temp color)
            });
            const blueSprite = new Sprite(blueMaterial);
            blueSprite.scale.set(0.08, 0.08, 1);
            beadGroup.add(blueSprite);

            // Store metadata for bead group
            beadGroup.userData = {
                angle: valleys[i].angle,
                depth: valleys[i].depth,
                baseIntensity: valleys[i].baseIntensity,
                isHero: valleys[i].isHero, // Rule of thirds: hero beads are larger/brighter
                sizeMultiplier: valleys[i].isHero ? 1.5 : 1.0, // Hero beads 50% larger
                targetOpacity: 0,
                currentOpacity: 0,
                redSprite,
                greenSprite,
                blueSprite
            };

            this.beads.push(beadGroup);
            this.scene.add(beadGroup);
        }
    }

    /**
     * Generate simulated lunar valley positions using rule of thirds
     * 3 hero beads at 120° intervals + supporting beads clustered around them
     * @private
     * @returns {Array} Array of valley data {angle, depth, baseIntensity, isHero}
     */
    generateLunarValleys() {
        const valleys = [];

        // Use a simple seeded random for consistency
        let seed = 12345;
        const seededRandom = () => {
            seed = (seed * 9301 + 49297) % 233280;
            return seed / 233280;
        };

        // RULE OF THIRDS: 3 hero beads positioned 120° apart
        const baseHeroAngle = seededRandom() * Math.PI * 2; // Random rotation
        for (let h = 0; h < this.heroBeadCount; h++) {
            const heroAngle = baseHeroAngle + (h * Math.PI * 2 / 3); // 120° spacing

            valleys.push({
                angle: heroAngle,
                depth: 0.8 + seededRandom() * 0.2, // Hero beads: deeper valleys (0.8-1.0)
                baseIntensity: 0.8 + seededRandom() * 0.2, // Hero beads: brighter (0.8-1.0)
                isHero: true
            });
        }

        // Supporting beads clustered around hero beads
        for (let i = 0; i < this.supportBeadCount; i++) {
            // Assign to nearest hero bead (thirds grouping)
            const heroTarget = Math.floor(i / (this.supportBeadCount / 3));
            const heroAngle = baseHeroAngle + (heroTarget * Math.PI * 2 / 3);

            // Cluster around hero with varied offset
            const clusterOffset = (seededRandom() - 0.5) * 1.2; // ±0.6 radians (~±34°)

            valleys.push({
                angle: heroAngle + clusterOffset,
                depth: 0.3 + seededRandom() * 0.5, // Supporting beads: shallower (0.3-0.8)
                baseIntensity: 0.4 + seededRandom() * 0.4, // Supporting beads: dimmer (0.4-0.8)
                isHero: false
            });
        }

        return valleys;
    }

    /**
     * Update bead positions and visibility based on eclipse coverage
     * @param {THREE.Camera} camera - Camera for billboard positioning
     * @param {THREE.Vector3} sunPosition - Current sun position in world space
     * @param {number} coverage - Eclipse coverage (0=no eclipse, 1=total)
     * @param {number} deltaTime - Time since last frame in milliseconds
     * @param {number} worldScale - Current world scale of the sun (for proper sizing)
     */
    update(camera, sunPosition, coverage, deltaTime, worldScale = 1.0) {
        // ALWAYS update bead positions to follow the sun, regardless of visibility
        // Only opacity should be controlled by visibility state

        // Update bead positions to circle around sun
        // Account for world scale to stay on the rim regardless of sun size/transforms
        const scaledRadius = this.sunRadius * worldScale * 1.0; // Exactly on the rim

        // Calculate camera-relative vectors for proper positioning (like shadow disk)
        // REUSE temp vectors to avoid allocations
        const cameraPosition = camera.position;
        this._directionToCamera.subVectors(cameraPosition, sunPosition).normalize();
        this._right.crossVectors(this._directionToCamera, this._up).normalize();
        this._upVector.crossVectors(this._right, this._directionToCamera).normalize();

        for (const bead of this.beads) {
            const {angle, redSprite, greenSprite, blueSprite, sizeMultiplier} = bead.userData;

            // Position beads on a circle in screen space (perpendicular to camera view)
            // Calculate position on rim using right and up vectors (billboard-style)
            const rimX = Math.cos(angle) * scaledRadius;
            const rimY = Math.sin(angle) * scaledRadius;

            // Build world position using camera-relative vectors - REUSE temp vector
            this._beadOffset.set(0, 0, 0); // Reset
            this._beadOffset.addScaledVector(this._right, rimX);
            this._beadOffset.addScaledVector(this._upVector, rimY);
            this._beadOffset.addScaledVector(this._directionToCamera, scaledRadius * 0.01); // Slightly in front

            const baseX = sunPosition.x + this._beadOffset.x;
            const baseY = sunPosition.y + this._beadOffset.y;
            const baseZ = sunPosition.z + this._beadOffset.z;

            // Chromatic aberration offset amount (radial from center in screen space)
            const chromaticOffset = worldScale * 0.008;

            // Position RGB channels with radial chromatic aberration in screen space
            // Red channel: offset outward (away from center)
            const redOffsetX = Math.cos(angle) * chromaticOffset;
            const redOffsetY = Math.sin(angle) * chromaticOffset;
            redSprite.position.set(redOffsetX, redOffsetY, 0.001);

            // Green channel: center (no offset)
            greenSprite.position.set(0, 0, 0);

            // Blue channel: offset inward (toward center)
            blueSprite.position.set(-redOffsetX, -redOffsetY, -1e-3);

            // Position the bead group at billboard location
            bead.position.set(baseX, baseY, baseZ);

            // Force matrix update to ensure position changes are applied immediately
            // Without this, sprites may lag behind during gesture animations
            bead.updateMatrixWorld(true);

            // Scale all sprites with sun to maintain consistent visual size
            // Hero beads are 50% larger (rule of thirds)
            const baseScale = worldScale * 0.15;
            const beadScale = baseScale * sizeMultiplier; // Apply hero multiplier
            redSprite.scale.set(beadScale, beadScale, 1);
            greenSprite.scale.set(beadScale, beadScale, 1);
            blueSprite.scale.set(beadScale, beadScale, 1);
        }

        // Now handle opacity based on visibility and coverage
        if (!this.visible) {
            // Fade out all beads
            for (const bead of this.beads) {
                bead.userData.targetOpacity = 0;
            }
        } else {
            // Bailey's Beads are visible in the range 0.90 to 1.0 coverage
            // They fade in as coverage approaches 0.95 and fade out at exactly 1.0
            const beadStart = 0.90; // Start showing beads
            const beadFull = 0.97;  // Full intensity
            const beadEnd = 1.00;   // Completely hidden at totality
            for (const bead of this.beads) {
                let targetOpacity = 0;

                if (coverage >= beadStart && coverage < beadEnd) {
                    // Calculate which beads are visible based on coverage
                    // As the moon moves across, different valleys are exposed

                    // Normalize coverage to 0-1 range within the bead visibility window
                    const normalizedCoverage = (coverage - beadStart) / (beadEnd - beadStart);

                    // Each bead becomes visible/invisible based on its angular position
                    // Simulate the moon's edge sweeping across the sun
                    const phaseAngle = normalizedCoverage * Math.PI * 2;
                    const angleToPhase = Math.abs(((bead.userData.angle - phaseAngle + Math.PI) % (Math.PI * 2)) - Math.PI);

                    // Beads near the current phase are visible
                    const angularProximity = Math.max(0, 1 - angleToPhase / 1.0);

                    // Intensity ramps up to full brightness near beadFull coverage
                    let intensityMultiplier = 1.0;
                    if (coverage < beadFull) {
                        intensityMultiplier = (coverage - beadStart) / (beadFull - beadStart);
                    }

                    targetOpacity = angularProximity * bead.userData.baseIntensity * intensityMultiplier * bead.userData.depth;

                    // Multiply by brightness multiplier to make beads much more visible
                    // Increased from 5.0 → 15.0 → 30.0 → 50.0 → 100.0 → 200.0 for maximum brilliance
                    targetOpacity *= 200.0;
                }

                bead.userData.targetOpacity = targetOpacity;
            }
        }

        // Smooth opacity transitions for all RGB channels
        // Use consistent fade speed for smooth animation
        const fadeSpeed = 3.0;
        for (const bead of this.beads) {
            const {redSprite, greenSprite, blueSprite} = bead.userData;
            const diff = bead.userData.targetOpacity - bead.userData.currentOpacity;
            bead.userData.currentOpacity += diff * fadeSpeed * (deltaTime / 1000); // Convert ms to seconds

            // Clamp to zero when very close (prevents floating point lingering)
            if (bead.userData.currentOpacity < 0.001) {
                bead.userData.currentOpacity = 0;
            }

            // Apply opacity to all RGB channels (green slightly brighter for white center)
            redSprite.material.opacity = bead.userData.currentOpacity * 0.7;
            greenSprite.material.opacity = bead.userData.currentOpacity * 1.0;
            blueSprite.material.opacity = bead.userData.currentOpacity * 0.7;
        }
    }

    /**
     * Set visibility of the beads effect
     * @param {boolean} visible - Whether beads should be visible
     */
    setVisible(visible) {
        this.visible = visible;
    }

    /**
     * Clean up resources
     */
    dispose() {
        for (const bead of this.beads) {
            const {redSprite, greenSprite, blueSprite} = bead.userData;

            // Dispose red sprite
            if (redSprite.material.map) {
                redSprite.material.map.dispose();
            }
            redSprite.material.dispose();

            // Dispose green sprite
            if (greenSprite.material.map) {
                greenSprite.material.map.dispose();
            }
            greenSprite.material.dispose();

            // Dispose blue sprite
            if (blueSprite.material.map) {
                blueSprite.material.map.dispose();
            }
            blueSprite.material.dispose();

            this.scene.remove(bead);
        }
        this.beads = [];

        // Dispose shared texture
        if (this.sharedTexture) {
            this.sharedTexture.dispose();
            this.sharedTexture = null;
        }

        // Clear temp objects
        this._directionToCamera = null;
        this._up = null;
        this._right = null;
        this._upVector = null;
        this._beadOffset = null;
        this._tempColor = null;

        // Clear scene reference
        this.scene = null;
    }
}

/**
 * Solar Eclipse Effect Manager
 *
 * Orchestrates solar eclipse shadow disk and corona effects.
 * Supports annular and total eclipses with billboarded rendering.
 *
 * SYNCHRONIZATION ARCHITECTURE:
 * - The eclipse effects are updated in ThreeRenderer.render() AFTER sun transforms
 *   are applied to ensure shadow/corona position matches the current frame's sun
 *   position, preventing visible lag during gesture animations.
 * - Shadow disk and corona are always added directly to the scene (not as children)
 *   and manually positioned each frame to maintain billboarding and proper scaling.
 */


class SolarEclipse {
    /**
     * Create a solar eclipse effect manager
     * @param {THREE.Scene} scene - Three.js scene
     * @param {number} sunRadius - Radius of the sun geometry
     * @param {THREE.Mesh} sunMesh - Sun mesh to parent shadow disk to
     */
    constructor(scene, sunRadius, sunMesh = null) {
        this.scene = scene;
        this.sunRadius = sunRadius;
        this.sunMesh = sunMesh;
        this.eclipseType = ECLIPSE_TYPES.OFF;
        this.previousEclipseType = ECLIPSE_TYPES.OFF; // Store previous type for exit animations
        this.enabled = false;
        this.time = 0;
        this.randomSeed = 12345; // Fixed initial seed - will be randomized on first total eclipse

        // Transition animation state
        this.isTransitioning = false;
        this.transitionProgress = 0;
        this.transitionDuration = 400; // 400ms for quick, snappy eclipse transition
        this.transitionDirection = 'in'; // 'in' or 'out'
        this.manualControl = false; // Flag to disable automatic animation when using sliders

        this.customShadowCoverage = undefined; // Override for shadow disk size from sliders
        // Reusable temp objects to avoid per-frame allocations (performance optimization)
        this._directionToCamera = new Vector3();
        this._up = new Vector3(0, 1, 0);
        this._right = new Vector3();
        this._upVector = new Vector3();
        this._tempOffset = new Vector3();
        this._tempColor = new Color(); // Temp color for reuse

        // Create shadow disk
        this.createShadowDisk();

        // Create corona disks (two counter-rotating for dynamic effect)
        this.createCoronaDisk();
        this.createCounterCoronaDisk();

        // Parent coronas to sun mesh for guaranteed transform sync (Fix 9)
        // Shadow disk stays in scene for proper billboarding
        if (this.sunMesh) {
            this.scene.remove(this.coronaDisk);
            this.scene.remove(this.counterCoronaDisk);
            this.sunMesh.add(this.coronaDisk);
            this.sunMesh.add(this.counterCoronaDisk);
        }

        // Create Bailey's Beads effect
        this.baileysBeads = new BaileysBeads(scene, sunRadius);
    }

    /**
     * Create the shadow disk geometry
     * @private
     */
    createShadowDisk() {
        // Start with a reasonable size - will be scaled in update()
        const initialShadowRadius = this.sunRadius;
        const shadowGeometry = new CircleGeometry(initialShadowRadius, 256);
        const shadowMaterial = new MeshBasicMaterial({
            color: 0x000000,
            transparent: true,  // Enable transparency for multiply blending
            opacity: 1.0,
            blending: MultiplyBlending,  // Black (0,0,0) * CoronaColor = Black (complete occlusion)
            premultipliedAlpha: true,  // Required for MultiplyBlending
            side: DoubleSide,
            depthWrite: false,   // Don't write to depth buffer (like coronas)
            depthTest: false,    // Don't test depth - always render on top
            fog: false
        });

        this.shadowDisk = new Mesh(shadowGeometry, shadowMaterial);
        this.shadowDisk.renderOrder = 10000;  // Render AFTER coronas to occlude them

        // Add to scene initially, will be re-parented to sun mesh if available
        this.shadowDisk.position.set(200, 0, 0); // Start off-screen
        this.scene.add(this.shadowDisk);
    }

    /**
     * Create the corona disk geometry with radial wave shader
     * @private
     */
    createCoronaDisk() {
        const coronaRadius = this.sunRadius * 2.05; // x sun diameter
        // RingGeometry with inner radius well inside sun, so corona overlaps bloomed edge
        const innerRadius = this.sunRadius * 0.60; // 40% inside sun's edge
        const coronaGeometry = new RingGeometry(innerRadius, coronaRadius, 256);

        // Shader material with radial wave pattern
        const coronaMaterial = new ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                glowColor: { value: new Color(0.9, 0.95, 1.0) }, // Cool white/blue-white
                intensity: { value: 2.4 },  // Increased for stronger bloom
                randomSeed: { value: this.randomSeed },
                uvRotation: { value: 0.0 },  // UV rotation angle in radians
                rayElongation: { value: 1.0 },  // Ray elongation factor (1.0 = circular, >1.0 = elongated)
                uberHeroElongation: { value: 1.0 },  // Uber hero ray elongation (much more dramatic)
                isTotalEclipse: { value: 0.0 },  // 1.0 = total eclipse effects enabled

                // Blend Layer Uniforms (up to 4 layers)
                // Default: Soft Light @ 2.155 to fix black edges
                layer1Mode: { value: 11.0 },  // Soft Light
                layer1Strength: { value: 2.155 },
                layer1Enabled: { value: 1.0 },

                // Default: Darken @ 0.695 for depth
                layer2Mode: { value: 5.0 },  // Overlay
                layer2Strength: { value: 0.695 },
                layer2Enabled: { value: 1.0 },

                layer3Mode: { value: 0.0 },
                layer3Strength: { value: 1.0 },
                layer3Enabled: { value: 0.0 },

                layer4Mode: { value: 0.0 },
                layer4Strength: { value: 1.0 },
                layer4Enabled: { value: 0.0 }
            },
            vertexShader: `
                uniform float uvRotation;
                varying vec2 vUv;

                void main() {
                    // Rotate UVs around center (0.5, 0.5)
                    vec2 centeredUV = uv - 0.5;
                    float cosRot = cos(uvRotation);
                    float sinRot = sin(uvRotation);
                    mat2 rotMatrix = mat2(cosRot, -sinRot, sinRot, cosRot);
                    vec2 rotatedUV = rotMatrix * centeredUV;
                    vUv = rotatedUV + 0.5;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec3 glowColor;
                uniform float intensity;
                uniform float randomSeed;
                uniform float rayElongation;
                uniform float uberHeroElongation;
                uniform float isTotalEclipse;

                // Blend Layer Uniforms (up to 4 layers)
                uniform float layer1Mode;
                uniform float layer1Strength;
                uniform float layer1Enabled;

                uniform float layer2Mode;
                uniform float layer2Strength;
                uniform float layer2Enabled;

                uniform float layer3Mode;
                uniform float layer3Strength;
                uniform float layer3Enabled;

                uniform float layer4Mode;
                uniform float layer4Strength;
                uniform float layer4Enabled;

                varying vec2 vUv;

                // ═══════════════════════════════════════════════════════════════════════════
                // UNIVERSAL BLEND MODES (injected from utils/blendModes.js)
                // ═══════════════════════════════════════════════════════════════════════════
                ${blendModesGLSL}

                // Hash function for pseudo-random variation
                float hash(float n) {
                    return fract(sin(n) * 43758.5453123);
                }

                // 2D hash for more variation
                float hash2(vec2 p) {
                    return fract(sin(dot(p, vec2(12.9898 + randomSeed, 78.233 + randomSeed))) * 43758.5453);
                }

                void main() {
                    // Calculate distance and angle from center
                    vec2 center = vec2(0.5, 0.5);
                    vec2 toCenter = vUv - center;
                    float dist = length(toCenter) * 2.0; // Normalize to 0-1 range
                    float angle = atan(toCenter.y, toCenter.x);  // UVs are already rotated in vertex shader

                    // Shadow edge - where corona rays start
                    // Ring inner edge is at (sunRadius*0.85)/coronaRadius = 0.765/1.845 = 0.415
                    // Start rays at sun's geometric edge (0.488) so they don't show inside sun
                    float shadowEdge = 0.488;

                    // Varied radial streamer pattern with artistic composition
                    float rayIntensity = 0.0;

                    // RULE OF THIRDS: Place 3 hero rays at compositionally strong points
                    // Golden angles based on rule of thirds: 1/3, 2/3, and offset positions
                    float heroAngles[3];
                    heroAngles[0] = hash(randomSeed * 1.234) * 6.28318; // First hero ray (random rotation)
                    heroAngles[1] = heroAngles[0] + 2.0944; // 120° apart (1/3 circle)
                    heroAngles[2] = heroAngles[0] + 4.1888; // 240° apart (2/3 circle)

                    // Process hero rays first (3 extra-long dramatic rays)
                    for (int h = 0; h < 3; h++) {
                        float rayAngle = heroAngles[h];
                        float angleDiff = abs(mod(angle - rayAngle + 3.14159, 6.28318) - 3.14159);

                        // Hero rays: extra long and prominent (fit within 0.535 normalized space)
                        float baseHeroLength = 0.45 + hash(float(h) * 31.415 + randomSeed) * 0.08; // 0.45 to 0.53 (max available, longer!)

                        // Apply UBER elongation: hero rays ALWAYS get extreme elongation (regardless of angle)
                        // This creates 3 dramatic streamers that extend far in their respective directions
                        float heroLength = baseHeroLength * uberHeroElongation;

                        // Uber hero rays: keep them narrow but visible for dramatic pointy effect
                        // Width scales with elongation to stay sharp but visible
                        float baseHeroWidth = 0.15 + hash(float(h) * 27.183 + randomSeed) * 0.15; // 0.15 to 0.3 base width
                        float narrowingFactor = mix(1.0, 0.3, (uberHeroElongation - 1.0) / max(uberHeroElongation, 1.0)); // 1.0 → 0.3 (70% narrower at max elongation)
                        float heroWidth = baseHeroWidth * narrowingFactor; // Narrow when elongated = pointy!

                        float distFromEdge = dist - shadowEdge;

                        // Ghostly ethereal taper - very gradual falloff
                        float taper = pow(1.0 - clamp(distFromEdge / max(heroLength, 0.001), 0.0, 1.0), 3.0);
                        float rayWidth = heroWidth * taper;

                        // Soft feathered edges instead of hard cutoff
                        float edgeSoftness = 0.15; // Wider feather for smooth edges
                        float angularMask = smoothstep(rayWidth + edgeSoftness, rayWidth - edgeSoftness, angleDiff);

                        // Very gentle radial falloff for ethereal look
                        float radialFalloff = pow(taper, 0.8);

                        // Soft radial range with feathered ends
                        float radialMask = smoothstep(-0.1, 0.05, distFromEdge) *
                                          smoothstep(heroLength + 0.15, heroLength - 0.05, distFromEdge);

                        float heroIntensity = angularMask * radialFalloff * radialMask * 0.7; // Reduced intensity for ghostly effect
                        rayIntensity = max(rayIntensity, heroIntensity);
                    }

                    // 20 supporting rays with rule-of-thirds-aware distribution
                    for (float i = 0.0; i < 20.0; i++) {
                        // Cluster more rays around hero ray positions (rule of thirds)
                        float clusterTarget = mod(i, 3.0); // Which hero ray to cluster near
                        float clusterAngle = heroAngles[int(clusterTarget)];

                        // Base distribution with clustering tendency
                        float spreadAngle = (i / 20.0) * 6.28318;
                        float clusterPull = (hash(i * 13.579 + randomSeed) - 0.5) * 1.5; // Stronger variation
                        float rayAngle = spreadAngle + clusterPull;

                        float angleDiff = abs(mod(angle - rayAngle + 3.14159, 6.28318) - 3.14159);

                        // Unique random values per ray
                        float random1 = hash(i * 12.9898 + randomSeed);
                        float random2 = hash(i * 78.233 + randomSeed);
                        float random3 = hash(i * 37.719 + randomSeed);
                        float random4 = hash(i * 93.989 + randomSeed);

                        // Varied lengths following power law distribution (more short, fewer long)
                        float lengthVariation = random1 * random1; // Squared for naturalistic distribution
                        float baseRayLength = 0.1 + lengthVariation * 0.7; // 0.1 to 0.8

                        // 20% chance of long streamers (supporting the hero rays)
                        float isLong = step(0.80, random2);
                        baseRayLength = mix(baseRayLength, 0.7 + random3 * 0.6, isLong); // 0.7 to 1.3

                        // Apply directional elongation: rays pointing up/down (vertical) get elongated
                        float verticalWeight = abs(sin(rayAngle));
                        float elongationFactor = mix(1.0, rayElongation, verticalWeight);
                        float rayLength = baseRayLength * elongationFactor;

                        // EQUATORIAL ASYMMETRY (total eclipse only): rays along equator are more prominent
                        // Solar minimum: streamers cluster along equatorial plane
                        float equatorialWeight = abs(cos(rayAngle)); // 1.0 at horizontal, 0.0 at vertical
                        float asymmetryBoost = mix(1.0, 1.0 + equatorialWeight * 0.5, isTotalEclipse);
                        rayLength *= asymmetryBoost;

                        // Varied widths with power law (more thin, fewer thick)
                        float baseWidth = 0.03 + (random4 * random4) * 0.2; // 0.03 to 0.23 (naturally varied)

                        // Taper: wide at base, narrow at tip
                        float distFromEdge = dist - shadowEdge;

                        // Ghostly ethereal taper - very gradual falloff
                        float taper = pow(1.0 - clamp(distFromEdge / max(rayLength, 0.001), 0.0, 1.0), 3.5);
                        float rayWidth = baseWidth * taper;

                        // Soft feathered edges for ethereal wisps
                        float edgeSoftness = 0.10; // Wider feather for smooth edges
                        float angularMask = smoothstep(rayWidth + edgeSoftness, rayWidth - edgeSoftness, angleDiff);

                        // Very gentle radial falloff for ghostly appearance
                        float radialFalloff = pow(taper, 1.0);

                        // Soft radial range with feathered ends
                        float radialMask = smoothstep(-0.08, 0.03, distFromEdge) *
                                          smoothstep(rayLength + 0.12, rayLength - 0.03, distFromEdge);

                        float streamerIntensity = angularMask * radialFalloff * radialMask * 0.5; // Reduced for ethereal wisps
                        rayIntensity = max(rayIntensity, streamerIntensity);
                    }

                    // Base corona glow - thinner during total eclipse for realism
                    float baseGlowWidth = mix(0.04, 0.015, isTotalEclipse); // Thinner during totality
                    float baseGlow = smoothstep(shadowEdge - 0.01, shadowEdge, dist) *
                                    (1.0 - smoothstep(shadowEdge + baseGlowWidth * 0.5, shadowEdge + baseGlowWidth, dist));

                    // Enhanced gradient: white → cool blue-white → deep blue with distance
                    // Distance normalized to corona extent (0 = shadow edge, 1 = far corona)
                    float coronaDist = clamp((dist - shadowEdge) / 0.6, 0.0, 1.0);

                    // ═══════════════════════════════════════════════════════════════════════════
                    // TOTAL ECLIPSE ENHANCEMENTS (scaled continuously by isTotalEclipse 0.0-1.0)
                    // ═══════════════════════════════════════════════════════════════════════════

                    // 1. CHROMOSPHERE RED RIM - thin pink/red ring at sun's edge (hydrogen emission)
                    float rimStart = shadowEdge;
                    float rimEnd = shadowEdge + 0.025;
                    float chromosphereRim = smoothstep(rimStart - 0.005, rimStart, dist) *
                                     (1.0 - smoothstep(rimEnd - 0.01, rimEnd, dist));
                    chromosphereRim *= 0.6 * isTotalEclipse; // Scale by eclipse progress
                    vec3 chromosphereColor = vec3(1.0, 0.3, 0.4); // Pink-red (H-alpha emission)

                    // 2. STRONGER BRIGHTNESS FALLOFF - inner corona much brighter
                    // Mix between 1.0 (normal) and enhanced falloff based on isTotalEclipse
                    float enhancedFalloff = mix(3.0, 0.3, pow(coronaDist, 0.7));
                    float brightnessMultiplier = mix(1.0, enhancedFalloff, isTotalEclipse);

                    // 3. F-CORONA OUTER GLOW - faint diffuse glow from interplanetary dust
                    float fCoronaDist = clamp((dist - shadowEdge) / 1.2, 0.0, 1.0);
                    float fCorona = (1.0 - fCoronaDist) * 0.08;
                    fCorona *= smoothstep(0.3, 0.5, coronaDist);
                    fCorona *= isTotalEclipse; // Scale by eclipse progress

                    // 4. WISPY TENDRILS - add fine detail noise to ray intensity
                    float noiseAngle = angle * 8.0 + time * 0.1;
                    float noiseRadius = dist * 15.0;
                    float wispyDetail = hash(noiseAngle + noiseRadius + randomSeed * 3.0) * 0.15;
                    wispyDetail *= rayIntensity * isTotalEclipse; // Scale by eclipse progress

                    // Combine: base glow + streamers + wispy detail
                    float finalIntensity = (baseGlow * 0.6 + rayIntensity + wispyDetail) * intensity;
                    finalIntensity *= brightnessMultiplier;

                    // Multi-stage color gradient for realistic corona
                    vec3 innerGlow = vec3(1.0, 1.0, 1.0);           // Pure white at base
                    vec3 middleGlow = vec3(0.9, 0.95, 1.0);         // Cool white
                    vec3 outerGlow = vec3(0.6, 0.75, 0.95);         // Pale blue
                    vec3 farGlow = vec3(0.3, 0.5, 0.8);             // Deep blue

                    // Three-stage color mix
                    vec3 coronaColor;
                    if (coronaDist < 0.3) {
                        // Inner: white → cool white
                        coronaColor = mix(innerGlow, middleGlow, coronaDist / 0.3);
                    } else if (coronaDist < 0.7) {
                        // Middle: cool white → pale blue
                        coronaColor = mix(middleGlow, outerGlow, (coronaDist - 0.3) / 0.4);
                    } else {
                        // Outer: pale blue → deep blue
                        coronaColor = mix(outerGlow, farGlow, (coronaDist - 0.7) / 0.3);
                    }

                    vec3 finalColor = coronaColor * finalIntensity;

                    // Add chromosphere red rim (total eclipse only)
                    finalColor += chromosphereColor * chromosphereRim * intensity;

                    // Add F-corona outer glow (total eclipse only)
                    finalColor += vec3(0.9, 0.85, 0.8) * fCorona * intensity; // Slightly warm white

                    // ═══════════════════════════════════════════════════════════════════════════
                    // BLEND LAYERS (Applied globally to entire corona)
                    // These allow adjusting the appearance of the corona to prevent black edges
                    // ═══════════════════════════════════════════════════════════════════════════

                    // Layer 1
                    if (layer1Enabled > 0.5) {
                        vec3 blendColor1 = vec3(min(layer1Strength, 1.0));
                        int mode1 = int(layer1Mode + 0.5);
                        vec3 blended1 = clamp(applyBlendMode(finalColor, blendColor1, mode1), 0.0, 1.0);
                        finalColor = clamp(blended1, 0.0, 1.0);
                    }

                    // Layer 2
                    if (layer2Enabled > 0.5) {
                        vec3 blendColor2 = vec3(min(layer2Strength, 1.0));
                        int mode2 = int(layer2Mode + 0.5);
                        vec3 blended2 = clamp(applyBlendMode(finalColor, blendColor2, mode2), 0.0, 1.0);
                        finalColor = clamp(blended2, 0.0, 1.0);
                    }

                    // Layer 3
                    if (layer3Enabled > 0.5) {
                        vec3 blendColor3 = vec3(min(layer3Strength, 1.0));
                        int mode3 = int(layer3Mode + 0.5);
                        vec3 blended3 = clamp(applyBlendMode(finalColor, blendColor3, mode3), 0.0, 1.0);
                        finalColor = clamp(blended3, 0.0, 1.0);
                    }

                    // Layer 4
                    if (layer4Enabled > 0.5) {
                        vec3 blendColor4 = vec3(min(layer4Strength, 1.0));
                        int mode4 = int(layer4Mode + 0.5);
                        vec3 blended4 = clamp(applyBlendMode(finalColor, blendColor4, mode4), 0.0, 1.0);
                        finalColor = clamp(blended4, 0.0, 1.0);
                    }

                    // Sharp alpha falloff to prevent black bleeding in bloom
                    // Higher power = sharper cutoff at edges (less semi-transparent area)
                    float alphaFalloff = pow(1.0 - coronaDist, 3.0);
                    float alpha = finalIntensity * alphaFalloff * 0.95;

                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            transparent: true,
            blending: AdditiveBlending,  // Additive blending to fill gap with sun bloom
            depthWrite: false,
            side: DoubleSide
        });

        this.coronaDisk = new Mesh(coronaGeometry, coronaMaterial);
        this.coronaDisk.position.set(0, 0, 0); // At sun center (will be parented to sun)
        this.coronaDisk.renderOrder = 9998;
        // Add to scene initially, will be re-parented to sun mesh when available
        this.scene.add(this.coronaDisk);
    }

    /**
     * Create counter-rotating corona disk (second layer for moiré effect)
     * @private
     */
    createCounterCoronaDisk() {
        // Reuse geometry from main corona (efficient - shared geometry)
        const coronaGeometry = this.coronaDisk.geometry;

        // Clone material with different random seed for variation
        const counterSeed = this.randomSeed + 5000; // Large offset for visibly different pattern
        const counterMaterial = new ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                glowColor: { value: new Color(0.9, 0.95, 1.0) },
                intensity: { value: 2.4 },  // Increased for stronger bloom
                randomSeed: { value: counterSeed },
                uvRotation: { value: 0.0 },  // UV rotation angle in radians
                rayElongation: { value: 1.0 },  // Ray elongation factor (1.0 = circular, >1.0 = elongated)
                uberHeroElongation: { value: 1.0 },  // Uber hero ray elongation (much more dramatic)
                isTotalEclipse: { value: 0.0 },  // 1.0 = total eclipse effects enabled

                // Blend Layer Uniforms (up to 4 layers) - shared with main corona
                // Default: Soft Light @ 2.155 to fix black edges
                layer1Mode: { value: 11.0 },  // Soft Light
                layer1Strength: { value: 2.155 },
                layer1Enabled: { value: 1.0 },

                // Default: Darken @ 0.695 for depth
                layer2Mode: { value: 5.0 },  // Overlay
                layer2Strength: { value: 0.695 },
                layer2Enabled: { value: 1.0 },

                layer3Mode: { value: 0.0 },
                layer3Strength: { value: 1.0 },
                layer3Enabled: { value: 0.0 },

                layer4Mode: { value: 0.0 },
                layer4Strength: { value: 1.0 },
                layer4Enabled: { value: 0.0 }
            },
            vertexShader: this.coronaDisk.material.vertexShader,
            fragmentShader: this.coronaDisk.material.fragmentShader,
            transparent: true,
            blending: AdditiveBlending,  // Additive blending to fill gap with sun bloom
            depthWrite: false,
            side: DoubleSide
        });

        this.counterCoronaDisk = new Mesh(coronaGeometry, counterMaterial);
        this.counterCoronaDisk.position.set(0, 0, 0); // At sun center
        this.counterCoronaDisk.renderOrder = 9997;
        this.scene.add(this.counterCoronaDisk);
    }
    /**
     * Set shadow coverage (billboard disk size)
     * @param {number} coverage - Shadow coverage multiplier (0-1+)
     */
    setShadowCoverage(coverage) {
        this.customShadowCoverage = coverage;
    }

    /**
     * Set corona blend layer parameters
     * @param {number} layerNum - Layer number (1-4)
     * @param {Object} params - Layer parameters { mode, strength, enabled }
     */
    setCoronaBlendLayer(layerNum, params) {
        if (layerNum < 1 || layerNum > 4) {
            console.error(`❌ Invalid corona layer number: ${layerNum} (must be 1-4)`);
            return;
        }

        const { mode = 0, strength = 1.0, enabled = false } = params;

        // Update both corona disks with the same blend layer settings
        if (this.coronaDisk?.material?.uniforms) {
            this.coronaDisk.material.uniforms[`layer${layerNum}Mode`].value = mode;
            this.coronaDisk.material.uniforms[`layer${layerNum}Strength`].value = strength;
            this.coronaDisk.material.uniforms[`layer${layerNum}Enabled`].value = enabled ? 1.0 : 0.0;
        }

        if (this.counterCoronaDisk?.material?.uniforms) {
            this.counterCoronaDisk.material.uniforms[`layer${layerNum}Mode`].value = mode;
            this.counterCoronaDisk.material.uniforms[`layer${layerNum}Strength`].value = strength;
            this.counterCoronaDisk.material.uniforms[`layer${layerNum}Enabled`].value = enabled ? 1.0 : 0.0;
        }
    }


    /**
     * Set eclipse type (annular, total, or off)
     * Triggers transition animation when type changes
     * @param {string} eclipseType - Eclipse type from ECLIPSE_TYPES
     */
    setEclipseType(eclipseType) {
        // Only trigger transition if type actually changed
        if (eclipseType === this.eclipseType) {
            return;
        }

        const wasEnabled = this.enabled;
        this.previousEclipseType = this.eclipseType; // Store previous type before changing
        this.eclipseType = eclipseType;
        this.enabled = (eclipseType !== ECLIPSE_TYPES.OFF);
        this.manualControl = false; // Reset manual control when eclipse type changes

        // Get shadow coverage values for interpolation
        const prevConfig = getEclipseConfig(this.previousEclipseType);
        const newConfig = getEclipseConfig(eclipseType);
        this.startShadowCoverage = prevConfig.shadowCoverage;
        this.targetShadowCoverage = newConfig.shadowCoverage;

        // Determine transition direction
        if (!wasEnabled && this.enabled) {
            // Entering eclipse: slide in from right
            this.transitionDirection = 'in';
            this.isTransitioning = true;
            this.transitionProgress = 0;
        } else if (wasEnabled && !this.enabled) {
            // Exiting eclipse: slide out to left
            this.transitionDirection = 'out';
            this.isTransitioning = true;
            this.transitionProgress = 0;
        } else if (wasEnabled && this.enabled) {
            // Switching between annular/total: animate shadow size change
            this.isTransitioning = true;
            this.transitionProgress = 0;
            this.transitionDirection = 'switch';
        }

        // Corona pattern uses fixed seed for consistency - no randomization on eclipse type change
    }

    /**
     * Cubic ease in-out function for smooth transitions
     * @param {number} t - Progress value (0-1)
     * @returns {number} Eased value (0-1)
     * @private
     */
    easeInOutCubic(t) {
        return t < 0.5
            ? 4 * t * t * t
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    /**
     * Manually set transition progress (for manual control via sliders)
     * @param {number} progress - Progress value (0-1, where 0 is start, 1 is totality)
     */
    setManualProgress(progress) {
        this.manualControl = true; // Enable manual control mode
        this.transitionProgress = Math.max(0, Math.min(1, progress));
        this.isTransitioning = true; // Keep transitioning active for effects
        this.transitionDirection = 'in'; // Always use 'in' direction for manual control
    }

    /**
     * Manually set shadow position (for full eclipse cycle control)
     * @param {number} shadowPosition - Shadow X position (-2.0 = left, 0.0 = center/totality, +2.0 = right)
     */
    setManualShadowPosition(shadowPosition) {
        this.manualControl = true; // Enable manual control mode
        this.manualShadowPosition = Math.max(-2, Math.min(2.0, shadowPosition)); // Clamp to valid range
        this.isTransitioning = true; // Keep effects active
        this.transitionDirection = 'manual'; // Special mode for direct position control
    }

    /**
     * Update eclipse effects (call every frame)
     *
     * IMPORTANT: This method must be called AFTER the sun mesh's position, rotation,
     * and scale have been updated for the current frame to ensure synchronized movement.
     * Called from ThreeRenderer.render() after transforms are applied.
     *
     * @param {THREE.Camera} camera - Camera for position calculations
     * @param {THREE.Mesh} sunMesh - Sun mesh for position/scale (already updated for current frame)
     * @param {number} deltaTime - Time since last frame (milliseconds)
     * @param {number|null} morphProgress - Morph animation progress (null = no morph, 0-1 = morphing)
     */
    update(camera, sunMesh, deltaTime, morphProgress = null) {
        const cameraPosition = camera.position;
        const sunPosition = sunMesh.position;
        const sunScale = sunMesh.scale;
        const worldScale = sunScale.x; // World scale for consistent sizing

        // Calculate corona fade multiplier for morph transitions
        // Entry (Anything->Sun): rays fade in with inverse cubic (slow start, fast finish - bloom effect)
        // Exit (Sun->Anything): rays fade out with cubic (fast start, slow finish - rays lead)
        let coronaMorphFade = 1.0;
        if (morphProgress !== null && morphProgress > 0.5) {
            // Grow phase (entry): progress 0.5->1.0
            // Inverse of exit: slow start, accelerating finish (rays bloom from sun)
            const t = (morphProgress - 0.5) * 2; // 0 to 1 as grow progresses
            coronaMorphFade = t * t * t; // Cubic: starts slow at 0, accelerates to 1
        } else if (morphProgress !== null && morphProgress <= 0.5) {
            // Shrink phase (exit): morphProgress goes 0->0.5
            // At start (morphProgress=0): rays should be full (1.0)
            // At end (morphProgress=0.5): rays should be gone (0.0)
            // Rays fade FAST (cubic) - they lead ahead of sun's shrink
            const t = morphProgress * 2; // 0 to 1 as shrink progresses
            coronaMorphFade = (1.0 - t) * (1.0 - t) * (1.0 - t); // Cubic: starts at 1, drops fast to 0
        }

        // Update time for corona animation
        // Accelerate time 3x for normal sun (more visible undulation), normal speed for eclipses
        const timeMultiplier = (this.eclipseType === ECLIPSE_TYPES.OFF) ? 3.0 : 1.0;
        this.time += deltaTime * timeMultiplier;

        // Update transition animation (skip if in manual control mode)
        if (this.isTransitioning && !this.manualControl) {
            const progressDelta = deltaTime / this.transitionDuration;
            this.transitionProgress += progressDelta;

            if (this.transitionProgress >= 1.0) {
                this.transitionProgress = 1.0;
                this.isTransitioning = false;
            }
        }

        // Update shadow disk if eclipse is active or transitioning out
        if (this.enabled || (this.transitionDirection === 'out' && this.isTransitioning)) {
            // Use previous eclipse type during exit animation (since eclipseType is now OFF)
            const activeEclipseType = (this.transitionDirection === 'out' && this.isTransitioning)
                ? this.previousEclipseType
                : this.eclipseType;
            const config = getEclipseConfig(activeEclipseType);
            const scaledSunRadius = this.sunRadius * worldScale;

            // Use eased progress for smooth transitions
            const easedProgress = this.easeInOutCubic(this.transitionProgress);

            // Calculate shadow size - only interpolate during 'switch' transitions (annular ↔ total)
            // For 'in' and 'out' transitions, shadow maintains its size (like real moon)
            let shadowCoverage;
            if (this.customShadowCoverage !== undefined) {
                // Manual slider override
                shadowCoverage = this.customShadowCoverage;
            } else if (this.transitionDirection === 'switch' && this.isTransitioning &&
                       this.startShadowCoverage !== undefined && this.targetShadowCoverage !== undefined) {
                // Only interpolate size when switching between annular/total
                shadowCoverage = this.startShadowCoverage + (this.targetShadowCoverage - this.startShadowCoverage) * easedProgress;
            } else {
                // Use target config coverage (constant size during in/out transitions)
                shadowCoverage = config.shadowCoverage;
            }
            const shadowRadius = scaledSunRadius * shadowCoverage;
            const baseShadowScale = shadowRadius / this.sunRadius;

            // Scale shadow disk
            this.shadowDisk.scale.setScalar(baseShadowScale);

            // Calculate shadow position
            // shadowPosX range: -2.0 to +2.0
            this.currentShadowPosX = -2; // Start off-screen

            if (this.transitionDirection === 'manual' && this.manualShadowPosition !== undefined) {
                // MANUAL CONTROL MODE: Use direct shadow position from dial
                this.currentShadowPosX = this.manualShadowPosition;
            } else if (this.isTransitioning) {
                if (this.transitionDirection === 'in') {
                    // Arc in from -2.0 to 0.0
                    this.currentShadowPosX = -2 + (easedProgress * 2.0); // -2.0 → 0.0
                } else if (this.transitionDirection === 'out') {
                    // Arc out from 0.0 to 1.0
                    this.currentShadowPosX = 0.0 + (easedProgress * 1.0); // 0.0 → 1.0
                } else if (this.transitionDirection === 'switch') {
                    // Shadow stays centered during annular<->total switch, only size changes
                    this.currentShadowPosX = 0.0;
                }
            } else {
                // At rest: centered
                this.currentShadowPosX = 0.0;
            }

            const shadowPosX = this.currentShadowPosX;

            // Calculate parabolic arc motion (like real eclipse)
            // Horizontal: linear movement from -2.0 to +2.0
            // Vertical: downward parabola y = -x²
            const arcRadius = scaledSunRadius * 2.5; // Arc depth
            const arcT = shadowPosX; // Use shadowPosX directly as arc parameter (-2.0 to +2.0)

            const horizontalOffset = arcT * arcRadius * 0.5; // Horizontal position
            const verticalOffset = -(arcT * arcT) * arcRadius * 0.25; // Downward parabola: y = -x²

            // Position shadow disk between camera and sun - REUSE temp vector
            this._directionToCamera.subVectors(cameraPosition, sunPosition).normalize();

            // Get perpendicular vectors for positioning - REUSE temp vectors
            this._right.crossVectors(this._directionToCamera, this._up).normalize();
            this._upVector.crossVectors(this._right, this._directionToCamera).normalize();

            // Position shadow at sun's surface (no offset) to maintain consistent relative size
            // The small Z-offset was causing perspective-based size changes when zooming
            const shadowOffset = 0;
            // Build position using temp vector to avoid allocations
            this._tempOffset.copy(this._directionToCamera).multiplyScalar(shadowOffset);
            this.shadowDisk.position.copy(sunPosition).add(this._tempOffset);

            // Add horizontal offset
            this._tempOffset.copy(this._right).multiplyScalar(horizontalOffset);
            this.shadowDisk.position.add(this._tempOffset);

            // Add vertical offset (parabolic arc)
            this._tempOffset.copy(this._upVector).multiplyScalar(verticalOffset);
            this.shadowDisk.position.add(this._tempOffset);

            // Make shadow face camera (billboard effect)
            this.shadowDisk.lookAt(cameraPosition);


            // Update corona disks - ALWAYS VISIBLE (intensity varies by eclipse state)
            // Coronas are parented to sun mesh, so position/scale is inherited
            // Only set position if NOT parented (fallback for older code paths)
            if (!this.coronaDisk.parent || this.coronaDisk.parent === this.scene) {
                this.coronaDisk.position.copy(sunPosition);
                this.counterCoronaDisk.position.copy(sunPosition);
                this.coronaDisk.scale.setScalar(worldScale);
                this.counterCoronaDisk.scale.setScalar(worldScale);
            }
            // If parented, position is (0,0,0) and scale is (1,1,1) relative to parent

            // Calculate proximity to totality for dynamic rotation speed and intensity
            // proximity = 0 at edges (shadow far away), 1 at totality (shadow centered)
            const distanceFromCenter = Math.abs(this.currentShadowPosX || 0);
            const maxDistance = 2.0;
            const proximity = Math.max(0, 1 - (distanceFromCenter / maxDistance));

            // Calculate total eclipse blend factor
            // During 'switch' transition, animate between 0 (annular) and 1 (total)
            let totalEclipseBlend = 0.0;
            if (this.transitionDirection === 'switch' && this.isTransitioning) {
                // Switching between annular/total: animate the blend
                const wasTotal = (this.previousEclipseType === ECLIPSE_TYPES.TOTAL);
                const isTotal = (this.eclipseType === ECLIPSE_TYPES.TOTAL);
                if (isTotal && !wasTotal) {
                    // Annular → Total: blend from 0 to 1
                    totalEclipseBlend = easedProgress;
                } else if (!isTotal && wasTotal) {
                    // Total → Annular: blend from 1 to 0
                    totalEclipseBlend = 1.0 - easedProgress;
                }
            } else if (activeEclipseType === ECLIPSE_TYPES.TOTAL) {
                // Normal total eclipse: use proximity-based effects
                totalEclipseBlend = 1.0;
            }

            // For total eclipse: elongate rays via shader (not geometry scaling)
            // Pass elongation factor to shader (1.0 = circular, 25.0 = 2400% longer rays at poles)
            // Use quartic easing (^4) to keep rays normal length until very close to totality
            const baseRayElongation = 1.0 + (24.0 * Math.pow(proximity, 4)); // 1.0 → 25.0
            const rayElongation = 1.0 + (baseRayElongation - 1.0) * totalEclipseBlend;

            // Uber hero rays: 3 dramatic streamers that extend MUCH further at totality
            const baseUberHeroElongation = 1.0 + (199.0 * Math.pow(proximity, 5)); // 1.0 → 200.0
            const uberHeroElongation = 1.0 + (baseUberHeroElongation - 1.0) * totalEclipseBlend;

            this.coronaDisk.material.uniforms.rayElongation.value = rayElongation;
            this.counterCoronaDisk.material.uniforms.rayElongation.value = rayElongation;
            this.coronaDisk.material.uniforms.uberHeroElongation.value = uberHeroElongation;
            this.counterCoronaDisk.material.uniforms.uberHeroElongation.value = uberHeroElongation;

            // Ease shader effects (chromosphere, asymmetry, F-corona) as we approach totality
            // Ramp from 0 to 1.0 between 0.50 and 0.99 proximity with easeInOut curve
            const effectsMin = 0.50;  // Start easing shader effects at 50% proximity
            const effectsMax = 0.99;  // Full shader effects at 99% proximity
            const effectsLinear = Math.max(0, Math.min(1, (proximity - effectsMin) / (effectsMax - effectsMin)));
            // Smoothstep easeInOut: 3t² - 2t³
            const effectsProgress = effectsLinear * effectsLinear * (3 - 2 * effectsLinear);
            // Apply total eclipse blend to shader effects
            const isTotalEclipse = effectsProgress * totalEclipseBlend;
            this.coronaDisk.material.uniforms.isTotalEclipse.value = isTotalEclipse;
            this.counterCoronaDisk.material.uniforms.isTotalEclipse.value = isTotalEclipse;

            // Layer 3: Linear Burn eases in with the other effects
            // Linear Burn: strength 1.0 = no effect, strength 0.0 = max darkening
            // So we ramp from 1.0 (no effect) DOWN to 0.053 (full effect) at totality
            const linearBurnEnabled = (totalEclipseBlend > 0 && proximity >= effectsMin);
            const linearBurnStrength = 1.0 - (1.0 - 0.053) * effectsProgress * totalEclipseBlend; // 1.0 → 0.053
            this.setCoronaBlendLayer(3, { mode: 1, strength: linearBurnStrength, enabled: linearBurnEnabled });

            // Billboard both coronas to camera (must happen BEFORE rotation)
            this.coronaDisk.lookAt(cameraPosition);
            this.counterCoronaDisk.lookAt(cameraPosition);

            // Rotation: dynamic speed based on eclipse state and proximity to totality
            // Use vertex shader UV rotation (mesh stays billboarded to camera)
            let rotationSpeed = 0;
            if (activeEclipseType === ECLIPSE_TYPES.OFF) {
                // NORMAL SUN: Full rotation speed
                rotationSpeed = (deltaTime / 1000) * 0.075; // radians per second (~84 seconds per rotation)
            } else if (activeEclipseType === ECLIPSE_TYPES.ANNULAR) {
                // ANNULAR ECLIPSE: Slow down rotation at totality (75% reduction)
                const baseSpeed = 0.075;
                const minSpeed = baseSpeed * 0.25; // 25% of normal = 75% reduction
                rotationSpeed = (deltaTime / 1000) * (baseSpeed - (baseSpeed - minSpeed) * proximity);
            } else if (activeEclipseType === ECLIPSE_TYPES.TOTAL) {
                // TOTAL ECLIPSE: Nearly freeze rotation at totality (95% reduction)
                const baseSpeed = 0.075;
                const minSpeed = baseSpeed * 0.05; // 5% of normal = 95% reduction
                rotationSpeed = (deltaTime / 1000) * (baseSpeed - (baseSpeed - minSpeed) * proximity);
            }

            // Apply rotation to both coronas
            this.coronaDisk.material.uniforms.uvRotation.value += rotationSpeed; // Clockwise
            this.counterCoronaDisk.material.uniforms.uvRotation.value -= rotationSpeed; // Counter-clockwise

            // Determine corona intensity based on eclipse state and proximity to totality
            let coronaIntensity = 1.2;

            if (activeEclipseType === ECLIPSE_TYPES.OFF) {
                // NORMAL SUN: Bright corona (solar atmosphere always visible)
                coronaIntensity = 3.6;  // Increased for stronger bloom
            } else if (activeEclipseType === ECLIPSE_TYPES.ANNULAR) {
                // ANNULAR ECLIPSE: Dim corona based on proximity to shadow
                const maxIntensity = 3.6; // Normal sun brightness
                const minIntensity = maxIntensity * 0.08; // 8% at totality
                if (this.transitionDirection === 'manual') {
                    coronaIntensity = maxIntensity - (maxIntensity - minIntensity) * proximity;
                } else {
                    // Use proximity for automatic dimming (shadow position determines intensity)
                    coronaIntensity = maxIntensity - (maxIntensity - minIntensity) * proximity;
                }
            } else if (activeEclipseType === ECLIPSE_TYPES.TOTAL) {
                // TOTAL ECLIPSE: Dim corona based on proximity to shadow
                const maxIntensity = 3.6; // Normal sun brightness
                const minIntensity = maxIntensity * 0.65; // 65% at totality
                if (this.transitionDirection === 'manual') {
                    coronaIntensity = maxIntensity - (maxIntensity - minIntensity) * proximity;
                } else {
                    // Use proximity for automatic dimming (shadow position determines intensity)
                    coronaIntensity = maxIntensity - (maxIntensity - minIntensity) * proximity;
                }
            }

            // Apply intensity to both coronas (with morph fade multiplier)
            this.coronaDisk.material.uniforms.intensity.value = coronaIntensity * coronaMorphFade;
            this.counterCoronaDisk.material.uniforms.intensity.value = coronaIntensity * coronaMorphFade;

            // Update shader time uniform for both
            this.coronaDisk.material.uniforms.time.value = this.time;
            this.counterCoronaDisk.material.uniforms.time.value = this.time;
        } else {
            // Eclipse disabled: hide shadow disk, but keep coronas visible for normal sun
            this.shadowDisk.position.set(200, 0, 0);

            // Position both coronas at sun center for normal sun mode
            // Only set position/scale if NOT parented (fallback for older code paths)
            if (!this.coronaDisk.parent || this.coronaDisk.parent === this.scene) {
                this.coronaDisk.position.copy(sunPosition);
                this.counterCoronaDisk.position.copy(sunPosition);
                this.coronaDisk.scale.setScalar(worldScale);
                this.counterCoronaDisk.scale.setScalar(worldScale);
            }
            // If parented, position is (0,0,0) and scale is (1,1,1) relative to parent

            // Reset elongation to normal (no uber rays when eclipse is off)
            this.coronaDisk.material.uniforms.rayElongation.value = 1.0;
            this.counterCoronaDisk.material.uniforms.rayElongation.value = 1.0;
            this.coronaDisk.material.uniforms.uberHeroElongation.value = 1.0;
            this.counterCoronaDisk.material.uniforms.uberHeroElongation.value = 1.0;

            // Disable total eclipse enhancements when not in eclipse
            this.coronaDisk.material.uniforms.isTotalEclipse.value = 0.0;
            this.counterCoronaDisk.material.uniforms.isTotalEclipse.value = 0.0;

            // Reduce corona intensity for normal sun (85% of base, with morph fade)
            this.coronaDisk.material.uniforms.intensity.value = 3.6 * 0.85 * coronaMorphFade;
            this.counterCoronaDisk.material.uniforms.intensity.value = 3.6 * 0.85 * coronaMorphFade;

            // Disable Linear Burn when not in eclipse
            this.setCoronaBlendLayer(3, { mode: 1, strength: 0.0, enabled: false });

            // Billboard both coronas to camera (must happen BEFORE rotation)
            this.coronaDisk.lookAt(cameraPosition);
            this.counterCoronaDisk.lookAt(cameraPosition);

            // Rotate coronas in opposite directions (living sun effect)
            // Use vertex shader UV rotation (mesh stays billboarded to camera)
            const rotationSpeed = (deltaTime / 1000) * 0.075; // radians per second (~84 seconds per rotation)
            this.coronaDisk.material.uniforms.uvRotation.value += rotationSpeed; // Clockwise
            this.counterCoronaDisk.material.uniforms.uvRotation.value -= rotationSpeed; // Counter-clockwise

            // Bright corona for normal sun (no eclipse, with morph fade)
            this.coronaDisk.material.uniforms.intensity.value = 3.6 * coronaMorphFade;
            this.counterCoronaDisk.material.uniforms.intensity.value = 3.6 * coronaMorphFade;

            // Update shader time uniform for both
            this.coronaDisk.material.uniforms.time.value = this.time;
            this.counterCoronaDisk.material.uniforms.time.value = this.time;
        }

        // Update Bailey's Beads effect
        // Beads are ONLY visible when shadow is near the sun's rim (final 20% of transition)
        if (this.eclipseType === ECLIPSE_TYPES.TOTAL) {
            // Calculate coverage based on transition progress or shadow position
            let coverage = 0;
            let beadsVisible = false;

            if (this.transitionDirection === 'manual') {
                // MANUAL MODE: Calculate coverage from shadow position
                // Shadow at -2.0 or +2.0 = 0% coverage (no eclipse)
                // Shadow at 0.0 = 100% coverage (totality)
                const distanceFromCenter = Math.abs(this.currentShadowPosX);
                const maxDistance = 2.0;
                coverage = Math.max(0, Math.min(1, 1 - (distanceFromCenter / maxDistance)));

                // Beads visible when coverage is between 90% and 100% (INCLUDING totality)
                if (coverage >= 0.90 && coverage <= 1.0) {
                    beadsVisible = true;
                }
            } else if (this.transitionDirection === 'in' && this.isTransitioning) {
                // Beads only appear in final 20% of transition (when shadow is nearly covering sun)
                const beadsStartProgress = 0.8; // Start showing beads at 80% of transition
                if (this.transitionProgress >= beadsStartProgress) {
                    beadsVisible = true;
                    // Map 0.8-1.0 transition progress to 0.9-1.0 coverage
                    const normalizedProgress = (this.transitionProgress - beadsStartProgress) / (1.0 - beadsStartProgress);
                    coverage = 0.9 + (normalizedProgress * 0.1);
                }
            } else if (this.transitionDirection === 'out' && this.isTransitioning) {
                // Beads appear in first 20% of exit transition (when shadow is leaving sun's rim)
                const beadsEndProgress = 0.2; // Stop showing beads at 20% of exit transition
                if (this.transitionProgress <= beadsEndProgress) {
                    beadsVisible = true;
                    // Map 0.0-0.2 transition progress to 1.0-0.9 coverage
                    const normalizedProgress = this.transitionProgress / beadsEndProgress;
                    coverage = 1.0 - (normalizedProgress * 0.1);
                }
            } else if (!this.isTransitioning) {
                // At totality: coverage = 1.0, beads VISIBLE (most dramatic moment)
                coverage = 1.0;
                beadsVisible = true;
            }

            this.baileysBeads.setVisible(beadsVisible);
            this.baileysBeads.update(camera, sunPosition, coverage, deltaTime, worldScale);
        } else {
            this.baileysBeads.setVisible(false);
            this.baileysBeads.update(camera, sunPosition, 0, deltaTime, worldScale);
        }
    }

    /**
     * Dispose of all eclipse resources
     */
    dispose() {
        // Dispose shadow disk (always in scene, not parented)
        if (this.shadowDisk) {
            this.scene.remove(this.shadowDisk);
            this.shadowDisk.geometry.dispose();
            this.shadowDisk.material.dispose();
            this.shadowDisk = null;
        }

        // Dispose corona disks
        // Corona disks may be children of sunMesh OR in scene directly
        if (this.coronaDisk) {
            // Remove from parent (sunMesh or scene)
            if (this.coronaDisk.parent) {
                this.coronaDisk.parent.remove(this.coronaDisk);
            }
            this.coronaDisk.geometry.dispose();
            // Dispose shader material uniforms - no need to null, just dispose material
            this.coronaDisk.material.dispose();
            this.coronaDisk = null;
        }

        if (this.counterCoronaDisk) {
            // Remove from parent (sunMesh or scene)
            if (this.counterCoronaDisk.parent) {
                this.counterCoronaDisk.parent.remove(this.counterCoronaDisk);
            }
            // Geometry is shared with main corona, already disposed above
            this.counterCoronaDisk.material.dispose();
            this.counterCoronaDisk = null;
        }

        // Dispose Bailey's Beads
        if (this.baileysBeads) {
            this.baileysBeads.dispose();
            this.baileysBeads = null;
        }

        // Clear temp objects
        this._directionToCamera = null;
        this._up = null;
        this._right = null;
        this._upVector = null;
        this._tempOffset = null;
        this._tempColor = null;

        // Clear references
        this.scene = null;
        this.sunMesh = null;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Lunar Eclipse Effect
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Lunar eclipse "Blood Moon" effect for moon geometry
 * @author Emotive Engine Team
 * @module 3d/effects/LunarEclipse
 *
 * Simulates Earth's shadow passing over the moon with realistic color shift:
 * - Penumbral: Subtle darkening (Earth's partial shadow)
 * - Partial: Edge of Earth's umbra covers part of moon
 * - Total: Full umbral coverage with reddish "blood moon" glow (Rayleigh scattering)
 *
 * Based on real lunar eclipse physics:
 * - Earth's atmosphere scatters blue light, red light refracts through
 * - Creates deep orange-red glow on fully eclipsed moon
 * - Shadow moves across surface from one side to the other
 */

/**
 * LunarEclipse Effect Manager
 * Animates Earth's shadow across the moon with color shift
 */
class LunarEclipse {
    constructor(moonMaterial) {
        this.material = moonMaterial;
        this.eclipseType = 'off'; // 'off', 'penumbral', 'partial', 'total'

        // Animation state
        this.progress = 0.0; // 0 = no eclipse, 1 = maximum eclipse
        this.targetProgress = 0.0;
        this.animating = false;

        // Blood Moon colors (based on real lunar eclipse photography)
        this.bloodMoonColor = {
            r: 0.85,  // Very high red for deep blood moon
            g: 0.18,  // Low green for reddish-orange
            b: 0.08   // Very minimal blue for saturation
        };

        // Eclipse timing (smooth, slow animation like real eclipse)
        this.animationDuration = 3000; // 3 seconds for full transition
        this.startTime = 0;

        // Shadow animation state
        this.shadowX = -2; // Start off-screen left
        this.shadowY = 0.0;  // Centered vertically
        this.shadowRadius = 0.70; // Shadow size (Earth's umbra)
        this.targetShadowX = -2;
        this.shadowSpeed = 1.0; // Shadow movement speed multiplier

        // Initialize shader uniforms if not present
        if (!this.material.uniforms.eclipseProgress) {
            this.material.uniforms.eclipseProgress = { value: 0.0 };
            this.material.uniforms.eclipseIntensity = { value: 0.0 };
            this.material.uniforms.bloodMoonColor = {
                value: [this.bloodMoonColor.r, this.bloodMoonColor.g, this.bloodMoonColor.b]
            };
            this.material.uniforms.eclipseShadowPos = { value: [this.shadowX, this.shadowY] };
            this.material.uniforms.eclipseShadowRadius = { value: this.shadowRadius };
        }
    }

    /**
     * Set eclipse type and trigger animation
     * @param {string} type - 'off', 'penumbral', 'partial', 'total'
     */
    setEclipseType(type) {
        if (this.eclipseType === type) return;

        const wasOff = this.eclipseType === 'off';
        this.eclipseType = type;

        // If starting a new eclipse (was off), reset shadow to west first
        // Shadow ALWAYS enters from the west (negative X)
        if (wasOff && type !== 'off') {
            this.shadowX = -2; // Reset to west
            this.material.uniforms.eclipseShadowPos.value = [this.shadowX, this.shadowY];
        }

        // Set target progress and shadow position based on type
        switch (type) {
        case 'off':
            this.targetProgress = 0.0;
            this.targetShadowX = 2.0; // Move shadow off-screen right (continue east, realistic exit)
            break;
        case 'penumbral':
            this.targetProgress = 0.3; // 30% coverage (subtle darkening)
            this.targetShadowX = -1; // Shadow edge just touching moon
            break;
        case 'partial':
            this.targetProgress = 0.65; // 65% coverage (edge of umbra)
            this.targetShadowX = -0.6; // Shadow partially covering moon (between edge and center)
            break;
        case 'total':
            this.targetProgress = 1.0; // 100% coverage (full blood moon)
            this.targetShadowX = 0.0;  // Shadow centered on moon
            break;
        default:
            console.warn(`Unknown lunar eclipse type: ${type}`);
            return;
        }

        // Start animation
        this.animating = true;
        this.startTime = performance.now();

    }

    /**
     * Update eclipse animation
     * @param {number} deltaTime - Time since last frame (ms)
     */
    update(deltaTime) {
        if (!this.animating) return;

        // Calculate animation progress
        const elapsed = performance.now() - this.startTime;
        const animProgress = Math.min(elapsed / this.animationDuration, 1.0);

        // Ease in-out for smooth, natural eclipse movement
        const eased = this.easeInOutCubic(animProgress);

        // Interpolate eclipse progress
        this.progress = this.progress + (this.targetProgress - this.progress) * eased;

        // Interpolate shadow position (animate shadow sweep)
        this.shadowX = this.shadowX + (this.targetShadowX - this.shadowX) * eased * this.shadowSpeed;

        // Update shader uniforms
        this.material.uniforms.eclipseProgress.value = this.progress;
        this.material.uniforms.eclipseShadowPos.value = [this.shadowX, this.shadowY];

        // Eclipse intensity affects darkening (separate from color shift)
        // Total eclipse: strong darkening + red color
        // Partial: moderate darkening
        // Penumbral: subtle darkening only
        let intensity = 0.0;
        if (this.eclipseType === 'total') {
            intensity = this.progress;  // Full darkening at totality
        } else if (this.eclipseType === 'partial') {
            intensity = this.progress * 0.6;  // Moderate darkening
        } else if (this.eclipseType === 'penumbral') {
            intensity = this.progress * 0.25; // Subtle darkening
        }
        this.material.uniforms.eclipseIntensity.value = intensity;

        // Stop animation when complete
        if (animProgress >= 1.0) {
            this.animating = false;
        }
    }

    /**
     * Ease in-out cubic for smooth animation
     */
    easeInOutCubic(t) {
        return t < 0.5
            ? 4 * t * t * t
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    /**
     * Reset eclipse to off state instantly
     */
    reset() {
        this.progress = 0.0;
        this.targetProgress = 0.0;
        this.shadowX = -2;
        this.targetShadowX = -2;
        this.animating = false;
        this.eclipseType = 'off';

        if (this.material.uniforms.eclipseProgress) {
            this.material.uniforms.eclipseProgress.value = 0.0;
            this.material.uniforms.eclipseIntensity.value = 0.0;
            this.material.uniforms.eclipseShadowPos.value = [this.shadowX, this.shadowY];
        }
    }

    /**
     * Dispose resources
     */
    dispose() {
        // Shader uniforms are disposed with material, nothing to clean up
    }
}

/**
 * EffectManager - Manages geometry-specific visual effects
 *
 * Handles lifecycle management for:
 * - SolarEclipse (sun geometry)
 * - LunarEclipse (moon geometry)
 * - CrystalSoul (crystal-type geometries)
 *
 * Extracted from Core3DManager to improve separation of concerns.
 *
 * @module 3d/managers/EffectManager
 */


/**
 * Geometry types that use CrystalSoul effect
 */
const CRYSTAL_SOUL_GEOMETRIES = ['crystal', 'rough', 'heart', 'star'];

class EffectManager {
    /**
     * Create effect manager
     * @param {ThreeRenderer} renderer - The Three.js renderer
     * @param {string} assetBasePath - Base path for loading assets
     */
    constructor(renderer, assetBasePath = '/assets') {
        this.renderer = renderer;
        this.assetBasePath = assetBasePath;

        // Effect instances
        this.solarEclipse = null;
        this.lunarEclipse = null;
        this.crystalSoul = null;

        // State tracking
        this.currentGeometryType = null;
        this.coreGlowEnabled = true;
    }

    /**
     * Initialize effects for a specific geometry type
     * @param {string} geometryType - The geometry type (sun, moon, crystal, etc.)
     * @param {Object} options - Options for initialization
     * @param {THREE.Mesh} options.coreMesh - The core mesh to attach effects to
     * @param {Object} options.customMaterial - Custom material (for lunar eclipse)
     * @param {number} options.sunRadius - Sun radius (for solar eclipse)
     */
    initializeForGeometry(geometryType, options = {}) {
        const { coreMesh, customMaterial, sunRadius = 1.0 } = options;
        this.currentGeometryType = geometryType;

        // Clean up effects not needed for this geometry
        this._cleanupUnneededEffects(geometryType);

        // Initialize geometry-specific effects
        if (geometryType === 'sun') {
            this._initSolarEclipse(sunRadius, coreMesh);
        } else if (geometryType === 'moon') {
            this._initLunarEclipse(customMaterial);
        } else ;
    }

    /**
     * Initialize solar eclipse effect
     * @private
     */
    _initSolarEclipse(sunRadius, coreMesh) {
        if (!this.solarEclipse && this.renderer?.scene) {
            this.solarEclipse = new SolarEclipse(this.renderer.scene, sunRadius, coreMesh);
        }
    }

    /**
     * Initialize lunar eclipse effect
     * @private
     */
    _initLunarEclipse(customMaterial) {
        if (!this.lunarEclipse && customMaterial) {
            this.lunarEclipse = new LunarEclipse(customMaterial);
        }
    }

    /**
     * Clean up effects that are not needed for the current geometry
     * @private
     */
    _cleanupUnneededEffects(geometryType) {
        // Dispose solar eclipse if not sun
        if (geometryType !== 'sun' && this.solarEclipse) {
            this.solarEclipse.dispose();
            this.solarEclipse = null;
        }

        // Dispose lunar eclipse if not moon
        if (geometryType !== 'moon' && this.lunarEclipse) {
            this.lunarEclipse.dispose();
            this.lunarEclipse = null;
        }

        // Dispose crystal soul if not a crystal-type geometry
        if (!CRYSTAL_SOUL_GEOMETRIES.includes(geometryType) && this.crystalSoul) {
            this.crystalSoul.dispose();
            this.crystalSoul = null;
        }
    }

    /**
     * Create crystal soul effect (async due to inclusion geometry loading)
     * @param {Object} options - Crystal soul options
     * @param {THREE.Mesh} options.coreMesh - Core mesh to attach to
     * @param {string} options.geometryType - Geometry type for configuration
     * @returns {Object} Soul configuration { mesh, material, baseScale, shellBaseScale }
     */
    async createCrystalSoul(options = {}) {
        const { coreMesh, geometryType } = options;

        // Dispose existing soul
        if (this.crystalSoul) {
            this.crystalSoul.dispose();
            this.crystalSoul = null;
        }

        if (!coreMesh) {
            return null;
        }

        // Preload inclusion geometry
        await CrystalSoul._loadInclusionGeometry(this.assetBasePath);

        // Create new soul
        this.crystalSoul = new CrystalSoul({
            radius: 0.35,
            detail: 1,
            geometryType,
            renderer: this.renderer,
            assetBasePath: this.assetBasePath
        });

        this.crystalSoul.attachTo(coreMesh, this.renderer?.scene);

        // Get geometry-specific scale configuration
        const { shellBaseScale, soulScale } = this._getCrystalScaleConfig(geometryType);

        this.crystalSoul.baseScale = soulScale;
        this.crystalSoul.mesh.scale.setScalar(soulScale);
        this.crystalSoul.setVisible(this.coreGlowEnabled);

        return {
            mesh: this.crystalSoul.mesh,
            material: this.crystalSoul.material,
            baseScale: this.crystalSoul.baseScale,
            shellBaseScale
        };
    }

    /**
     * Create crystal soul synchronously (non-async version)
     * @param {Object} options - Crystal soul options
     * @returns {Object} Soul configuration
     */
    createCrystalSoulSync(options = {}) {
        const { coreMesh, geometryType } = options;

        if (this.crystalSoul) {
            this.crystalSoul.dispose();
            this.crystalSoul = null;
        }

        if (!coreMesh) {
            return null;
        }

        this.crystalSoul = new CrystalSoul({
            radius: 0.35,
            detail: 1,
            geometryType,
            renderer: this.renderer,
            assetBasePath: this.assetBasePath
        });

        this.crystalSoul.attachTo(coreMesh, this.renderer?.scene);

        const { shellBaseScale, soulScale } = this._getCrystalScaleConfig(geometryType);

        this.crystalSoul.baseScale = soulScale;
        this.crystalSoul.mesh.scale.setScalar(soulScale);
        this.crystalSoul.setVisible(this.coreGlowEnabled);

        return {
            mesh: this.crystalSoul.mesh,
            material: this.crystalSoul.material,
            baseScale: this.crystalSoul.baseScale,
            shellBaseScale
        };
    }

    /**
     * Get scale configuration for crystal-type geometries
     * @private
     */
    _getCrystalScaleConfig(geometryType) {
        let shellBaseScale = 2.0;  // Default crystal shell size
        let soulScale = 1.0;       // Default: full size

        if (geometryType === 'heart') {
            shellBaseScale = 2.4;
            soulScale = 1.0;
        } else if (geometryType === 'rough') {
            shellBaseScale = 1.6;
            soulScale = 1.0;
        } else if (geometryType === 'star') {
            shellBaseScale = 2.0;
            soulScale = 1.4;  // Larger soul for star to fill the shape
        } else if (geometryType === 'crystal') {
            shellBaseScale = 2.0;
            soulScale = 1.0;
        }

        return { shellBaseScale, soulScale };
    }

    /**
     * Set solar eclipse type
     * @param {string} eclipseType - 'off', 'annular', or 'total'
     * @returns {boolean} True if eclipse was set
     */
    setSolarEclipse(eclipseType) {
        if (!this.solarEclipse) {
            return false;
        }
        this.solarEclipse.setEclipseType(eclipseType);
        return true;
    }

    /**
     * Set lunar eclipse type
     * @param {string} eclipseType - 'off', 'penumbral', 'partial', 'total'
     * @returns {boolean} True if eclipse was set
     */
    setLunarEclipse(eclipseType) {
        if (!this.lunarEclipse) {
            return false;
        }
        this.lunarEclipse.setEclipseType(eclipseType);
        return true;
    }

    /**
     * Stop all eclipse effects
     */
    stopAllEclipses() {
        if (this.solarEclipse) {
            this.solarEclipse.setEclipseType('off');
        }
        if (this.lunarEclipse) {
            this.lunarEclipse.setEclipseType('off');
        }
    }

    /**
     * Update crystal soul
     * @param {number} deltaTime - Time since last frame
     * @param {Array} glowColor - RGB color [r, g, b]
     * @param {number} breathScale - Breathing animation scale
     */
    updateCrystalSoul(deltaTime, glowColor, breathScale = 1.0) {
        if (this.crystalSoul) {
            this.crystalSoul.update(deltaTime, glowColor, breathScale);
        }
    }

    /**
     * Update lunar eclipse
     * @param {number} deltaTime - Time since last frame
     */
    updateLunarEclipse(deltaTime) {
        if (this.lunarEclipse) {
            this.lunarEclipse.update(deltaTime);
        }
    }

    /**
     * Set crystal soul effect parameters
     * @param {Object} params - Effect parameters
     */
    setCrystalSoulEffects(params) {
        if (this.crystalSoul) {
            this.crystalSoul.setEffects(params);
        }
    }

    /**
     * Set crystal soul size
     * @param {number} size - Size value
     * @returns {number} The new base scale
     */
    setCrystalSoulSize(size) {
        if (this.crystalSoul) {
            this.crystalSoul.setSize(size);
            return this.crystalSoul.baseScale;
        }
        return 1.0;
    }

    /**
     * Set crystal soul visibility
     * @param {boolean} visible - Whether soul should be visible
     */
    setCrystalSoulVisible(visible) {
        this.coreGlowEnabled = visible;
        if (this.crystalSoul) {
            this.crystalSoul.setVisible(visible);
        }
    }

    /**
     * Check if crystal soul exists
     * @returns {boolean}
     */
    hasCrystalSoul() {
        return !!this.crystalSoul;
    }

    /**
     * Get crystal soul base scale
     * @returns {number}
     */
    getCrystalSoulBaseScale() {
        return this.crystalSoul?.baseScale ?? 1.0;
    }

    /**
     * Check if solar eclipse is active
     * @returns {boolean}
     */
    hasSolarEclipse() {
        return !!this.solarEclipse;
    }

    /**
     * Check if lunar eclipse is active
     * @returns {boolean}
     */
    hasLunarEclipse() {
        return !!this.lunarEclipse;
    }

    /**
     * Get solar eclipse instance (for render pass)
     * @returns {SolarEclipse|null}
     */
    getSolarEclipse() {
        return this.solarEclipse;
    }

    /**
     * Dispose all effects
     */
    dispose() {
        if (this.solarEclipse) {
            this.solarEclipse.dispose();
            this.solarEclipse = null;
        }

        if (this.lunarEclipse) {
            this.lunarEclipse.dispose();
            this.lunarEclipse = null;
        }

        if (this.crystalSoul) {
            this.crystalSoul.dispose();
            this.crystalSoul = null;
        }

        this.renderer = null;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - 3D Rotation Behavior System
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Evaluates state-based rotation behaviors for 3D mascot
 * @author Emotive Engine Team
 * @module 3d/behaviors/RotationBehavior
 */

/**
 * Rotation behavior system for state-based mascot rotation patterns
 *
 * Supports multiple rotation types:
 * - gentle: Smooth slow spin (calm, neutral)
 * - unstable: Wobble/shake pattern (anger, fear)
 * - rhythmic: Syncs to music BPM (joy, excited)
 * - orbital: Figure-8 or circular patterns (euphoria)
 * - still: Minimal/no rotation (focused, resting)
 */
class RotationBehavior {
    /**
     * Create rotation behavior evaluator
     * @param {object} config - Rotation config from emotional state's 3d section
     * @param {object} rhythmEngine - Optional rhythm engine for BPM sync
     * @param {object} geometryRotation - Optional geometry-specific rotation base (from geometry config)
     */
    constructor(config = {}, rhythmEngine = null, geometryRotation = null) {
        this.config = config;
        this.rhythmEngine = rhythmEngine;
        this.geometryRotation = geometryRotation;

        // Rotation type (gentle, unstable, rhythmic, orbital, still)
        this.type = config.type || 'gentle';

        // Speed multiplier (default 1.0 = neutral speed)
        this.speed = config.speed || 1.0;

        // Rotation axes rates [X, Y, Z] in radians per second
        // If geometry has base rotation, use it as the foundation and apply emotion multiplier
        if (geometryRotation && geometryRotation.baseSpeed !== undefined) {
            const geoSpeed = geometryRotation.baseSpeed;
            const geoAxes = geometryRotation.axes || [0, 1.0, 0];
            // Scale geometry's normalized axes by its baseSpeed, then multiply by emotion's speed
            this.axes = [
                geoAxes[0] * geoSpeed * this.speed,
                geoAxes[1] * geoSpeed * this.speed,
                geoAxes[2] * geoSpeed * this.speed
            ];
        } else {
            // Fall back to emotion's axes if no geometry rotation defined
            this.axes = config.axes || [0, 0.01, 0]; // Default: gentle Y-axis spin
        }

        // Shake/wobble config (for unstable type)
        this.shake = config.shake || { amplitude: 0, frequency: 0 };

        // Wobble enabled flag (can be toggled at runtime to disable shake effects)
        this.wobbleEnabled = true;

        // Eruption config (explosive bursts for anger)
        this.eruption = config.eruption || { enabled: false };
        if (this.eruption.enabled) {
            this.eruption.interval = this.eruption.interval || 3000;
            this.eruption.speedMultiplier = this.eruption.speedMultiplier || 3.0;
            this.eruption.duration = this.eruption.duration || 400;
            this.eruption.nextEruptionTime = this.eruption.interval;
            this.eruption.eruptionStartTime = -1;
        }

        // Music sync enabled
        this.musicSync = config.musicSync !== undefined ? config.musicSync : false;

        // Internal state for time-based patterns
        this.time = 0;

        // Episodic wobble (random shake bursts, e.g., for nervous undertone)
        this.episodicWobble = {
            enabled: false,              // Set by undertone
            minInterval: 2000,           // Minimum time between wobbles (ms)
            maxInterval: 5000,           // Maximum time between wobbles (ms)
            amplitude: 0.05,             // Wobble amplitude (radians)
            duration: 200,               // Wobble duration (ms)
            nextWobbleTime: 0,           // When next wobble should trigger
            wobbleStartTime: -1,         // When current wobble started (-1 = not wobbling)
            wobbleTarget: [0, 0, 0]      // Random target angles for current wobble
        };
    }

    /**
     * Update rotation behavior based on delta time
     * @param {number} deltaTime - Time since last frame (ms)
     * @param {Array} baseRotation - Current base rotation [x, y, z] to modify
     * @returns {Array} Updated rotation [x, y, z]
     */
    update(deltaTime, baseRotation) {
        // Update internal time
        this.time += deltaTime;

        // Apply episodic wobble if enabled (before type-specific behavior)
        // Also requires wobbleEnabled to be true (user can disable all wobble effects)
        if (this.episodicWobble.enabled && this.wobbleEnabled) {
            this._applyEpisodicWobble(deltaTime, baseRotation);
        }

        // Evaluate rotation based on type
        switch (this.type) {
        case 'gentle':
            return this._evaluateGentle(deltaTime, baseRotation);

        case 'unstable':
            return this._evaluateUnstable(deltaTime, baseRotation);

        case 'rhythmic':
            return this._evaluateRhythmic(deltaTime, baseRotation);

        case 'orbital':
            return this._evaluateOrbital(deltaTime, baseRotation);

        case 'still':
            return this._evaluateStill(deltaTime, baseRotation);

        case 'suspicious':
            return this._evaluateSuspicious(deltaTime, baseRotation);

        default:
            return this._evaluateGentle(deltaTime, baseRotation);
        }
    }

    /**
     * Gentle rotation - smooth slow spin
     * Used by: calm, neutral, love
     */
    _evaluateGentle(deltaTime, baseRotation) {
        const dt = deltaTime * 0.001; // Convert ms to seconds

        // Apply axes rotation rates with speed multiplier
        baseRotation[0] += this.axes[0] * this.speed * dt;
        baseRotation[1] += this.axes[1] * this.speed * dt;
        baseRotation[2] += this.axes[2] * this.speed * dt;

        return baseRotation;
    }

    /**
     * Unstable rotation - wobble and shake
     * Used by: anger, fear, glitch
     */
    _evaluateUnstable(deltaTime, baseRotation) {
        const dt = deltaTime * 0.001; // Convert ms to seconds

        // Check for eruption (explosive burst)
        let eruptionMultiplier = 1.0;
        if (this.eruption.enabled) {
            // Check if it's time for next eruption
            if (this.eruption.eruptionStartTime < 0 && this.time >= this.eruption.nextEruptionTime) {
                this.eruption.eruptionStartTime = this.time;
            }

            // Apply eruption speed multiplier during active eruption
            if (this.eruption.eruptionStartTime >= 0) {
                const eruptionElapsed = this.time - this.eruption.eruptionStartTime;

                if (eruptionElapsed < this.eruption.duration) {
                    // Eruption is active - apply speed multiplier with ease in/out
                    const progress = eruptionElapsed / this.eruption.duration;
                    const easedProgress = Math.sin(progress * Math.PI); // Sine ease in/out
                    eruptionMultiplier = 1.0 + (this.eruption.speedMultiplier - 1.0) * easedProgress;
                } else {
                    // Eruption finished - schedule next one
                    this.eruption.eruptionStartTime = -1;
                    this.eruption.nextEruptionTime = this.time + this.eruption.interval;
                }
            }
        }

        // Base rotation on all axes with eruption multiplier
        const effectiveSpeed = this.speed * eruptionMultiplier;
        baseRotation[0] += this.axes[0] * effectiveSpeed * dt;
        baseRotation[1] += this.axes[1] * effectiveSpeed * dt;
        baseRotation[2] += this.axes[2] * effectiveSpeed * dt;

        // Add shake/tremor using high-frequency sine waves (only if wobble enabled)
        if (this.wobbleEnabled) {
            const shakeTime = this.time * 0.001; // Time in seconds
            const freq = this.shake.frequency || 8; // Default 8 Hz
            const amp = this.shake.amplitude || 0.02; // Default 0.02 radians (~1 degree)

            // Hard limit shake amplitude to never overcome righting mechanism
            // Righting strength is 5.0, so max safe shake is ~0.02 radians to prevent tipping
            const MAX_SAFE_SHAKE = 0.02;
            const clampedAmp = Math.min(amp, MAX_SAFE_SHAKE);

            // Multi-frequency shake for more organic feel
            const shakeX = Math.sin(shakeTime * freq * Math.PI * 2) * clampedAmp * 0.7;
            const shakeY = Math.sin(shakeTime * freq * Math.PI * 2 * 1.3) * clampedAmp * 0.5;
            const shakeZ = Math.sin(shakeTime * freq * Math.PI * 2 * 0.9) * clampedAmp * 0.8;

            baseRotation[0] += shakeX;
            baseRotation[1] += shakeY;
            baseRotation[2] += shakeZ;
        }

        return baseRotation;
    }

    /**
     * Rhythmic rotation - syncs to music BPM
     * Used by: joy, excited, euphoria
     */
    _evaluateRhythmic(deltaTime, baseRotation) {
        const dt = deltaTime * 0.001; // Convert ms to seconds

        // If music sync enabled and rhythm engine available
        if (this.musicSync && this.rhythmEngine) {
            const bpm = this.rhythmEngine.bpm || 120;
            const beatDuration = 60 / bpm; // Seconds per beat

            // Pulse rotation speed on beat
            const beatPhase = (this.time * 0.001) % beatDuration;
            const beatPulse = Math.sin((beatPhase / beatDuration) * Math.PI * 2);
            const speedMod = 1.0 + (beatPulse * 0.3); // Pulse ±30% speed

            baseRotation[0] += this.axes[0] * this.speed * speedMod * dt;
            baseRotation[1] += this.axes[1] * this.speed * speedMod * dt;
            baseRotation[2] += this.axes[2] * this.speed * speedMod * dt;
        } else {
            // Fall back to gentle rotation if no rhythm engine
            return this._evaluateGentle(deltaTime, baseRotation);
        }

        return baseRotation;
    }

    /**
     * Orbital rotation - figure-8 or circular patterns
     * Used by: euphoria, surprise
     */
    _evaluateOrbital(deltaTime, baseRotation) {
        const dt = deltaTime * 0.001; // Convert ms to seconds
        const time = this.time * 0.001;

        // Figure-8 pattern using Lissajous curves
        const orbitSpeed = this.speed * 0.5; // Slower for smooth orbits
        const x = Math.sin(time * orbitSpeed * Math.PI * 2) * 0.1;
        const z = Math.sin(time * orbitSpeed * Math.PI * 2 * 0.5) * 0.05;

        // FIXED: Additive rotation (not setting) - works with righting behavior
        // Previous code set rotation directly, completely bypassing righting corrections
        baseRotation[0] += x * dt;
        baseRotation[1] += this.axes[1] * this.speed * dt; // Continue Y-axis spin
        baseRotation[2] += z * dt;

        return baseRotation;
    }

    /**
     * Still rotation - minimal or no rotation
     * Used by: focused, resting
     */
    _evaluateStill(deltaTime, baseRotation) {
        // Very slow or no rotation - just maintain current rotation
        // Apply minimal drift if axes are defined
        const dt = deltaTime * 0.001;
        const stillSpeed = 0.1; // 10% of normal speed

        baseRotation[0] += this.axes[0] * stillSpeed * dt;
        baseRotation[1] += this.axes[1] * stillSpeed * dt;
        baseRotation[2] += this.axes[2] * stillSpeed * dt;

        return baseRotation;
    }

    /**
     * Suspicious rotation - biased toward facing forward
     * Used by: suspicion
     *
     * Like a nervous person keeping eyes on a threat - spends most time
     * facing forward, then quick snap to look around before returning.
     * Uses sawtooth wave for asymmetric rotation (slow one way, fast back).
     */
    _evaluateSuspicious(deltaTime, baseRotation) {
        const dt = deltaTime * 0.001; // Convert to seconds
        const time = this.time * 0.001; // Time in seconds

        // Rotation cycle parameters
        const cycleDuration = 4.0; // 4 second cycle (configurable via speed)
        const adjustedCycle = cycleDuration / this.speed;

        // Current position in cycle [0, 1]
        const cycleProgress = (time % adjustedCycle) / adjustedCycle;

        // Sawtooth wave: slow rotation away from forward (0 → 180°), quick snap back (180° → 0°)
        // Spend 85% of time rotating slowly away, 15% snapping back (more forward-facing time)
        let targetYaw;
        if (cycleProgress < 0.85) {
            // Slow rotation phase: 0 → π over 85% of cycle
            targetYaw = (cycleProgress / 0.85) * Math.PI;
        } else {
            // Quick snap back: π → 0 over 15% of cycle
            const snapProgress = (cycleProgress - 0.85) / 0.15;
            targetYaw = Math.PI * (1.0 - snapProgress);
        }

        // Smooth interpolation toward target (prevents instant jumps)
        const lerpSpeed = 3.0; // Higher = faster following
        const yawDelta = targetYaw - baseRotation[1];
        baseRotation[1] += yawDelta * lerpSpeed * dt;

        return baseRotation;
    }

    /**
     * Reset internal time (useful for state transitions)
     */
    reset() {
        this.time = 0;
    }

    /**
     * Apply episodic wobble (random shake bursts)
     * @param {number} deltaTime - Time since last frame (ms)
     * @param {Array} baseRotation - Current base rotation to modify
     */
    _applyEpisodicWobble(deltaTime, baseRotation) {
        const wobble = this.episodicWobble;

        // Check if it's time to start a new wobble
        if (wobble.wobbleStartTime === -1 && this.time >= wobble.nextWobbleTime) {
            // Start new wobble
            wobble.wobbleStartTime = this.time;

            // Generate random target angles
            wobble.wobbleTarget = [
                (Math.random() - 0.5) * wobble.amplitude,  // Pitch
                (Math.random() - 0.5) * wobble.amplitude,  // Yaw
                (Math.random() - 0.5) * wobble.amplitude   // Roll
            ];

            // Schedule next wobble
            const interval = wobble.minInterval + Math.random() * (wobble.maxInterval - wobble.minInterval);
            wobble.nextWobbleTime = this.time + interval;
        }

        // Apply wobble if active
        if (wobble.wobbleStartTime !== -1) {
            const elapsed = this.time - wobble.wobbleStartTime;
            const progress = Math.min(elapsed / wobble.duration, 1.0);

            if (progress < 1.0) {
                // Wobble in progress - use sine wave for smooth shake
                const wobbleIntensity = Math.sin(progress * Math.PI);

                baseRotation[0] += wobble.wobbleTarget[0] * wobbleIntensity;
                baseRotation[1] += wobble.wobbleTarget[1] * wobbleIntensity;
                baseRotation[2] += wobble.wobbleTarget[2] * wobbleIntensity;
            } else {
                // Wobble complete
                wobble.wobbleStartTime = -1;
            }
        }
    }

    /**
     * Update config (when emotional state changes)
     * @param {object} config - New rotation config from state's 3d section
     */
    updateConfig(config) {
        this.config = config;
        this.type = config.type || 'gentle';
        this.speed = config.speed || 1.0;

        // Recalculate axes using geometry rotation if available
        if (this.geometryRotation && this.geometryRotation.baseSpeed !== undefined) {
            const geoSpeed = this.geometryRotation.baseSpeed;
            const geoAxes = this.geometryRotation.axes || [0, 1.0, 0];
            // Scale geometry's normalized axes by its baseSpeed, then multiply by emotion's speed
            this.axes = [
                geoAxes[0] * geoSpeed * this.speed,
                geoAxes[1] * geoSpeed * this.speed,
                geoAxes[2] * geoSpeed * this.speed
            ];
        } else {
            // Fall back to emotion's axes if no geometry rotation defined
            this.axes = config.axes || [0, 0.01, 0];
        }

        this.shake = config.shake || { amplitude: 0, frequency: 0 };
        this.musicSync = config.musicSync !== undefined ? config.musicSync : false;
    }

    /**
     * Apply undertone multipliers to rotation behavior
     * Called after updateConfig when an undertone is active
     * @param {object} undertoneRotation - Undertone rotation multipliers
     */
    applyUndertoneMultipliers(undertoneRotation) {
        // Apply speed multiplier
        if (undertoneRotation.speedMultiplier !== undefined) {
            this.speed *= undertoneRotation.speedMultiplier;
        }

        // Apply shake multiplier to shake amplitude
        if (undertoneRotation.shakeMultiplier !== undefined && this.shake.amplitude) {
            this.shake.amplitude *= undertoneRotation.shakeMultiplier;
        }

        // Enable episodic wobble for nervous undertone
        if (undertoneRotation.enableEpisodicWobble !== undefined) {
            this.episodicWobble.enabled = undertoneRotation.enableEpisodicWobble;

            // Initialize first wobble timing if enabling
            if (this.episodicWobble.enabled && this.episodicWobble.nextWobbleTime === 0) {
                const interval = this.episodicWobble.minInterval +
                                Math.random() * (this.episodicWobble.maxInterval - this.episodicWobble.minInterval);
                this.episodicWobble.nextWobbleTime = this.time + interval;
            }
        }
    }

    /**
     * Enable or disable wobble/shake effects
     * @param {boolean} enabled - Whether wobble is enabled
     */
    setWobbleEnabled(enabled) {
        this.wobbleEnabled = enabled;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - 3D Righting Behavior System
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Self-righting mechanism for 3D models (like inflatable punching clowns)
 * @author Emotive Engine Team
 * @module 3d/behaviors/RightingBehavior
 */

/**
 * Righting behavior - automatically returns model to upright orientation
 *
 * Like a weighted bottom or gyroscopic stabilization. The model naturally
 * returns its "up" vector (local Y-axis) to world up, even as it rotates.
 *
 * Physics simulation:
 * - Center of mass creates restoring torque when tilted
 * - Torque proportional to tilt angle (small angle approximation)
 * - Damping prevents oscillation
 * - Yaw rotation preserved (free spin around vertical)
 */
class RightingBehavior {
    /**
     * Create righting behavior
     * @param {object} config - Righting configuration
     */
    constructor(config = {}) {
        this.config = config;

        // Strength of righting force (0.0 = disabled, 1.0 = strong)
        this.strength = config.strength !== undefined ? config.strength : 0.5;

        // Damping coefficient (prevents oscillation)
        // Low = bouncy/springy, High = smooth/overdamped
        this.damping = config.damping !== undefined ? config.damping : 0.8;

        // Center of mass offset from model center [x, y, z]
        // Negative Y = bottom-heavy (strong righting)
        // Positive Y = top-heavy (weak/inverted righting)
        // X/Z offsets = eccentric weighting (leans to one side)
        this.centerOfMass = config.centerOfMass || [0, -0.3, 0];

        // Which axes to apply righting force to
        // { pitch: true, roll: true, yaw: false } = upright but free spin
        this.axes = config.axes || { pitch: true, roll: true, yaw: false };

        // Velocity state (for damping calculation)
        this.angularVelocity = { x: 0, y: 0, z: 0 };
    }

    /**
     * Apply righting torque to Euler angles
     * @param {number} deltaTime - Time since last frame (ms)
     * @param {Array} euler - Current Euler angles [pitch, yaw, roll] to modify
     * @returns {Array} Updated Euler angles
     */
    update(deltaTime, euler) {
        if (this.strength === 0) return euler; // Disabled

        const dt = deltaTime * 0.001; // Convert ms to seconds

        // Current orientation
        const pitch = euler[0]; // Rotation around X (forward/back tilt)
        const yaw = euler[1];   // Rotation around Y (left/right spin)
        const roll = euler[2];  // Rotation around Z (left/right tilt)

        // Calculate restoring torque based on center of mass
        // Torque = -k * angle (spring force, small angle approximation)
        // Larger tilt = larger torque pulling back to upright

        if (this.axes.pitch) {
            // Pitch righting (X-axis)
            const pitchTorque = -pitch * this.strength;

            // Apply torque to angular velocity with damping
            this.angularVelocity.x += pitchTorque * dt;
            this.angularVelocity.x *= (1.0 - this.damping);

            // Update pitch from velocity
            euler[0] += this.angularVelocity.x * dt;
        }

        if (this.axes.roll) {
            // Roll righting (Z-axis)
            const rollTorque = -roll * this.strength;

            // Apply torque to angular velocity with damping
            this.angularVelocity.z += rollTorque * dt;
            this.angularVelocity.z *= (1.0 - this.damping);

            // Update roll from velocity
            euler[2] += this.angularVelocity.z * dt;
        }

        // Yaw is typically left free (no righting) for natural spin
        // But can be enabled for models that should resist yaw rotation
        if (this.axes.yaw) {
            const yawTorque = -yaw * this.strength;
            this.angularVelocity.y += yawTorque * dt;
            this.angularVelocity.y *= (1.0 - this.damping);
            euler[1] += this.angularVelocity.y * dt;
        }

        // TODO: Center of mass offset affects torque magnitude
        // More bottom-heavy (larger -Y offset) = stronger righting
        // For now, centerOfMass is stored but not used in calculation
        // Future: torque = crossProduct(centerOfMass, gravityDirection) * strength

        return euler;
    }

    /**
     * Reset angular velocity (when changing states or teleporting)
     */
    reset() {
        this.angularVelocity = { x: 0, y: 0, z: 0 };
    }

    /**
     * Update configuration
     * @param {object} config - New righting config
     */
    updateConfig(config) {
        this.config = config;
        this.strength = config.strength !== undefined ? config.strength : this.strength;
        this.damping = config.damping !== undefined ? config.damping : this.damping;
        this.centerOfMass = config.centerOfMass || this.centerOfMass;
        this.axes = config.axes || this.axes;
    }

    /**
     * Apply undertone multipliers to righting behavior
     * Called after updateConfig when an undertone is active
     * @param {object} undertoneRighting - Undertone righting multipliers
     */
    applyUndertoneMultipliers(undertoneRighting) {
        // Apply strength multiplier
        if (undertoneRighting.strengthMultiplier !== undefined) {
            this.strength *= undertoneRighting.strengthMultiplier;
        }
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - 3D Facing Behavior System
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Tidal-lock mechanism for 3D models (keeps one face always toward camera)
 * @author Emotive Engine Team
 * @module 3d/behaviors/FacingBehavior
 */


/**
 * Facing behavior - automatically keeps one face oriented toward camera
 *
 * Like the Moon's tidal lock with Earth, or billboard sprites. The object
 * maintains a fixed orientation relative to the camera, canceling out any
 * rotation from other behaviors.
 *
 * Physics simulation:
 * - Calculates camera-to-object direction vector
 * - Applies counter-rotation to maintain fixed face orientation
 * - Can specify which face should point toward camera
 * - Strength parameter allows partial tidal lock (wobble)
 */
class FacingBehavior {
    /**
     * Create facing behavior
     * @param {object} config - Facing configuration
     * @param {THREE.Camera} camera - Camera reference for orientation tracking
     */
    constructor(config = {}, camera = null) {
        this.config = config;
        this.camera = camera;

        // Strength of facing force (0.0 = disabled, 1.0 = full tidal lock)
        this.strength = config.strength !== undefined ? config.strength : 1.0;

        // Locked face direction in local space [x, y, z]
        // Default: +Z faces camera (standard Three.js forward)
        this.lockedFace = config.lockedFace || [0, 0, 1];

        // Fixed calibration rotation applied AFTER facing calculation
        // This allows "Man in the Moon" style orientation offset
        // [pitch, yaw, roll] in radians
        this.calibrationRotation = config.calibrationRotation || [0, 0, 0];

        // Interpolation speed (1.0 = instant, <1.0 = smooth transition)
        this.lerpSpeed = config.lerpSpeed !== undefined ? config.lerpSpeed : 1.0;

        // Temp objects for calculations (reused to avoid GC)
        this.tempVector = new Vector3();
        this.tempQuaternion = new Quaternion();
        this.targetQuaternion = new Quaternion();
        this.calibrationQuaternion = new Quaternion();
        this.currentQuaternion = new Quaternion();

        // Additional temp objects (reused in update() hot path)
        this._lockedFaceVec = new Vector3();
        this._targetMatrix = new Matrix4();
        this._lookAtOrigin = new Vector3(0, 0, 0);
        this._upVector = new Vector3(0, 1, 0);
        this._tempEuler = new Euler(0, 0, 0, 'XYZ');
        this._defaultPosition = new Vector3(0, 0, 0);
    }

    /**
     * Apply facing orientation to Euler angles
     * @param {number} deltaTime - Time since last frame (ms)
     * @param {Array} euler - Current Euler angles [pitch, yaw, roll] to modify
     * @param {THREE.Vector3} objectPosition - Object's world position (optional)
     * @returns {Array} Updated Euler angles
     */
    update(deltaTime, euler, objectPosition) {
        if (this.strength === 0 || !this.camera) return euler; // Disabled

        // Use default position if not provided (avoids allocation)
        const objPos = objectPosition || this._defaultPosition;

        const dt = deltaTime * 0.001; // Convert ms to seconds

        // Calculate direction from object to camera
        this.tempVector.copy(this.camera.position).sub(objPos);

        // If camera is at same position as object, use default forward
        if (this.tempVector.lengthSq() < 0.0001) {
            this.tempVector.set(0, 0, 1);
        }
        this.tempVector.normalize();

        // Calculate target quaternion that orients lockedFace toward camera
        // Reuse cached vector instead of creating new one
        this._lockedFaceVec.set(
            this.lockedFace[0],
            this.lockedFace[1],
            this.lockedFace[2]
        ).normalize();

        // Use lookAt-style rotation (object's Z-axis points toward camera)
        // Reuse cached matrix and vectors
        this._targetMatrix.lookAt(this.tempVector, this._lookAtOrigin, this._upVector);
        this.targetQuaternion.setFromRotationMatrix(this._targetMatrix);

        // Apply calibration rotation (fixed offset, e.g., "Man in the Moon" orientation)
        if (this.calibrationRotation[0] !== 0 ||
            this.calibrationRotation[1] !== 0 ||
            this.calibrationRotation[2] !== 0) {
            this._tempEuler.set(
                this.calibrationRotation[0],
                this.calibrationRotation[1],
                this.calibrationRotation[2],
                'XYZ'
            );
            this.calibrationQuaternion.setFromEuler(this._tempEuler);
            this.targetQuaternion.multiply(this.calibrationQuaternion);
        }

        // Get current rotation as quaternion (reuse temp euler)
        this._tempEuler.set(euler[0], euler[1], euler[2], 'XYZ');
        this.currentQuaternion.setFromEuler(this._tempEuler);

        // Interpolate toward target based on strength and lerpSpeed
        const alpha = Math.min(1.0, this.strength * this.lerpSpeed * dt * 60); // 60fps normalized
        this.currentQuaternion.slerp(this.targetQuaternion, alpha);

        // Convert back to Euler angles
        this._tempEuler.setFromQuaternion(this.currentQuaternion, 'XYZ');
        euler[0] = this._tempEuler.x; // Pitch
        euler[1] = this._tempEuler.y; // Yaw
        euler[2] = this._tempEuler.z; // Roll

        return euler;
    }

    /**
     * Set camera reference (useful when camera changes)
     * @param {THREE.Camera} camera - New camera reference
     */
    setCamera(camera) {
        this.camera = camera;
    }

    /**
     * Update calibration rotation (e.g., when morphing geometries)
     * @param {Array} rotation - [pitch, yaw, roll] in radians
     */
    setCalibrationRotation(rotation) {
        this.calibrationRotation = rotation;
    }

    /**
     * Update configuration
     * @param {object} config - New facing config
     */
    updateConfig(config) {
        this.config = config;
        this.strength = config.strength !== undefined ? config.strength : this.strength;
        this.lockedFace = config.lockedFace || this.lockedFace;
        this.calibrationRotation = config.calibrationRotation || this.calibrationRotation;
        this.lerpSpeed = config.lerpSpeed !== undefined ? config.lerpSpeed : this.lerpSpeed;
    }

    /**
     * Dispose resources
     */
    dispose() {
        this.camera = null;
        this.tempVector = null;
        this.tempQuaternion = null;
        this.targetQuaternion = null;
        this.calibrationQuaternion = null;
        this.currentQuaternion = null;
    }
}

/**
 * BehaviorController - Manages rotation, righting, and facing behaviors
 *
 * Centralizes behavior management for 3D mascot:
 * - RotationBehavior: Emotion-driven rotation with wobble
 * - RightingBehavior: Self-stabilization (punching bag effect)
 * - FacingBehavior: Tidal lock for moon geometry
 *
 * Extracted from Core3DManager to improve separation of concerns.
 *
 * @module 3d/managers/BehaviorController
 */


/**
 * Default righting behavior configuration
 */
const DEFAULT_RIGHTING_CONFIG = {
    strength: 5.0,              // Strong righting without overdoing it
    damping: 0.85,              // Critically damped for smooth return
    centerOfMass: [0, -0.3, 0], // Bottom-heavy
    axes: { pitch: true, roll: true, yaw: false }
};

class BehaviorController {
    /**
     * Create behavior controller
     * @param {Object} options - Configuration options
     * @param {boolean} options.rotationDisabled - Whether rotation is disabled
     * @param {boolean} options.wobbleEnabled - Whether wobble effects are enabled
     * @param {Object} options.rhythmEngine - Optional rhythm engine for beat-synced rotation
     * @param {THREE.Camera} options.camera - Camera reference for facing behavior
     */
    constructor(options = {}) {
        this.rotationBehavior = null;
        this.rightingBehavior = null;
        this.facingBehavior = null;

        // State flags
        this.rotationDisabled = options.rotationDisabled || false;
        this.wobbleEnabled = options.wobbleEnabled !== false; // Default: enabled

        // External references
        this.rhythmEngine = options.rhythmEngine || null;
        this.camera = options.camera || null;

        // Current geometry type (affects behavior configuration)
        this.geometryType = null;

        // Initialize righting behavior (always active)
        this.rightingBehavior = new RightingBehavior(DEFAULT_RIGHTING_CONFIG);
    }

    /**
     * Configure rotation behavior based on emotion and geometry
     * @param {Object} options - Configuration options
     * @param {string} options.geometryType - Current geometry type
     * @param {Object} options.emotionData - Emotion data with 3d rotation config
     * @param {Object} options.facingConfig - Facing behavior config (for moon)
     * @param {Object} options.geometryRotation - Geometry-specific base rotation config (e.g., SUN_ROTATION_CONFIG)
     */
    configureForEmotion(options = {}) {
        const { geometryType, emotionData, facingConfig, geometryRotation } = options;

        // Track current geometry type
        this.geometryType = geometryType;

        // Moon is tidally locked - no rotation
        if (geometryType === 'moon') {
            this._disableRotation();
            this._initFacingBehavior(facingConfig);
            return;
        }

        // Dispose facing behavior if not moon
        this._disposeFacingBehavior();

        // Skip if rotation is disabled by user
        if (this.rotationDisabled) {
            this._disableRotation();
            return;
        }

        // Configure rotation based on emotion
        if (emotionData?.['3d']?.rotation) {
            this._configureRotationFromEmotion(emotionData['3d'].rotation, geometryRotation);
        } else {
            // Default rotation if no emotion-specific config
            this._ensureDefaultRotation(geometryRotation);
        }

        // Reset righting behavior on emotion change
        if (this.rightingBehavior) {
            this.rightingBehavior.reset();
        }
    }

    /**
     * Apply undertone modifiers to behaviors
     * @param {Object} undertone3d - 3D undertone modifiers
     */
    applyUndertone(undertone3d) {
        if (!undertone3d) return;

        if (undertone3d.rotation && this.rotationBehavior) {
            this.rotationBehavior.applyUndertoneMultipliers(undertone3d.rotation);
        }

        if (undertone3d.righting && this.rightingBehavior) {
            this.rightingBehavior.applyUndertoneMultipliers(undertone3d.righting);
        }
    }

    /**
     * Update all behaviors for current frame
     * @param {number} deltaTime - Time since last frame
     * @param {Array} baseEuler - Base euler rotation array [x, y, z] to modify
     */
    update(deltaTime, baseEuler) {
        // Update rotation behavior
        if (this.rotationBehavior) {
            this.rotationBehavior.update(deltaTime, baseEuler);
        } else if (this.geometryType !== 'moon' && !this.rotationDisabled) {
            // Fallback: simple Y rotation if no behavior defined
            // EXCEPT for moon (tidally locked - no rotation)
            // EXCEPT when user has manually disabled rotation
            baseEuler[1] += deltaTime * 0.0003;
        }

        // Update righting behavior (self-stabilization) after rotation
        // This pulls tilted models back to upright while preserving yaw spin
        if (this.rightingBehavior) {
            this.rightingBehavior.update(deltaTime, baseEuler);
        }

        // Apply facing behavior (tidal lock) after righting
        // This overrides rotation to keep object stationary (no rotation)
        // Tidal lock is achieved by keeping baseEuler at [0,0,0]
        if (this.facingBehavior) {
            // Simply reset baseEuler to zero - moon doesn't rotate at all
            baseEuler[0] = 0; // No pitch
            baseEuler[1] = 0; // No yaw
            baseEuler[2] = 0; // No roll
            // calibrationRotation is already applied in renderer to show correct face
        }
    }

    /**
     * Set wobble enabled state
     * @param {boolean} enabled - Whether wobble is enabled
     */
    setWobbleEnabled(enabled) {
        this.wobbleEnabled = enabled;
        if (this.rotationBehavior) {
            this.rotationBehavior.setWobbleEnabled(enabled);
        }

        // When disabling wobble, reset to upright position
        if (!enabled && this.rightingBehavior) {
            this.rightingBehavior.reset();
        }
    }

    /**
     * Reset righting behavior
     */
    resetRighting() {
        if (this.rightingBehavior) {
            this.rightingBehavior.reset();
        }
    }

    /**
     * Get angular velocity from rotation behavior
     * @returns {Array} [x, y, z] angular velocity or [0, 0, 0]
     */
    getAngularVelocity() {
        return this.rotationBehavior ? this.rotationBehavior.axes : [0, 0, 0];
    }

    /**
     * Check if rotation behavior is active
     * @returns {boolean}
     */
    hasRotationBehavior() {
        return !!this.rotationBehavior;
    }

    /**
     * Check if facing behavior is active (for moon tidal lock)
     * @returns {boolean}
     */
    hasFacingBehavior() {
        return !!this.facingBehavior;
    }

    /**
     * Configure for a geometry morph transition
     * Called when morphing to a new geometry type
     * @param {Object} options - Configuration options
     * @param {string} options.targetGeometryType - Target geometry type
     * @param {Object} options.emotionData - Current emotion data
     * @param {Object} options.facingConfig - Facing behavior config (for moon)
     * @param {Object} options.geometryRotation - Geometry-specific rotation config
     */
    configureForMorph(options = {}) {
        const { targetGeometryType, emotionData, facingConfig, geometryRotation } = options;

        // Reset righting behavior during morph transition
        this.resetRighting();

        // Configure for target geometry (same logic as emotion change)
        this.configureForEmotion({
            geometryType: targetGeometryType,
            emotionData,
            facingConfig,
            geometryRotation
        });
    }

    /**
     * Configure rotation behavior from emotion data
     * @param {Object} rotationConfig - Rotation configuration from emotion
     * @param {Object} geometryRotation - Geometry-specific base rotation config
     * @private
     */
    _configureRotationFromEmotion(rotationConfig, geometryRotation) {
        if (this.rotationBehavior) {
            this.rotationBehavior.updateConfig(rotationConfig);
        } else {
            this.rotationBehavior = new RotationBehavior(
                rotationConfig,
                this.rhythmEngine,
                geometryRotation
            );
        }
        this.rotationBehavior.setWobbleEnabled(this.wobbleEnabled);
    }

    /**
     * Ensure default rotation behavior exists
     * @param {Object} geometryRotation - Geometry-specific base rotation config
     * @private
     */
    _ensureDefaultRotation(geometryRotation) {
        if (!this.rotationBehavior) {
            this.rotationBehavior = new RotationBehavior(
                { type: 'gentle', speed: 1.0, axes: [0, 0.01, 0] },
                this.rhythmEngine,
                geometryRotation
            );
            this.rotationBehavior.setWobbleEnabled(this.wobbleEnabled);
        }
    }

    /**
     * Disable rotation behavior
     * @private
     */
    _disableRotation() {
        this.rotationBehavior = null;
    }

    /**
     * Initialize facing behavior for tidal lock
     * @private
     */
    _initFacingBehavior(facingConfig) {
        if (!this.facingBehavior && facingConfig?.enabled) {
            this.facingBehavior = new FacingBehavior({
                strength: facingConfig.strength,
                lockedFace: facingConfig.lockedFace,
                lerpSpeed: facingConfig.lerpSpeed,
                calibrationRotation: facingConfig.calibrationRotation
            }, this.camera);
        }
    }

    /**
     * Dispose facing behavior
     * @private
     */
    _disposeFacingBehavior() {
        if (this.facingBehavior) {
            this.facingBehavior.dispose();
            this.facingBehavior = null;
        }
    }

    /**
     * Dispose all behaviors and clean up
     */
    dispose() {
        if (this.rotationBehavior) {
            this.rotationBehavior.destroy?.();
            this.rotationBehavior = null;
        }

        if (this.rightingBehavior) {
            this.rightingBehavior.destroy?.();
            this.rightingBehavior = null;
        }

        if (this.facingBehavior) {
            this.facingBehavior.dispose();
            this.facingBehavior = null;
        }
    }
}

/**
 * BreathingPhaseManager - Imperative breathing phase animation
 *
 * Provides explicit control over breathing animations for meditation:
 * - breathePhase('inhale', 4) animates scale up over 4 seconds
 * - breathePhase('exhale', 4) animates scale down over 4 seconds
 * - breathePhase('hold', 4) maintains current scale
 *
 * Extracted from Core3DManager to improve separation of concerns.
 *
 * @module 3d/managers/BreathingPhaseManager
 */

/**
 * Scale targets for different phases
 */
const PHASE_SCALES = {
    inhale: 1.3,    // Max inhale size
    exhale: 0.85,   // Min exhale size
    neutral: 1.0    // Default/reset scale
};

/**
 * Duration limits in seconds
 */
const MIN_DURATION = 0.5;
const MAX_DURATION = 30;

class BreathingPhaseManager {
    constructor() {
        // Current phase state
        this._phase = null;           // 'inhale' | 'hold' | 'exhale' | null
        this._startTime = 0;
        this._duration = 0;           // Duration in ms
        this._startScale = 1.0;
        this._targetScale = 1.0;
        this._currentScale = 1.0;     // Current animated scale
    }

    /**
     * Start a breathing phase animation
     * @param {string} phase - 'inhale' | 'exhale' | 'hold'
     * @param {number} durationSec - Duration in seconds for the animation
     */
    startPhase(phase, durationSec) {
        // Clamp duration to reasonable values
        const duration = Math.max(MIN_DURATION, Math.min(MAX_DURATION, durationSec));

        // Store current scale as starting point
        this._startScale = this._currentScale;
        this._startTime = performance.now();
        this._duration = duration * 1000; // Convert to ms
        this._phase = phase;

        // Set target scale based on phase
        switch (phase) {
            case 'inhale':
                this._targetScale = PHASE_SCALES.inhale;
                break;
            case 'exhale':
                this._targetScale = PHASE_SCALES.exhale;
                break;
            case 'hold':
            default:
                // Hold at current scale - no animation needed
                this._targetScale = this._startScale;
                break;
        }
    }

    /**
     * Stop any active breathing phase animation and reset to neutral scale
     */
    stop() {
        this._phase = null;
        this._currentScale = PHASE_SCALES.neutral;
        this._startScale = PHASE_SCALES.neutral;
        this._targetScale = PHASE_SCALES.neutral;
    }

    /**
     * Check if a breathing phase is currently active
     * @returns {boolean}
     */
    isActive() {
        return this._phase !== null;
    }

    /**
     * Get current phase name
     * @returns {string|null}
     */
    getPhase() {
        return this._phase;
    }

    /**
     * Update breathing phase animation
     * @param {number} _deltaTime - Time since last frame in ms (unused, we use elapsed time)
     * @returns {number} Current breathing phase scale multiplier (1.0 if inactive)
     */
    update(_deltaTime) {
        // If no active phase, return current scale
        if (!this._phase) {
            return this._currentScale;
        }

        const now = performance.now();
        const elapsed = now - this._startTime;

        // Calculate progress (0 to 1)
        const progress = Math.min(1.0, elapsed / this._duration);

        // Use sine easing for natural breathing rhythm
        // sin(0 to π/2) maps 0→1 smoothly, reaches target exactly at end
        // This feels more like natural breathing than cubic easing
        const eased = Math.sin(progress * Math.PI / 2);

        // Interpolate between start and target scale
        this._currentScale = this._startScale +
            (this._targetScale - this._startScale) * eased;

        // Clear phase when complete
        if (progress >= 1.0) {
            this._currentScale = this._targetScale;
            this._phase = null;
        }

        return this._currentScale;
    }

    /**
     * Get current scale multiplier
     * @returns {number}
     */
    getScaleMultiplier() {
        return this._currentScale;
    }

    /**
     * Get current animation state for debugging
     * @returns {Object}
     */
    getState() {
        return {
            phase: this._phase,
            startScale: this._startScale,
            targetScale: this._targetScale,
            currentScale: this._currentScale,
            duration: this._duration,
            isActive: this._phase !== null
        };
    }

    /**
     * Dispose manager (nothing to clean up, but follows pattern)
     */
    dispose() {
        this._phase = null;
    }
}

/**
 * Core3DManager - Main orchestrator for Three.js 3D rendering
 *
 * Manages:
 * - Three.js renderer
 * - 3D geometry selection
 * - Animation playback
 * - Emotion-based lighting and materials
 *
 * @class Core3DManager
 */


// Crystal calibration rotation to show flat facet facing camera
// Hexagonal crystal has vertices at 0°, 60°, 120°, etc.
// Rotating 30° around Y puts a flat face toward the camera (default -Z view direction)
const CRYSTAL_CALIBRATION_ROTATION = {
    x: 0,    // No X rotation
    y: 30,   // 30° Y rotation to show flat facet
    z: 0     // No Z rotation
};

class Core3DManager {
    /**
     * Create a new Core3DManager instance
     * @param {HTMLCanvasElement} canvas - WebGL canvas element
     * @param {Object} [options={}] - Configuration options
     * @param {string} [options.geometry='sphere'] - Geometry type (sphere, crystal, diamond, moon, sun, etc.)
     * @param {string} [options.emotion='neutral'] - Initial emotion state
     * @param {boolean} [options.enableParticles=true] - Enable particle effects
     * @param {boolean} [options.enablePostProcessing=true] - Enable post-processing (bloom, etc.)
     * @param {boolean} [options.enableShadows=false] - Enable shadow rendering
     * @param {boolean} [options.enableControls=true] - Enable camera orbit controls
     * @param {boolean} [options.autoRotate=true] - Enable auto-rotation
     * @param {number} [options.autoRotateSpeed=0.5] - Auto-rotate speed
     * @param {boolean} [options.enableBlinking=true] - Enable blinking animation
     * @param {boolean} [options.enableBreathing=true] - Enable breathing animation
     * @param {number} [options.cameraDistance=3] - Camera Z distance from origin
     * @param {number} [options.fov=45] - Camera field of view in degrees
     * @param {number} [options.minZoom] - Minimum zoom distance
     * @param {number} [options.maxZoom] - Maximum zoom distance
     * @param {string} [options.materialVariant] - Material variant override
     * @param {string} [options.assetBasePath='/assets'] - Base path for loading assets (textures, models)
     */
    constructor(canvas, options = {}) {
        this._instanceId = Math.random().toString(36).substr(2, 6);

        this.canvas = canvas;
        this.options = options;
        this._destroyed = false;
        this._ready = false;  // Flag indicating all async loading is complete
        this._readyPromise = null;  // Promise that resolves when ready

        // Asset base path for textures and models (configurable for GitHub Pages, etc.)
        // Empty string triggers auto-detection in ThreeRenderer
        this.assetBasePath = options.assetBasePath !== undefined ? options.assetBasePath : '';

        // Load geometry type first (needed to determine if moon = tidally locked)
        this.geometryType = options.geometry || 'sphere';

        // Initialize Three.js renderer
        // Moon is tidally locked - disable auto-rotate for moon regardless of options
        const isMoon = this.geometryType === 'moon';
        this.renderer = new ThreeRenderer(canvas, {
            enablePostProcessing: options.enablePostProcessing !== false,
            enableShadows: options.enableShadows || false,
            enableControls: options.enableControls !== false, // Camera controls (mouse/touch)
            autoRotate: isMoon ? false : (options.autoRotate !== false), // Moon is tidally locked
            autoRotateSpeed: options.autoRotateSpeed, // Auto-rotate speed (undefined = default 0.5)
            cameraDistance: options.cameraDistance, // Camera Z distance (undefined = default 3)
            fov: options.fov, // Field of view (undefined = default 45)
            minZoom: options.minZoom, // Minimum zoom distance
            maxZoom: options.maxZoom, // Maximum zoom distance
            assetBasePath: this.assetBasePath // Base path for HDRI and other assets
        });
        const geometryConfig = THREE_GEOMETRIES[this.geometryType];

        if (!geometryConfig) {
            console.warn(`Unknown geometry: ${this.geometryType}, falling back to sphere`);
            this.geometryConfig = THREE_GEOMETRIES.sphere;
        } else {
            this.geometryConfig = geometryConfig;
        }

        this.geometry = this.geometryConfig.geometry;

        // Store geometry type name for material/rendering logic
        if (this.geometry && !this.geometry.isGroup) {
            this.geometry.userData.geometryType = this.geometryType;
        }

        // Store materialVariant for use when morphing geometries
        this.materialVariant = options.materialVariant || null;

        // Callback for when material is swapped during morph (allows immediate preset application)
        this.onMaterialSwap = null;

        // Check if this geometry requires custom material (e.g., moon with textures, sun with emissive)
        // Use MaterialFactory for centralized material creation
        // IMPORTANT: Must create material BEFORE calling _loadAsyncGeometry so it's available when OBJ loads
        let customMaterial = null;
        const emotionData = getEmotion(this.emotion);
        const materialResult = createCustomMaterial(this.geometryType, this.geometryConfig, {
            glowColor: this.glowColor || [1.0, 1.0, 0.95],
            glowIntensity: this.glowIntensity || 1.0,
            materialVariant: this.materialVariant,
            emotionData, // Pass emotion data for auto-deriving geometry params
            assetBasePath: this.assetBasePath
        });

        if (materialResult) {
            customMaterial = materialResult.material;
            this.customMaterial = customMaterial;
            this.customMaterialType = materialResult.type;
        }

        // Check for async geometry loader (e.g., OBJ models)
        // Must be called AFTER material is created so this.customMaterial is available
        if (this.geometryConfig.geometryLoader) {
            // Store promise so callers can await full initialization
            this._readyPromise = this._loadAsyncGeometry();
        } else {
            // No async loading needed - immediately ready
            this._ready = true;
            this._readyPromise = Promise.resolve();
        }

        // Create core mesh with geometry (and optional custom material)
        // If geometry is null (e.g., crystal waiting for OBJ), defer mesh creation
        if (this.geometry === null && this.geometryConfig.geometryLoader) {
            this._deferredMeshCreation = true;
            // Mesh will be created in _loadAsyncGeometry when OBJ loads
        } else {
            this.coreMesh = this.renderer.createCoreMesh(this.geometry, customMaterial);

            // For crystal/rough with blend-layers shader, create inner glowing core
            if (this.customMaterialType === 'crystal') {
                this.createCrystalInnerCore();
            }
        }

        // Calibration rotation offset (applied on top of all animations)
        // Used for moon orientation calibration
        this.calibrationRotation = [0, 0, 0]; // [X, Y, Z] in radians

        // Camera-space roll: rotates the tidally-locked face around camera's viewing axis
        // Applied AFTER all world-space rotations, spins the face like a wheel
        this.cameraRoll = 0; // in radians

        // Set initial calibration rotation for moon to show classic Earth-facing side
        // This shows the "Man in the Moon" view with Mare Imbrium upper-right
        if (this.geometryType === 'moon') {
            const degToRad = Math.PI / 180;
            this.calibrationRotation = [
                MOON_CALIBRATION_ROTATION.x * degToRad,  // X: world-space rotation
                MOON_CALIBRATION_ROTATION.y * degToRad,  // Y: world-space rotation
                MOON_CALIBRATION_ROTATION.z * degToRad   // Z: camera-space roll (spins face CW/CCW)
            ];
            this.cameraRoll = 0; // Camera-space roll (spin the face)
        }

        // Set initial calibration rotation for crystal/rough/heart/star to show flat facet facing camera
        if (this.geometryType === 'crystal' || this.geometryType === 'rough' || this.geometryType === 'heart' || this.geometryType === 'star') {
            const degToRad = Math.PI / 180;
            this.calibrationRotation = [
                CRYSTAL_CALIBRATION_ROTATION.x * degToRad,
                CRYSTAL_CALIBRATION_ROTATION.y * degToRad,
                CRYSTAL_CALIBRATION_ROTATION.z * degToRad
            ];
        }

        // Animation controller
        this.animator = new ProceduralAnimator();

        // Gesture blender
        this.gestureBlender = new GestureBlender();

        // Animation manager (orchestrates gesture playback and blending)
        this.animationManager = new AnimationManager(this.animator, this.gestureBlender);

        // Effect manager (manages SolarEclipse, LunarEclipse, CrystalSoul effects)
        this.effectManager = new EffectManager(this.renderer, this.assetBasePath);

        // Behavior controller (manages rotation, righting, and facing behaviors)
        // Note: rhythmEngine is passed later via setRhythmEngine() if needed
        this.behaviorController = new BehaviorController({
            rotationDisabled: options.autoRotate === false,
            wobbleEnabled: true,
            rhythmEngine: options.rhythmEngine || null,
            camera: this.renderer.camera
        });

        // Breathing phase manager (imperative meditation-style breathing control)
        this.breathingPhaseManager = new BreathingPhaseManager();

        // Breathing animator
        this.breathingAnimator = new BreathingAnimator();
        this.breathingEnabled = options.enableBreathing !== false; // Enabled by default

        // Note: Imperative breathing phase animation state is now managed by BreathingPhaseManager
        // See: breathePhase(), stopBreathingPhase(), _updateBreathingPhase()

        // Geometry morpher for smooth shape transitions
        this.geometryMorpher = new GeometryMorpher();
        this._skipRenderFrames = 0; // Frame counter for post-morph render skipping

        // Blink animator (emotion-aware)
        this.blinkAnimator = new BlinkAnimator(this.geometryConfig);
        this.blinkAnimator.setEmotion(this.emotion);
        this.blinkingManuallyDisabled = false; // Track if user disabled blinking

        // Disable blinking if requested
        if (options.enableBlinking === false) {
            this.blinkAnimator.pause();
            this.blinkingManuallyDisabled = true;
        }

        // Rotation state flags (BehaviorController manages the actual behaviors)
        this.rotationDisabled = options.autoRotate === false; // Disable rotation if autoRotate is false
        this.wobbleEnabled = true; // Wobble/shake effects enabled by default

        // Initialize behavior controller for moon geometry if needed
        if (isMoon && MOON_FACING_CONFIG.enabled) {
            const degToRad = Math.PI / 180;
            this.behaviorController.configureForEmotion({
                geometryType: 'moon',
                emotionData: null, // Will be set in setEmotion
                facingConfig: {
                    enabled: true,
                    strength: MOON_FACING_CONFIG.strength,
                    lockedFace: MOON_FACING_CONFIG.lockedFace,
                    lerpSpeed: MOON_FACING_CONFIG.lerpSpeed,
                    calibrationRotation: [
                        MOON_CALIBRATION_ROTATION.x * degToRad,
                        MOON_CALIBRATION_ROTATION.y * degToRad,
                        MOON_CALIBRATION_ROTATION.z * degToRad
                    ]
                }
            });
        }

        // Current state
        this.emotion = options.emotion || 'neutral';
        this.undertone = options.undertone || null;
        this.glowColor = [1.0, 1.0, 1.0]; // RGB
        this.glowColorHex = '#FFFFFF'; // Hex color for luminance normalization
        this.glowIntensity = 1.0;
        this.coreGlowEnabled = true; // Toggle to enable/disable core glow
        this.glowIntensityOverride = null; // Manual override for testing
        this.intensityCalibrationOffset = 0; // Universal filter calibration offset

        // Quaternion-based rotation system for smooth 3D orientation
        this.baseEuler = [0, 0, 0]; // Persistent base Euler angles (updated by RotationBehavior)
        this.baseQuaternion = new Quaternion(); // Ambient rotation (from emotion state)
        this.gestureQuaternion = new Quaternion(); // Gesture delta rotation (for debugging)
        this.tempEuler = new Euler(); // Temp for conversions
        this.rotation = [0, 0, 0]; // Final Euler angles for renderer

        // Match 2D sizing: core is 1/12th of canvas size (coreSizeDivisor: 12)
        this.baseScale = 0.16; // Properly sized core relative to particles
        this.scale = 0.16; // Current scale (base + animation)
        this.position = [0, 0, 0];

        // Rhythm engine reference (for BPM sync)
        this.rhythmEngine = options.rhythmEngine || null;

        // Initialize 3D rhythm adapter for beat-synced animations
        this.rhythm3DAdapter = rhythm3DAdapter;
        this.rhythmEnabled = options.enableRhythm !== false; // Enabled by default
        if (this.rhythmEnabled) {
            this.rhythm3DAdapter.initialize();
            // Wire up breathing animator to rhythm adapter for coordination
            this.breathingAnimator.setRhythmAdapter(this.rhythm3DAdapter);
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // PARTICLE SYSTEM INTEGRATION
        // ═══════════════════════════════════════════════════════════════════════════

        // Enable/disable particles
        this.particlesEnabled = options.enableParticles !== false;
        this.particleVisibility = this.particlesEnabled; // Runtime toggle matches initial state

        // ALWAYS create particle system (even if disabled) so it can be toggled later
        // Create 2D particle system (reuse existing logic)
        const particleSystem = new ParticleSystem(50); // 50 particles max

        // Set canvas size for particle spawning
        particleSystem.canvasWidth = canvas.width;
        particleSystem.canvasHeight = canvas.height;

        // Create 3D translator (converts 2D → 3D)
        // Note: coreRadius3D is now updated each frame from Core3DManager
        // to ensure particles orbit at correct distance regardless of screen size
        const particleTranslator = new Particle3DTranslator({
            worldScale: 2.0,
            baseRadius: 1.5,      // Legacy fallback (coreRadius3D takes precedence)
            depthScale: 0.75,
            verticalScale: 1.0,
            coreRadius3D: 2.0     // Initial value, updated each frame
        });

        // Create 3D renderer (Three.js points system)
        // Increased particle count for richer particle effects
        const particleRenderer = new Particle3DRenderer(150, { renderer: this.renderer.renderer });

        // Add particle points to scene
        const particlePoints = particleRenderer.getPoints();
        // Put particles on layer 1 for separate particle bloom pipeline
        // Layer 1 uses white clear color to prevent dark halos from blur sampling
        particlePoints.layers.set(1);
        this.renderer.scene.add(particlePoints);

        // Create orchestrator (coordinates everything)
        this.particleOrchestrator = new Particle3DOrchestrator(
            particleSystem,
            particleTranslator,
            particleRenderer
        );

        // Set geometry type for special rendering rules (e.g., black hole particle culling)
        this.particleOrchestrator.setGeometryType(this.geometryType);

        // If particles disabled, hide them immediately
        if (!this.particlesEnabled) {
            particleRenderer.geometry.setDrawRange(0, 0);
        }

        // Initialize geometry-specific effects via EffectManager
        const sunRadius = this.geometry?.parameters?.radius || 0.5;
        this.effectManager.initializeForGeometry(this.geometryType, {
            coreMesh: this.coreMesh,
            customMaterial: this.customMaterial,
            sunRadius
        });

        // Note: Virtual particle pool is now managed by AnimationManager

        // Apply default glass mode for initial geometry (if specified)
        // Crystal and diamond geometries have defaultGlassMode: true
        // BUT skip this if we have a custom material (e.g., blend-layers shader)
        if (this.geometryConfig.defaultGlassMode && !this.customMaterial) {
            this.setGlassMaterialEnabled(true);
        }

        // Initialize emotion
        this.setEmotion(this.emotion);
    }

    // Note: createVirtualParticlePool and getVirtualParticleFromPool
    // have been moved to AnimationManager

    /**
     * Set emotional state
     * Updates glow color, lighting, rotation behavior, and triggers emotion animation
     * @param {string} emotion - Emotion name
     * @param {string|null} undertone - Optional undertone modifier
     */
    setEmotion(emotion, undertone = null) {
        this.emotion = emotion;
        this.undertone = undertone;

        // Get emotion color and intensity from existing emotion system
        const emotionData = getEmotion(emotion);
        if (emotionData && emotionData.visual) {
            // Convert hex to RGB
            if (emotionData.visual.glowColor) {
                let rgb = hexToRGB(emotionData.visual.glowColor);

                // Apply undertone saturation modifier to glow color
                rgb = applyUndertoneSaturation$1(rgb, undertone);

                this.glowColor = rgb;
                // Store hex color for bloom luminance normalization
                this.glowColorHex = emotionData.visual.glowColor;

                // Calculate intensity using universal filter based on color luminance
                // This ensures consistent visibility across all emotions regardless of color brightness
                const materialMode = this.renderer.materialMode || 'glass';
                this.glowIntensity = getGlowIntensityForColor(
                    emotionData.visual.glowColor,
                    this.intensityCalibrationOffset,
                    materialMode
                );
            }

            // Update Three.js lighting based on emotion
            this.renderer.updateLighting(emotion, emotionData);

            // Update custom material with emotion glow color
            if (this.customMaterial && this.customMaterialType === 'moon') {
                const glowColorThree = new Color(this.glowColor[0], this.glowColor[1], this.glowColor[2]);
                updateMoonGlow(this.customMaterial, glowColorThree, this.glowIntensity);
            } else if (this.customMaterial && this.customMaterialType === 'sun') {
                // Update sun material colors (no time delta needed here - just color update)
                updateSunMaterial(this.coreMesh, this.glowColor, this.glowIntensity, 0);
            }

            // Note: Bloom is updated every frame in render() for smooth transitions
        }

        // Configure behavior controller for this emotion and geometry
        // Get geometry-specific rotation config if available
        const geometryRotation = this.geometryType === 'sun' ? SUN_ROTATION_CONFIG : null;

        // Build facing config for moon if needed
        let facingConfig = null;
        if (this.geometryType === 'moon' && MOON_FACING_CONFIG.enabled) {
            const degToRad = Math.PI / 180;
            facingConfig = {
                enabled: true,
                strength: MOON_FACING_CONFIG.strength,
                lockedFace: MOON_FACING_CONFIG.lockedFace,
                lerpSpeed: MOON_FACING_CONFIG.lerpSpeed,
                calibrationRotation: [
                    MOON_CALIBRATION_ROTATION.x * degToRad,
                    MOON_CALIBRATION_ROTATION.y * degToRad,
                    MOON_CALIBRATION_ROTATION.z * degToRad
                ]
            };
        }

        // Configure behaviors via controller
        this.behaviorController.configureForEmotion({
            geometryType: this.geometryType,
            emotionData,
            facingConfig,
            geometryRotation
        });

        // Reset Euler angles to upright [pitch=0, yaw=current, roll=0]
        // Preserve yaw to maintain current spin direction, but reset pitch/roll
        this.baseEuler[0] = 0; // Reset pitch
        this.baseEuler[2] = 0; // Reset roll
        // Keep baseEuler[1] (yaw) to preserve rotation continuity

        // Apply undertone multipliers if present
        const undertoneModifier = getUndertoneModifier(undertone);

        if (undertoneModifier && undertoneModifier['3d']) {
            this.behaviorController.applyUndertone(undertoneModifier['3d']);
        }

        // Stop all previous emotion animations to prevent stacking
        this.animator.stopAll();

        // Store base glow intensity for this emotion (before animation modulation)
        // Use universal filter to calculate intensity from color luminance
        // Pass material mode so formula adjusts correctly (glass vs glow mode)
        const glowColor = emotionData?.visual?.glowColor || '#00BCD4';
        const materialMode = this.renderer.materialMode || 'glass';
        this.baseGlowIntensity = getGlowIntensityForColor(
            glowColor,
            this.intensityCalibrationOffset,
            materialMode
        );


        // Apply undertone glow multiplier to base intensity
        if (undertoneModifier && undertoneModifier['3d'] && undertoneModifier['3d'].glow) {
            this.baseGlowIntensity;
            this.baseGlowIntensity *= undertoneModifier['3d'].glow.intensityMultiplier;
        }

        // Update breathing animator with emotion and undertone
        this.breathingAnimator.setEmotion(emotion, undertoneModifier);

        // Update blink animator with new emotion
        this.blinkAnimator.setEmotion(emotion);

        // Update groove preset based on emotion (if rhythm is playing)
        // Energetic emotions → bounce groove, calm emotions → subtle groove, flowing → zen groove
        if (this.rhythmEnabled && this.rhythm3DAdapter?.isPlaying?.()) {
            const emotionGroove = this._getEmotionGroove(emotion);
            // Use quantize + bars for smooth, musical transition
            this.rhythm3DAdapter.setGroove(emotionGroove, { quantize: true, bars: 2 });
        }

        // Immediately reset bloom to prevent accumulation (fast transition on emotion change)
        this.renderer.updateBloom(this.baseGlowIntensity, 1.0, this.geometryType);

        // Trigger emotion animation - now handled by blending system in render()
        this.animator.playEmotion(emotion);

        // ═══════════════════════════════════════════════════════════════════════════
        // UPDATE PARTICLE SYSTEM FOR NEW EMOTION
        // ═══════════════════════════════════════════════════════════════════════════
        if (this.particlesEnabled && this.particleOrchestrator) {
            // Notify orchestrator of emotion change (will recalculate config)
            this.particleOrchestrator.setEmotion(emotion, undertone);
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // UPDATE CRYSTAL SOUL ANIMATION FROM EMOTION CONFIG
        // ═══════════════════════════════════════════════════════════════════════════
        // Soul animation parameters are geometry-agnostic and can be used by:
        // - Crystal (inner core drift/shimmer)
        // - Sun (plasma flow) - future
        // - Moon (subtle glow pulse) - future
        if (emotionData && emotionData.soulAnimation) {
            const soul = emotionData.soulAnimation;
            this.setCrystalSoulEffects({
                driftEnabled: true,
                driftSpeed: soul.driftSpeed || 0.5,
                shimmerEnabled: true,
                shimmerSpeed: soul.shimmerSpeed || 0.5
                // Note: turbulence will be used for future geometries (Sun plasma chaos)
            });
        }
    }

    /**
     * Enable or disable core glow
     * @param {boolean} enabled - True to enable glow, false to disable
     */
    setCoreGlowEnabled(enabled) {
        this.coreGlowEnabled = enabled;

        // Also toggle crystal soul visibility for crystal-type geometries
        if (this.crystalSoul) {
            this.crystalSoul.setVisible(enabled);
        }
    }

    /**
     * Set glass material mode
     * @param {boolean} enabled - True for glass material, false for glow material
     */
    setGlassMaterialEnabled(enabled) {
        const mode = enabled ? 'glass' : 'glow';
        this.renderer.setMaterialMode(mode);
    }

    /**
     * Set glow intensity override
     * @param {number} intensity - Glow intensity value (0.3-10.0 range for auto system, 0.8-1.2 for normalized), or null to clear override
     */
    setGlowIntensity(intensity) {
        this.glowIntensityOverride = intensity;
        if (intensity !== null) {
            this.glowIntensity = intensity;
            this.baseGlowIntensity = intensity;
        }
    }

    /**
     * Convert linear slider value (0-100) to logarithmic glow intensity (0.3-10.0)
     * Use this for UI sliders to make intensity changes feel linear to the user
     *
     * @param {number} sliderValue - Linear slider value (0-100)
     * @returns {number} Logarithmic intensity value (0.3-10.0)
     *
     * @example
     * const sliderVal = 50; // Middle of slider
     * const intensity = core3d.sliderToIntensity(sliderVal);
     * core3d.setGlowIntensity(intensity);
     */
    sliderToIntensity(sliderValue) {
        // Map 0-100 to 0.3-10.0 using exponential curve
        // This makes the slider feel linear while outputting the wide range the system expects
        const normalized = sliderValue / 100; // 0-1
        const min = 0.3;
        const max = 10.0;
        // Exponential mapping: intensity = min * (max/min)^normalized
        return min * Math.pow(max / min, normalized);
    }

    /**
     * Set universal filter intensity calibration offset
     * Adjusts global brightness for all emotions in real-time
     * @param {number} offset - Calibration offset (-0.5 to +0.5 recommended)
     */
    setIntensityCalibration(offset) {
        this.intensityCalibrationOffset = offset;

        // Recalculate current emotion's glow intensity with new offset
        this.setEmotion(this.emotion, this.undertone);
    }

    /**
     * Get current glow intensity
     * @returns {number} Current glow intensity
     */
    getGlowIntensity() {
        return this.glowIntensity;
    }

    /**
     * Play gesture animation using 2D gesture data translated to 3D
     * Delegates to AnimationManager for gesture orchestration
     */
    playGesture(gestureName) {
        this.animationManager.playGesture(gestureName, {
            onUpdate: (props, _progress) => {
                if (props.position) this.position = props.position;
                if (props.rotation) {
                    // Convert gesture Euler rotation to quaternion
                    this.tempEuler.set(props.rotation[0], props.rotation[1], props.rotation[2], 'XYZ');
                    this.gestureQuaternion.setFromEuler(this.tempEuler);
                }
                if (props.scale !== undefined) this.scale = this.baseScale * props.scale;
                // Apply glow intensity as multiplier on base intensity (not absolute override)
                if (props.glowIntensity !== undefined) {
                    this.glowIntensity = this.baseGlowIntensity * props.glowIntensity;
                }
            },
            onComplete: () => {
                // Reset to base state
                this.position = [0, 0, 0];
                // NOTE: Don't reset rotation - it's computed from quaternions in render()
                // gestureQuaternion will be reset to identity in render() when no gestures active
                this.scale = this.baseScale;
            }
        });
    }

    /**
     * Set solar eclipse type (only works for sun geometry)
     * @param {string} eclipseType - Eclipse type: 'off', 'annular', or 'total'
     */
    setSunShadow(eclipseType = 'off') {
        if (this.geometryType !== 'sun' || !this.effectManager.hasSolarEclipse()) {
            console.warn('⚠️ Eclipse only available for sun geometry');
            return;
        }

        // Set eclipse type via EffectManager
        this.effectManager.setSolarEclipse(eclipseType);
    }

    /**
     * Start a solar eclipse animation
     * Morphs to sun geometry if needed, then triggers eclipse
     * @param {Object} options - Eclipse options
     * @param {string} options.type - Eclipse type: 'annular' or 'total' (default: 'total')
     */
    startSolarEclipse(options = {}) {
        const eclipseType = options.type || 'total';

        // If already on sun, just trigger eclipse
        if (this.geometryType === 'sun' && this.effectManager.hasSolarEclipse()) {
            this.effectManager.setSolarEclipse(eclipseType);
            return;
        }

        // Morph to sun, then trigger eclipse after morph completes
        this.morphToShape('sun');

        // Wait for morph to complete (shrink + grow phases)
        // Default morph duration is 500ms, so wait a bit longer
        setTimeout(() => {
            if (this.effectManager.hasSolarEclipse()) {
                this.effectManager.setSolarEclipse(eclipseType);
            }
        }, 600);
    }

    /**
     * Start a lunar eclipse animation (blood moon)
     * Morphs to moon geometry if needed, then triggers eclipse
     * @param {Object} options - Eclipse options
     * @param {string} options.type - Eclipse type: 'total' (blood moon), 'partial', 'penumbral'
     */
    startLunarEclipse(options = {}) {
        const eclipseType = options.type || 'total';

        // If already on moon, just trigger eclipse
        if (this.geometryType === 'moon' && this.effectManager.hasLunarEclipse()) {
            this.effectManager.setLunarEclipse(eclipseType);
            return;
        }

        // Morph to moon, then trigger eclipse after morph completes
        this.morphToShape('moon');

        // Wait for morph to complete (shrink + grow phases)
        setTimeout(() => {
            if (this.effectManager.hasLunarEclipse()) {
                this.effectManager.setLunarEclipse(eclipseType);
            }
        }, 600);
    }

    /**
     * Stop any active eclipse animation
     */
    stopEclipse() {
        this.effectManager.stopAllEclipses();
    }

    /**
     * Set lunar eclipse (Blood Moon) effect
     * @param {string} eclipseType - 'off', 'penumbral', 'partial', 'total'
     */
    setMoonEclipse(eclipseType = 'off') {
        if (this.geometryType !== 'moon' || !this.effectManager.hasLunarEclipse()) {
            console.warn('⚠️ Lunar eclipse only available for moon geometry');
            return;
        }

        // Set eclipse type via EffectManager
        this.effectManager.setLunarEclipse(eclipseType);
    }

    /**
     * Set blood moon blend parameters
     * @param {Object} params - { blendMode, blendStrength, emissiveStrength, eclipseIntensity }
     */
    setBloodMoonBlend(params = {}) {
        if (this.geometryType !== 'moon' || !this.customMaterial) {
            console.warn('⚠️ Blood moon blend only available for moon geometry');
            return;
        }

        if (params.blendMode !== undefined) {
            this.customMaterial.uniforms.blendMode.value = params.blendMode;
        }
        if (params.blendStrength !== undefined) {
            this.customMaterial.uniforms.blendStrength.value = params.blendStrength;
        }
        if (params.emissiveStrength !== undefined) {
            this.customMaterial.uniforms.emissiveStrength.value = params.emissiveStrength;
        }
        if (params.eclipseIntensity !== undefined) {
            this.customMaterial.uniforms.eclipseIntensity.value = params.eclipseIntensity;
        }
    }

    /**
     * Update a specific blend multiplexer layer
     * @param {number} layerIndex - Layer index (1-4)
     * @param {Object} params - { mode, strength, enabled }
     */
    setBlendLayer(layerIndex, params = {}) {
        if ((this.geometryType !== 'moon' && this.geometryType !== 'sun') || !this.customMaterial) {
            console.warn('⚠️ Blend layers only available for moon and sun geometry');
            return;
        }

        const layerPrefix = `layer${layerIndex}`;

        if (params.mode !== undefined && this.customMaterial.uniforms[`${layerPrefix}Mode`]) {
            this.customMaterial.uniforms[`${layerPrefix}Mode`].value = params.mode;
        }
        if (params.strength !== undefined && this.customMaterial.uniforms[`${layerPrefix}Strength`]) {
            this.customMaterial.uniforms[`${layerPrefix}Strength`].value = params.strength;
        }
        if (params.enabled !== undefined && this.customMaterial.uniforms[`${layerPrefix}Enabled`]) {
            this.customMaterial.uniforms[`${layerPrefix}Enabled`].value = params.enabled ? 1.0 : 0.0;
        }
    }

    /**
     * Update all blend multiplexer layers at once
     * @param {Array} layers - Array of layer configs [{mode, strength, enabled}, ...]
     */
    setAllBlendLayers(layers) {
        if ((this.geometryType !== 'moon' && this.geometryType !== 'sun') || !this.customMaterial) {
            console.warn('⚠️ Blend layers only available for moon and sun geometry');
            return;
        }

        layers.forEach((layer, index) => {
            this.setBlendLayer(index + 1, layer);
        });
    }

    /**
     * Set crystal blend layer for a specific visual component
     * @param {string} component - Component name: 'core', 'fresnel', 'trans', 'facet'
     * @param {number} blendIndex - Blend index (1 or 2)
     * @param {Object} params - { mode, strength, enabled }
     */
    setCrystalBlendLayer(component, blendIndex, params = {}) {
        if ((this.geometryType !== 'crystal' && this.geometryType !== 'rough') ||
            !this.customMaterial || this.customMaterialType !== 'crystal') {
            return;
        }

        const prefix = `${component}Blend${blendIndex}`;

        if (params.mode !== undefined && this.customMaterial.uniforms[`${prefix}Mode`]) {
            this.customMaterial.uniforms[`${prefix}Mode`].value = params.mode;
        }
        if (params.strength !== undefined && this.customMaterial.uniforms[`${prefix}Strength`]) {
            this.customMaterial.uniforms[`${prefix}Strength`].value = params.strength;
        }
        if (params.enabled !== undefined && this.customMaterial.uniforms[`${prefix}Enabled`]) {
            this.customMaterial.uniforms[`${prefix}Enabled`].value = params.enabled ? 1.0 : 0.0;
        }
    }

    /**
     * Set crystal shader uniforms
     * @param {Object} params - Crystal uniform values
     */
    setCrystalUniforms(params = {}) {
        if ((this.geometryType !== 'crystal' && this.geometryType !== 'rough') ||
            !this.customMaterial || this.customMaterialType !== 'crystal') {
            console.warn('⚠️ Crystal uniforms only available with crystal blend-layers material');
            return;
        }

        const {uniforms} = this.customMaterial;

        // Helper to safely set uniform value (protect against NaN)
        const safeSet = (uniform, value, min = 0, max = 10) => {
            if (uniform && typeof value === 'number' && !isNaN(value) && isFinite(value)) {
                uniform.value = Math.max(min, Math.min(max, value));
            }
        };

        // Crystal-specific parameters with validation
        safeSet(uniforms.coreGlowStrength, params.coreGlowStrength, 0, 2);
        if (params.coreGlowFalloff !== undefined && !isNaN(params.coreGlowFalloff)) {
            safeSet(uniforms.coreGlowFalloff, params.coreGlowFalloff, 0.1, 3);
            // Also update inner core size
            this.setCrystalCoreSize(params.coreGlowFalloff);
        }
        safeSet(uniforms.fresnelStrength, params.fresnelStrength, 0, 2);
        safeSet(uniforms.fresnelPower, params.fresnelPower, 0.5, 10); // Min 0.5 to avoid pow issues
        safeSet(uniforms.transmissionStrength, params.transmissionStrength, 0, 1);
        safeSet(uniforms.facetStrength, params.facetStrength, 0, 2);
        safeSet(uniforms.iridescenceStrength, params.iridescenceStrength, 0, 1);
        safeSet(uniforms.chromaticAberration, params.chromaticAberration, 0, 1);
        safeSet(uniforms.causticStrength, params.causticStrength, 0, 1);
        safeSet(uniforms.emissiveIntensity, params.emissiveIntensity, 0, 5);

        // Animation controls
        safeSet(uniforms.sparkleEnabled, params.sparkleEnabled, 0, 1);
        safeSet(uniforms.sparkleSpeed, params.sparkleSpeed, 0.1, 5);
        safeSet(uniforms.causticEnabled, params.causticEnabled, 0, 1);
        safeSet(uniforms.causticSpeed, params.causticSpeed, 0.1, 10);
        safeSet(uniforms.causticScale, params.causticScale, 0.5, 10);
        safeSet(uniforms.causticCoverage, params.causticCoverage, 0, 1);
        safeSet(uniforms.energyPulseEnabled, params.energyPulseEnabled, 0, 1);
        safeSet(uniforms.energyPulseSpeed, params.energyPulseSpeed, 0.1, 5);
    }

    /**
     * Create inner glowing core for crystal-type geometries
     * Uses CrystalSoul class for reusable soul effect
     */
    createCrystalInnerCore() {
        // Dispose existing soul if present
        if (this.crystalSoul) {
            this.crystalSoul.dispose();
            this.crystalSoul = null;
        }

        if (!this.coreMesh) {
            return;
        }

        // Create new soul and attach to coreMesh
        // Pass renderer for scene locking during async geometry swaps
        // Use _targetGeometryType during morph, fall back to geometryType for initial load
        const effectiveGeometryType = this._targetGeometryType || this.geometryType;
        this.crystalSoul = new CrystalSoul({ radius: 0.35, detail: 1, geometryType: effectiveGeometryType, renderer: this.renderer, assetBasePath: this.assetBasePath });
        this.crystalSoul.attachTo(this.coreMesh, this.renderer?.scene);

        // Geometry-specific shell and soul sizes (permanent values)
        // Use effectiveGeometryType to get correct scale during morph transitions
        let soulScale = 1.0;  // Default: full size (HUGE)
        if (effectiveGeometryType === 'heart') {
            this.crystalShellBaseScale = 2.4;
            soulScale = 1.0;  // Full size for heart
        } else if (effectiveGeometryType === 'rough') {
            this.crystalShellBaseScale = 1.6;
            soulScale = 1.0;  // Full size for rough
        } else if (effectiveGeometryType === 'star') {
            this.crystalShellBaseScale = 2.0;
            soulScale = 1.4;  // Larger soul for star to fill the shape
        } else if (effectiveGeometryType === 'crystal') {
            this.crystalShellBaseScale = 2.0;  // Default crystal shell size
            soulScale = 1.0;  // Full size for crystal
        }

        this.crystalSoul.baseScale = soulScale;
        this.crystalSoul.mesh.scale.setScalar(soulScale);

        // Respect coreGlowEnabled toggle state
        this.crystalSoul.setVisible(this.coreGlowEnabled);

        // Legacy references for backwards compatibility
        this.crystalInnerCore = this.crystalSoul.mesh;
        this.crystalInnerCoreMaterial = this.crystalSoul.material;
        this.crystalInnerCoreBaseScale = this.crystalSoul.baseScale;
    }

    /**
     * Update crystal inner core color, intensity, and animation based on emotion
     * @param {Array} glowColor - RGB color array [r, g, b] (0-1 range)
     * @param {number} deltaTime - Time since last frame in ms (for animation)
     */
    updateCrystalInnerCore(glowColor, deltaTime = 0) {
        if (!this.crystalSoul) {
            return;
        }

        // Get breathing scale if enabled
        const breathScale = (this.breathingAnimator && this.breathingEnabled)
            ? this.breathingAnimator.getBreathingScale()
            : 1.0;

        // Update the soul
        this.crystalSoul.update(deltaTime, glowColor, breathScale);

        // Keep legacy reference in sync
        this.crystalInnerCoreBaseScale = this.crystalSoul.baseScale;
    }

    /**
     * Set crystal soul effect parameters
     * @param {Object} params - Soul effect parameters
     * @param {boolean} params.driftEnabled - Enable/disable drifting energy
     * @param {number} params.driftSpeed - Drift animation speed (0.1-3.0)
     * @param {boolean} params.shimmerEnabled - Enable/disable vertical shimmer
     * @param {number} params.shimmerSpeed - Shimmer animation speed (0.1-3.0)
     */
    setCrystalSoulEffects(params = {}) {
        if (!this.crystalSoul) return;
        this.crystalSoul.setEffects(params);
    }

    /**
     * Set crystal inner core (soul) size
     * @param {number} size - Size value 0-1, where 0.5 is default
     */
    setCrystalCoreSize(size) {
        if (!this.crystalSoul) return;
        this.crystalSoul.setSize(size);
        this.crystalInnerCoreBaseScale = this.crystalSoul.baseScale;
    }

    /**
     * Set crystal shell size (outer crystal)
     * @param {number} size - Size value 0.5-2.0, where 1.0 is default
     */
    setCrystalShellSize(size) {
        if (!this.coreMesh || (this.geometryType !== 'crystal' && this.geometryType !== 'rough' && this.geometryType !== 'heart')) return;

        // Store base shell scale for use during rendering
        this.crystalShellBaseScale = size;
        // Don't apply directly - it will be applied in render() along with other transforms
    }

    /**
     * Enable or disable wobble/shake effects on rotation
     * @param {boolean} enabled - Whether wobble is enabled
     */
    setWobbleEnabled(enabled) {
        this.wobbleEnabled = enabled;
        this.behaviorController.setWobbleEnabled(enabled);

        // When disabling wobble, reset pitch/roll to upright, preserve yaw for rotation continuity
        if (!enabled) {
            this.baseEuler[0] = 0; // Reset pitch
            this.baseEuler[2] = 0; // Reset roll
        }
    }

    /**
     * Set material variant for use in morphing
     * Call this before morphToShape() to change material during transition
     * @param {string|null} variant - Material variant (e.g., 'multiplexer' for moon blood moon support)
     */
    setMaterialVariant(variant) {
        this.materialVariant = variant;
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // RHYTHM SYNC API
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Enable or disable rhythm sync for 3D animations
     * @param {boolean} enabled - Whether rhythm sync is enabled
     */
    setRhythmEnabled(enabled) {
        this.rhythmEnabled = enabled;
        if (enabled && this.rhythm3DAdapter && !this.rhythm3DAdapter.enabled) {
            this.rhythm3DAdapter.initialize();
        }
    }

    /**
     * Enable or disable ambient groove (subtle idle animation synced to beat)
     * @param {boolean} enabled - Whether groove is enabled
     */
    setGrooveEnabled(enabled) {
        if (this.rhythm3DAdapter) {
            this.rhythm3DAdapter.setGrooveEnabled(enabled);
        }
    }

    /**
     * Set beat sync strength for gesture animations
     * @param {number} strength - Sync strength (0-1), higher = more pronounced beat sync
     */
    setBeatSyncStrength(strength) {
        if (this.rhythm3DAdapter) {
            this.rhythm3DAdapter.setBeatSyncStrength(strength);
        }
    }

    /**
     * Set groove configuration for idle animations
     * @param {Object} config - Groove settings
     * @param {number} config.grooveBounceAmount - Vertical bounce amplitude (default: 0.02)
     * @param {number} config.grooveSwayAmount - Horizontal sway amplitude (default: 0.015)
     * @param {number} config.groovePulseAmount - Scale pulse amplitude (default: 0.03)
     * @param {number} config.grooveRotationAmount - Rotation sway amplitude (default: 0.02)
     */
    setGrooveConfig(config) {
        if (this.rhythm3DAdapter) {
            this.rhythm3DAdapter.setGrooveConfig(config);
        }
    }

    /**
     * Check if rhythm is currently playing
     * @returns {boolean}
     */
    isRhythmPlaying() {
        return this.rhythm3DAdapter?.isPlaying() || false;
    }

    /**
     * Get current BPM from rhythm system
     * @returns {number}
     */
    getRhythmBPM() {
        return this.rhythm3DAdapter?.getBPM() || 120;
    }

    /**
     * Start rhythm playback for 3D animations
     * @param {number} bpm - Beats per minute (default: 120)
     * @param {string} pattern - Rhythm pattern (default: 'straight')
     */
    startRhythm(bpm = 120, pattern = 'straight') {
        if (this.rhythm3DAdapter) {
            this.rhythm3DAdapter.start(bpm, pattern);
        }
    }

    /**
     * Stop rhythm playback
     */
    stopRhythm() {
        if (this.rhythm3DAdapter) {
            this.rhythm3DAdapter.stop();
        }
    }

    /**
     * Set rhythm BPM
     * @param {number} bpm - Beats per minute (20-360)
     */
    setRhythmBPM(bpm) {
        if (this.rhythm3DAdapter) {
            this.rhythm3DAdapter.setBPM(bpm);
        }
    }

    /**
     * Set rhythm pattern
     * @param {string} pattern - Pattern name: 'straight', 'swing', 'waltz', 'dubstep', etc.
     */
    setRhythmPattern(pattern) {
        if (this.rhythm3DAdapter) {
            this.rhythm3DAdapter.setPattern(pattern);
        }
    }

    /**
     * Set the active groove preset
     * Groove presets define the character of the ambient groove animation:
     * - 'groove1': Subtle, elegant - gentle bounce and sway (default)
     * - 'groove2': Energetic, bouncy - pronounced vertical motion
     * - 'groove3': Smooth, flowing - emphasis on rotation and sway
     *
     * @param {string} grooveName - Groove preset name ('groove1', 'groove2', 'groove3')
     * @param {Object} [options] - Transition options
     * @param {number} [options.bars] - Transition duration in bars (e.g., 2 = morph over 2 bars)
     * @param {number} [options.duration] - Transition duration in seconds (alternative to bars)
     */
    setGroove(grooveName, options = {}) {
        if (this.rhythm3DAdapter) {
            this.rhythm3DAdapter.setGroove(grooveName, options);
        }
    }

    /**
     * Get available groove preset names
     * @returns {string[]} Array of groove preset names
     */
    getGroovePresets() {
        if (this.rhythm3DAdapter) {
            return this.rhythm3DAdapter.getGroovePresets();
        }
        return ['groove1', 'groove2', 'groove3'];
    }

    /**
     * Get current groove preset name
     * @returns {string} Current groove preset name
     */
    getCurrentGroove() {
        if (this.rhythm3DAdapter) {
            return this.rhythm3DAdapter.getCurrentGroove();
        }
        return 'groove1';
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // IMPERATIVE BREATHING PHASE API (for meditation)
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Animate mascot scale for a breathing phase over a specified duration.
     * Used by meditation controller for precise breathing exercise timing.
     *
     * Scale targets:
     * - 'inhale': 1.0 → 1.3 (grow larger as lungs fill)
     * - 'exhale': current → 0.85 (shrink as lungs empty)
     * - 'hold': maintain current scale (no animation)
     *
     * @param {string} phase - 'inhale' | 'exhale' | 'hold'
     * @param {number} durationSec - Duration in seconds for the animation
     */
    breathePhase(phase, durationSec) {
        // Delegate to BreathingPhaseManager
        this.breathingPhaseManager.startPhase(phase, durationSec);
        const state = this.breathingPhaseManager.getState();
        console.log(`[Core3D] breathePhase: ${phase} for ${durationSec}s (${state.startScale.toFixed(2)} → ${state.targetScale.toFixed(2)})`);
    }

    /**
     * Stop any active breathing phase animation and reset to neutral scale
     */
    stopBreathingPhase() {
        this.breathingPhaseManager.stop();
        console.log('[Core3D] breathePhase stopped, scale reset to 1.0');
    }

    /**
     * Update imperative breathing phase animation
     * Called from render loop
     * @private
     * @param {number} deltaTime - Time since last frame in ms
     * @returns {number} Current breathing phase scale multiplier (1.0 if inactive)
     */
    _updateBreathingPhase(deltaTime) {
        // Delegate to BreathingPhaseManager
        return this.breathingPhaseManager.update(deltaTime);
    }

    /**
     * Morph to different shape with smooth transition
     * Supports interruption - calling this while a morph is in progress will
     * smoothly transition to the new target without visual glitches.
     *
     * @param {string} shapeName - Target geometry name
     * @param {number} duration - Transition duration in ms (default: 800ms)
     */
    morphToShape(shapeName, duration = 800) {
        const targetGeometryConfig = THREE_GEOMETRIES[shapeName];
        if (!targetGeometryConfig) {
            console.warn(`Unknown shape: ${shapeName}`);
            return;
        }

        // Start smooth morph transition (handles interruptions internally)
        const started = this.geometryMorpher.startMorph(
            this.geometryType,
            shapeName,
            duration
        );

        // If morph didn't start (already at target), skip
        if (!started) {
            return;
        }

        // Check if this was an interruption that changed the target
        // (getInterruptedTarget clears the flag after reading)
        this.geometryMorpher.getInterruptedTarget();

        // Pause blinks during morph (cleaner visual experience)
        this.blinkAnimator.pause();

        // Store target geometry for when morph completes
        this._targetGeometryConfig = targetGeometryConfig;
        this._targetGeometryType = shapeName;

        // Handle async geometry loaders (e.g., crystal OBJ)
        if (targetGeometryConfig.geometryLoader && !targetGeometryConfig.geometry) {
            // Start loading during shrink phase so it's ready for swap
            this._targetGeometry = null; // Will be set when loaded
            this._pendingGeometryLoad = targetGeometryConfig.geometryLoader(this.assetBasePath).then(geometry => {
                this._targetGeometry = geometry;
                // Also update the registry so subsequent morphs don't need to reload
                targetGeometryConfig.geometry = geometry;
                this._pendingGeometryLoad = null;
            });
        } else {
            this._targetGeometry = targetGeometryConfig.geometry;
            this._pendingGeometryLoad = null;
        }
    }

    /**
     * Check if a morph is currently in progress
     * @returns {boolean} True if morphing
     */
    isMorphing() {
        return this.geometryMorpher.isTransitioning;
    }

    /**
     * Get current morph state for debugging/UI
     * @returns {Object} Morph state including progress, target, etc.
     */
    getMorphState() {
        return this.geometryMorpher.getState();
    }

    /**
     * Start a grow-in animation from scale 0 to 1
     * Used for initial appearance of mascots (pop-in effect)
     * @param {number} duration - Duration in milliseconds (default: 500ms)
     */
    growIn(duration = 500) {
        this.geometryMorpher.growIn(this.geometryType, duration);
    }

    /**
     * Easing function for smooth transitions
     * @param {number} t - Progress (0.0 to 1.0)
     * @returns {number} - Eased progress
     */
    easeInOutCubic(t) {
        return t < 0.5
            ? 4 * t * t * t
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    /**
     * Render frame
     */
    render(deltaTime) {
        // Guard against calls after destroy
        if (this._destroyed) {
            return;
        }

        // Guard against rendering before geometry is ready (async loading)
        // This prevents Three.js errors during crystal/rough OBJ loading
        // Callers should use waitUntilReady() before starting render loop
        if (!this._ready) {
            return;
        }

        // Update animations
        this.animator.update(deltaTime);

        // Update geometry morph animation
        const morphState = this.geometryMorpher.update(deltaTime);

        // If waiting for async geometry to load, pause morph at midpoint
        if (morphState.shouldSwapGeometry && this._pendingGeometryLoad) {
            // Geometry still loading - pause at minimum scale until ready
            this.geometryMorpher.pauseAtSwap();
        }

        // Check if async geometry finished loading while paused
        if (morphState.waitingForGeometry && this._targetGeometry && !this._pendingGeometryLoad) {
            this.geometryMorpher.resumeFromSwap();
            // Re-trigger swap by setting hasSwappedGeometry back to false
            this.geometryMorpher.hasSwappedGeometry = false;
        }

        // Swap geometry at midpoint (when scale is at minimum) for smooth transition
        // Skip render for multiple frames after swap to let Three.js scene fully stabilize
        // Single-frame skip isn't enough - null refs can persist for 1-2 additional frames
        if (morphState.shouldSwapGeometry && this._targetGeometry) {
            // Skip render for 3 frames after swap to ensure scene is fully stable
            this._skipRenderFrames = 3;
            console.log('[Core3DManager] Morph swap starting, will skip render for 3 frames');
            // ═══════════════════════════════════════════════════════════════════
            // RESET OLD GEOMETRY STATE
            // Clear shader uniforms to defaults before swapping to prevent
            // visual remnants (e.g., blood moon effects bleeding to crystal)
            // ═══════════════════════════════════════════════════════════════════
            const oldGeometryType = this.geometryType;
            if (this.customMaterial) {
                resetGeometryState(oldGeometryType, this.customMaterial);
            }

            this.geometry = this._targetGeometry;
            this.geometryType = this._targetGeometryType;
            this.geometryConfig = this._targetGeometryConfig;

            // Dispose old custom material textures before creating new ones (prevent GPU memory leak)
            if (this.customMaterial) {
                // Use MaterialFactory for proper disposal of textures
                disposeCustomMaterial(this.customMaterial);
                // Then dispose the material itself
                this.renderer.disposeMaterial(this.customMaterial);
                this.customMaterial = null;
                this.customMaterialType = null;
            }

            // Check if target geometry needs custom material (e.g., moon, sun, future black hole)
            // Use MaterialFactory for centralized material creation
            let customMaterial = null;
            const emotionData = getEmotion(this.emotion);
            const materialResult = createCustomMaterial(this._targetGeometryType, this._targetGeometryConfig, {
                glowColor: this.glowColor || [1.0, 1.0, 0.95],
                glowIntensity: this.glowIntensity || 1.0,
                materialVariant: this.materialVariant,
                emotionData, // Pass emotion data for auto-deriving geometry params
                assetBasePath: this.assetBasePath
            });

            if (materialResult) {
                customMaterial = materialResult.material;
                this.customMaterial = customMaterial;
                this.customMaterialType = materialResult.type;
            }
            // Note: If not using custom material, references were already cleared above

            // Swap geometry (and material if custom)
            if (customMaterial) {
                this.renderer.swapGeometry(this.geometry, customMaterial);
            } else {
                this.renderer.swapGeometry(this.geometry);

                // Apply default glass mode for this geometry (only for non-custom materials)
                // Crystal and diamond have defaultGlassMode: true, others default to false
                const shouldEnableGlass = this._targetGeometryConfig.defaultGlassMode === true;
                this.setGlassMaterialEnabled(shouldEnableGlass);
            }

            // Invoke material swap callback immediately (before geometry becomes visible)
            // This allows presets to be applied while scale is still 0
            if (this.onMaterialSwap) {
                this.onMaterialSwap({
                    geometryType: this._targetGeometryType,
                    material: this.customMaterial,
                    materialType: this.customMaterialType
                });
            }

            // Update blink animator with new geometry's blink config
            this.blinkAnimator.setGeometry(this._targetGeometryConfig);

            // Reset Euler angles to upright [pitch=0, yaw=0, roll=0]
            this.rotation = [0, 0, 0];

            // Initialize effects for target geometry via EffectManager
            // This automatically disposes effects not needed for the target geometry
            const sunRadius = this.geometry.parameters?.radius || 0.5;
            this.effectManager.initializeForGeometry(this._targetGeometryType, {
                coreMesh: this.renderer.coreMesh,
                customMaterial: this.customMaterial,
                sunRadius
            });

            // Create or dispose crystal inner core (still uses createCrystalInnerCore for now)
            if (this._targetGeometryType === 'crystal' || this._targetGeometryType === 'rough' || this._targetGeometryType === 'heart' || this._targetGeometryType === 'star') {
                // Create inner core if morphing to crystal/rough/heart/star
                if (this.customMaterialType === 'crystal') {
                    this.createCrystalInnerCore();
                }
            } else {
                // Dispose inner core if morphing away from crystal/rough/heart/star
                if (this.crystalSoul) {
                    this.crystalSoul.dispose();
                    this.crystalSoul = null;
                    this.crystalInnerCore = null;
                    this.crystalInnerCoreMaterial = null;
                }
            }

            // Update behavior controller for target geometry
            // Build facing config for moon if needed
            let facingConfig = null;
            if (this._targetGeometryType === 'moon' && MOON_FACING_CONFIG.enabled) {
                const degToRad = Math.PI / 180;
                facingConfig = {
                    enabled: true,
                    strength: MOON_FACING_CONFIG.strength,
                    lockedFace: MOON_FACING_CONFIG.lockedFace,
                    lerpSpeed: MOON_FACING_CONFIG.lerpSpeed,
                    calibrationRotation: [
                        MOON_CALIBRATION_ROTATION.x * degToRad,
                        MOON_CALIBRATION_ROTATION.y * degToRad,
                        MOON_CALIBRATION_ROTATION.z * degToRad
                    ]
                };
            }

            // Configure behaviors for target geometry via controller
            // Note: emotionData is already declared above in this scope
            this.behaviorController.configureForMorph({
                targetGeometryType: this._targetGeometryType,
                emotionData,
                facingConfig,
                geometryRotation: null // No geometry-specific rotation during morph
            });

            // Handle moon-specific camera and controls
            if (this._targetGeometryType === 'moon') {
                // Disable OrbitControls camera rotation for moon (tidally locked)
                if (this.renderer?.controls) {
                    this.renderer.controls.autoRotate = false;
                }

                // Reset camera to front view INSTANTLY (immune to auto-rotate position)
                // This ensures moon always faces camera directly with calibrated orientation
                // Use instant reset (0ms) to avoid camera still moving during morph
                // preserveTarget=true keeps the Y offset set by the host app (emotive-holo)
                if (this.renderer?.setCameraPreset) {
                    this.renderer.setCameraPreset('front', 0, true);
                }

                // Apply calibrated rotation to show "Man in the Moon" Earth-facing view
                const degToRad = Math.PI / 180;
                this.calibrationRotation[0] = MOON_CALIBRATION_ROTATION.x * degToRad;
                this.calibrationRotation[1] = MOON_CALIBRATION_ROTATION.y * degToRad;
                this.calibrationRotation[2] = MOON_CALIBRATION_ROTATION.z * degToRad;
            } else {
                // Re-enable auto-rotate when morphing away from moon (if it was originally enabled)
                if (this.renderer?.controls && this.options.autoRotate !== false) {
                    this.renderer.controls.autoRotate = true;
                }

                // Set calibration rotation for crystal/rough/heart, clear for others
                if (this._targetGeometryType === 'crystal' || this._targetGeometryType === 'rough' || this._targetGeometryType === 'heart') {
                    const degToRad = Math.PI / 180;
                    this.calibrationRotation[0] = CRYSTAL_CALIBRATION_ROTATION.x * degToRad;
                    this.calibrationRotation[1] = CRYSTAL_CALIBRATION_ROTATION.y * degToRad;
                    this.calibrationRotation[2] = CRYSTAL_CALIBRATION_ROTATION.z * degToRad;
                } else {
                    // Clear calibration rotation for other geometries
                    this.calibrationRotation[0] = 0;
                    this.calibrationRotation[1] = 0;
                    this.calibrationRotation[2] = 0;
                }
            }
        }

        // Clean up on completion and resume blinks
        if (morphState.completed) {
            this._targetGeometry = null;
            this._targetGeometryType = null;
            this._targetGeometryConfig = null;

            // Resume blinks after morph completes (unless manually disabled)
            if (!this.blinkingManuallyDisabled) {
                this.blinkAnimator.resume();
            }
        }

        // Update breathing animation
        this.breathingAnimator.update(deltaTime, this.emotion, getUndertoneModifier(this.undertone));

        // Update imperative breathing phase (for meditation)
        const imperativeBreathScale = this._updateBreathingPhase(deltaTime);

        // Get breathing scale multiplier
        // If imperative breathing is active (scale != 1.0), use it exclusively
        // Otherwise fall back to ambient breathing if enabled
        const breathScale = (imperativeBreathScale !== 1.0)
            ? imperativeBreathScale
            : (this.breathingEnabled ? this.breathingAnimator.getBreathingScale() : 1.0);

        // Get morph scale multiplier (for shrink/grow effect)
        const morphScale = morphState.scaleMultiplier;

        // Update blink animation
        const blinkState = this.blinkAnimator.update(deltaTime);

        // Update all behaviors (rotation, righting, facing) via controller
        // This handles: ambient spin, self-stabilization, and tidal lock for moon
        this.behaviorController.update(deltaTime, this.baseEuler);

        // HARD LIMIT: Clamp pitch and roll to prevent lateral/dolphin tipping
        // No emotion should ever tip more than ~20 degrees from upright
        const MAX_TILT_ANGLE = 0.35; // ~20 degrees in radians
        this.baseEuler[0] = Math.max(-MAX_TILT_ANGLE, Math.min(MAX_TILT_ANGLE, this.baseEuler[0])); // Pitch (X)
        this.baseEuler[2] = Math.max(-MAX_TILT_ANGLE, Math.min(MAX_TILT_ANGLE, this.baseEuler[2])); // Roll (Z)
        // Yaw (Y) is left unclamped for free rotation

        // Convert base Euler to quaternion
        this.tempEuler.set(this.baseEuler[0], this.baseEuler[1], this.baseEuler[2], 'XYZ');
        this.baseQuaternion.setFromEuler(this.tempEuler);

        // ═══════════════════════════════════════════════════════════════════════════
        // UPDATE RHYTHM ADAPTER - Must happen before gesture blending
        // Always update - the adapter handles its own enabled/playing state
        // ═══════════════════════════════════════════════════════════════════════════
        if (this.rhythm3DAdapter) {
            this.rhythm3DAdapter.update(deltaTime);
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // GESTURE BLENDING SYSTEM - Blend multiple simultaneous gestures
        // ═══════════════════════════════════════════════════════════════════════════
        const blended = this.animationManager.blend(
            this.baseQuaternion,
            this.baseScale,
            this.baseGlowIntensity
        );

        // Get rhythm modulation (applies to gesture output)
        // Auto-detects if rhythm is playing (started by any system - audio manager, etc.)
        const rhythmMod = this.rhythm3DAdapter?.isPlaying()
            ? this.rhythm3DAdapter.getModulation()
            : null;

        // ═══════════════════════════════════════════════════════════════════════════
        // GROOVE + GESTURE BLENDING SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        // Two types of gestures:
        // 1. ABSOLUTE gestures (bounce, spin): Create their own motion, reduce groove to avoid conflict
        // 2. ACCENT gestures (pop, punch): Boost groove as punctuation, keep groove at full strength
        //
        // Key insight: Accent gestures work WITH the groove, not against it.

        // Determine groove blend factor based on gesture type
        // - Accent-only: Keep groove at 100% (accents enhance groove)
        // - Absolute gestures: Reduce groove to 30% (avoid competing animations)
        // - No gestures: Full groove
        const hasAbsolute = blended.hasAbsoluteGestures;
        blended.hasAccentGestures;

        // Smooth the groove blend transition to avoid discontinuity
        // Initialize if not set
        if (this._grooveBlendCurrent === undefined) {
            this._grooveBlendCurrent = 1.0;
        }

        // Initialize smoothed boost values (match groove smoothing for consistent feel)
        if (this._smoothedBoost === undefined) {
            this._smoothedBoost = {
                position: [0, 0, 0],
                rotation: [0, 0, 0],
                scale: 1.0
            };
        }

        // Target: 30% for absolute gestures, 100% for accent-only or no gestures
        const grooveBlendTarget = hasAbsolute ? 0.3 : 1.0;
        const dt = deltaTime / 1000;
        const t = 1 - Math.exp(-12 * dt);

        this._grooveBlendCurrent += (grooveBlendTarget - this._grooveBlendCurrent) * t;
        const grooveBlend = this._grooveBlendCurrent;

        // Smooth boost values toward their targets (same speed as groove)
        const targetPosBoost = blended.positionBoost || [0, 0, 0];
        const targetRotBoost = blended.rotationBoost || [0, 0, 0];
        const targetScaleBoost = blended.scaleBoost || 1.0;

        for (let i = 0; i < 3; i++) {
            this._smoothedBoost.position[i] += (targetPosBoost[i] - this._smoothedBoost.position[i]) * t;
            this._smoothedBoost.rotation[i] += (targetRotBoost[i] - this._smoothedBoost.rotation[i]) * t;
        }
        this._smoothedBoost.scale += (targetScaleBoost - this._smoothedBoost.scale) * t;

        // Use smoothed boost values (computed above) for all channels
        const posBoost = this._smoothedBoost.position;
        const rotBoost = this._smoothedBoost.rotation;
        const scaleBoost = this._smoothedBoost.scale;

        // ═══════════════════════════════════════════════════════════════════════════
        // CAMERA-RELATIVE POSITION: Transform view-space to world-space
        // ═══════════════════════════════════════════════════════════════════════════
        // This enables "tidally locked" gestures that move toward/away from camera
        // regardless of camera angle. View-space: Z = toward camera, Y = up, X = right
        let camRelWorldX = 0, camRelWorldY = 0, camRelWorldZ = 0;

        if (blended.hasCameraRelativeGestures && this.renderer.camera) {
            const cam = this.renderer.camera;
            const camRelPos = blended.cameraRelativePosition;

            // Get camera's basis vectors in world space
            // Forward = direction camera is looking (negative Z in camera space)
            // We want "toward camera" so we negate it
            if (!this._camTempVec3) {
                this._camTempVec3 = new Vector3();
                this._camRight = new Vector3();
                this._camUp = new Vector3();
                this._camForward = new Vector3();
            }

            // Ensure camera matrix is up to date
            cam.updateMatrixWorld();

            // Get camera direction (where it's looking)
            cam.getWorldDirection(this._camForward);

            // Right vector = camera's X axis in world space
            this._camRight.setFromMatrixColumn(cam.matrixWorld, 0);

            // Up vector = camera's Y axis in world space
            this._camUp.setFromMatrixColumn(cam.matrixWorld, 1);

            // Transform view-space position to world-space:
            // X (right in view) -> camera right
            // Y (up in view) -> camera up
            // Z (toward camera in view) -> negative camera forward
            camRelWorldX = this._camRight.x * camRelPos[0] + this._camUp.x * camRelPos[1] - this._camForward.x * camRelPos[2];
            camRelWorldY = this._camRight.y * camRelPos[0] + this._camUp.y * camRelPos[1] - this._camForward.y * camRelPos[2];
            camRelWorldZ = this._camRight.z * camRelPos[0] + this._camUp.z * camRelPos[1] - this._camForward.z * camRelPos[2];

            // Debug: log first few frames to verify
            if (!this._camRelDebugCount) this._camRelDebugCount = 0;
            if (this._camRelDebugCount < 3 && (camRelPos[0] !== 0 || camRelPos[1] !== 0 || camRelPos[2] !== 0)) {
                console.log('[CamRel] input:', camRelPos, '→ world:', [camRelWorldX, camRelWorldY, camRelWorldZ]);
                console.log('[CamRel] forward:', this._camForward.toArray(), 'right:', this._camRight.toArray());
                this._camRelDebugCount++;
            }
        }

        if (rhythmMod) {
            // ═══════════════════════════════════════════════════════════════════════
            // POSITION: Groove + Absolute gestures + Camera-relative + Accent boosts
            // ═══════════════════════════════════════════════════════════════════════
            // 1. Groove offset (scaled by grooveBlend)
            const grooveOffsetX = rhythmMod.grooveOffset[0] * grooveBlend;
            const grooveOffsetY = rhythmMod.grooveOffset[1] * grooveBlend;
            const grooveOffsetZ = rhythmMod.grooveOffset[2] * grooveBlend;

            // 2. Absolute gesture position (with rhythm multiplier)
            const posMult = hasAbsolute ? rhythmMod.positionMultiplier : 1.0;

            // 3. Combine: gesture + camera-relative + groove + smoothed boost
            this.position = [
                blended.position[0] * posMult + camRelWorldX + grooveOffsetX + posBoost[0],
                blended.position[1] * posMult + camRelWorldY + grooveOffsetY + posBoost[1],
                blended.position[2] * posMult + camRelWorldZ + grooveOffsetZ + posBoost[2]
            ];

            // ═══════════════════════════════════════════════════════════════════════
            // ROTATION: Groove sway + Absolute gestures + Accent boosts (smoothed)
            // ═══════════════════════════════════════════════════════════════════════
            this.rotation = [
                blended.rotation[0] + rhythmMod.grooveRotation[0] * grooveBlend + rotBoost[0],
                blended.rotation[1] + rhythmMod.grooveRotation[1] * grooveBlend + rotBoost[1],
                blended.rotation[2] + rhythmMod.grooveRotation[2] * grooveBlend + rotBoost[2]
            ];

            // ═══════════════════════════════════════════════════════════════════════
            // SCALE: Groove pulse × Absolute gestures × Accent boost (smoothed)
            // ═══════════════════════════════════════════════════════════════════════
            // grooveScale oscillates around 1.0, so we lerp toward 1.0 when reduced
            const grooveScaleEffect = 1.0 + (rhythmMod.grooveScale - 1.0) * grooveBlend;
            const scaleMult = hasAbsolute ? rhythmMod.scaleMultiplier : 1.0;

            this.scale = blended.scale * grooveScaleEffect * scaleMult * scaleBoost;
        } else {
            // No rhythm - apply gestures + camera-relative with smoothed boosts
            this.position = [
                blended.position[0] + camRelWorldX + posBoost[0],
                blended.position[1] + camRelWorldY + posBoost[1],
                blended.position[2] + camRelWorldZ + posBoost[2]
            ];
            this.rotation = [
                blended.rotation[0] + rotBoost[0],
                blended.rotation[1] + rotBoost[1],
                blended.rotation[2] + rotBoost[2]
            ];
            this.scale = blended.scale * scaleBoost;
        }

        // Only apply blended glow if no manual override is active
        if (this.glowIntensityOverride === null) {
            if (rhythmMod) {
                // Blend groove glow with gesture glow multiplier
                const grooveGlowEffect = 1.0 + (rhythmMod.grooveGlow - 1.0) * grooveBlend;
                const glowMult = hasAbsolute ? rhythmMod.glowMultiplier : 1.0;
                this.glowIntensity = blended.glowIntensity * grooveGlowEffect * glowMult;
            } else {
                this.glowIntensity = blended.glowIntensity;
            }
        }
        this.gestureQuaternion = blended.gestureQuaternion;
        this.glowBoost = blended.glowBoost || 0; // For isolated glow layer

        // Apply blink effects (AFTER gestures, blending with other animations)
        if (blinkState.isBlinking) {
            // Apply blink rotation (additive to gesture rotation)
            if (blinkState.rotation) {
                this.rotation[0] += blinkState.rotation[0];
                this.rotation[1] += blinkState.rotation[1];
                this.rotation[2] += blinkState.rotation[2];
            }
        }

        // Calculate final scale: gesture * morph * breathing * BLINK * crystal shell scale
        // Crystal/diamond don't squish on blink - they use energy pulse instead
        // Use Y-axis blink scale (primary squish axis) for uniform application
        const shouldApplyBlinkScale = this.geometryType !== 'crystal' && this.geometryType !== 'rough';
        const blinkScale = (blinkState.isBlinking && shouldApplyBlinkScale) ? blinkState.scale[1] : 1.0;
        const crystalShellScale = this.crystalShellBaseScale || 2.0;  // Default shell size
        const finalScale = this.scale * morphScale * breathScale * blinkScale * crystalShellScale;

        // ═══════════════════════════════════════════════════════════════════════════
        // PARTICLE SYSTEM UPDATE & RENDERING (Orchestrated)
        // ═══════════════════════════════════════════════════════════════════════════
        // Only check particleVisibility (runtime toggle), not particlesEnabled (initial config)
        if (this.particleVisibility && this.particleOrchestrator) {
            // Calculate actual 3D core radius in world units
            // This ensures particles orbit at consistent distance regardless of screen size
            // Crystal shell scale is the main factor (default 2.0)
            // particleRadiusMultiplier adjusts for different geometry shapes/sizes
            const particleRadiusMultiplier = this.geometryConfig?.particleRadiusMultiplier || 1.0;
            const coreRadius3D = (this.crystalShellBaseScale || 2.0) * this.scale * breathScale * particleRadiusMultiplier;

            // Delegate all particle logic to orchestrator
            this.particleOrchestrator.update(
                deltaTime,
                this.emotion,
                this.undertone,
                this.animationManager.getActiveAnimations(), // Active gestures
                this.animationManager.getTime(),             // Current animation time
                { x: this.position[0], y: this.position[1], z: this.position[2] }, // Core position
                { width: this.canvas.width, height: this.canvas.height }, // Canvas size
                // Rotation state for orbital physics
                {
                    euler: this.baseEuler,
                    quaternion: this.baseQuaternion,
                    angularVelocity: this.behaviorController.getAngularVelocity()
                },
                this.baseScale, // Pass base scale only (shader handles perspective)
                coreRadius3D    // Pass actual 3D core radius for particle orbit distance
            );
        }

        // Calculate effective glow intensity (blink boost applied at render time, non-mutating)
        // Use multiplicative blending (1.0 + boost) so fade can still reach 0
        const blinkBoostMultiplier = blinkState.isBlinking && blinkState.glowBoost ? (1.0 + blinkState.glowBoost) : 1.0;

        // Respect coreGlowEnabled toggle for both glass and glow modes
        // When disabled, set intensity to 0 which hides inner core and emissive glow
        // Also multiply by virtual particle opacity for fade/ghost effects
        const baseIntensity = this.coreGlowEnabled
            ? this.glowIntensity * blinkBoostMultiplier
            : 0.0;

        const virtualParticle = this.emotiveEngine?.getVirtualParticle();
        const opacity = virtualParticle?.opacity ?? 1.0;
        const effectiveGlowIntensity = baseIntensity * opacity;

        // Update bloom pass with effective glow intensity (smooth transitions)
        // Use faster transition during geometry morphs for quicker bloom adaptation
        const bloomTransitionSpeed = morphState.isTransitioning ? 0.3 : 0.1;
        this.renderer.updateBloom(effectiveGlowIntensity, bloomTransitionSpeed, this.geometryType);

        // Update isolated glow layer for gesture effects (glow/flash)
        // This is a separate screen-space effect that doesn't affect baseline appearance
        if (this.glowBoost > 0 || (this.renderer.glowLayer && this.renderer.glowLayer.isActive())) {
            // Get world position of core mesh for glow center
            const worldPosition = this.coreMesh?.position;
            this.renderer.updateGlowLayer(this.glowBoost, this.glowColor, worldPosition, deltaTime);
        }

        // Update sun material animation if using sun geometry
        if (this.customMaterialType === 'sun') {
            updateSunMaterial(this.coreMesh, this.glowColor, effectiveGlowIntensity, deltaTime);
        }

        // Moon: glowIntensity affects subtle emotion-colored glow (very subtle effect, * 0.02 in shader)
        // Unlike crystals, moon doesn't have a "core" that glows - it's a textured lit sphere
        if ((this.customMaterialType === 'moon' || this.customMaterialType === 'moon-multiplexer') && this.customMaterial) {
            if (this.customMaterial.uniforms && this.customMaterial.uniforms.glowIntensity) {
                this.customMaterial.uniforms.glowIntensity.value = effectiveGlowIntensity;
            }
        }

        // Update crystal material if using crystal blend-layers geometry
        if (this.customMaterialType === 'crystal' && this.customMaterial) {
            // Only update uniforms if material is a ShaderMaterial with uniforms
            if (this.customMaterial.uniforms) {
                // Update time for animation (convert ms to seconds for sane speed values)
                this.customMaterial.uniforms.time.value += deltaTime / 1000;

                // Update glow intensity - respects coreGlowEnabled toggle
                if (this.customMaterial.uniforms.glowIntensity) {
                    this.customMaterial.uniforms.glowIntensity.value = effectiveGlowIntensity;
                }

                // Normalize emotion color for consistent perceived brightness across all emotions
                // This ensures yellow (joy) doesn't wash out the soul while blue (sadness) stays visible
                // IMPORTANT: Use glowColor (RGB), not glowColorHex - glowColor has undertone saturation applied
                const normalized = normalizeRGBLuminance(this.glowColor, 0.30);
                const normalizedColor = [normalized.r, normalized.g, normalized.b];

                // Update emotion color on outer shell (luminance-normalized)
                this.customMaterial.uniforms.emotionColor.value.setRGB(
                    normalizedColor[0], normalizedColor[1], normalizedColor[2]
                );
                // Update blink intensity for energy pulse (smooth sine curve during blink)
                if (this.customMaterial.uniforms.blinkIntensity) {
                    const blinkPulse = blinkState.isBlinking ? Math.sin(blinkState.progress * Math.PI) : 0;
                    this.customMaterial.uniforms.blinkIntensity.value = blinkPulse;
                }
            }
            // Update inner core color and animation (also use normalized color)
            // Only update if core glow is enabled
            // IMPORTANT: Use glowColor (RGB), not glowColorHex - glowColor has undertone saturation applied
            if (this.coreGlowEnabled) {
                const normalizedCore = normalizeRGBLuminance(this.glowColor, 0.30);
                const normalizedCoreColor = [normalizedCore.r, normalizedCore.g, normalizedCore.b];
                this.updateCrystalInnerCore(normalizedCoreColor, deltaTime);
            }
        }

        // Skip render for multiple frames after morph swap
        // This prevents Three.js from iterating the scene while it's stabilizing
        // The mascot is at scale ~0 during swap anyway, so skipping a few frames is invisible
        if (this._skipRenderFrames > 0) {
            this._skipRenderFrames--;
            console.log(`[Core3DManager] Skipping render, ${this._skipRenderFrames} frames remaining`);
            return;
        }

        // Render with Three.js
        this.renderer.render({
            position: this.position,
            rotation: this.rotation,
            scale: finalScale,
            glowColor: this.glowColor,
            glowColorHex: this.glowColorHex,  // For bloom luminance normalization
            glowIntensity: effectiveGlowIntensity,
            hasActiveGesture: this.animationManager.hasActiveAnimations(),  // Faster lerp during gestures
            calibrationRotation: this.calibrationRotation,  // Applied on top of animated rotation
            solarEclipse: this.effectManager.getSolarEclipse(),  // Pass eclipse manager for synchronized updates
            deltaTime,  // Pass deltaTime for eclipse animation
            morphProgress: morphState.isTransitioning ? morphState.visualProgress : null  // For corona fade-in
        });

        // Update lunar eclipse animation (Blood Moon)
        this.effectManager.updateLunarEclipse(deltaTime);
    }

    /**
     * Load async geometry (e.g., OBJ models) and set up mesh when ready
     * Uses GeometryCache for caching to prevent race conditions and duplicate loads
     *
     * IMPORTANT: This is fully async and completes BEFORE render() should be called.
     * Use isReady() or await waitUntilReady() before starting render loop.
     * @private
     * @returns {Promise<void>}
     */
    async _loadAsyncGeometry() {
        try {
            // Use GeometryCache for proper caching - this ensures:
            // 1. Multiple calls during React Strict Mode don't cause duplicate loads
            // 2. Preloaded geometry is reused instantly
            // 3. Race conditions are avoided
            const cached = await preload(this.geometryType, {
                glowColor: this.glowColor || [1.0, 1.0, 0.95],
                glowIntensity: this.glowIntensity || 1.0,
                materialVariant: this.materialVariant,
                emotionData: getEmotion(this.emotion),
                assetBasePath: this.assetBasePath
            });


            // CRITICAL: Check if destroyed during async load (React Strict Mode can unmount during load)
            if (this._destroyed) {
                return;
            }

            if (!cached || !cached.geometry) {
                console.warn(`[Core3D:${this._instanceId}] Async geometry load returned null!`);
                this._ready = true;
                return;
            }

            // Clone the cached geometry so each instance has its own copy
            const loadedGeometry = cached.geometry.clone();

            // Store geometry type
            loadedGeometry.userData.geometryType = this.geometryType;
            this.geometry = loadedGeometry;

            if (this._deferredMeshCreation) {
                // First time: create mesh with loaded geometry (no fallback was shown)
                this.coreMesh = this.renderer.createCoreMesh(loadedGeometry, this.customMaterial);

                // Check again - createCoreMesh could take time
                if (this._destroyed) {
                    return;
                }

                // Create inner core for crystal - do this SYNCHRONOUSLY before marking ready
                // CrystalSoul will load its inclusion geometry asynchronously, but we wait for it
                if (this.customMaterialType === 'crystal') {
                    await this._createCrystalInnerCoreAsync();
                    // Check AGAIN after async operation
                    if (this._destroyed) {
                        return;
                    }
                }

                this._deferredMeshCreation = false;
            } else if (this.coreMesh) {
                // Existing mesh: swap geometry
                const oldGeometry = this.coreMesh.geometry;
                this.coreMesh.geometry = loadedGeometry;

                // Dispose old procedural geometry
                if (oldGeometry && oldGeometry !== loadedGeometry) {
                    oldGeometry.dispose();
                }

                // Check again
                if (this._destroyed) {
                    return;
                }

                // Recreate inner core if crystal
                if (this.customMaterialType === 'crystal') {
                    await this._createCrystalInnerCoreAsync();
                    // Check AGAIN after async operation
                    if (this._destroyed) {
                        return;
                    }
                }
            }

            // Final check before marking ready - don't set ready on destroyed instance
            if (this._destroyed) {
                return;
            }

            // NOW we're fully ready for rendering
            this._logSceneHierarchy();
            this._ready = true;
        } catch (error) {
            console.warn(`[Core3D:${this._instanceId}] Async geometry load FAILED:`, error);
            // Mark ready even on failure so render doesn't hang (unless destroyed)
            if (!this._destroyed) {
                this._ready = true;
            }
        }
    }

    /**
     * Debug: Log scene hierarchy
     * @private
     */
    _logSceneHierarchy() {
        const scene = this.renderer?.scene;
        if (!scene) {
            return;
        }
        scene.children.forEach((child, i) => {
            const status = child === null ? 'NULL!' :
                child === undefined ? 'UNDEFINED!' :
                    child.visible === null ? 'visible=NULL!' :
                        child.visible === undefined ? 'visible=UNDEF!' : 'OK';
            console.log(`  [${i}] ${child?.name || child?.type || 'UNKNOWN'} status=${status} uuid=${child?.uuid?.slice(0,8) || 'N/A'}`);
        });
    }

    /**
     * Create crystal inner core and wait for its async geometry to load
     * @private
     * @returns {Promise<void>}
     */
    async _createCrystalInnerCoreAsync() {

        // Dispose existing soul if present
        if (this.crystalSoul) {
            this.crystalSoul.dispose();
            this.crystalSoul = null;
        }

        if (!this.coreMesh) {
            return;
        }

        // Preload the inclusion geometry BEFORE creating CrystalSoul
        // This ensures the soul mesh has its final geometry before being added to scene
        await CrystalSoul._loadInclusionGeometry(this.assetBasePath);

        // Check if destroyed during async load
        if (this._destroyed || !this.coreMesh) {
            return;
        }

        // Create new soul - geometry is already cached so it will be used immediately
        this.crystalSoul = new CrystalSoul({
            radius: 0.35,
            detail: 1,
            geometryType: this.geometryType,
            renderer: this.renderer,
            assetBasePath: this.assetBasePath
        });

        // Attach to coreMesh - this adds soul to the scene
        this.crystalSoul.attachTo(this.coreMesh, this.renderer?.scene);

        // Geometry-specific shell and soul sizes (permanent values)
        let soulScale = 1.0;  // Default: full size (HUGE)
        if (this.geometryType === 'heart') {
            this.crystalShellBaseScale = 2.4;
            soulScale = 1.0;  // Full size for heart
        } else if (this.geometryType === 'rough') {
            this.crystalShellBaseScale = 1.6;
            soulScale = 1.0;  // Full size for rough
        } else if (this.geometryType === 'crystal') {
            soulScale = 1.0;  // Full size for crystal
        }

        this.crystalSoul.baseScale = soulScale;
        this.crystalSoul.mesh.scale.setScalar(soulScale);

        // Respect coreGlowEnabled toggle state
        this.crystalSoul.setVisible(this.coreGlowEnabled);

        // Legacy references for backwards compatibility
        this.crystalInnerCore = this.crystalSoul.mesh;
        this.crystalInnerCoreMaterial = this.crystalSoul.material;
        this.crystalInnerCoreBaseScale = this.crystalSoul.baseScale;
    }

    /**
     * Check if the manager is fully initialized and ready for rendering
     * @returns {boolean}
     */
    isReady() {
        return this._ready;
    }

    /**
     * Wait until the manager is fully initialized
     * Use this before starting your render loop for geometries with async loading (crystal, rough, heart)
     * @returns {Promise<void>}
     */
    async waitUntilReady() {
        if (this._ready) return;
        if (this._readyPromise) {
            await this._readyPromise;
        }
    }

    /**
     * Cleanup
     */
    destroy() {
        // Log SYNCHRONOUSLY with all state at time of call
        ({
            id: this._instanceId,
            ready: this._ready,
            destroyed: this._destroyed,
            hasCrystalSoul: !!this.crystalSoul,
            hasRenderer: !!this.renderer
        });

        // Set destroyed flag first to prevent any pending render calls
        this._destroyed = true;

        // Clean up crystal soul FIRST - before renderer.destroy() clears the scene
        // This ensures we properly remove the mesh from scene before scene is cleared
        if (this.crystalSoul) {
            this.crystalSoul.dispose();
            this.crystalSoul = null;
            this.crystalInnerCore = null;
            this.crystalInnerCoreMaterial = null;
        }

        // Clean up particle system (remove from scene before destroying)
        if (this.particleOrchestrator) {
            // Get particle points reference before destroying
            const particleRenderer = this.particleOrchestrator.renderer;
            if (particleRenderer) {
                const points = particleRenderer.getPoints();
                if (points && this.renderer?.scene) {
                    this.renderer.scene.remove(points);
                }
            }
            this.particleOrchestrator.destroy();
            this.particleOrchestrator = null;
        }

        // Clean up effect manager (handles eclipse and crystal soul disposal)
        // Note: EffectManager.dispose() removes eclipse meshes from scene internally
        if (this.effectManager) {
            this.effectManager.dispose();
            this.effectManager = null;
        }

        // Clean up behavior controller
        if (this.behaviorController) {
            this.behaviorController.dispose();
            this.behaviorController = null;
        }

        // Clean up breathing phase manager
        if (this.breathingPhaseManager) {
            this.breathingPhaseManager.dispose();
            this.breathingPhaseManager = null;
        }

        // Dispose custom material textures if they exist
        if (this.customMaterial) {
            this.renderer.disposeMaterial(this.customMaterial);
            this.customMaterial = null;
            this.customMaterialType = null;
        }

        // Dispose facing behavior
        if (this.facingBehavior) {
            this.facingBehavior.dispose();
            this.facingBehavior = null;
        }

        // Stop animations before destroying renderer
        this.animationManager.stopAll();

        // Destroy renderer LAST (after all scene children are cleaned up)
        this.renderer.destroy();

        // Clean up animation manager (includes virtual particle pool)
        this.animationManager.dispose();
        this.animationManager = null;

        // Clean up animator sub-components
        this.animator.destroy?.();
        this.breathingAnimator.destroy?.();
        this.gestureBlender.destroy?.();
        this.geometryMorpher.destroy?.();
        this.blinkAnimator.destroy?.();

        // Clean up behavior controller (disposes all behavior objects)
        this.behaviorController.dispose();
        this.behaviorController = null;

        // Clean up temp THREE.js objects
        this.tempEuler = null;
        this.baseQuaternion = null;
        this.gestureQuaternion = null;

        // Clean up geometry references
        this.geometry = null;
        this.geometryConfig = null;
        this._targetGeometry = null;
        this._targetGeometryConfig = null;
        this._targetGeometryType = null;

        // Clean up canvas and options references
        this.canvas = null;
        this.options = null;

        // Clean up core mesh reference
        this.coreMesh = null;

        // Clean up rhythm engine reference
        this.rhythmEngine = null;

        // Clean up rhythm 3D adapter (don't destroy singleton, just clear reference)
        this.rhythm3DAdapter = null;

        // Clean up emotive engine reference
        this.emotiveEngine = null;

        // Dispose geometry cache
        dispose();
    }

    /**
     * Map emotion to appropriate groove preset
     * Energetic emotions use bounce groove, calm emotions use subtle groove,
     * flowing/zen emotions use the flowing zen groove
     * @private
     * @param {string} emotion - Emotion name
     * @returns {string} Groove preset name
     */
    _getEmotionGroove(emotion) {
        const emotionGrooveMap = {
            // Energetic emotions → groove2 (bouncy, energetic)
            happy: 'groove2',
            excited: 'groove2',
            amused: 'groove2',
            silly: 'groove2',
            surprised: 'groove2',

            // Calm/subtle emotions → groove1 (subtle, elegant)
            calm: 'groove1',
            neutral: 'groove1',
            sad: 'groove1',
            content: 'groove1',
            focused: 'groove1',
            bored: 'groove1',
            tired: 'groove1',
            sleepy: 'groove1',

            // Flowing/zen emotions → groove3 (flowing, zen)
            zen: 'groove3',
            love: 'groove3',
            grateful: 'groove3',
            inspired: 'groove3',
            hopeful: 'groove3',
            proud: 'groove3',

            // Intense emotions → groove2 with strong beats
            angry: 'groove2',
            anxious: 'groove2',
            determined: 'groove2'
        };

        return emotionGrooveMap[emotion] || 'groove1';
    }

    /**
     * Preload all geometry assets for instant morphing
     * Call this during app initialization for best UX
     * @returns {Promise<void>}
     */
    async preloadGeometries() {
        const options = {
            glowColor: this.glowColor || [1.0, 1.0, 0.95],
            glowIntensity: this.glowIntensity || 1.0,
            materialVariant: this.materialVariant,
            emotionData: getEmotion(this.emotion)
        };

        await preloadAll(options);
    }
}

/**
 * Event Manager
 * Centralized event listener management to prevent memory leaks
 *
 * @module core/EventManager
 * @version 1.0.0
 */

/**
 * Manages all event listeners to ensure proper cleanup
 */
class EventManager {
    constructor() {
        // Track all registered listeners
        this.listeners = new Map();

        // Track listener groups for batch operations
        this.groups = new Map();

        // Auto-cleanup on page unload
        // Removed unload handler - not needed and causes violations

        // Stats
        this.stats = {
            registered: 0,
            removed: 0,
            active: 0
        };
    }

    /**
     * Register an event listener
     * @param {EventTarget} target - Event target (element, window, document, etc.)
     * @param {string} eventType - Event type (click, resize, etc.)
     * @param {Function} handler - Event handler function
     * @param {Object} options - addEventListener options
     * @param {string} group - Optional group name for batch operations
     * @returns {string} Listener ID for later removal
     */
    addEventListener(target, eventType, handler, options = {}, group = 'default') {
        // Generate unique ID
        const id = this.generateId();

        // Create listener info
        const listenerInfo = {
            id,
            target,
            eventType,
            handler,
            options,
            group,
            active: true
        };

        // Store listener
        this.listeners.set(id, listenerInfo);

        // Add to group
        if (!this.groups.has(group)) {
            this.groups.set(group, new Set());
        }
        this.groups.get(group).add(id);

        // Actually add the listener
        target.addEventListener(eventType, handler, options);

        // Update stats
        this.stats.registered++;
        this.stats.active++;

        return id;
    }

    /**
     * Remove an event listener by ID
     * @param {string} id - Listener ID
     * @returns {boolean} Success status
     */
    removeEventListener(id) {
        const listenerInfo = this.listeners.get(id);

        if (!listenerInfo || !listenerInfo.active) {
            return false;
        }

        // Remove the actual listener
        listenerInfo.target.removeEventListener(
            listenerInfo.eventType,
            listenerInfo.handler,
            listenerInfo.options
        );

        // Mark as inactive
        listenerInfo.active = false;

        // Remove from group
        const group = this.groups.get(listenerInfo.group);
        if (group) {
            group.delete(id);
            if (group.size === 0) {
                this.groups.delete(listenerInfo.group);
            }
        }

        // Remove from listeners map
        this.listeners.delete(id);

        // Update stats
        this.stats.removed++;
        this.stats.active--;

        return true;
    }

    /**
     * Remove all listeners in a group
     * @param {string} group - Group name
     * @returns {number} Number of listeners removed
     */
    removeGroup(group) {
        const groupSet = this.groups.get(group);

        if (!groupSet) {
            return 0;
        }

        let removed = 0;

        for (const id of groupSet) {
            if (this.removeEventListener(id)) {
                removed++;
            }
        }

        return removed;
    }

    /**
     * Remove all listeners for a specific target
     * @param {EventTarget} target - Event target
     * @returns {number} Number of listeners removed
     */
    removeAllForTarget(target) {
        let removed = 0;

        for (const [id, info] of this.listeners.entries()) {
            if (info.target === target && info.active) {
                if (this.removeEventListener(id)) {
                    removed++;
                }
            }
        }

        return removed;
    }

    /**
     * Remove all listeners of a specific type
     * @param {string} eventType - Event type
     * @returns {number} Number of listeners removed
     */
    removeAllOfType(eventType) {
        let removed = 0;

        for (const [id, info] of this.listeners.entries()) {
            if (info.eventType === eventType && info.active) {
                if (this.removeEventListener(id)) {
                    removed++;
                }
            }
        }

        return removed;
    }

    /**
     * Remove all listeners
     * @returns {number} Number of listeners removed
     */
    removeAll() {
        let removed = 0;

        for (const [id, info] of this.listeners.entries()) {
            if (info.active) {
                if (this.removeEventListener(id)) {
                    removed++;
                }
            }
        }

        return removed;
    }

    /**
     * Create a bound listener that auto-removes
     * @param {EventTarget} target - Event target
     * @param {string} eventType - Event type
     * @param {Function} handler - Event handler
     * @param {Object} options - Options
     * @returns {Object} Controller with remove method
     */
    createAutoRemove(target, eventType, handler, options = {}) {
        const id = this.addEventListener(target, eventType, handler, options);

        return {
            id,
            remove: () => this.removeEventListener(id)
        };
    }

    /**
     * Add listener that fires only once
     * @param {EventTarget} target - Event target
     * @param {string} eventType - Event type
     * @param {Function} handler - Event handler
     * @param {Object} options - Options
     * @returns {string} Listener ID
     */
    once(target, eventType, handler, options = {}) {
        const wrappedHandler = event => {
            handler(event);
            this.removeEventListener(id);
        };

        const id = this.addEventListener(target, eventType, wrappedHandler, options);

        return id;
    }

    /**
     * Debounced event listener
     * @param {EventTarget} target - Event target
     * @param {string} eventType - Event type
     * @param {Function} handler - Event handler
     * @param {number} delay - Debounce delay in ms
     * @param {Object} options - Options
     * @returns {string} Listener ID
     */
    debounced(target, eventType, handler, delay = 250, options = {}) {
        let timeoutId;

        const debouncedHandler = event => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => handler(event), delay);
        };

        return this.addEventListener(target, eventType, debouncedHandler, options);
    }

    /**
     * Throttled event listener
     * @param {EventTarget} target - Event target
     * @param {string} eventType - Event type
     * @param {Function} handler - Event handler
     * @param {number} limit - Throttle limit in ms
     * @param {Object} options - Options
     * @returns {string} Listener ID
     */
    throttled(target, eventType, handler, limit = 100, options = {}) {
        let inThrottle = false;

        const throttledHandler = event => {
            if (!inThrottle) {
                handler(event);
                inThrottle = true;
                setTimeout(() => {
                    inThrottle = false;
                }, limit);
            }
        };

        return this.addEventListener(target, eventType, throttledHandler, options);
    }

    // Removed setupUnloadHandler - causes permission violations
    // Browser automatically cleans up event listeners on unload

    /**
     * Generate unique ID
     * @private
     * @returns {string} Unique ID
     */
    generateId() {
        return `listener_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Get statistics
     * @returns {Object} Statistics
     */
    getStats() {
        return {
            ...this.stats,
            groups: this.groups.size,
            listeners: this.listeners.size
        };
    }

    /**
     * Get active listeners for debugging
     * @returns {Array} Active listener info
     */
    getActiveListeners() {
        const active = [];

        for (const [id, info] of this.listeners.entries()) {
            if (info.active) {
                active.push({
                    id,
                    eventType: info.eventType,
                    group: info.group,
                    target: info.target.constructor.name
                });
            }
        }

        return active;
    }

    /**
     * Check for potential memory leaks
     * @returns {Object} Leak analysis
     */
    analyzeLeaks() {
        const analysis = {
            totalListeners: this.listeners.size,
            activeListeners: this.stats.active,
            inactiveButNotRemoved: 0,
            byTarget: new Map(),
            byType: new Map(),
            potentialLeaks: []
        };

        for (const [id, info] of this.listeners.entries()) {
            // Count by target
            const targetName = info.target.constructor.name;
            analysis.byTarget.set(
                targetName,
                (analysis.byTarget.get(targetName) || 0) + 1
            );

            // Count by type
            analysis.byType.set(
                info.eventType,
                (analysis.byType.get(info.eventType) || 0) + 1
            );

            // Check for inactive but not removed
            if (!info.active) {
                analysis.inactiveButNotRemoved++;
                analysis.potentialLeaks.push({
                    id,
                    eventType: info.eventType,
                    target: targetName
                });
            }
        }

        // Convert maps to objects for easier reading
        analysis.byTarget = Object.fromEntries(analysis.byTarget);
        analysis.byType = Object.fromEntries(analysis.byType);

        return analysis;
    }

    /**
     * Clean up inactive listeners
     * @returns {number} Number cleaned
     */
    cleanup() {
        let cleaned = 0;

        for (const [id, info] of this.listeners.entries()) {
            if (!info.active) {
                this.listeners.delete(id);
                cleaned++;
            }
        }

        return cleaned;
    }

    /**
     * Destroy the event manager and remove all listeners
     * @returns {number} Number of listeners removed
     */
    destroy() {
        const count = this.removeAll();
        this.listeners.clear();
        this.groups.clear();
        this.stats = {
            registered: 0,
            removed: 0,
            active: 0
        };
        return count;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                       ◐ ◑ ◒ ◓  ERROR BOUNDARY  ◓ ◒ ◑ ◐                       
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Error Boundary - Error Handling & Recovery System
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module ErrorBoundary
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The SAFETY NET of the Emotive Engine. Catches errors, provides fallbacks,         
 * ║ logs issues for debugging, and attempts recovery to keep the animation            
 * ║ running even when things go wrong. Never let the orb die!                         
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🛡️ ERROR HANDLING FEATURES                                                        
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Try-catch wrapping for all critical functions                                   
 * │ • Safe default values for all emotional states                                    
 * │ • Error logging with context and timestamps                                       
 * │ • Automatic error suppression after threshold                                     
 * │ • Recovery attempts with exponential backoff                                      
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔄 FALLBACK VALUES                                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • emotion       : 'neutral' (safe default state)                                  
 * │ • gesture       : null (no animation)                                             
 * │ • audioLevel    : 0 (silent)                                                      
 * │ • particleCount : 0 (no particles)                                                
 * │ • glowIntensity : 0.7 (moderate glow)                                             
 * │ • color         : '#B0B0B0' (neutral gray)                                        
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 📊 VALIDATION LISTS                                                               
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ VALID EMOTIONS:                                                                   
 * │   neutral, joy, sadness, anger, fear, surprise, disgust, love,                    
 * │   suspicion, resting, connecting, thinking, speaking, zen, focused                
 * │                                                                                    
 * │ VALID UNDERTONES:                                                                 
 * │   nervous, confident, tired, intense, subdued                                     
 * │                                                                                    
 * │ VALID GESTURES:                                                                    
 * │   bounce, pulse, shake, spin, nod, tilt, expand, contract, flash,                 
 * │   drift, breathe, wave, slowBlink, jump, breathHold                               
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚠️  ERROR THRESHOLDS                                                              
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Max errors in log      : 10 (then rotates)                                      
 * │ • Errors before suppress : 3 per context                                          
 * │ • Recovery max attempts  : 3                                                      
 * │ • Recovery backoff       : 100ms * 2^attempt                                      
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                           USING ERROR BOUNDARY                                    
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ // Wrap any risky function:                                                       
 * ║ const safeFunction = errorBoundary.wrap(riskyFunction, 'context', fallback);      
 * ║                                                                                    
 * ║ // Validate input:                                                                
 * ║ const validEmotion = errorBoundary.validateInput(input, 'emotion', 'neutral');    
 * ║                                                                                    
 * ║ // Attempt recovery:                                                              
 * ║ await errorBoundary.attemptRecovery('render', retryFn, 3);                        
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */
class ErrorBoundary {
    constructor() {
        this.errors = [];
        this.maxErrors = 10;
        this.errorCounts = new Map();
        
        // Safe default values for various contexts
        this.defaults = {
            emotion: 'neutral',
            gesture: null,
            audioLevel: 0,
            particleCount: 0,
            glowIntensity: 0.7,
            coreSize: 1.0,
            breathRate: 1.0,
            color: '#B0B0B0'
        };
    }

    /**
     * Wraps a function with error handling
     * @param {Function} fn - Function to wrap
     * @param {string} context - Context description for error logging
     * @param {*} fallbackValue - Value to return on error
     * @returns {Function} Wrapped function
     */
    wrap(fn, context, fallbackValue = null) {
        return (...args) => {
            try {
                return fn(...args);
            } catch (error) {
                this.logError(error, context);
                return fallbackValue !== null ? fallbackValue : this.getDefault(context);
            }
        };
    }

    /**
     * Logs an error with context and timestamp
     * @param {Error} error - The error object
     * @param {string} context - Context where the error occurred
     */
    logError(error, context) {
        const timestamp = new Date().toISOString();
        const errorEntry = {
            timestamp,
            context,
            message: error.message,
            stack: error.stack
        };

        // Add to error log
        this.errors.push(errorEntry);
        
        // Maintain error count per context
        const count = this.errorCounts.get(context) || 0;
        this.errorCounts.set(context, count + 1);

        // Rotate error log if it gets too large
        if (this.errors.length > this.maxErrors) {
            this.errors.shift();
        }
    }

    /**
     * Gets a safe default value for a given context
     * @param {string} context - The context to get default for
     * @returns {*} Safe default value
     */
    getDefault(context) {
        // Context-specific defaults
        const contextDefaults = {
            'emotion-transition': this.defaults.emotion,
            'gesture-execution': this.defaults.gesture,
            'audio-processing': this.defaults.audioLevel,
            'particle-system': this.defaults.particleCount,
            'rendering': {
                glowIntensity: this.defaults.glowIntensity,
                coreSize: this.defaults.coreSize,
                color: this.defaults.color
            },
            'canvas-operations': null,
            'state-management': this.defaults.emotion
        };

        return Object.prototype.hasOwnProperty.call(contextDefaults, context) ? contextDefaults[context] : null;
    }

    /**
     * Validates input parameters and returns safe values
     * @param {*} value - Value to validate
     * @param {string} type - Expected type
     * @param {*} defaultValue - Default value if validation fails
     * @returns {*} Validated value or default
     */
    validateInput(value, type, defaultValue) {
        try {
            switch (type) {
            case 'emotion': {
                const validEmotions = ['neutral', 'joy', 'sadness', 'anger', 'fear', 'surprise', 'disgust', 'love', 'euphoria'];
                return validEmotions.includes(value) ? value : defaultValue;
            }
                
            case 'undertone': {
                const validUndertones = ['nervous', 'confident', 'tired', 'intense', 'subdued'];
                return value === null || validUndertones.includes(value) ? value : null;
            }
                
            case 'gesture': {
                const validGestures = ['bounce', 'pulse', 'shake', 'spin', 'nod', 'tilt', 'expand', 'contract', 'flash', 'drift'];
                return validGestures.includes(value) ? value : defaultValue;
            }
                
            case 'number':
                return typeof value === 'number' && !isNaN(value) ? value : defaultValue;
                
            case 'string':
                return typeof value === 'string' ? value : defaultValue;
                
            case 'boolean':
                return typeof value === 'boolean' ? value : defaultValue;
                
            default:
                return value !== undefined && value !== null ? value : defaultValue;
            }
        } catch (error) {
            this.logError(error, 'input-validation');
            return defaultValue;
        }
    }

    /**
     * Checks if a context has exceeded error threshold
     * @param {string} context - Context to check
     * @param {number} threshold - Error threshold (default: 5)
     * @returns {boolean} True if threshold exceeded
     */
    hasExceededThreshold(context, threshold = 5) {
        return (this.errorCounts.get(context) || 0) >= threshold;
    }

    /**
     * Gets error statistics
     * @returns {Object} Error statistics
     */
    getErrorStats() {
        return {
            totalErrors: this.errors.length,
            errorsByContext: Object.fromEntries(this.errorCounts),
            recentErrors: this.errors.slice(-5)
        };
    }

    /**
     * Clears error history
     */
    clearErrors() {
        this.errors = [];
        this.errorCounts.clear();
    }

    /**
     * Attempts to recover from a failed operation
     * @param {string} operation - The operation that failed
     * @param {Function} retryFn - Function to retry
     * @param {number} maxRetries - Maximum retry attempts
     * @returns {Promise} Recovery attempt result
     */
    async attemptRecovery(operation, retryFn, maxRetries = 3) {
        let attempts = 0;
        
        while (attempts < maxRetries) {
            try {
                return await retryFn();
            } catch (error) {
                attempts++;
                this.logError(error, `recovery-${operation}-attempt-${attempts}`);
                
                if (attempts >= maxRetries) {
                    throw new Error(`Recovery failed for ${operation} after ${maxRetries} attempts`);
                }
                
                // Exponential backoff
                await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempts) * 100));
            }
        }
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - SSS Material Presets
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Predefined subsurface scattering material presets for crystal geometries
 * @author Emotive Engine Team
 * @module 3d/presets/SSSPresets
 *
 * These presets configure the SSS (Subsurface Scattering) shader uniforms to create
 * realistic gemstone-like materials: quartz, emerald, ruby, sapphire, amethyst, etc.
 */

/**
 * SSS preset definitions
 * Each preset contains uniform values for the SSS shader
 */
const SSSPresets = {
    quartz: {
        sssStrength: 0.8,
        sssAbsorption: [2.8, 2.9, 3.0],
        sssScatterDistance: [0.2, 0.2, 0.25],
        sssThicknessBias: 0.60,
        sssThicknessScale: 1.8,
        sssCurvatureScale: 3.0,
        sssAmbient: 0.12,
        frostiness: 0.15,
        innerGlowStrength: 0.20,
        fresnelIntensity: 1.5,
        causticIntensity: 1.2,
        emotionColorBleed: 0.0
    },
    emerald: {
        sssStrength: 2.0,
        sssAbsorption: [0.05, 4.0, 0.1],
        sssScatterDistance: [0.1, 0.5, 0.1],
        sssThicknessBias: 0.65,
        sssThicknessScale: 1.8,
        sssCurvatureScale: 3.0,
        sssAmbient: 0.10,
        frostiness: 0.20,
        innerGlowStrength: 0.15,
        fresnelIntensity: 1.2,
        causticIntensity: 1.0,
        emotionColorBleed: 0.35
    },
    ruby: {
        sssStrength: 1.8,
        sssAbsorption: [4.0, 0.03, 0.08],
        sssScatterDistance: [0.4, 0.04, 0.08],
        sssThicknessBias: 0.65,
        sssThicknessScale: 1.9,
        sssCurvatureScale: 2.5,
        sssAmbient: 0.08,
        frostiness: 0.12,
        innerGlowStrength: 0.12,
        fresnelIntensity: 1.2,
        causticIntensity: 1.15,
        emotionColorBleed: 0.35
    },
    sapphire: {
        sssStrength: 2.2,
        sssAbsorption: [0.15, 0.4, 4.0],
        sssScatterDistance: [0.1, 0.15, 0.5],
        sssThicknessBias: 0.65,
        sssThicknessScale: 1.8,
        sssCurvatureScale: 3.0,
        sssAmbient: 0.10,
        frostiness: 0.18,
        innerGlowStrength: 0.15,
        fresnelIntensity: 1.3,
        causticIntensity: 1.0,
        emotionColorBleed: 0.35
    },
    amethyst: {
        sssStrength: 2.5,
        sssAbsorption: [3.0, 0.05, 4.5],
        sssScatterDistance: [0.4, 0.05, 0.5],
        sssThicknessBias: 0.70,
        sssThicknessScale: 2.0,
        sssCurvatureScale: 3.0,
        sssAmbient: 0.08,
        frostiness: 0.18,
        innerGlowStrength: 0.12,
        fresnelIntensity: 1.4,
        causticIntensity: 1.0,
        emotionColorBleed: 0.35
    },
    topaz: {
        sssStrength: 1.5,
        sssAbsorption: [3.5, 2.0, 0.1],
        sssScatterDistance: [0.3, 0.2, 0.05],
        sssThicknessBias: 0.60,
        sssThicknessScale: 1.7,
        sssCurvatureScale: 2.8,
        sssAmbient: 0.12,
        frostiness: 0.14,
        innerGlowStrength: 0.18,
        fresnelIntensity: 1.4,
        causticIntensity: 1.1,
        emotionColorBleed: 0.25
    },
    citrine: {
        sssStrength: 1.6,
        sssAbsorption: [3.8, 2.5, 0.05],
        sssScatterDistance: [0.35, 0.25, 0.05],
        sssThicknessBias: 0.58,
        sssThicknessScale: 1.6,
        sssCurvatureScale: 2.6,
        sssAmbient: 0.14,
        frostiness: 0.12,
        innerGlowStrength: 0.22,
        fresnelIntensity: 1.3,
        causticIntensity: 1.2,
        emotionColorBleed: 0.20
    },
    diamond: {
        sssStrength: 0.5,
        sssAbsorption: [2.5, 2.5, 2.5],
        sssScatterDistance: [0.15, 0.15, 0.15],
        sssThicknessBias: 0.55,
        sssThicknessScale: 1.5,
        sssCurvatureScale: 4.0,
        sssAmbient: 0.15,
        frostiness: 0.08,
        innerGlowStrength: 0.25,
        fresnelIntensity: 2.0,
        causticIntensity: 1.5,
        emotionColorBleed: 0.0
    }
};

/**
 * Apply an SSS preset to a mascot's custom material
 * @param {Object} mascot - The EmotiveMascot3D instance
 * @param {string} presetName - Name of the preset to apply
 * @returns {boolean} True if preset was applied successfully
 */
function applySSSPreset(mascot, presetName) {
    if (!presetName || !mascot?.core3D?.customMaterial?.uniforms) {
        return false;
    }

    const preset = SSSPresets[presetName];
    if (!preset) {
        return false;
    }

    const u = mascot.core3D.customMaterial.uniforms;

    // Apply all preset values to uniforms
    if (u.sssStrength) u.sssStrength.value = preset.sssStrength;
    if (u.sssAbsorption) u.sssAbsorption.value.set(...preset.sssAbsorption);
    if (u.sssScatterDistance) u.sssScatterDistance.value.set(...preset.sssScatterDistance);
    if (u.sssThicknessBias) u.sssThicknessBias.value = preset.sssThicknessBias;
    if (u.sssThicknessScale) u.sssThicknessScale.value = preset.sssThicknessScale;
    if (u.sssCurvatureScale) u.sssCurvatureScale.value = preset.sssCurvatureScale;
    if (u.sssAmbient) u.sssAmbient.value = preset.sssAmbient;
    if (u.frostiness) u.frostiness.value = preset.frostiness;
    if (u.innerGlowStrength) u.innerGlowStrength.value = preset.innerGlowStrength;
    if (u.fresnelIntensity) u.fresnelIntensity.value = preset.fresnelIntensity;
    if (preset.causticIntensity !== undefined && u.causticIntensity) {
        u.causticIntensity.value = preset.causticIntensity;
    }
    if (u.emotionColorBleed) {
        u.emotionColorBleed.value = preset.emotionColorBleed ?? 0.0;
    }

    return true;
}

/**
 * Get list of available preset names
 * @returns {string[]} Array of preset names
 */
function getPresetNames() {
    return Object.keys(SSSPresets);
}

/**
 * Get a specific preset's configuration
 * @param {string} name - Preset name
 * @returns {Object|null} Preset configuration or null if not found
 */
function getPreset(name) {
    return SSSPresets[name] || null;
}

/**
 * Intent Tokenizer
 *
 * Breaks down natural language intent strings into tokens for parsing.
 * Handles multi-word phrases, punctuation, and normalization.
 *
 * @module core/intent/tokenizer
 */

/**
 * Known multi-word phrases that should be kept together
 * Order matters - longer phrases should come first
 */
const MULTI_WORD_PHRASES = [
    // Gestures (3+ words)
    'bouncing up and down', 'hopping around', 'rocking back and forth',
    'side to side', 'light on feet', 'spring in step',
    'leaning forward', 'leaning in', 'leaning closer', 'leaning toward',
    'reaching out', 'reaching toward', 'pointing at', 'pointing to',
    'waving hello', 'waving goodbye', 'nodding head', 'shaking head',
    'head shake', 'head nod', 'head bob', 'head tilt',
    'deep breath', 'taking a breath', 'breathing deeply',
    'settling down', 'calming down', 'winding down',
    'getting bigger', 'getting smaller', 'puffing up',
    'spinning around', 'twirling around',

    // Emotions (2-3 words)
    'at peace', 'in love', 'on cloud nine', 'over the moon',
    'on top of the world', 'in awe', 'grossed out', 'freaked out',
    'low key', 'low-key', 'high key',

    // Undertones (2 words)
    'on edge', 'keyed up', 'wound up',
    'low energy', 'no energy', 'running low',

    // Modifiers (2-3 words)
    'just a bit', 'just a little', 'a little bit',
    'kind of', 'sort of', 'a bit', 'a little', 'a lot',
    'over the top', 'off the charts', 'through the roof',
    'split second', 'one time', 'few times', 'many times',
    'again and again', 'over and over', 'on repeat',

    // Shapes (2 words)
    'blood moon', 'full moon', 'new moon', 'half moon',
    'solar eclipse', 'lunar eclipse', 'total eclipse',
    'ring of fire', 'diamond ring',

    // Slang (2 words)
    'killing it', 'crushing it', 'nailed it',
    'sussy baka', 'side eye'
];

/**
 * Characters that act as separators between intent components
 */
const SEPARATORS = /[,;|\/]+/;

/**
 * Words to strip (articles, filler words that don't affect meaning)
 */
const FILLER_WORDS = new Set([
    'a', 'an', 'the',
    'is', 'are', 'am', 'be', 'being', 'been',
    'i', 'me', 'my',
    'it', 'its',
    'to', 'of', 'for', 'with', 'as',
    'this', 'that', 'these', 'those',
    'just', 'only', 'also', 'too',
    'please', 'pls', 'plz'
]);

/**
 * Words that should NOT be stripped even though they look like filler
 * (they have meaning in our context)
 */
const KEEP_WORDS = new Set([
    'but', 'and', 'or', 'yet', 'while', 'although', // Connectors matter
    'not', 'no', 'never', // Negations matter
    'very', 'really', 'so', 'quite', 'rather', // Modifiers matter
    'slightly', 'barely', 'extremely', 'completely', // Modifiers matter
    'feeling', 'feel', 'feels', // Context hints
    'become', 'becoming', 'morph', 'morphing' // Shape context
]);

/**
 * Normalize a string for matching
 * @param {string} str - Input string
 * @returns {string} Normalized string
 */
function normalize(str) {
    return str
        .toLowerCase()
        .trim()
        .replace(/['']/g, "'")  // Normalize quotes
        .replace(/[""]/g, '"')
        .replace(/\s+/g, ' ');  // Collapse whitespace
}

/**
 * Extract multi-word phrases from input, replacing them with placeholders
 * @param {string} input - Normalized input string
 * @returns {{ processed: string, phrases: Map<string, string> }}
 */
function extractPhrases(input) {
    const phrases = new Map();
    let processed = input;
    let placeholderIndex = 0;

    for (const phrase of MULTI_WORD_PHRASES) {
        const phraseNorm = normalize(phrase);
        if (processed.includes(phraseNorm)) {
            const placeholder = `__PHRASE_${placeholderIndex}__`;
            processed = processed.replace(new RegExp(phraseNorm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), placeholder);
            phrases.set(placeholder, phraseNorm);
            placeholderIndex++;
        }
    }

    return { processed, phrases };
}

/**
 * Tokenize an intent string into meaningful tokens
 *
 * @param {string} intent - Natural language intent string
 * @returns {Object} Tokenization result
 * @returns {string[]} returns.tokens - Array of normalized tokens
 * @returns {string[]} returns.segments - Original segments split by separators
 * @returns {Map<string, string>} returns.phrases - Multi-word phrases found
 *
 * @example
 * tokenize('happy, bouncing up and down')
 * // Returns:
 * // {
 * //   tokens: ['happy', 'bouncing up and down'],
 * //   segments: ['happy', 'bouncing up and down'],
 * //   phrases: Map { '__PHRASE_0__' => 'bouncing up and down' }
 * // }
 */
function tokenize(intent) {
    if (!intent || typeof intent !== 'string') {
        return { tokens: [], segments: [], phrases: new Map() };
    }

    // Normalize input
    const normalized = normalize(intent);

    // Extract multi-word phrases first
    const { processed, phrases } = extractPhrases(normalized);

    // Split by separators to get segments
    const rawSegments = processed.split(SEPARATORS)
        .map(s => s.trim())
        .filter(s => s.length > 0);

    // Process each segment
    const tokens = [];
    const segments = [];

    for (const segment of rawSegments) {
        // Restore phrases in segment for display
        let displaySegment = segment;
        for (const [placeholder, phrase] of phrases) {
            displaySegment = displaySegment.replace(placeholder, phrase);
        }
        segments.push(displaySegment.trim());

        // Split segment into words
        const words = segment.split(/\s+/);

        for (const word of words) {
            // Check if it's a phrase placeholder
            if (phrases.has(word)) {
                tokens.push(phrases.get(word));
                continue;
            }

            // Skip empty
            if (!word) continue;

            // Check if it's a filler word (but respect KEEP_WORDS)
            if (FILLER_WORDS.has(word) && !KEEP_WORDS.has(word)) {
                continue;
            }

            // Clean punctuation from edges
            const cleaned = word.replace(/^[^\w]+|[^\w]+$/g, '');
            if (cleaned) {
                tokens.push(cleaned);
            }
        }
    }

    return { tokens, segments, phrases };
}

/**
 * Check if a token is a connector word
 * @param {string} token - Token to check
 * @returns {boolean}
 */
function isConnector(token) {
    return ['but', 'and', 'or', 'yet', 'while', 'although', 'with'].includes(token);
}

/**
 * Check if a token is a negation
 * @param {string} token - Token to check
 * @returns {boolean}
 */
function isNegation(token) {
    return ['not', 'no', 'never', "don't", 'dont', "doesn't", 'doesnt', "isn't", 'isnt'].includes(token);
}

/**
 * Conflict Resolution Rules
 *
 * Handles cases where a word or phrase could map to multiple categories.
 * Provides disambiguation rules and context hints for the parser.
 *
 * @module core/intent/synonyms/conflicts
 */

/**
 * Words that exist in multiple synonym categories
 * Maps word → array of potential categories with priority
 *
 * Priority order (highest to lowest):
 * 1. emotion - Primary emotional state
 * 2. gesture - Physical action
 * 3. shape - Visual form
 * 4. undertone - Emotional modifier
 * 5. modifier - Intensity/timing
 */
const conflictRules = {
    // ═══════════════════════════════════════════════════════════════════
    // EMOTION vs UNDERTONE conflicts
    // ═══════════════════════════════════════════════════════════════════

    // "nervous" could be emotion (fear variant) or undertone
    nervous: {
        candidates: [
            { category: 'emotion', target: 'fear', priority: 1 },
            { category: 'undertone', target: 'nervous', priority: 2 }
        ],
        // If standalone, it's an emotion. If modifying another emotion, it's undertone.
        rule: 'standalone_is_emotion',
        examples: [
            { input: 'nervous', resolved: { emotion: 'fear' } },
            { input: 'happy but nervous', resolved: { emotion: 'joy', undertone: 'nervous' } }
        ]
    },

    // "anxious" - similar to nervous
    anxious: {
        candidates: [
            { category: 'emotion', target: 'fear', priority: 1 },
            { category: 'undertone', target: 'nervous', priority: 2 }
        ],
        rule: 'standalone_is_emotion'
    },

    // "confident" could be emotion (trust/pride) or undertone
    confident: {
        candidates: [
            { category: 'emotion', target: 'trust', priority: 2 },
            { category: 'undertone', target: 'confident', priority: 1 }
        ],
        // Confident is more often used as a modifier
        rule: 'prefer_undertone',
        examples: [
            { input: 'confident', resolved: { undertone: 'confident' } },
            { input: 'feeling confident', resolved: { emotion: 'trust' } }
        ]
    },

    // "tired" could be emotion (sadness variant) or undertone
    tired: {
        candidates: [
            { category: 'emotion', target: 'sadness', priority: 2 },
            { category: 'undertone', target: 'tired', priority: 1 }
        ],
        rule: 'prefer_undertone',
        examples: [
            { input: 'tired', resolved: { undertone: 'tired' } },
            { input: 'feeling tired', resolved: { emotion: 'sadness', undertone: 'tired' } }
        ]
    },

    // "intense" - modifier or undertone
    intense: {
        candidates: [
            { category: 'undertone', target: 'intense', priority: 1 },
            { category: 'modifier', target: 'intensity.very', priority: 2 }
        ],
        rule: 'prefer_undertone'
    },

    // ═══════════════════════════════════════════════════════════════════
    // EMOTION vs GESTURE conflicts
    // ═══════════════════════════════════════════════════════════════════

    // "curious" could be emotion (focused) or gesture (lean)
    curious: {
        candidates: [
            { category: 'emotion', target: 'focused', priority: 1 },
            { category: 'gesture', target: 'lean', priority: 2 }
        ],
        rule: 'standalone_is_emotion',
        examples: [
            { input: 'curious', resolved: { emotion: 'focused' } },
            { input: 'curious, leaning in', resolved: { emotion: 'focused', gesture: 'lean' } }
        ]
    },

    // "interested" - similar to curious
    interested: {
        candidates: [
            { category: 'emotion', target: 'focused', priority: 1 },
            { category: 'gesture', target: 'lean', priority: 2 }
        ],
        rule: 'standalone_is_emotion'
    },

    // "excited" could be emotion or gesture (bounce)
    excited: {
        candidates: [
            { category: 'emotion', target: 'joy', priority: 1 },
            { category: 'gesture', target: 'bounce', priority: 3 }
        ],
        rule: 'standalone_is_emotion'
    },

    // "shaking" could be emotion (fear) or gesture (shake)
    shaking: {
        candidates: [
            { category: 'gesture', target: 'shake', priority: 1 },
            { category: 'emotion', target: 'fear', priority: 2 }
        ],
        rule: 'standalone_is_gesture'
    },

    // "nodding" - gesture primarily
    nodding: {
        candidates: [
            { category: 'gesture', target: 'nod', priority: 1 }
        ],
        rule: 'always_gesture'
    },

    // ═══════════════════════════════════════════════════════════════════
    // GESTURE vs SHAPE conflicts
    // ═══════════════════════════════════════════════════════════════════

    // "glowing" could be gesture or shape modifier
    glowing: {
        candidates: [
            { category: 'gesture', target: 'glow', priority: 1 },
            { category: 'shape', target: 'sun', priority: 3 }
        ],
        rule: 'standalone_is_gesture'
    },

    // "spinning" - gesture
    spinning: {
        candidates: [
            { category: 'gesture', target: 'spin', priority: 1 }
        ],
        rule: 'always_gesture'
    },

    // ═══════════════════════════════════════════════════════════════════
    // EMOTION vs SHAPE conflicts
    // ═══════════════════════════════════════════════════════════════════

    // "love" could be emotion or shape (heart)
    love: {
        candidates: [
            { category: 'emotion', target: 'love', priority: 1 },
            { category: 'shape', target: 'heart', priority: 2 }
        ],
        rule: 'standalone_is_emotion',
        examples: [
            { input: 'love', resolved: { emotion: 'love' } },
            { input: 'love heart', resolved: { emotion: 'love', shape: 'heart' } },
            { input: 'become love', resolved: { shape: 'heart' } }
        ]
    },

    // "suspicious" could be emotion or shape
    suspicious: {
        candidates: [
            { category: 'emotion', target: 'suspicion', priority: 1 },
            { category: 'shape', target: 'suspicion', priority: 2 }
        ],
        rule: 'standalone_is_emotion'
    },

    // "bright" could be emotion (joy) or shape (sun/star)
    bright: {
        candidates: [
            { category: 'emotion', target: 'joy', priority: 2 },
            { category: 'shape', target: 'sun', priority: 3 },
            { category: 'modifier', target: 'intensity.very', priority: 4 }
        ],
        rule: 'context_dependent'
    },

    // ═══════════════════════════════════════════════════════════════════
    // AGREEMENT/DISAGREEMENT - Gesture specific
    // ═══════════════════════════════════════════════════════════════════

    // "yes" - nod gesture
    yes: {
        candidates: [
            { category: 'gesture', target: 'nod', priority: 1 }
        ],
        rule: 'always_gesture'
    },

    // "no" - shake gesture
    no: {
        candidates: [
            { category: 'gesture', target: 'shake', priority: 1 }
        ],
        rule: 'always_gesture'
    },

    // "agree" - could be gesture or emotion
    agree: {
        candidates: [
            { category: 'gesture', target: 'nod', priority: 1 },
            { category: 'emotion', target: 'trust', priority: 2 }
        ],
        rule: 'standalone_is_gesture'
    },

    // "disagree" - shake gesture
    disagree: {
        candidates: [
            { category: 'gesture', target: 'shake', priority: 1 }
        ],
        rule: 'always_gesture'
    }
};

/**
 * Context hints that help disambiguate
 * If these words appear nearby, they suggest a particular category
 */
const contextHints = {
    // Words that suggest emotion context
    emotionContext: [
        'feeling', 'feel', 'feels', 'felt',
        'emotion', 'emotional', 'emotionally',
        'mood', 'moody', 'state',
        'am', 'is', 'are', 'being',
        'becoming', 'become', 'grew', 'growing'
    ],

    // Words that suggest gesture context
    gestureContext: [
        'do', 'doing', 'does', 'did',
        'perform', 'performing', 'action',
        'move', 'moving', 'movement',
        'start', 'starting', 'begin', 'beginning',
        'physically', 'motion'
    ],

    // Words that suggest shape context
    shapeContext: [
        'morph', 'morphing', 'morphed',
        'transform', 'transforming', 'transformed',
        'become', 'becoming', 'turn into',
        'shape', 'form', 'look like',
        'change to', 'change into'
    ],

    // Words that suggest undertone context
    undertoneContext: [
        'but', 'yet', 'while', 'although',
        'with', 'and also', 'mixed with',
        'underneath', 'underlying', 'beneath',
        'a bit', 'slightly', 'somewhat'
    ],

    // Words that suggest modifier context
    modifierContext: [
        'very', 'really', 'so', 'extremely',
        'slightly', 'barely', 'completely',
        'quickly', 'slowly', 'briefly'
    ]
};

/**
 * Resolution rules explained:
 *
 * standalone_is_emotion: If the word appears alone without other context,
 *   treat it as an emotion. If it appears with another emotion word, it
 *   becomes an undertone or gesture modifier.
 *
 * standalone_is_gesture: If the word appears alone, treat it as a gesture.
 *
 * prefer_undertone: Default to undertone interpretation unless "feeling"
 *   or other emotion context words are present.
 *
 * always_gesture: This word is always interpreted as a gesture.
 *
 * context_dependent: Look at surrounding words to determine category.
 *   Falls back to highest priority if no context helps.
 */

/**
 * Conflict Resolver
 *
 * Resolves ambiguous tokens that could map to multiple categories.
 * Uses context, priority rules, and co-occurrence to disambiguate.
 *
 * @module core/intent/conflictResolver
 */


/**
 * Check if context words suggest a particular category
 * @param {string[]} tokens - All tokens in the intent
 * @param {number} tokenIndex - Index of the ambiguous token
 * @param {string} category - Category to check for
 * @returns {boolean} Whether context suggests this category
 */
function hasContextFor(tokens, tokenIndex, category) {
    const hints = contextHints[`${category}Context`];
    if (!hints) return false;

    // Check tokens before and after (within 3 positions)
    const start = Math.max(0, tokenIndex - 3);
    const end = Math.min(tokens.length, tokenIndex + 4);

    for (let i = start; i < end; i++) {
        if (i === tokenIndex) continue;
        if (hints.includes(tokens[i])) {
            return true;
        }
    }

    return false;
}

/**
 * Check if another token of a specific category exists
 * @param {Object} parsed - Current parsed result
 * @param {string} category - Category to check
 * @returns {boolean}
 */
function hasCategory(parsed, category) {
    switch (category) {
    case 'emotion':
        return parsed.emotion !== null;
    case 'gesture':
        return parsed.gestures && parsed.gestures.length > 0;
    case 'shape':
        return parsed.shape !== null;
    case 'undertone':
        return parsed.undertone !== null;
    default:
        return false;
    }
}

/**
 * Resolve a conflicting token to its most appropriate category
 *
 * @param {string} token - The ambiguous token
 * @param {string[]} allTokens - All tokens in the intent
 * @param {number} tokenIndex - Index of this token
 * @param {Object} currentParsed - Current parsing state
 * @returns {Object|null} Resolution { category, target } or null if no conflict
 *
 * @example
 * resolve('nervous', ['nervous'], 0, {})
 * // Returns: { category: 'emotion', target: 'fear' }
 *
 * resolve('nervous', ['happy', 'but', 'nervous'], 2, { emotion: 'joy' })
 * // Returns: { category: 'undertone', target: 'nervous' }
 */
function resolve(token, allTokens, tokenIndex, currentParsed) {
    const rule = conflictRules[token];

    // No conflict for this token
    if (!rule) {
        return null;
    }

    const { candidates, rule: ruleName } = rule;

    // Single candidate - no actual conflict
    if (candidates.length === 1) {
        return candidates[0];
    }

    // Apply the specific rule
    switch (ruleName) {
    case 'standalone_is_emotion': {
        // If we already have an emotion, this becomes undertone/gesture
        if (hasCategory(currentParsed, 'emotion')) {
            // Find first non-emotion candidate
            const nonEmotion = candidates.find(c => c.category !== 'emotion');
            if (nonEmotion) return nonEmotion;
        }
        // Check for emotion context words
        if (hasContextFor(allTokens, tokenIndex, 'emotion')) {
            return candidates.find(c => c.category === 'emotion') || candidates[0];
        }
        // Default to emotion
        return candidates.find(c => c.category === 'emotion') || candidates[0];
    }

    case 'standalone_is_gesture': {
        // If we already have this gesture type, maybe it's something else
        if (hasCategory(currentParsed, 'gesture')) {
            const nonGesture = candidates.find(c => c.category !== 'gesture');
            if (nonGesture) return nonGesture;
        }
        // Check for gesture context words
        if (hasContextFor(allTokens, tokenIndex, 'gesture')) {
            return candidates.find(c => c.category === 'gesture') || candidates[0];
        }
        // Default to gesture
        return candidates.find(c => c.category === 'gesture') || candidates[0];
    }

    case 'prefer_undertone': {
        // If emotion context is explicit, use emotion
        if (hasContextFor(allTokens, tokenIndex, 'emotion')) {
            return candidates.find(c => c.category === 'emotion') || candidates[0];
        }
        // Default to undertone
        return candidates.find(c => c.category === 'undertone') || candidates[0];
    }

    case 'always_gesture':
        return candidates.find(c => c.category === 'gesture') || candidates[0];

    case 'always_emotion':
        return candidates.find(c => c.category === 'emotion') || candidates[0];

    case 'context_dependent': {
        // Check each category's context
        for (const category of ['emotion', 'gesture', 'shape', 'undertone']) {
            if (hasContextFor(allTokens, tokenIndex, category)) {
                const match = candidates.find(c => c.category === category);
                if (match) return match;
            }
        }
        // Fall back to highest priority
        return candidates.sort((a, b) => a.priority - b.priority)[0];
    }

    default:
        // Unknown rule, use priority
        return candidates.sort((a, b) => a.priority - b.priority)[0];
    }
}

/**
 * Check if a token has potential conflicts
 * @param {string} token - Token to check
 * @returns {boolean}
 */
function hasConflict(token) {
    return token in conflictRules;
}

/**
 * Emotion Synonyms
 *
 * Maps natural language words to the 15 canonical emotions.
 * Organized by intensity and register (formal, casual, slang, regional).
 *
 * @module core/intent/synonyms/emotions
 */

const emotions = {
    // ═══════════════════════════════════════════════════════════════════
    // NEUTRAL - Absence of strong emotion, default state
    // ═══════════════════════════════════════════════════════════════════
    neutral: [
        // Direct
        'neutral', 'default', 'normal', 'baseline', 'standard',

        // Absence descriptors
        'nothing special', 'nothing particular', 'no strong feeling',
        'not much', 'meh', 'whatever', 'indifferent',

        // Equilibrium
        'balanced', 'even', 'steady', 'stable', 'centered',
        'level', 'middle ground', 'in between',

        // Waiting states
        'ready', 'waiting', 'standing by', 'at attention',
        'present', 'here', 'available', 'attentive',

        // Reset
        'reset', 'clear', 'blank', 'empty', 'clean slate'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // JOY - Happiness, pleasure, positive feelings
    // ═══════════════════════════════════════════════════════════════════
    joy: [
        // Core
        'happy', 'joy', 'joyful', 'joyous',

        // Mild happiness
        'pleased', 'glad', 'content', 'satisfied', 'gratified',
        'comfortable', 'good',

        // Medium happiness
        'cheerful', 'cheery', 'merry', 'jovial', 'jolly',
        'upbeat', 'sunny', 'bright', 'lighthearted', 'buoyant',

        // Strong happiness
        'delighted', 'thrilled', 'overjoyed', 'elated',
        'jubilant', 'exultant', 'gleeful',

        // Warm happiness
        'glowing', 'beaming', 'radiant',

        // Slang - American
        'pumped', 'stoked', 'psyched', 'amped', 'hyped',

        // Slang - Internet/Gen-Z
        'vibing', 'living', 'slaying', 'winning',
        'lit', 'fire', 'sick', 'dope',

        // British
        'chuffed', 'pleased as punch', 'over the moon', 'made up',
        'tickled', 'tickled pink',

        // Formal
        'felicitous', 'beatific', 'blissful',

        // Action-oriented
        'smiling', 'grinning', 'laughing', 'giggling'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // CALM - Peace, tranquility, relaxation
    // ═══════════════════════════════════════════════════════════════════
    calm: [
        // Core
        'calm', 'peaceful', 'serene', 'tranquil',

        // Relaxation
        'relaxed', 'at ease', 'comfortable', 'loose',
        'unwound', 'decompressed', 'chilled',

        // Stillness
        'still', 'quiet', 'hushed', 'silent', 'soft',
        'gentle', 'mild', 'placid', 'smooth',

        // Mental calm
        'composed', 'collected', 'centered', 'grounded',
        'untroubled', 'unworried', 'unbothered', 'unfazed',

        // Meditative
        'meditative', 'zen', 'mindful',
        'contemplative', 'reflective', 'introspective',

        // Physical relaxation
        'soothed', 'eased', 'mellowed', 'softened',

        // Slang
        'chill', 'coasting', 'floating', 'drifting',
        'laid back', 'easy going', 'low key',

        // British
        'sorted', 'easy peasy'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // EXCITED - High energy, enthusiasm, anticipation
    // ═══════════════════════════════════════════════════════════════════
    excited: [
        // Core
        'excited', 'exciting', 'excitable',

        // Enthusiasm
        'enthusiastic', 'eager', 'keen', 'avid',
        'passionate', 'fervent', 'ardent', 'zealous',

        // Energy
        'energetic', 'energized', 'animated', 'lively',
        'spirited', 'vivacious', 'vibrant', 'dynamic',
        'bouncy', 'peppy', 'perky', 'sprightly',

        // Anticipation
        'anticipating', 'expectant', 'looking forward',
        'itching', 'raring', 'chomping at the bit',

        // Intensity
        'fired up', 'charged', 'electric', 'electrified',
        'buzzing', 'tingling', 'crackling', 'sparking',

        // Slang
        'jazzed', 'juiced', 'geeked', 'hype',
        'turnt', 'going off',

        // British
        'well excited', 'buzzing',

        // Physical
        'restless', 'fidgety', 'antsy', 'jumpy',
        'twitchy', 'keyed up', 'wound up'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // SADNESS - Unhappiness, sorrow, grief
    // ═══════════════════════════════════════════════════════════════════
    sadness: [
        // Core
        'sad', 'sadness', 'saddened', 'unhappy',

        // Mild sadness
        'down', 'low', 'blue', 'glum', 'bummed',
        'disappointed', 'let down', 'discouraged',
        'disheartened', 'dispirited', 'deflated',

        // Medium sadness
        'melancholy', 'melancholic', 'somber', 'gloomy',
        'mournful', 'sorrowful', 'doleful', 'woeful',
        'heavy-hearted', 'downcast', 'crestfallen',

        // Strong sadness
        'heartbroken', 'devastated', 'crushed', 'shattered',
        'despairing', 'despondent', 'desolate', 'inconsolable',
        'grief', 'grieving', 'mourning', 'bereft',

        // Emptiness
        'empty', 'hollow', 'numb', 'void',

        // Longing
        'wistful', 'longing', 'yearning', 'pining', 'nostalgic',

        // Slang
        'bummed out', 'down in the dumps',
        'in a funk', 'in the dumps', 'feeling low',

        // British
        'gutted', 'choked',

        // Physical
        'crying', 'tearful', 'weeping', 'sobbing',
        'sighing', 'drooping', 'wilting', 'slumping'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // ANGER - Frustration, irritation, rage
    // ═══════════════════════════════════════════════════════════════════
    anger: [
        // Core
        'angry', 'anger', 'angered', 'mad',

        // Mild anger
        'annoyed', 'irritated', 'bothered', 'irked',
        'peeved', 'miffed', 'vexed', 'displeased',
        'put out', 'ticked off', 'ticked',

        // Medium anger
        'frustrated', 'aggravated', 'exasperated',
        'fed up', 'sick of', 'had enough',
        'cross', 'upset', 'worked up',

        // Strong anger
        'furious', 'enraged', 'livid', 'irate',
        'incensed', 'infuriated', 'outraged', 'seething',
        'fuming', 'boiling', 'burning', 'smoldering',

        // Extreme anger
        'raging', 'ballistic', 'apoplectic', 'berserk',
        'seeing red', 'losing it',

        // Slang
        'pissed', 'pissed off', 'salty', 'pressed',
        'triggered', 'tilted', 'heated', 'steaming',

        // British
        'narked', 'cheesed off', 'brassed off',
        'shirty', 'stroppy', 'mardy',

        // Australian
        'ropeable', 'filthy', 'spewing',

        // Physical
        'clenching', 'tensing', 'grinding'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // FEAR - Anxiety, worry, terror
    // ═══════════════════════════════════════════════════════════════════
    fear: [
        // Core
        'afraid', 'scared', 'fear', 'fearful',

        // Mild fear
        'uneasy', 'unsettled', 'apprehensive', 'wary',
        'concerned', 'worried',

        // Physical anxiety
        'jittery', 'shaky', 'trembling', 'quivering',
        'tense', 'tight', 'clenched', 'knotted',

        // Medium fear
        'frightened', 'alarmed', 'startled', 'spooked',
        'freaked', 'freaked out', 'creeped out',
        'on edge', 'rattled', 'unnerved',

        // Strong fear
        'terrified', 'petrified', 'horrified', 'panicked',
        'panic', 'panicking', 'terror', 'dread',

        // Paranoia
        'paranoid', 'distrustful',
        'looking over shoulder',

        // Slang
        'sketched', 'sketched out', 'wigged out',
        'shook',

        // British
        'bricking it', 'having kittens', 'in a flap',

        // Physical
        'frozen', 'paralyzed', 'deer in headlights',
        'heart racing', 'heart pounding', 'sweating'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // SURPRISE - Astonishment, unexpectedness, shock
    // ═══════════════════════════════════════════════════════════════════
    surprise: [
        // Core
        'surprised', 'surprise', 'surprising',

        // Mild surprise
        'oh', 'huh', 'hmm', 'interesting',
        'unexpected', 'caught off guard',

        // Medium surprise
        'astonished', 'amazed', 'astounded',
        'startled', 'taken aback', 'struck',

        // Strong surprise
        'shocked', 'stunned', 'staggered', 'floored',
        'dumbfounded', 'flabbergasted', 'gobsmacked',
        'blown away', 'mind blown', 'speechless',

        // Positive surprise
        'wow', 'whoa', 'omg', 'no way',
        'incredible', 'unbelievable', 'amazing',

        // Negative surprise
        'alarmed', 'dismayed', 'appalled',

        // Confusion element
        'bewildered', 'baffled', 'perplexed', 'puzzled',
        'confused', 'disoriented', 'thrown',

        // Slang
        'shooketh', 'gagged', 'dead',
        'wait what',

        // British
        'blimey', 'crikey', 'bloody hell',

        // Physical
        'jaw dropped', 'eyes wide', 'double take',
        'gasp', 'gasping'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // DISGUST - Revulsion, aversion, distaste
    // ═══════════════════════════════════════════════════════════════════
    disgust: [
        // Core
        'disgusted', 'disgust', 'disgusting',

        // Mild disgust
        'distaste', 'dislike', 'aversion',
        'put off', 'turned off', 'off-putting',

        // Medium disgust
        'repulsed', 'revolted', 'repelled',
        'grossed out', 'creeped out', 'icked out',

        // Strong disgust
        'sickened', 'nauseated', 'nauseous',
        'appalled', 'horrified', 'scandalized',

        // Moral disgust
        'offended', 'outraged', 'indignant',
        'contempt', 'contemptuous', 'disdain', 'scorn',

        // Physical
        'gagging', 'retching', 'cringing', 'wincing',
        'recoiling', 'shrinking back',

        // Slang
        'gross', 'ew', 'eww', 'yuck', 'yucky',
        'ick', 'nasty', 'foul', 'vile',

        // British
        'rank', 'minging', 'manky', 'grotty'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // LOVE - Affection, adoration, tenderness
    // ═══════════════════════════════════════════════════════════════════
    love: [
        // Core
        'love', 'loving', 'loved',

        // Affection
        'affection', 'affectionate', 'fond', 'fondness',
        'tender', 'tenderness', 'gentle',

        // Care
        'caring', 'care', 'nurturing', 'supportive',
        'protective', 'devoted', 'dedicated',

        // Warmth
        'warm', 'warmth', 'warm-hearted', 'kind',
        'kind-hearted', 'compassionate', 'sympathetic',

        // Adoration
        'adoring', 'adore', 'cherish', 'cherishing',
        'treasure', 'treasuring', 'doting',

        // Romantic
        'romantic', 'amorous', 'passionate',
        'smitten', 'infatuated', 'enamored', 'besotted',
        'head over heels', 'falling for',

        // Connection
        'connected', 'bonded', 'attached', 'close',
        'intimate', 'deep', 'profound',

        // Slang
        'heart eyes', 'crushing', 'swooning', 'melting',

        // Physical
        'hugging', 'embracing', 'holding', 'cuddling',
        'snuggling', 'nuzzling'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // EUPHORIA - Extreme joy, transcendence, bliss
    // ═══════════════════════════════════════════════════════════════════
    euphoria: [
        // Core
        'euphoric', 'euphoria', 'bliss', 'blissful',

        // Transcendence
        'transcendent', 'otherworldly', 'sublime',
        'heavenly', 'divine', 'ethereal', 'celestial',

        // Ecstasy
        'ecstatic', 'ecstasy', 'rapture', 'rapturous',
        'exultant', 'exalted', 'elevated',

        // Peak experience
        'peak', 'pinnacle', 'height', 'climax',
        'breakthrough', 'revelation', 'epiphany',

        // Overwhelming positivity
        'overwhelming joy', 'pure joy', 'absolute joy',
        'complete happiness', 'total bliss',

        // Physical
        'floating', 'soaring', 'flying', 'weightless',
        'radiating', 'shining',

        // Slang
        'on cloud nine', 'in heaven',
        'on top of the world', 'walking on air',
        'living my best life', 'ascended'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // FOCUSED - Concentration, attention, engagement
    // ═══════════════════════════════════════════════════════════════════
    focused: [
        // Core
        'focused', 'focus', 'focusing',

        // Concentration
        'concentrating', 'concentration', 'concentrated',
        'attentive', 'attention', 'attending',

        // Mental state
        'thinking', 'thought', 'thoughtful',
        'pondering', 'considering', 'contemplating',
        'reflecting', 'musing', 'mulling',

        // Engagement
        'engaged', 'absorbed', 'immersed', 'engrossed',
        'rapt', 'riveted', 'captivated', 'enthralled',

        // Intensity
        'intent', 'determined', 'resolute',
        'single-minded', 'laser focused', 'zeroed in',

        // Work state
        'working', 'processing', 'analyzing', 'examining',
        'studying', 'learning', 'figuring out',

        // Slang
        'locked in', 'dialed in', 'in the zone',
        'flow state', 'deep work', 'grinding',

        // Physical
        'staring', 'gazing', 'peering', 'squinting',
        'furrowed brow'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // SUSPICION - Doubt, wariness, skepticism
    // ═══════════════════════════════════════════════════════════════════
    suspicion: [
        // Core
        'suspicious', 'suspicion', 'suspect',

        // Doubt
        'doubtful', 'doubt', 'doubting',
        'skeptical', 'skepticism', 'questioning',
        'uncertain', 'unsure', 'unconvinced',

        // Wariness
        'wary', 'cautious', 'guarded', 'careful',
        'leery', 'circumspect', 'vigilant',

        // Distrust
        'distrustful', 'mistrust', 'mistrustful',
        'disbelieving', 'incredulous', 'unbelieving',

        // Evaluation
        'scrutinizing', 'examining', 'assessing',
        'evaluating', 'judging', 'sizing up',

        // Slang
        'sus', 'sussy', 'suss', 'side eye',
        'giving side eye', 'side-eyeing', 'eyeing',
        'not buying it',

        // Physical
        'narrowed eyes', 'squinting', 'raised eyebrow',
        'cocked head', 'tilted head', 'looking askance'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // RESTING - Low energy, dormancy, tiredness
    // ═══════════════════════════════════════════════════════════════════
    resting: [
        // Core
        'resting', 'rest', 'restful',

        // Tiredness
        'tired', 'weary', 'fatigued', 'exhausted',
        'drained', 'spent', 'depleted', 'worn out',

        // Sleepiness
        'sleepy', 'drowsy', 'dozy', 'groggy',
        'yawning', 'nodding off', 'drifting off',

        // Low energy
        'sluggish', 'lethargic', 'listless', 'languid',
        'lazy', 'idle', 'inactive',

        // Recovery
        'recovering', 'recuperating', 'recharging',
        'winding down', 'powering down', 'shutting down',

        // Sleep states
        'sleeping', 'asleep', 'slumbering', 'dozing',
        'napping', 'snoozing',

        // Slang
        'zonked', 'wiped', 'beat', 'dead tired',
        'running on empty', 'out of gas', 'crashed',

        // British
        'knackered', 'shattered', 'cream crackered'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // GLITCH - Error state, malfunction, corruption
    // ═══════════════════════════════════════════════════════════════════
    glitch: [
        // Core
        'glitch', 'glitchy', 'glitching',

        // Malfunction
        'malfunction', 'malfunctioning', 'broken',
        'bugged', 'buggy', 'error', 'erroring',

        // Corruption
        'corrupted', 'corruption', 'scrambled',
        'garbled', 'distorted', 'warped',

        // Digital
        'static', 'noise', 'interference',
        'pixelated', 'artifacting', 'tearing',

        // Chaos
        'haywire', 'fritzing', 'shorting out',
        'going crazy', 'spazzing',

        // Unstable
        'unstable', 'erratic', 'unpredictable',
        'flickering', 'stuttering', 'lagging',

        // Confused
        'does not compute', 'syntax error', 'crash'
    ]
};

/**
 * Undertone Synonyms
 *
 * Maps natural language words to the 6 canonical undertones.
 * Undertones modify the primary emotion, adding nuance.
 *
 * Example: "happy but nervous" = joy + nervous undertone
 *
 * @module core/intent/synonyms/undertones
 */

const undertones = {
    // ═══════════════════════════════════════════════════════════════════
    // NERVOUS - Adds jittery, anxious energy to any emotion
    // ═══════════════════════════════════════════════════════════════════
    nervous: [
        // Core
        'nervous', 'nervously',

        // Anxiety
        'anxious', 'anxiously', 'worried', 'worriedly',
        'uneasy', 'uneasily', 'apprehensive',

        // Physical
        'jittery', 'shaky', 'trembling', 'quivering',
        'fidgety', 'restless', 'twitchy',

        // Tension
        'tense', 'tensely', 'on edge', 'edgy',
        'keyed up', 'wound up', 'uptight',

        // Self-conscious
        'self-conscious', 'awkward', 'awkwardly',
        'hesitant', 'hesitantly', 'uncertain', 'uncertainly',

        // Slang
        'sketchy', 'stressed', 'stressing',
        'low-key panicking', 'kinda freaking out'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // CONFIDENT - Adds assurance, boldness, strength
    // ═══════════════════════════════════════════════════════════════════
    confident: [
        // Core
        'confident', 'confidently', 'confidence',

        // Assurance
        'assured', 'assuredly', 'certain', 'certainly',
        'sure', 'surely', 'positive', 'positively',

        // Boldness
        'bold', 'boldly', 'brave', 'bravely',
        'daring', 'daringly', 'fearless', 'fearlessly',

        // Strength
        'strong', 'strongly', 'powerful', 'powerfully',
        'firm', 'firmly', 'solid', 'solidly',

        // Authority
        'authoritative', 'commanding', 'assertive',
        'decisive', 'decisively', 'resolute', 'resolutely',

        // Poise
        'poised', 'self-assured',
        'unflappable', 'unfazed',

        // Slang
        'owning it', 'killing it', 'crushing it',
        'boss', 'like a boss'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // TIRED - Adds weariness, low energy, sluggishness
    // ═══════════════════════════════════════════════════════════════════
    tired: [
        // Core
        'tired', 'tiredly', 'tiredness',

        // Exhaustion
        'exhausted', 'weary', 'wearily',
        'fatigued', 'drained', 'spent', 'depleted',

        // Sluggishness
        'sluggish', 'sluggishly', 'slow', 'slowly',
        'lethargic', 'listless', 'languid',

        // Low energy
        'low energy', 'no energy', 'out of energy',
        'running low', 'running on fumes',

        // Physical
        'droopy', 'drooping', 'sagging', 'slumping',
        'heavy', 'weighted', 'dragging',

        // Slang
        'wiped', 'beat', 'dead', 'zonked',
        'burned out', 'fried', 'cooked', 'toast'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // INTENSE - Adds heightened energy, sharpness, focus
    // ═══════════════════════════════════════════════════════════════════
    intense: [
        // Core
        'intense', 'intensely', 'intensity',

        // Heightened
        'heightened', 'elevated', 'amplified',
        'magnified', 'increased', 'enhanced',

        // Force
        'forceful', 'forcefully', 'powerful', 'powerfully',
        'fierce', 'fiercely', 'strong', 'strongly',

        // Passion
        'passionate', 'passionately', 'fervent', 'fervently',
        'ardent', 'ardently', 'vehement', 'vehemently',

        // Sharpness
        'sharp', 'sharply', 'acute', 'acutely',
        'keen', 'keenly', 'piercing', 'piercingly',

        // Extreme
        'extreme', 'extremely', 'deeply', 'profoundly',
        'tremendously', 'immensely', 'incredibly',

        // Slang
        'super', 'mega', 'ultra', 'hella', 'mad', 'crazy'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // SUBDUED - Adds softness, restraint, gentleness
    // ═══════════════════════════════════════════════════════════════════
    subdued: [
        // Core
        'subdued', 'subduedly',

        // Softness
        'soft', 'softly', 'gentle', 'gently',
        'mild', 'mildly', 'light', 'lightly',

        // Restraint
        'restrained', 'held back', 'contained',
        'tempered', 'moderated', 'toned down',

        // Quietness
        'quiet', 'quietly', 'hushed', 'muted',
        'understated', 'subtle', 'subtly',

        // Modesty
        'modest', 'modestly', 'humble', 'humbly',
        'reserved', 'demure', 'unassuming',

        // Fading
        'faint', 'faintly', 'dim', 'dimly',
        'pale', 'faded', 'washed out',

        // Slang
        'low key', 'lowkey', 'easy', 'easy going'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // CLEAR - Neutral undertone, no modification
    // ═══════════════════════════════════════════════════════════════════
    clear: [
        // Core
        'clear', 'clearly',

        // Purity
        'pure', 'purely', 'clean', 'cleanly',
        'simple', 'simply', 'plain', 'plainly',

        // Directness
        'direct', 'directly', 'straightforward',
        'honest', 'honestly', 'frank', 'frankly',

        // Transparency
        'transparent', 'transparently', 'open', 'openly',
        'obvious', 'obviously', 'evident', 'evidently',

        // Absence of modifier
        'unmodified', 'unaltered', 'unchanged',
        'normal', 'normally', 'regular', 'regularly',
        'standard', 'basic', 'baseline'
    ]
};

/**
 * Gesture Synonyms
 *
 * Maps natural language words and phrases to canonical gestures.
 * Includes both single words and multi-word phrases.
 *
 * @module core/intent/synonyms/gestures
 */

const gestures = {
    // ═══════════════════════════════════════════════════════════════════
    // MOTION GESTURES - Movement-based animations
    // ═══════════════════════════════════════════════════════════════════

    bounce: [
        // Single words
        'bounce', 'bouncing', 'bouncy',
        'hop', 'hopping', 'hoppy',
        'spring', 'springing', 'springy',
        'boing', 'boinging',

        // Phrases
        'bouncing up and down', 'hopping around',
        'spring in step', 'light on feet'
    ],

    pulse: [
        // Single words
        'pulse', 'pulsing', 'pulsate', 'pulsating',
        'throb', 'throbbing',
        'beat', 'beating',

        // Phrases
        'pulsing gently', 'steady pulse',
        'heartbeat', 'heart beat'
    ],

    shake: [
        // Single words
        'shake', 'shaking', 'shaky',
        'shudder', 'shuddering',
        'tremble', 'trembling',
        'quake', 'quaking',
        'shiver', 'shivering',

        // Disagreement
        'no', 'nope', 'nah',
        'disagree', 'disagreeing',
        'refuse', 'refusing',
        'deny', 'denying',

        // Phrases
        'shaking head', 'shake head', 'head shake',
        'saying no', 'shaking no'
    ],

    nod: [
        // Single words
        'nod', 'nodding',

        // Agreement
        'yes', 'yeah', 'yep', 'yup',
        'agree', 'agreeing',
        'acknowledge', 'acknowledging',
        'confirm', 'confirming',
        'accept', 'accepting',
        'approve', 'approving',

        // Understanding
        'understand', 'understanding',
        'got it', 'gotcha', 'i see',
        'makes sense', 'understood',

        // Phrases
        'nodding head', 'nod head', 'head nod',
        'nodding along', 'nodding yes'
    ],

    vibrate: [
        // Single words
        'vibrate', 'vibrating', 'vibration',
        'buzz', 'buzzing',
        'hum', 'humming',
        'quiver', 'quivering',

        // Phrases
        'vibrating slightly', 'gentle buzz',
        'low hum', 'subtle vibration'
    ],

    orbit: [
        // Single words
        'orbit', 'orbiting',
        'circle', 'circling',
        'revolve', 'revolving',
        'rotate', 'rotating',

        // Phrases
        'circling around', 'going around',
        'rotating slowly', 'orbital motion'
    ],

    sway: [
        // Single words
        'sway', 'swaying',
        'rock', 'rocking',
        'swing', 'swinging',
        'oscillate', 'oscillating',

        // Phrases
        'swaying gently', 'rocking back and forth',
        'gentle sway', 'side to side'
    ],

    float: [
        // Single words
        'float', 'floating',
        'drift', 'drifting',
        'hover', 'hovering',
        'glide', 'gliding',
        'levitate', 'levitating',

        // Weightlessness
        'weightless', 'weightlessness',
        'buoyant', 'airy',

        // Phrases
        'floating gently', 'drifting along',
        'hovering in place', 'light as air'
    ],

    lean: [
        // Single words
        'lean', 'leaning',
        'incline', 'inclining',
        'tilt', 'tilting',

        // Directional
        'leaning in', 'lean in',
        'leaning forward', 'lean forward',
        'leaning toward', 'lean toward',
        'leaning closer', 'lean closer',
        'moving closer', 'coming closer',
        'drawing near', 'approaching',

        // Interest
        'interested', 'intrigued', 'curious',
        'engaged', 'attentive',
        'listening closely', 'paying attention'
    ],

    reach: [
        // Single words
        'reach', 'reaching',
        'extend', 'extending',
        'stretch', 'stretching',

        // Directional
        'reaching out', 'reach out',
        'reaching toward', 'reach toward',
        'extending toward', 'stretching toward',

        // Offering
        'offer', 'offering',
        'present', 'presenting',
        'give', 'giving',
        'help', 'helping'
    ],

    point: [
        // Single words
        'point', 'pointing',
        'indicate', 'indicating',
        'gesture', 'gesturing',
        'direct', 'directing',

        // Phrases
        'pointing at', 'pointing to',
        'pointing toward', 'gesturing toward',
        'showing', 'directing attention'
    ],

    wave: [
        // Single words
        'wave', 'waving',

        // Greetings
        'greet', 'greeting',
        'hello', 'hi', 'hey',
        'goodbye', 'bye', 'farewell',
        'welcome', 'welcoming',

        // Phrases
        'waving hello', 'waving goodbye',
        'friendly wave', 'waving hand'
    ],

    headBob: [
        // Direct
        'headbob', 'head bob', 'headbobbing', 'head bobbing',
        'bobbing', 'bob',

        // Musical
        'nodding to beat', 'nodding to music',
        'bobbing along', 'bobbing to rhythm',
        'vibing', 'grooving', 'jamming',

        // Phrases
        'bobbing head', 'bob head',
        'feeling the beat', 'moving to music'
    ],

    wiggle: [
        // Single words
        'wiggle', 'wiggling', 'wiggly',
        'jiggle', 'jiggling', 'jiggly',
        'squirm', 'squirming',
        'wriggle', 'wriggling',

        // Phrases
        'wiggling around', 'little wiggle',
        'happy wiggle', 'excited wiggle'
    ],

    groove: [
        // Single words
        'groove', 'grooving', 'groovy',
        'dance', 'dancing',
        'boogie', 'boogying',
        'funk', 'funky',

        // Musical
        'rhythmic', 'moving to music',
        'feeling the music', 'in the groove',

        // Phrases
        'getting down', 'busting a move',
        'doing a little dance'
    ],

    twitch: [
        // Single words
        'twitch', 'twitching', 'twitchy',
        'spasm', 'spasming',
        'jerk', 'jerking', 'jerky',
        'flinch', 'flinching',

        // Phrases
        'quick twitch', 'nervous twitch',
        'sudden movement'
    ],

    jitter: [
        // Single words
        'jitter', 'jittering', 'jittery',
        'stutter', 'stuttering',

        // Phrases
        'jittering around', 'slight jitter',
        'nervous jitter'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // TRANSFORM GESTURES - Shape/size changes
    // ═══════════════════════════════════════════════════════════════════

    spin: [
        // Single words
        'spin', 'spinning',
        'twirl', 'twirling',
        'whirl', 'whirling',
        'rotate', 'rotating',
        'turn', 'turning',

        // Phrases
        'spinning around', 'quick spin',
        'full rotation', 'twirling around'
    ],

    jump: [
        // Single words
        'jump', 'jumping', 'jumpy',
        'leap', 'leaping',
        'spring', 'springing',
        'bound', 'bounding',

        // Phrases
        'jumping up', 'leap up',
        'spring up', 'jumping for joy'
    ],

    stretch: [
        // Single words
        'stretch', 'stretching', 'stretchy',
        'elongate', 'elongating',
        'extend', 'extending',
        'lengthen', 'lengthening',

        // Phrases
        'stretching out', 'big stretch',
        'reaching up', 'stretching tall'
    ],

    expand: [
        // Single words
        'expand', 'expanding',
        'grow', 'growing',
        'enlarge', 'enlarging',
        'swell', 'swelling',
        'inflate', 'inflating',
        'bloat', 'bloating',

        // Phrases
        'getting bigger', 'growing larger',
        'puffing up', 'expanding outward'
    ],

    contract: [
        // Single words
        'contract', 'contracting',
        'shrink', 'shrinking',
        'compress', 'compressing',
        'deflate', 'deflating',
        'reduce', 'reducing',

        // Phrases
        'getting smaller', 'shrinking down',
        'pulling in', 'contracting inward'
    ],

    twist: [
        // Single words
        'twist', 'twisting', 'twisty',
        'contort', 'contorting',
        'warp', 'warping',
        'distort', 'distorting',

        // Phrases
        'twisting around', 'getting twisted',
        'warping shape'
    ],

    tilt: [
        // Single words
        'tilt', 'tilting', 'tilted',
        'angle', 'angling', 'angled',
        'cock', 'cocking', 'cocked',

        // Phrases
        'tilting head', 'tilt head',
        'cocking head', 'curious tilt',
        'angling sideways', 'head tilt'
    ],

    hula: [
        // Direct
        'hula', 'hula-ing',

        // Motion
        'hip sway', 'swaying hips',
        'circular sway', 'round motion',

        // Phrases
        'hula motion', 'hula dance'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // EFFECT GESTURES - Visual effects and glows
    // ═══════════════════════════════════════════════════════════════════

    sparkle: [
        // Single words
        'sparkle', 'sparkling', 'sparkly',
        'twinkle', 'twinkling', 'twinkly',
        'glitter', 'glittering', 'glittery',
        'shine', 'shining', 'shiny',

        // Celebration
        'celebrate', 'celebrating', 'celebration', 'celebratory',
        'festive', 'party', 'partying',
        'victory', 'triumphant', 'triumph',

        // Success
        'winning', 'success', 'successful',
        'achievement', 'accomplished', 'nailed it',

        // Slang
        'slay', 'slaying', 'killing it',
        'yasss', 'yay', 'woo', 'woohoo'
    ],

    shimmer: [
        // Single words
        'shimmer', 'shimmering', 'shimmery',
        'glisten', 'glistening',
        'gleam', 'gleaming',
        'lustrous', 'luminous',

        // Phrases
        'soft shimmer', 'gentle gleam',
        'shimmering light', 'pearlescent'
    ],

    glow: [
        // Single words
        'glow', 'glowing', 'glowy',
        'radiate', 'radiating',
        'emanate', 'emanating',
        'luminous', 'luminescent',
        'bright', 'brighten', 'brightening',

        // Phrases
        'soft glow', 'warm glow',
        'inner glow', 'glowing warmly',
        'lighting up', 'lit up'
    ],

    flash: [
        // Single words
        'flash', 'flashing', 'flashy',
        'blink', 'blinking',
        'strobe', 'strobing',
        'flare', 'flaring',

        // Phrases
        'quick flash', 'bright flash',
        'flashing light', 'strobing light'
    ],

    flicker: [
        // Single words
        'flicker', 'flickering', 'flickery',
        'flutter', 'fluttering',
        'waver', 'wavering',
        'guttering',

        // Phrases
        'flickering light', 'unsteady light',
        'wavering glow', 'candle-like'
    ],

    burst: [
        // Single words
        'burst', 'bursting',
        'explode', 'exploding', 'explosion',
        'erupt', 'erupting', 'eruption',
        'pop', 'popping',
        'boom', 'booming',

        // Phrases
        'bursting out', 'burst of energy',
        'explosive', 'big burst'
    ],

    settle: [
        // Single words
        'settle', 'settling', 'settled',
        'calm', 'calming',
        'ground', 'grounding', 'grounded',
        'center', 'centering', 'centered',
        'anchor', 'anchoring', 'anchored',
        'root', 'rooting', 'rooted',

        // Relaxing
        'relax', 'relaxing',
        'unwind', 'unwinding',
        'decompress', 'decompressing',

        // Phrases
        'settling down', 'calming down',
        'winding down', 'cooling down',
        'coming to rest', 'finding peace',
        'sinking into', 'melting into'
    ],

    breathe: [
        // Single words
        'breathe', 'breathing', 'breath',
        'inhale', 'inhaling',
        'exhale', 'exhaling',
        'sigh', 'sighing',
        'respire', 'respiring',

        // Depth
        'deep breath', 'deep breathing',
        'slow breath', 'slow breathing',
        'long breath', 'full breath',

        // Phrases
        'breathing deeply', 'breathing slowly',
        'taking a breath', 'take a breath',
        'catching breath', 'breath work', 'breathwork',
        'inhale exhale', 'in and out',

        // Descriptive
        'meditative breathing', 'calming breath',
        'cleansing breath', 'relaxing breath',
        'centering breath', 'mindful breathing'
    ],

    peek: [
        // Single words
        'peek', 'peeking',
        'peer', 'peering',
        'peep', 'peeping',
        'glance', 'glancing',

        // Phrases
        'peeking out', 'peek out',
        'looking shyly', 'shy glance',
        'quick peek', 'sneaking a look'
    ],

    fade: [
        // Single words
        'fade', 'fading',
        'dim', 'dimming',
        'disappear', 'disappearing',
        'vanish', 'vanishing',

        // Phrases
        'fading out', 'fading away',
        'growing dim', 'becoming transparent',
        'dissolving', 'melting away'
    ],

    hold: [
        // Single words
        'hold', 'holding',
        'pause', 'pausing', 'paused',
        'freeze', 'freezing', 'frozen',
        'still', 'stillness',
        'stop', 'stopping', 'stopped',

        // Phrases
        'holding still', 'staying still',
        'frozen in place', 'completely still',
        'motionless', 'stationary'
    ],

    rain: [
        // Single words
        'rain', 'raining',
        'shower', 'showering',
        'drip', 'dripping',
        'pour', 'pouring',
        'fall', 'falling',

        // Phrases
        'raining down', 'particles falling',
        'gentle rain', 'shower of particles'
    ]
};

/**
 * Shape Synonyms
 *
 * Maps natural language words and phrases to canonical shapes.
 * Shapes are the geometric/symbolic forms the mascot can morph into.
 *
 * @module core/intent/synonyms/shapes
 */

const shapes = {
    // ═══════════════════════════════════════════════════════════════════
    // GEOMETRIC SHAPES - Basic forms
    // ═══════════════════════════════════════════════════════════════════

    circle: [
        // Direct
        'circle', 'circular', 'round', 'rounded',
        'orb', 'ball', 'sphere', 'spherical',
        'ring', 'disc', 'disk',

        // Abstract
        'whole', 'complete', 'unity', 'unified',
        'endless', 'infinite', 'continuous',

        // Phrases
        'full circle', 'perfect round', 'come full circle'
    ],

    sphere: [
        // Direct
        'sphere', 'spherical', 'globe', 'globular',
        'ball', '3d circle', 'three dimensional',

        // Phrases
        'round ball', 'floating sphere'
    ],

    square: [
        // Direct
        'square', 'squared', 'boxy', 'box',
        'rectangle', 'rectangular', 'quadrilateral',
        'cube', 'cubic', 'block', 'blocky',

        // Abstract
        'stable', 'solid', 'grounded', 'sturdy',
        'rigid', 'firm', 'structured',

        // Phrases
        'four sided', 'four corners', 'box shape'
    ],

    triangle: [
        // Direct
        'triangle', 'triangular', 'tri',
        'pyramid', 'pyramidal', 'delta',
        'wedge', 'arrow', 'arrowhead',

        // Abstract
        'pointed', 'sharp', 'dynamic',
        'directional', 'ascending',

        // Phrases
        'three sided', 'three pointed', 'pointing up'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // ORGANIC SHAPES - Natural and emotional forms
    // ═══════════════════════════════════════════════════════════════════

    heart: [
        // Direct
        'heart', 'hearted', 'hearts',
        'love', 'loving', 'lovely',
        'valentine', 'romantic',

        // Emotional
        'affection', 'affectionate',
        'caring', 'care', 'tender',
        'warmth', 'warm-hearted', 'heartfelt',
        'compassion', 'compassionate',
        'devotion', 'devoted',

        // Slang
        'luv', 'wuv', '<3', '❤️', '💕', '💗',

        // Phrases
        'full of love', 'with love', 'heart shape',
        'heart shaped', 'from the heart'
    ],

    suspicion: [
        // Direct
        'suspicion', 'suspicious', 'suspect',
        'sly', 'slyly', 'sneaky', 'sneakily',
        'mischievous', 'mischief',

        // Facial
        'smirk', 'smirking', 'smirky',
        'grin', 'grinning', 'sly grin',
        'side eye', 'sideeye', 'side-eye',

        // Emotion
        'skeptical', 'skepticism',
        'doubtful', 'doubt', 'doubting',
        'wary', 'distrustful', 'distrust',

        // Slang
        'sus', 'sussy', 'sussy baka',
        'hmm', 'hmmm', 'hmmmm',
        'shady', 'fishy', 'sketchy',

        // Phrases
        'not buying it', 'something fishy',
        'seems off', 'up to something'
    ],

    // ═══════════════════════════════════════════════════════════════════
    // ASTRONOMICAL SHAPES - Celestial bodies
    // ═══════════════════════════════════════════════════════════════════

    star: [
        // Direct
        'star', 'starred', 'starry', 'stars',
        'stellar', 'astral',
        'twinkle', 'twinkling',

        // Success
        'achievement', 'achieved',
        'excellence', 'excellent',
        'gold star', 'five star',
        'superstar', 'rockstar', 'rock star',

        // Wonder
        'wonder', 'wonderful', 'wondrous',
        'magical', 'magic', 'miraculous',
        'amazing', 'spectacular',

        // Phrases
        'reach for stars', 'seeing stars',
        'star shape', 'shining star'
    ],

    sun: [
        // Direct
        'sun', 'sunny', 'sunshine', 'sunlight',
        'solar', 'sol',
        'daylight', 'daytime', 'day',

        // Energy
        'radiant', 'radiance', 'radiating',
        'bright', 'brightness', 'brilliant',
        'glowing', 'glow', 'blazing', 'blaze',
        'warm', 'warmth',

        // Positivity
        'cheerful', 'cheery',
        'optimistic', 'optimism',
        'hopeful', 'hope',
        'positive', 'positivity',

        // Phrases
        'full of light', 'ray of sunshine',
        'like the sun', 'sunny disposition'
    ],

    moon: [
        // Direct
        'moon', 'moony', 'moonlight', 'moonlit',
        'lunar', 'crescent',
        'nighttime', 'night', 'nocturnal',

        // Phases
        'waxing', 'waning', 'gibbous',
        'new moon', 'full moon', 'half moon',
        'quarter moon', 'crescent moon',

        // Emotion
        'dreamy', 'dreamlike', 'dream',
        'mysterious', 'mystery', 'mystical',
        'ethereal', 'otherworldly',
        'serene', 'serenity', 'tranquil',
        'contemplative', 'reflective',

        // Phrases
        'moonlit night', 'by moonlight',
        'moon shape', 'under the moon'
    ],

    lunar: [
        // Eclipse specific
        'lunar eclipse', 'blood moon', 'blood-moon',
        'red moon', 'copper moon', 'rust moon',

        // Eclipse phases
        'eclipsing', 'eclipsed',
        'shadow crossing', 'earth shadow',

        // Mood
        'ominous', 'foreboding', 'portentous',
        'dramatic', 'intense',
        'transforming', 'transformation',

        // Phrases
        'moon in shadow', 'moon turning red',
        'eclipse phase', 'lunar event'
    ],

    solar: [
        // Eclipse specific
        'solar eclipse', 'total eclipse',
        'corona', 'diamond ring',
        'totality', 'umbra', 'penumbra',

        // Visual
        'ring of fire', 'dark sun',
        'blocked sun', 'occluded',

        // Mood
        'awe', 'awesome', 'awe-inspiring',
        'rare', 'momentous', 'historic',
        'breathtaking', 'magnificent',

        // Phrases
        'sun blocked', 'sun covered',
        'total darkness', 'corona visible'
    ],

    eclipse: [
        // General eclipse
        'eclipse', 'eclipsing', 'eclipsed',
        'celestial event', 'astronomical event',

        // Metaphorical
        'overshadow', 'overshadowed',
        'blocked', 'blocking', 'obscured',
        'hidden', 'hiding', 'concealed',

        // Transition
        'passing', 'crossing', 'alignment',

        // Phrases
        'in eclipse', 'going dark',
        'being eclipsed', 'eclipsed by'
    ]
};

/**
 * Modifier Synonyms
 *
 * Maps natural language words to intensity and timing modifiers.
 * These modify how emotions and gestures are expressed.
 *
 * @module core/intent/synonyms/modifiers
 */

const modifiers = {
    // ═══════════════════════════════════════════════════════════════════
    // INTENSITY MODIFIERS - How strongly to express
    // ═══════════════════════════════════════════════════════════════════

    intensity: {
        // Very low (0.1 - 0.2)
        barely: [
            'barely', 'hardly', 'scarcely',
            'faintly', 'slightly', 'marginally',
            'just a bit', 'just a little', 'just barely',
            'hint of', 'touch of', 'trace of'
        ],

        // Low (0.2 - 0.4)
        slightly: [
            'slightly', 'somewhat', 'a little',
            'a bit', 'mildly', 'lightly',
            'kind of', 'kinda', 'sort of', 'sorta',
            'a tad', 'a touch', 'a smidge'
        ],

        // Medium-low (0.4 - 0.5)
        moderately: [
            'moderately', 'reasonably', 'fairly',
            'pretty', 'rather', 'quite'
        ],

        // Medium (0.5 - 0.6) - Default, no modifier needed
        normal: [
            'normal', 'normally', 'regular', 'regularly',
            'standard', 'typical', 'typically',
            'average', 'ordinary'
        ],

        // Medium-high (0.6 - 0.7)
        notably: [
            'notably', 'noticeably', 'clearly',
            'definitely', 'certainly', 'decidedly',
            'genuinely', 'truly', 'really'
        ],

        // High (0.7 - 0.85)
        very: [
            'very', 'really', 'so', 'such',
            'quite', 'highly', 'deeply',
            'seriously', 'majorly', 'hella',
            'super', 'extra', 'mad'
        ],

        // Very high (0.85 - 0.95)
        extremely: [
            'extremely', 'incredibly', 'immensely',
            'tremendously', 'enormously', 'hugely',
            'intensely', 'fiercely', 'wildly',
            'insanely', 'crazy', 'ridiculously',
            'mega', 'ultra', 'hyper'
        ],

        // Maximum (0.95 - 1.0)
        absolutely: [
            'absolutely', 'completely', 'totally',
            'utterly', 'entirely', 'wholly',
            'fully', 'maximum', 'max',
            'over the top', 'off the charts',
            'through the roof', 'to the max'
        ]
    },

    // ═══════════════════════════════════════════════════════════════════
    // DURATION MODIFIERS - How long to express
    // ═══════════════════════════════════════════════════════════════════

    duration: {
        // Very brief (< 500ms)
        flash: [
            'flash', 'instant', 'instantaneous',
            'split second', 'split-second',
            'momentary', 'fleeting', 'brief flash'
        ],

        // Brief (500ms - 1s)
        quick: [
            'quick', 'quickly', 'fast', 'rapid',
            'swift', 'swiftly', 'brief', 'briefly',
            'short', 'shortly', 'snap'
        ],

        // Normal (1s - 2s) - Default
        normal: [
            'normal', 'regular', 'standard',
            'typical', 'usual'
        ],

        // Extended (2s - 4s)
        slow: [
            'slow', 'slowly', 'gradual', 'gradually',
            'gentle', 'gently', 'easy', 'easily',
            'leisurely', 'unhurried'
        ],

        // Long (4s - 8s)
        long: [
            'long', 'prolonged', 'extended',
            'sustained', 'lasting', 'lingering',
            'drawn out', 'drawn-out'
        ],

        // Persistent (> 8s or until changed)
        persistent: [
            'persistent', 'constant', 'continuous',
            'ongoing', 'steady', 'maintained',
            'held', 'holding', 'stay', 'staying',
            'keep', 'keeping', 'remain', 'remaining'
        ]
    },

    // ═══════════════════════════════════════════════════════════════════
    // TRANSITION MODIFIERS - How to change between states
    // ═══════════════════════════════════════════════════════════════════

    transition: {
        // Instant (no easing)
        instant: [
            'instant', 'instantly', 'immediate', 'immediately',
            'sudden', 'suddenly', 'abrupt', 'abruptly',
            'snap', 'cut', 'jump'
        ],

        // Quick ease
        snappy: [
            'snappy', 'crisp', 'sharp', 'sharply',
            'brisk', 'briskly', 'punchy'
        ],

        // Normal ease - Default
        smooth: [
            'smooth', 'smoothly', 'natural', 'naturally',
            'fluid', 'fluidly', 'flowing'
        ],

        // Slow ease
        gentle: [
            'gentle', 'gently', 'soft', 'softly',
            'gradual', 'gradually', 'easing',
            'gliding', 'drifting'
        ],

        // Very slow ease with float
        dreamy: [
            'dreamy', 'dreamlike', 'floaty',
            'ethereal', 'languid', 'lazy',
            'flowing', 'melting'
        ]
    },

    // ═══════════════════════════════════════════════════════════════════
    // REPETITION MODIFIERS - How often to repeat
    // ═══════════════════════════════════════════════════════════════════

    repetition: {
        // Once (no loop)
        once: [
            'once', 'one time', 'single', 'just once',
            'only once', 'one shot'
        ],

        // Few times (2-3)
        few: [
            'few', 'few times', 'couple', 'couple times',
            'twice', 'two times', 'thrice', 'three times'
        ],

        // Several times (4-6)
        several: [
            'several', 'several times', 'multiple',
            'multiple times', 'repeatedly', 'again and again'
        ],

        // Many times (7+)
        many: [
            'many', 'many times', 'lots', 'lots of times',
            'over and over', 'nonstop'
        ],

        // Continuous loop
        loop: [
            'loop', 'looping', 'looped',
            'continuous', 'continuously', 'forever',
            'infinitely', 'endlessly', 'always',
            'keep going', 'on repeat'
        ]
    }
};

/**
 * Intensity value mappings
 * Maps intensity level names to numeric ranges
 */
const intensityValues = {
    barely: { min: 0.1, max: 0.2, default: 0.15 },
    slightly: { min: 0.2, max: 0.4, default: 0.3 },
    moderately: { min: 0.4, max: 0.5, default: 0.45 },
    normal: { min: 0.5, max: 0.6, default: 0.55 },
    notably: { min: 0.6, max: 0.7, default: 0.65 },
    very: { min: 0.7, max: 0.85, default: 0.8 },
    extremely: { min: 0.85, max: 0.95, default: 0.9 },
    absolutely: { min: 0.95, max: 1.0, default: 1.0 }
};

/**
 * Duration value mappings (in milliseconds)
 */
const durationValues = {
    flash: { min: 100, max: 500, default: 250 },
    quick: { min: 500, max: 1000, default: 750 },
    normal: { min: 1000, max: 2000, default: 1500 },
    slow: { min: 2000, max: 4000, default: 3000 },
    long: { min: 4000, max: 8000, default: 6000 },
    persistent: { min: 8000, max: Infinity, default: 10000 }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Intent Parser
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview IntentParser - Natural Language Intent Parsing for LLM Integration
 * @author Emotive Engine Team
 * @version 1.0.0
 * @module core/intent/IntentParser
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Parses natural language intent strings from LLMs into structured commands
 * ║ that the Emotive Engine can execute. Enables LLMs to express intent in plain
 * ║ text like "curious, leaning in" rather than API calls.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎯 EXAMPLE USAGE
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ const parser = new IntentParser();
 * │ const result = parser.parse('happy, bouncing, heart shape');
 * │ // Returns: {
 * │ //   emotion: 'joy',
 * │ //   undertone: 'clear',
 * │ //   gestures: ['bounce'],
 * │ //   shape: 'heart',
 * │ //   intensity: 0.55,
 * │ //   duration: 1500
 * │ // }
 * └───────────────────────────────────────────────────────────────────────────────────
 */


/**
 * Build a reverse lookup map from synonyms to canonical names
 * @param {Object} synonymMap - Map of canonical → [synonyms]
 * @returns {Map<string, string>} Map of synonym → canonical
 */
function buildReverseLookup(synonymMap) {
    const lookup = new Map();
    for (const [canonical, synonyms] of Object.entries(synonymMap)) {
        for (const synonym of synonyms) {
            // Normalize the synonym
            const normalized = synonym.toLowerCase().trim();
            lookup.set(normalized, canonical);
        }
        // Also map canonical to itself
        lookup.set(canonical.toLowerCase(), canonical);
    }
    return lookup;
}

/**
 * Build reverse lookup for nested modifier structure
 * @param {Object} modifierMap - Nested modifier map
 * @returns {Map<string, {type: string, level: string}>}
 */
function buildModifierLookup(modifierMap) {
    const lookup = new Map();
    for (const [type, levels] of Object.entries(modifierMap)) {
        for (const [level, synonyms] of Object.entries(levels)) {
            for (const synonym of synonyms) {
                const normalized = synonym.toLowerCase().trim();
                lookup.set(normalized, { type, level });
            }
        }
    }
    return lookup;
}

/**
 * IntentParser class
 *
 * Parses natural language intent strings into structured mascot commands.
 */
class IntentParser {
    constructor() {
        // Build reverse lookup tables
        this.emotionLookup = buildReverseLookup(emotions);
        this.undertoneLookup = buildReverseLookup(undertones);
        this.gestureLookup = buildReverseLookup(gestures);
        this.shapeLookup = buildReverseLookup(shapes);
        this.modifierLookup = buildModifierLookup(modifiers);
    }

    /**
     * Parse a natural language intent string
     *
     * @param {string} intent - Natural language intent (e.g., "happy, bouncing")
     * @returns {Object} Parsed intent object
     * @returns {string|null} returns.emotion - Canonical emotion name
     * @returns {string} returns.undertone - Canonical undertone name (default: 'clear')
     * @returns {string[]} returns.gestures - Array of canonical gesture names
     * @returns {string|null} returns.shape - Canonical shape name
     * @returns {number} returns.intensity - Intensity value (0-1)
     * @returns {number} returns.duration - Duration in milliseconds
     * @returns {string[]} returns.unrecognized - Tokens that couldn't be parsed
     *
     * @example
     * parser.parse('excited, bouncing, star shape')
     * // { emotion: 'joy', gestures: ['bounce'], shape: 'star', ... }
     *
     * parser.parse('nervous but trying to be confident')
     * // { emotion: 'fear', undertone: 'confident', ... }
     *
     * parser.parse('very happy, slow nod')
     * // { emotion: 'joy', intensity: 0.8, gestures: ['nod'], duration: 3000, ... }
     */
    parse(intent) {
        // Initialize result
        const result = {
            emotion: null,
            undertone: 'clear',
            gestures: [],
            shape: null,
            intensity: intensityValues.normal.default,
            duration: durationValues.normal.default,
            transition: 'smooth',
            repetition: 'once',
            unrecognized: [],
            raw: intent
        };

        // Handle empty/invalid input
        if (!intent || typeof intent !== 'string') {
            return result;
        }

        // Tokenize
        const { tokens } = tokenize(intent);

        if (tokens.length === 0) {
            return result;
        }

        // Track negations for the next token
        let negateNext = false;

        // Process each token
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];

            // Handle connectors (but, and, etc.)
            if (isConnector(token)) {
                // 'but' often introduces an undertone
                continue;
            }

            // Handle negations
            if (isNegation(token)) {
                negateNext = true;
                continue;
            }

            // Skip if negated (we don't support "not happy" yet - complex semantics)
            if (negateNext) {
                negateNext = false;
                continue;
            }

            // Check for conflicts first
            if (hasConflict(token)) {
                const resolution = resolve(token, tokens, i, result);
                if (resolution) {
                    this._applyResolution(result, resolution);
                    continue;
                }
            }

            // Try each category in priority order
            if (this._tryEmotion(token, result)) continue;
            if (this._tryGesture(token, result)) continue;
            if (this._tryShape(token, result)) continue;
            if (this._tryUndertone(token, result)) continue;
            if (this._tryModifier(token, result)) continue;

            // Unrecognized token
            result.unrecognized.push(token);
        }

        return result;
    }

    /**
     * Apply a conflict resolution result
     * @private
     */
    _applyResolution(result, resolution) {
        const { category, target } = resolution;

        switch (category) {
        case 'emotion':
            if (!result.emotion) {
                result.emotion = target;
            }
            break;
        case 'undertone':
            if (result.undertone === 'clear') {
                result.undertone = target;
            }
            break;
        case 'gesture':
            if (!result.gestures.includes(target)) {
                result.gestures.push(target);
            }
            break;
        case 'shape':
            if (!result.shape) {
                result.shape = target;
            }
            break;
        }
    }

    /**
     * Try to match token as emotion
     * @private
     */
    _tryEmotion(token, result) {
        const emotion = this.emotionLookup.get(token);
        if (emotion && !result.emotion) {
            result.emotion = emotion;
            return true;
        }
        return false;
    }

    /**
     * Try to match token as gesture
     * @private
     */
    _tryGesture(token, result) {
        const gesture = this.gestureLookup.get(token);
        if (gesture && !result.gestures.includes(gesture)) {
            result.gestures.push(gesture);
            return true;
        }
        return false;
    }

    /**
     * Try to match token as shape
     * @private
     */
    _tryShape(token, result) {
        const shape = this.shapeLookup.get(token);
        if (shape && !result.shape) {
            result.shape = shape;
            return true;
        }
        return false;
    }

    /**
     * Try to match token as undertone
     * @private
     */
    _tryUndertone(token, result) {
        const undertone = this.undertoneLookup.get(token);
        if (undertone && result.undertone === 'clear') {
            result.undertone = undertone;
            return true;
        }
        return false;
    }

    /**
     * Try to match token as modifier
     * @private
     */
    _tryModifier(token, result) {
        const modifier = this.modifierLookup.get(token);
        if (modifier) {
            const { type, level } = modifier;

            switch (type) {
            case 'intensity':
                result.intensity = intensityValues[level]?.default || result.intensity;
                break;
            case 'duration':
                result.duration = durationValues[level]?.default || result.duration;
                break;
            case 'transition':
                result.transition = level;
                break;
            case 'repetition':
                result.repetition = level;
                break;
            }
            return true;
        }
        return false;
    }

    /**
     * Validate a parsed result
     * @param {Object} parsed - Parsed intent result
     * @returns {Object} Validation result { valid: boolean, errors: string[] }
     */
    validate(parsed) {
        const errors = [];

        // Must have at least one actionable element
        if (!parsed.emotion && parsed.gestures.length === 0 && !parsed.shape) {
            errors.push('No actionable intent found (need emotion, gesture, or shape)');
        }

        // Intensity must be in range
        if (parsed.intensity < 0 || parsed.intensity > 1) {
            errors.push(`Intensity ${parsed.intensity} out of range [0, 1]`);
        }

        // Duration must be positive
        if (parsed.duration <= 0) {
            errors.push(`Duration ${parsed.duration} must be positive`);
        }

        return {
            valid: errors.length === 0,
            errors
        };
    }

    /**
     * Get available emotions
     * @returns {string[]}
     */
    static getAvailableEmotions() {
        return Object.keys(emotions);
    }

    /**
     * Get available undertones
     * @returns {string[]}
     */
    static getAvailableUndertones() {
        return Object.keys(undertones);
    }

    /**
     * Get available gestures
     * @returns {string[]}
     */
    static getAvailableGestures() {
        return Object.keys(gestures);
    }

    /**
     * Get available shapes
     * @returns {string[]}
     */
    static getAvailableShapes() {
        return Object.keys(shapes);
    }
}

/**
 * BPMDetector - Simple interval-based BPM detection
 *
 * Algorithm:
 * 1. Receive peak events with timestamps
 * 2. Measure intervals between consecutive peaks
 * 3. Build histogram of intervals → BPM
 * 4. Lock when one BPM dominates
 *
 * @module core/morpher/AgentBPMDetector
 */

class AgentBPMDetector {
    constructor() {
        // BPM range
        this.minBPM = 60;
        this.maxBPM = 180;

        // Peak tracking
        this.lastPeakTime = 0;
        this.peakCount = 0;

        // Interval collection
        this.intervals = [];
        this.maxIntervals = 40;

        // BPM voting histogram
        this.bpmVotes = new Map();

        // Output
        this.currentBPM = 0;
        this.lockedBPM = 0;
        this.confidence = 0;
        this.isActive = false;

        // 3-Stage Lock System:
        // Stage 0: Detecting - collecting data, no lock yet
        // Stage 1: Initial Lock - fast lock for user feedback, refinement window open
        // Stage 2: Refinement - can apply ONE halve/double correction
        // Stage 3: Final Lock - micro-tuning only, then memory cleanup
        this.lockStage = 0;
        this.stage1LockTime = 0;           // When Stage 1 lock occurred
        this.stage2CorrectionApplied = false;
        this.correctionType = 'none';      // 'none', 'halved', or 'doubled'
        this._recentSubdivisionChecks = []; // Rolling buffer for Stage 2 evidence
        this._stage3StartTime = 0;         // When Stage 3 began
        this._stage3StableTime = 0;        // How long BPM has been stable in Stage 3
        this._memoryCleanedUp = false;     // Flag to prevent repeated cleanup
        this._microTuneBPM = 0;            // Fractional BPM for micro-tuning accumulation

        // Groove confidence: smooth value for animation intensity scaling
        // Maps lockStage to target: Stage 0=15%, Stage 1=40%, Stage 2=65%, Stage 3=85%, Finalized=100%
        // Never decreases within a song, smoothly interpolates toward target
        this.grooveConfidence = 0.15;      // Start at minimal groove
        this._grooveConfidenceTarget = 0.15;

        // Debug logging - periodic to avoid spam
        this._lastLogTime = 0;
        this._logIntervalMs = 2000; // Log every 2 seconds
        this._recentIntervals = []; // Track intervals since last log
        this._recentRawBPMs = []; // Track raw BPMs before normalization
        this._recentNormalizedBPMs = []; // Track BPMs after normalization
        this._skippedPeaks = 0; // Count of skipped weak peaks
        this._skippedIntervals = 0; // Count of out-of-range intervals

        // Log buffer for copy-to-clipboard functionality
        this._logBuffer = [];
        this._maxLogEntries = 20; // Keep last 20 log entries

        console.log('[BPM] AgentBPMDetector initialized');
    }

    /**
     * Process a detected peak/onset
     * @param {number} strength - Peak strength (0-1)
     * @param {number} time - Timestamp in ms
     */
    processPeak(strength, time = performance.now()) {
        this.isActive = true;
        this.peakCount++;

        // Log every peak for debugging (first 10 peaks only)
        if (this.peakCount <= 10) {
            console.log(`[BPM] Peak #${this.peakCount}: strength=${strength.toFixed(3)}, time=${Math.round(time)}`);
        }

        // Skip weak peaks
        if (strength < 0.1) {
            this._skippedPeaks++;
            return;
        }

        // Calculate interval from last peak
        if (this.lastPeakTime > 0) {
            const interval = time - this.lastPeakTime;

            // Valid interval: 250ms (240 BPM) to 2000ms (30 BPM)
            if (interval >= 250 && interval <= 2000) {
                this.intervals.push(interval);
                this._recentIntervals.push(Math.round(interval));
                if (this.intervals.length > this.maxIntervals) {
                    this.intervals.shift();
                }

                // Vote for this interval's BPM
                this.voteForInterval(interval);
            } else {
                this._skippedIntervals++;
            }
        }

        this.lastPeakTime = time;

        // Update BPM estimate
        this.updateBPM();

        // Periodic debug logging
        this._debugLog(time);
    }

    /**
     * Vote for a BPM based on interval
     */
    voteForInterval(interval) {
        // Convert to BPM
        const rawBPM = 60000 / interval;

        // Track raw BPM before normalization
        this._recentRawBPMs.push(Math.round(rawBPM));

        // Normalize to 60-180 range using octave folding
        // But prefer NOT doubling/halving if close to boundaries
        let bpm = rawBPM;

        // Only normalize if clearly outside the range (with 5% tolerance at edges)
        const minWithTolerance = this.minBPM * 0.95; // 57 BPM
        const maxWithTolerance = this.maxBPM * 1.05; // 189 BPM

        if (bpm < minWithTolerance) {
            // Double until in range
            while (bpm < this.minBPM) bpm *= 2;
        } else if (bpm > maxWithTolerance) {
            // Halve until in range
            while (bpm > this.maxBPM) bpm /= 2;
        }
        // If bpm is between 57-60 or 180-189, clamp to valid range
        bpm = Math.max(this.minBPM, Math.min(this.maxBPM, bpm));

        // Track normalized BPM
        this._recentNormalizedBPMs.push(Math.round(bpm));

        // Round to nearest integer
        const bpmInt = Math.round(bpm);

        // Vote for this BPM and neighbors (±2 BPM, gaussian weighted)
        for (let offset = -2; offset <= 2; offset++) {
            const voteBPM = bpmInt + offset;
            if (voteBPM >= this.minBPM && voteBPM <= this.maxBPM) {
                // Gaussian weight: center gets 1.0, ±1 gets 0.6, ±2 gets 0.14
                const weight = Math.exp(-(offset * offset) / 2);
                const current = this.bpmVotes.get(voteBPM) || 0;
                this.bpmVotes.set(voteBPM, current + weight);
            }
        }

        // Decay all votes to favor recent data
        for (const [bpmKey, votes] of this.bpmVotes) {
            const decayed = votes * 0.95;
            if (decayed < 0.3) {
                this.bpmVotes.delete(bpmKey);
            } else {
                this.bpmVotes.set(bpmKey, decayed);
            }
        }
    }

    /**
     * Find winning BPM from votes - implements 3-stage lock system
     */
    updateBPM() {
        if (this.bpmVotes.size === 0 || this.intervals.length < 3) return;

        const now = performance.now();

        // Find winner and total
        let bestBPM = 0;
        let bestVotes = 0;
        let totalVotes = 0;

        for (const [bpm, votes] of this.bpmVotes) {
            totalVotes += votes;
            if (votes > bestVotes) {
                bestVotes = votes;
                bestBPM = bpm;
            }
        }

        if (bestBPM === 0) return;

        // Calculate cluster votes (sum of votes within ±2 BPM of winner)
        let clusterVotes = 0;
        for (let offset = -2; offset <= 2; offset++) {
            const nearbyBPM = bestBPM + offset;
            clusterVotes += this.bpmVotes.get(nearbyBPM) || 0;
        }
        const effectiveVotes = clusterVotes;

        // Check half-BPM votes (for subdivision detection)
        const halfBPM = Math.round(bestBPM / 2);
        let halfBPMVotes = 0;
        if (halfBPM >= this.minBPM) {
            for (let offset = -2; offset <= 2; offset++) {
                halfBPMVotes += this.bpmVotes.get(halfBPM + offset) || 0;
            }
        }

        // Check double-BPM votes (for songs detected too slow)
        const doubleBPM = bestBPM * 2;
        let doubleBPMVotes = 0;
        if (doubleBPM <= this.maxBPM) {
            for (let offset = -2; offset <= 2; offset++) {
                doubleBPMVotes += this.bpmVotes.get(doubleBPM + offset) || 0;
            }
        }

        // Calculate subdivision evidence (used in Stage 2)
        let alternatingScore = 0;
        let pairVariancePercent = 0;
        let halfVoteRatio = effectiveVotes > 0 ? halfBPMVotes / effectiveVotes : 0;

        if (this.intervals.length >= 6) {
            const recentIntervals = this.intervals.slice(-8);
            const avgInterval = recentIntervals.reduce((a, b) => a + b, 0) / recentIntervals.length;

            // Alternating pattern detection
            let alternatingCount = 0;
            for (let i = 0; i < recentIntervals.length - 1; i++) {
                const currAboveAvg = recentIntervals[i] > avgInterval;
                const nextAboveAvg = recentIntervals[i + 1] > avgInterval;
                if (currAboveAvg !== nextAboveAvg) {
                    alternatingCount++;
                }
            }
            alternatingScore = alternatingCount / (recentIntervals.length - 1);

            // Pair sum variance
            const pairSums = [];
            for (let i = 0; i < recentIntervals.length - 1; i += 2) {
                pairSums.push(recentIntervals[i] + recentIntervals[i + 1]);
            }
            if (pairSums.length >= 2) {
                const avgPairSum = pairSums.reduce((a, b) => a + b, 0) / pairSums.length;
                const pairSumVariance = pairSums.reduce((sum, ps) => sum + Math.abs(ps - avgPairSum), 0) / pairSums.length;
                pairVariancePercent = pairSumVariance / avgPairSum;
            }
        }

        // Confidence = cluster's share of votes
        this.confidence = totalVotes > 0 ? effectiveVotes / totalVotes : 0;

        // Check interval consistency
        let intervalConsistency = 0;
        if (this.intervals.length >= 4) {
            const expectedInterval = 60000 / bestBPM;
            const subdivisionInterval = expectedInterval / 2;
            const recentIntervals = this.intervals.slice(-8);
            let consistentCount = 0;
            for (const interval of recentIntervals) {
                const matchesBeat = Math.abs(interval - expectedInterval) / expectedInterval < 0.15;
                const matchesSubdivision = Math.abs(interval - subdivisionInterval) / subdivisionInterval < 0.15;
                const matchesDouble = Math.abs(interval - expectedInterval * 2) / (expectedInterval * 2) < 0.15;
                if (matchesBeat || matchesSubdivision || matchesDouble) {
                    consistentCount++;
                }
            }
            intervalConsistency = consistentCount / recentIntervals.length;
        }

        // Smooth currentBPM transition (for display before lock)
        if (this.currentBPM === 0) {
            this.currentBPM = bestBPM;
        } else {
            const alpha = this.intervals.length < 6 ? 0.5 : 0.3;
            this.currentBPM = this.currentBPM * (1 - alpha) + bestBPM * alpha;
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // 3-STAGE LOCK SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════

        // STAGE 0: Initial detection - try to lock quickly
        if (this.lockStage === 0) {
            // Store debug info
            this._lastLockCheck = {
                intervalCount: this.intervals.length,
                bestVotes: bestVotes.toFixed(1),
                clusterVotes: effectiveVotes.toFixed(1),
                confidence: (this.confidence * 100).toFixed(0) + '%',
                consistency: (intervalConsistency * 100).toFixed(0) + '%',
                bestBPM,
                adjustedBPM: bestBPM,
                isSubdivision: false,
                stage: 0,
                failReasons: []
            };

            // Simple lock criteria - no subdivision gating, lock fast for UX
            const minIntervals = bestBPM > 120 ? 12 : 8;
            const confidenceThreshold = 0.20;
            const consistencyThreshold = 0.45;

            if (this.intervals.length < minIntervals) {
                this._lastLockCheck.failReasons.push(`intervals<${minIntervals}`);
            }
            if (effectiveVotes <= 5) {
                this._lastLockCheck.failReasons.push(`votes<=5`);
            }
            if (this.confidence <= confidenceThreshold) {
                this._lastLockCheck.failReasons.push(`conf<=${(confidenceThreshold*100).toFixed(0)}%`);
            }
            if (intervalConsistency <= consistencyThreshold) {
                this._lastLockCheck.failReasons.push(`consistency<=${(consistencyThreshold*100).toFixed(0)}%`);
            }

            if (this.intervals.length >= minIntervals &&
                effectiveVotes > 5 &&
                this.confidence > confidenceThreshold &&
                intervalConsistency > consistencyThreshold) {

                // Stage 1 lock - fast initial lock, refinement coming
                this.lockedBPM = Math.round(this.currentBPM);
                this.lockStage = 1;
                this.stage1LockTime = now;
                console.log(`[BPM] Stage 1: Initial lock at ${this.lockedBPM} BPM (conf=${(this.confidence * 100).toFixed(0)}%, consistency=${(intervalConsistency * 100).toFixed(0)}%)`);
            }
        }

        // STAGE 1 & 2: Refinement window - collect subdivision evidence, allow ONE correction
        if (this.lockStage === 1 || this.lockStage === 2) {
            // Store subdivision check
            this._recentSubdivisionChecks.push({
                alternatingScore,
                pairVariance: pairVariancePercent,
                halfVoteRatio,
                time: now
            });
            if (this._recentSubdivisionChecks.length > 15) {
                this._recentSubdivisionChecks.shift();
            }

            // Calculate evidence for halving
            const positiveChecks = this._recentSubdivisionChecks.filter(c =>
                c.alternatingScore > 0.70 && c.pairVariance < 0.10
            ).length;

            // Also check average metrics
            const avgAltScore = this._recentSubdivisionChecks.reduce((s, c) => s + c.alternatingScore, 0) / this._recentSubdivisionChecks.length;
            const avgPairVar = this._recentSubdivisionChecks.reduce((s, c) => s + c.pairVariance, 0) / this._recentSubdivisionChecks.length;
            const avgHalfRatio = this._recentSubdivisionChecks.reduce((s, c) => s + c.halfVoteRatio, 0) / this._recentSubdivisionChecks.length;

            // Check for doubling (song detected too slow)
            const avgInterval = this.intervals.length > 0
                ? this.intervals.reduce((a, b) => a + b, 0) / this.intervals.length
                : 0;
            const doubleVoteRatio = effectiveVotes > 0 ? doubleBPMVotes / effectiveVotes : 0;

            // Calculate interval variance for debug (with outlier filtering)
            let intervalVarianceDebug = 0;
            let filteredCountDebug = 0;
            if (this.intervals.length >= 8) {
                const recentInts = this.intervals.slice(-12);
                const sorted = [...recentInts].sort((a, b) => a - b);
                const median = sorted[Math.floor(sorted.length / 2)];
                const filtered = recentInts.filter(i => Math.abs(i - median) / median < 0.5);
                filteredCountDebug = filtered.length;
                if (filtered.length >= 6) {
                    const avgInt = filtered.reduce((a, b) => a + b, 0) / filtered.length;
                    intervalVarianceDebug = filtered.reduce((sum, i) => sum + Math.abs(i - avgInt), 0) / filtered.length / avgInt;
                }
            }

            // Update debug info
            this._lastLockCheck = {
                intervalCount: this.intervals.length,
                bestBPM,
                adjustedBPM: this.lockedBPM,
                halfBPM,
                stage: this.lockStage,
                subdivisionChecks: this._recentSubdivisionChecks.length,
                positiveChecks,
                avgAltScore: (avgAltScore * 100).toFixed(0) + '%',
                avgPairVar: (avgPairVar * 100).toFixed(1) + '%',
                avgHalfRatio: (avgHalfRatio * 100).toFixed(0) + '%',
                intervalVariance: (intervalVarianceDebug * 100).toFixed(1) + '%',
                filteredCount: filteredCountDebug,
                correctionApplied: this.stage2CorrectionApplied,
                failReasons: []
            };

            // Stage 2 halving trigger (if in Stage 1, auto-advance to Stage 2)
            if (!this.stage2CorrectionApplied &&
                this._recentSubdivisionChecks.length >= 10 &&
                halfBPM >= this.minBPM) {

                // PATH A: Strong alternating pattern evidence (visible subdivisions)
                const shouldHalveByPattern = positiveChecks >= 7 &&   // 7/10+ checks positive
                    avgAltScore > 0.70 &&                    // Strong alternating pattern
                    avgPairVar < 0.10 &&                     // Consistent pair sums
                    this.lockedBPM > 100;                    // Only halve fast tempos

                // PATH B: Significant half-BPM votes (for fingerpicking where subdivisions
                // aren't detected by onset detector, but some intervals hit the half-tempo)
                // This catches Landslide-style songs where bass notes are consistent but
                // the actual tempo is half of what we detected
                // TIGHTENED: 40% threshold and >150 BPM to avoid false halving on fast syncopated songs
                const shouldHalveByVotes = avgHalfRatio > 0.40 &&   // 40%+ votes for half-BPM (was 25%)
                    this.lockedBPM > 150 &&                         // Only very fast detections (was 130)
                    halfBPM >= 65 && halfBPM <= 85;                 // Tighter range for acoustic ballads

                // PATH C: Very consistent high-tempo intervals (fingerpicking signature)
                // Real fast songs (EDM, punk) have varied intervals due to syncopation
                // Fingerpicking produces metronomic subdivisions with low variance
                // Use median-based outlier rejection to handle occasional missed beats
                let intervalVariance = 0;
                let filteredIntervalCount = 0;
                if (this.intervals.length >= 8) {
                    const recentInts = this.intervals.slice(-12);
                    // Sort to find median
                    const sorted = [...recentInts].sort((a, b) => a - b);
                    const median = sorted[Math.floor(sorted.length / 2)];
                    // Filter out intervals >50% away from median (likely missed beats or doubles)
                    const filtered = recentInts.filter(i => Math.abs(i - median) / median < 0.5);
                    filteredIntervalCount = filtered.length;
                    if (filtered.length >= 6) {
                        const avgInt = filtered.reduce((a, b) => a + b, 0) / filtered.length;
                        intervalVariance = filtered.reduce((sum, i) => sum + Math.abs(i - avgInt), 0) / filtered.length / avgInt;
                    }
                }
                // Require enough consistent intervals after filtering
                // TIGHT threshold: fingerpicking produces ~3% variance, real fast songs ~8%+
                const shouldHalveByConsistency = this.lockedBPM > 140 &&  // Very fast detection
                    halfBPM >= 65 && halfBPM <= 85 &&                     // Half in acoustic ballad range
                    filteredIntervalCount >= 8 &&                         // Enough consistent intervals
                    intervalVariance < 0.05;                              // Very consistent intervals (<5% variance)

                if (shouldHalveByPattern || shouldHalveByVotes || shouldHalveByConsistency) {
                    const oldBPM = this.lockedBPM;
                    this.lockedBPM = Math.round(this.lockedBPM / 2);
                    this.lockStage = 2;
                    this.stage2CorrectionApplied = true;
                    this.correctionType = 'halved';
                    const reason = shouldHalveByPattern
                        ? `pattern: ${positiveChecks}/${this._recentSubdivisionChecks.length} checks, altScore=${(avgAltScore*100).toFixed(0)}%`
                        : shouldHalveByVotes
                        ? `votes: halfRatio=${(avgHalfRatio*100).toFixed(0)}%`
                        : `consistency: variance=${(intervalVariance*100).toFixed(1)}%, filtered=${filteredIntervalCount}/12, halfBPM=${halfBPM}`;
                    console.log(`[BPM] Stage 2: HALVED ${oldBPM} → ${this.lockedBPM} BPM (${reason})`);
                }
            }

            // Stage 2 doubling trigger (for songs detected too slow)
            if (!this.stage2CorrectionApplied &&
                this._recentSubdivisionChecks.length >= 10 &&
                doubleBPM <= this.maxBPM) {

                // Doubling conditions: very slow intervals + strong double-BPM votes
                const shouldDouble = avgInterval > 900 &&    // Very slow (<67 BPM)
                    doubleVoteRatio > 0.5 &&                 // Significant double-BPM votes
                    this.lockedBPM < 75;                     // Only double slow tempos

                if (shouldDouble) {
                    const oldBPM = this.lockedBPM;
                    this.lockedBPM = Math.round(this.lockedBPM * 2);
                    this.lockStage = 2;
                    this.stage2CorrectionApplied = true;
                    this.correctionType = 'doubled';
                    console.log(`[BPM] Stage 2: DOUBLED ${oldBPM} → ${this.lockedBPM} BPM (avgInterval=${avgInterval.toFixed(0)}ms, doubleRatio=${(doubleVoteRatio*100).toFixed(0)}%)`);
                }
            }

            // Stage 1 → Stage 2 transition: after collecting enough subdivision evidence
            // This ensures Stage 2 (yellow) is visible in the UI as a distinct refinement phase
            const timeSinceLock = now - this.stage1LockTime;
            if (this.lockStage === 1 && this._recentSubdivisionChecks.length >= 6) {
                this.lockStage = 2;
                console.log(`[BPM] Stage 2: Entering refinement phase (${this._recentSubdivisionChecks.length} checks collected)`);
            }

            // Exit Stage 2 → Stage 3 conditions
            const conclusivelyNotSubdivision = this._recentSubdivisionChecks.length >= 12 && positiveChecks < 3;
            const timeoutReached = timeSinceLock > 10000; // 10 seconds

            if (this.lockStage === 2 && (this.stage2CorrectionApplied || conclusivelyNotSubdivision || timeoutReached)) {
                this.lockStage = 3;
                this._stage3StartTime = now;
                const reason = this.stage2CorrectionApplied ? 'correction applied' :
                    conclusivelyNotSubdivision ? 'not subdivision' : 'timeout';
                console.log(`[BPM] Stage 3: Entering final lock phase (${reason})`);
            }
        }

        // STAGE 3: Final lock - micro-tuning only, then cleanup
        if (this.lockStage === 3) {
            const timeSinceStage3 = now - this._stage3StartTime;

            // Micro-tuning: allow small adjustments within ±5%
            const recentIntervals = this.intervals.slice(-8);
            if (recentIntervals.length >= 4) {
                const avgRecentInterval = recentIntervals.reduce((a, b) => a + b, 0) / recentIntervals.length;
                const recentBPM = 60000 / avgRecentInterval;
                const drift = Math.abs(recentBPM - this.lockedBPM) / this.lockedBPM;

                if (drift < 0.05) {
                    // Small drift - accumulate micro-adjustments fractionally
                    // Initialize microTuneBPM on first Stage 3 entry
                    if (this._microTuneBPM === 0) {
                        this._microTuneBPM = this.lockedBPM;
                    }
                    // Smooth fractional adjustment (10% weight for faster response)
                    this._microTuneBPM = this._microTuneBPM * 0.90 + recentBPM * 0.10;
                    const newBPM = Math.round(this._microTuneBPM);
                    if (newBPM !== this.lockedBPM) {
                        console.log(`[BPM] Stage 3: Micro-tuned ${this.lockedBPM} → ${newBPM} BPM (fractional: ${this._microTuneBPM.toFixed(1)})`);
                        this.lockedBPM = newBPM;
                    }
                    this._stage3StableTime += 100; // Assume ~100ms between calls
                } else {
                    // Large drift - might be track change, don't adjust
                    this._stage3StableTime = 0;
                }
            }

            // Final cleanup after 5 seconds OR stable for 3 seconds (only once)
            const shouldFinalize = (timeSinceStage3 > 5000 || this._stage3StableTime > 3000) && !this._memoryCleanedUp;

            if (shouldFinalize && this.lockStage === 3) {
                this._performMemoryCleanup();
                this._memoryCleanedUp = true;
                console.log(`[BPM] 🔒 FINAL: Locked at ${this.lockedBPM} BPM (correction: ${this.correctionType})`);
                // lockStage stays at 3 to indicate fully locked
            }

            this._lastLockCheck = {
                stage: 3,
                lockedBPM: this.lockedBPM,
                correctionType: this.correctionType,
                timeSinceStage3: (timeSinceStage3 / 1000).toFixed(1) + 's',
                stableTime: (this._stage3StableTime / 1000).toFixed(1) + 's',
                finalized: shouldFinalize,
                failReasons: []
            };
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // GROOVE CONFIDENCE UPDATE
        // Maps lockStage to animation intensity, smoothly interpolated, never decreases
        // ═══════════════════════════════════════════════════════════════════════════
        this._updateGrooveConfidence();
    }

    /**
     * Update groove confidence based on current lock stage
     * This value is used by Rhythm3DAdapter to scale animation amplitudes
     * @private
     */
    _updateGrooveConfidence() {
        // Map lockStage to target confidence
        // Stage 0 (Detecting): 15% - tentative, searching
        // Stage 1 (Initial Lock): 40% - found something, building confidence
        // Stage 2 (Refinement): 65% - refining, getting comfortable
        // Stage 3 (Final Lock): 85% - confident, grooving
        // Finalized: 100% - locked in, full groove
        const stageTargets = [0.15, 0.40, 0.65, 0.85];

        if (this._memoryCleanedUp) {
            // Finalized - full groove
            this._grooveConfidenceTarget = 1.0;
        } else {
            this._grooveConfidenceTarget = stageTargets[this.lockStage] || 0.15;
        }

        // Smoothly interpolate toward target (but never decrease)
        // Use exponential smoothing: ~0.1 per call means ~10 calls to reach halfway
        const smoothingFactor = 0.08;
        const newConfidence = this.grooveConfidence + (this._grooveConfidenceTarget - this.grooveConfidence) * smoothingFactor;

        // Only increase, never decrease (maintain achieved groove level)
        if (newConfidence > this.grooveConfidence) {
            this.grooveConfidence = newConfidence;
        }
    }

    /**
     * Clean up memory after final lock
     * Keeps minimal state for drift detection
     * @private
     */
    _performMemoryCleanup() {
        // Keep only last 8 intervals for drift detection
        if (this.intervals.length > 8) {
            this.intervals = this.intervals.slice(-8);
        }

        // Clear voting histogram - no longer needed
        this.bpmVotes.clear();

        // Clear subdivision history - no longer needed
        this._subdivisionHistory = [];
        this._recentSubdivisionChecks = [];

        // Clear debug arrays
        this._recentIntervals = [];
        this._recentRawBPMs = [];
        this._recentNormalizedBPMs = [];

        console.log('[BPM] Memory cleanup: cleared voting histogram and subdivision history');
    }

    /**
     * Process frequency frame (for compatibility with frame-based detection)
     */
    processFrame(frequencyData, time = performance.now()) {
        // This detector is peak-based, not frame-based
        // The 3D engine calls processPeak directly from its own onset detection
        // This method is here for API compatibility only
    }

    /**
     * Reset detection
     */
    reset() {
        this.intervals = [];
        this.bpmVotes.clear();
        this.lastPeakTime = 0;
        this.peakCount = 0;
        this.currentBPM = 0;
        this.lockedBPM = 0;
        this.confidence = 0;
        this.isActive = false;

        // Reset 3-stage lock state
        this.lockStage = 0;
        this.stage1LockTime = 0;
        this.stage2CorrectionApplied = false;
        this.correctionType = 'none';
        this._recentSubdivisionChecks = [];
        this._stage3StartTime = 0;
        this._stage3StableTime = 0;
        this._memoryCleanedUp = false;
        this._microTuneBPM = 0;

        // Reset groove confidence
        this.grooveConfidence = 0.15;
        this._grooveConfidenceTarget = 0.15;

        // Also reset debug state
        this._lastLogTime = 0;
        this._recentIntervals = [];
        this._recentRawBPMs = [];
        this._recentNormalizedBPMs = [];
        this._skippedPeaks = 0;
        this._skippedIntervals = 0;
        this._logBuffer = [];
        this._lastLockCheck = null;
        this._subdivisionHistory = [];

        console.log('[BPM] Detector reset');
    }

    getBPM() {
        return this.lockedBPM > 0 ? this.lockedBPM : Math.round(this.currentBPM) || 0;
    }

    getSubdivision() {
        return 1;
    }

    getStatus() {
        return {
            bpm: this.getBPM(),
            subdivision: 1,
            confidence: this.confidence,
            locked: this.lockedBPM > 0,
            lockStage: this.lockStage,
            correctionType: this.correctionType,
            finalized: this._memoryCleanedUp,  // True only after final lock + cleanup
            grooveConfidence: this.grooveConfidence,  // Smooth animation intensity (0.15-1.0)
            agentCount: this.bpmVotes.size,
            peakCount: this.peakCount,
            histogramSize: this.bpmVotes.size,
            topAgents: this.getTopCandidates(5),
            intervalCount: this.intervals.length
        };
    }

    getTopCandidates(count = 5) {
        return [...this.bpmVotes.entries()]
            .sort((a, b) => b[1] - a[1])
            .slice(0, count)
            .map(([bpm, score]) => ({
                bpm,
                score: score.toFixed(1),
                interval: Math.round(60000 / bpm)
            }));
    }

    getTopIntervals(count = 5) {
        return this.getTopCandidates(count).map(c => ({
            interval: c.interval,
            bpm: c.bpm,
            weight: c.score
        }));
    }

    /**
     * Periodic debug logging - called from processPeak
     */
    _debugLog(time) {
        // Only log every 2 seconds
        if (time - this._lastLogTime < this._logIntervalMs) return;
        this._lastLogTime = time;

        // Skip if nothing to report
        if (this._recentIntervals.length === 0 && this._skippedPeaks === 0) return;

        // Build log entry for buffer
        const lines = [];

        // Stage names for display
        const stageNames = ['Detecting', 'Initial Lock', 'Refinement', 'Final Lock'];
        const stageName = stageNames[this.lockStage] || 'Unknown';

        lines.push('═══════════════════════════════════════════════════');
        lines.push(`Status: Stage ${this.lockStage} (${stageName}) | Current: ${Math.round(this.currentBPM)} BPM | Locked: ${this.lockedBPM || '-'}`);

        // Peak stats
        lines.push(`Peaks: ${this.peakCount} total | ${this._skippedPeaks} skipped (weak) | ${this._skippedIntervals} intervals out-of-range`);

        // Recent intervals (raw data)
        if (this._recentIntervals.length > 0) {
            lines.push(`Recent intervals (ms): [${this._recentIntervals.join(', ')}]`);
        }

        // Raw BPMs before normalization
        if (this._recentRawBPMs.length > 0) {
            lines.push(`Raw BPMs (before normalize): [${this._recentRawBPMs.join(', ')}]`);
        }

        // Normalized BPMs
        if (this._recentNormalizedBPMs.length > 0) {
            lines.push(`Normalized BPMs (60-180): [${this._recentNormalizedBPMs.join(', ')}]`);
        }

        // Top candidates from histogram
        const topCandidates = this.getTopCandidates(5);
        if (topCandidates.length > 0) {
            const candStr = topCandidates.map(c => `${c.bpm}(${c.score})`).join(', ');
            lines.push(`Top candidates: ${candStr}`);
        }

        // Lock check status (stage-aware)
        if (this._lastLockCheck) {
            const lc = this._lastLockCheck;
            if (lc.stage === 0) {
                // Stage 0: Detection phase
                if (lc.failReasons && lc.failReasons.length > 0) {
                    lines.push(`Stage 0: NOT locking - ${lc.failReasons.join(', ')}`);
                } else {
                    lines.push(`Stage 0: Ready to lock at ${lc.bestBPM} BPM`);
                }
            } else if (lc.stage === 1 || lc.stage === 2) {
                // Stage 1/2: Refinement phase
                lines.push(`Stage ${lc.stage}: Locked=${lc.adjustedBPM} BPM | checks=${lc.subdivisionChecks} positive=${lc.positiveChecks}`);
                lines.push(`  altScore=${lc.avgAltScore} pairVar=${lc.avgPairVar} halfRatio=${lc.avgHalfRatio}`);
                if (lc.correctionApplied) {
                    lines.push(`  Correction applied: ${this.correctionType}`);
                }
            } else if (lc.stage === 3) {
                // Stage 3: Final lock phase
                lines.push(`Stage 3: Final=${lc.lockedBPM} BPM | correction=${lc.correctionType} | time=${lc.timeSinceStage3} stable=${lc.stableTime}`);
                if (lc.finalized) {
                    lines.push(`  FINALIZED - memory cleaned`);
                }
            }
        }

        // Interval pattern info (helps diagnose subdivision detection)
        if (this.intervals.length >= 6) {
            const recentIntervals = this.intervals.slice(-8);
            const avgInterval = recentIntervals.reduce((a, b) => a + b, 0) / recentIntervals.length;
            const variance = recentIntervals.reduce((sum, i) => sum + Math.abs(i - avgInterval), 0) / recentIntervals.length;
            const variancePct = (variance / avgInterval * 100).toFixed(1);

            // Calculate alternating score
            let alternatingCount = 0;
            for (let i = 0; i < recentIntervals.length - 1; i++) {
                const currAboveAvg = recentIntervals[i] > avgInterval;
                const nextAboveAvg = recentIntervals[i + 1] > avgInterval;
                if (currAboveAvg !== nextAboveAvg) alternatingCount++;
            }
            const altScore = (alternatingCount / (recentIntervals.length - 1) * 100).toFixed(0);

            lines.push(`Interval pattern: variance=${variancePct}% alternating=${altScore}% (>70% triggers subdivision)`);
        }

        // Interval histogram summary
        const allIntervals = [...this.intervals].map(i => Math.round(i));
        if (allIntervals.length > 0) {
            const min = Math.min(...allIntervals);
            const max = Math.max(...allIntervals);
            const avg = Math.round(allIntervals.reduce((a, b) => a + b, 0) / allIntervals.length);
            lines.push(`Interval buffer (${allIntervals.length}/${this.maxIntervals}): min=${min}ms max=${max}ms avg=${avg}ms (=${Math.round(60000/avg)} BPM)`);
        }

        lines.push('═══════════════════════════════════════════════════');

        // Store in buffer with timestamp
        const timestamp = new Date().toLocaleTimeString('en-US', {
            hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'
        });
        this._logBuffer.push({
            time: timestamp,
            lines: lines
        });

        // Trim buffer to max entries
        while (this._logBuffer.length > this._maxLogEntries) {
            this._logBuffer.shift();
        }

        // Output to console with [BPM] prefix
        console.log('\n[BPM] ' + lines[0]);
        for (let i = 1; i < lines.length; i++) {
            console.log('[BPM] ' + lines[i]);
        }
        console.log('');

        // Reset recent trackers
        this._recentIntervals = [];
        this._recentRawBPMs = [];
        this._recentNormalizedBPMs = [];
        this._skippedPeaks = 0;
        this._skippedIntervals = 0;
    }

    /**
     * Get the debug log buffer as a string for clipboard copy
     * @returns {string} Formatted log buffer
     */
    getDebugLog() {
        if (this._logBuffer.length === 0) {
            return 'No BPM debug logs yet. Play audio to generate logs.';
        }

        let output = '=== BPM Debug Log ===\n\n';

        for (const entry of this._logBuffer) {
            output += `[${entry.time}]\n`;
            for (const line of entry.lines) {
                output += line + '\n';
            }
            output += '\n';
        }

        return output;
    }

    /**
     * Clear the debug log buffer
     */
    clearDebugLog() {
        this._logBuffer = [];
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Dance Choreographer
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Automatic dance choreography system triggered by audio signals
 * @author Emotive Engine Team
 * @module 3d/animation/DanceChoreographer
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║ CONCEPT
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Once BPM is locked, the mascot should start dancing automatically. This module
 * ║ monitors audio signals (bass energy, vocal flux, spectral data) and intelligently
 * ║ triggers gestures, switches groove presets, and fires effects at musically
 * ║ appropriate moments.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * FEATURES:
 * • Audio-driven gesture triggering based on bass/vocal/spectral analysis
 * • Automatic groove preset switching with 2-bar quantized transitions
 * • Intensity slider for user control (0-1)
 * • Glow effect safety limits (epilepsy-safe)
 * • Section detection for chorus/verse groove matching
 *
 * ARCHITECTURE:
 * ┌──────────────────────────────────────────────────────────────────────────────────┐
 * │  Audio Stream → AudioDeformer → DanceChoreographer → Rhythm3DAdapter/Mascot     │
 * │                     ↓                    ↓                                       │
 * │              bass/vocal/flux     gesture triggers                                │
 * │              spectral data       groove switches                                 │
 * └──────────────────────────────────────────────────────────────────────────────────┘
 *
 * SAFETY:
 * • Glow effects limited to max 2Hz frequency changes
 * • Max glow boost capped at 1.3x (not 3x)
 * • 2 second cooldown between glow events
 * • Max 1 flash per 8 bars
 */


/**
 * Glow-based gestures (USE SPARINGLY - brightness changes)
 * These are rate-limited for epilepsy safety
 */
const GLOW_GESTURES = ['flash', 'glow', 'burst', 'flicker'];

/**
 * Gesture pools by energy level
 * Single gestures are the norm; combos are rare and reserved for high energy
 */
const GESTURE_POOLS = {
    // Low energy: gentle accents + subtle absolutes (no combos)
    subtle: {
        single: ['pop', 'bob', 'swell', 'nod', 'sway', 'tilt'],
        combo: []  // No combos at low energy
    },
    // Medium energy: moderate variety (rare combos)
    moderate: {
        single: ['pop', 'bob', 'dip', 'swagger', 'bounce', 'wiggle', 'headBob', 'lean'],
        combo: [['pop', 'bob'], ['dip', 'swell']]  // 10% chance
    },
    // High energy: full variety (occasional combos)
    energetic: {
        single: ['flare', 'swagger', 'dip', 'spin', 'jump', 'twist', 'hula'],
        combo: [['flare', 'bob'], ['pop', 'dip'], ['swagger', 'flare']]  // 15% chance
    }
};

/**
 * Morph targets available for section changes
 * Each target specifies geometry and optional variant (eclipse, phase, material)
 *
 * Safe geometries with compatible material systems:
 * - Crystal-type: crystal, rough, heart, star (CrystalSoul + SSS shader)
 * - Moon: phases (full, new, crescent, etc.) and lunar eclipse (blood moon)
 * - Sun: normal and solar eclipses (annular, total)
 */
const MORPH_TARGETS = [
    // Crystal family (SSS shader + CrystalSoul)
    { geometry: 'crystal', variant: null },
    { geometry: 'rough', variant: null },
    { geometry: 'heart', variant: null },
    { geometry: 'star', variant: null },

    // Moon variants
    { geometry: 'moon', variant: { type: 'phase', value: 'full' } },
    { geometry: 'moon', variant: { type: 'phase', value: 'waxing-gibbous' } },
    { geometry: 'moon', variant: { type: 'phase', value: 'first-quarter' } },
    { geometry: 'moon', variant: { type: 'phase', value: 'waxing-crescent' } },
    { geometry: 'moon', variant: { type: 'phase', value: 'new' } },
    { geometry: 'moon', variant: { type: 'eclipse', value: 'partial' } },
    { geometry: 'moon', variant: { type: 'eclipse', value: 'total' } },  // Blood moon

    // Sun variants
    { geometry: 'sun', variant: null },  // Normal sun
    { geometry: 'sun', variant: { type: 'eclipse', value: 'annular' } },
    { geometry: 'sun', variant: { type: 'eclipse', value: 'total' } }
];

/**
 * Emotions available for automatic switching during dance
 * Grouped by energy/mood to enable smart transitions
 */
const DANCE_EMOTIONS = {
    // High energy emotions - for drops, chorus, peak moments
    high: ['joy', 'excited', 'euphoria', 'surprise'],
    // Medium energy emotions - for verses, builds
    medium: ['focused', 'love', 'calm', 'neutral'],
    // Low energy emotions - for breakdowns, outros
    low: ['resting', 'calm', 'sadness'],
    // Special/dramatic emotions - rare, for impact moments
    dramatic: ['anger', 'fear', 'suspicion', 'glitch', 'disgust']
};

/**
 * Flat list of all dance-safe emotions
 */
const ALL_DANCE_EMOTIONS = [
    'joy', 'excited', 'euphoria', 'surprise',
    'focused', 'love', 'calm', 'neutral',
    'resting', 'sadness',
    'anger', 'fear', 'suspicion', 'glitch'
];

// ═══════════════════════════════════════════════════════════════════════════════════════
// ENERGY THRESHOLDS
// ═══════════════════════════════════════════════════════════════════════════════════════

/**
 * Audio energy thresholds for groove selection
 * Higher values = more demanding criteria
 */
const ENERGY_THRESHOLDS = {
    // groove2 (energetic): High energy sections - chorus, drop
    energetic: { bass: 0.55},
    // groove3 (flowing): Medium energy with melodic content - bridge, build
    flowing: { bass: 0.25, vocal: 0.50 }
};

/**
 * Safety limits for glow effects
 */
const GLOW_SAFETY = {
    maxBoost: 1.3,         // Cap brightness at 130%
    cooldownMs: 800,       // 0.8 seconds between glow events (was 2s)
    minBarsBetweenFlash: 4 // Minimum bars between flash effects (was 8)
};

// ═══════════════════════════════════════════════════════════════════════════════════════
// DANCE CHOREOGRAPHER CLASS
// ═══════════════════════════════════════════════════════════════════════════════════════

class DanceChoreographer {
    constructor() {
        // References (set via setters)
        this.rhythmAdapter = null;
        this.mascot = null;
        this.audioDeformer = null;

        // State
        this.enabled = false;
        this.intensity = 0.5;          // 0-1, affects gesture frequency & amplitude
        this.currentGroove = 'groove1';
        this.lastGestureTime = 0;
        this.lastGlowTime = 0;
        this.lastFlashBar = -4;
        this.barCount = 0;
        this.lastBarProgress = 0;

        // Rolling averages for section detection
        this._bassHistory = [];
        this._vocalHistory = [];
        this._historyLength = 60; // ~2 seconds at 30fps

        // Gesture scheduling
        this._pendingGestures = [];
        this._gesturesThisBar = 0;
        this._lastGestureBar = -1;

        // Morph tracking
        this._lastMorphBar = -16;  // Start with cooldown expired
        this._currentTarget = { geometry: 'crystal', variant: null };  // Current morph target
        this._baseTarget = { geometry: 'crystal', variant: null };     // "Home" target to return to
        this._morphReturnTimeout = null;    // Timer for returning to base geometry

        // Emotion tracking
        this._lastEmotionBar = -12;  // Start with cooldown expired
        this._currentEmotion = 'neutral';
        this._baseEmotion = 'neutral';  // "Home" emotion to return to
        this._emotionReturnTimeout = null;  // Timer for returning to base emotion

        // Configuration
        this.config = {
            // How often to trigger gestures (in bars)
            // At 100% intensity: 4 / (0.5 + 1.0) = 2.67 → rounds to 3 bars
            // At 50% intensity: 4 / (0.5 + 0.5) = 4 bars
            // At 0% intensity: 4 / (0.5 + 0) = 8 bars
            gestureFrequencyBars: 4,       // Base: every 4 bars (intentional, not frantic)
            minGestureIntervalMs: 800,     // Minimum time between gestures (longer)

            // Combo probability by energy level
            comboProbability: {
                subtle: 0,      // No combos at low energy
                moderate: 0.10, // 10% chance at medium energy
                energetic: 0.15 // 15% chance at high energy
            },

            // Morph settings (geometry changes on section changes)
            morphEnabled: true,
            morphCooldownBars: 16,         // Minimum 16 bars between morphs (~8 seconds at 120bpm)
            morphEnergyThreshold: 0.5,     // Only morph when energy changes significantly
            morphReturnBars: 8,            // Bars before morphing back to base geometry (~4 sec at 120bpm)

            // Emotion settings (mood changes during dance)
            emotionEnabled: true,
            emotionCooldownBars: 12,       // Minimum 12 bars between emotion changes (~6 seconds at 120bpm)
            emotionReturnBars: 16,         // Bars before returning to base emotion (~8 sec at 120bpm)
            emotionMatchEnergy: true,      // Match emotion energy level to audio energy
            dramaticEmotionProbability: 0.1, // 10% chance of dramatic emotion on high energy

            // Groove switching
            grooveSwitchBars: 2,           // Transition duration
            energySmoothing: 0.05,         // How fast energy averages update

            // Intensity scaling
            intensityAffectsFrequency: true,
            intensityAffectsAmplitude: true,

            // Glow settings (with safety limits)
            glowEnabled: true,
            maxGlowBoost: GLOW_SAFETY.maxBoost,
            glowCooldownMs: GLOW_SAFETY.cooldownMs,

            // Auto-enable when BPM locks
            autoEnableOnLock: true
        };
    }

    // ═══════════════════════════════════════════════════════════════════════════════════
    // SETUP
    // ═══════════════════════════════════════════════════════════════════════════════════

    /**
     * Set rhythm adapter reference
     * @param {Object} adapter - Rhythm3DAdapter instance
     */
    setRhythmAdapter(adapter) {
        this.rhythmAdapter = adapter;
    }

    /**
     * Set mascot reference for triggering gestures
     * @param {Object} mascot - Mascot instance with gesture() method
     */
    setMascot(mascot) {
        this.mascot = mascot;

        // Sync geometry from mascot to avoid morph crashes
        if (mascot?.core3D?.geometryType) {
            const geometry = mascot.core3D.geometryType;
            this._currentTarget = { geometry, variant: null };
            this._baseTarget = { geometry, variant: null };
        }

        // Sync emotion from mascot
        if (mascot?.core3D?.emotion) {
            this._currentEmotion = mascot.core3D.emotion;
            this._baseEmotion = mascot.core3D.emotion;
        }
    }

    /**
     * Set audio deformer reference for audio signals
     * @param {Object} deformer - AudioDeformer instance
     */
    setAudioDeformer(deformer) {
        this.audioDeformer = deformer;
    }

    /**
     * Enable choreographer
     */
    enable() {
        this.enabled = true;
    }

    /**
     * Disable choreographer
     */
    disable() {
        this.enabled = false;
    }

    /**
     * Set dance intensity (0-1)
     * Higher intensity = more frequent gestures, larger movements
     * @param {number} value - Intensity value 0-1
     */
    setIntensity(value) {
        this.intensity = Math.max(0, Math.min(1, value));
    }

    /**
     * Get current intensity
     * @returns {number} Current intensity 0-1
     */
    getIntensity() {
        return this.intensity;
    }

    // ═══════════════════════════════════════════════════════════════════════════════════
    // MAIN UPDATE LOOP
    // ═══════════════════════════════════════════════════════════════════════════════════

    /**
     * Update choreographer - call every frame
     * @param {number} deltaTime - Time since last frame in seconds
     * @param {Object} audioData - Audio analysis data (bass, vocal, flux)
     */
    update(deltaTime, audioData = null) {
        if (!this.rhythmAdapter) {
            console.log('[DanceChoreographer] No rhythmAdapter!');
            return;
        }

        // Check if we should auto-enable when BPM locks
        // BPM detector is on the mascot instance, not on rhythmAdapter
        if (this.config.autoEnableOnLock && !this.enabled && this.mascot) {
            const bpmDetector = this.mascot._bpmDetector;
            if (bpmDetector) {
                const status = bpmDetector.getStatus();
                if (status?.finalized) {
                    this.enable();
                    this.setIntensity(1.0); // Full intensity when auto-enabled
                    console.log('[DanceChoreographer] Auto-enabled at full intensity - BPM locked!');
                }
            }
        }

        // Skip rest of update if not enabled
        if (!this.enabled) return;

        // Debug: Log barProgress periodically (every ~2 seconds)
        if (!this._lastBarProgressLog || performance.now() - this._lastBarProgressLog > 2000) {
            const barProg = this.rhythmAdapter?.barProgress ?? 'N/A';
            const beatProg = this.rhythmAdapter?.beatProgress ?? 'N/A';
            const isPlaying = this.rhythmAdapter?.isPlaying?.() ?? false;
            console.log(`[DanceChoreographer] barProgress=${typeof barProg === 'number' ? barProg.toFixed(3) : barProg}, beatProgress=${typeof beatProg === 'number' ? beatProg.toFixed(3) : beatProg}, isPlaying=${isPlaying}, barCount=${this.barCount}`);
            this._lastBarProgressLog = performance.now();
        }

        // Get audio data from deformer if not provided
        const audio = audioData || this._getAudioData();

        // Update rolling averages
        this._updateEnergyHistory(audio);

        // Detect bar transitions
        this._detectBarTransition();

        // Decide groove preset based on audio energy
        this._updateGroovePreset();

        // Trigger gestures at appropriate moments
        this._triggerGestures(audio);

        // Consider morphing on significant energy changes
        this._considerMorph(audio);

        // Consider emotion changes based on energy/section
        this._considerEmotion(audio);
    }

    /**
     * Get audio data from AudioDeformer
     * @private
     * @returns {Object} Audio data object
     */
    _getAudioData() {
        if (!this.audioDeformer) {
            return { bass: 0, vocal: 0, flux: 0 };
        }

        return {
            bass: this.audioDeformer.bassEnergy || 0,
            vocal: this.audioDeformer.vocalPresence || 0,
            flux: this.audioDeformer.transientStrength || 0
        };
    }

    /**
     * Update rolling energy averages
     * @private
     * @param {Object} audio - Current audio data
     */
    _updateEnergyHistory(audio) {
        // Add to history
        this._bassHistory.push(audio.bass);
        this._vocalHistory.push(audio.vocal);

        // Trim to max length
        while (this._bassHistory.length > this._historyLength) {
            this._bassHistory.shift();
        }
        while (this._vocalHistory.length > this._historyLength) {
            this._vocalHistory.shift();
        }
    }

    /**
     * Get smoothed average of energy history
     * @private
     * @param {number[]} history - Energy history array
     * @returns {number} Smoothed average
     */
    _getSmoothedEnergy(history) {
        if (history.length === 0) return 0;
        return history.reduce((a, b) => a + b, 0) / history.length;
    }

    /**
     * Detect bar boundary crossings
     * @private
     */
    _detectBarTransition() {
        if (!this.rhythmAdapter) return;

        const currentBarProgress = this.rhythmAdapter.barProgress || 0;

        // Detect bar boundary: progress wraps from high value back to low value
        // Use a more robust check that handles cases where we might miss the exact wrap
        // due to frame rate or timing issues (e.g., going from 0.75 to 0.25 directly)
        const wrapped = currentBarProgress < this.lastBarProgress - 0.5;

        if (wrapped) {
            this.barCount++;
            this._gesturesThisBar = 0;
            console.log(`[DanceChoreographer] Bar transition! barCount=${this.barCount} (${this.lastBarProgress.toFixed(2)} → ${currentBarProgress.toFixed(2)})`);
        }

        this.lastBarProgress = currentBarProgress;
    }

    // ═══════════════════════════════════════════════════════════════════════════════════
    // GROOVE PRESET SWITCHING
    // ═══════════════════════════════════════════════════════════════════════════════════

    /**
     * Update groove preset based on audio energy
     * Uses 2-bar quantized transitions for smooth changes
     * @private
     */
    _updateGroovePreset() {
        if (!this.rhythmAdapter) return;

        // Get smoothed energy levels
        const avgBass = this._getSmoothedEnergy(this._bassHistory);
        const avgVocal = this._getSmoothedEnergy(this._vocalHistory);

        // Detect appropriate groove preset
        const newGroove = this._detectGroovePreset(avgBass, avgVocal);

        // Switch if different (with 2-bar transition)
        if (newGroove !== this.currentGroove) {
            this._switchGroove(newGroove);
        }
    }

    /**
     * Detect appropriate groove preset based on energy levels
     * @private
     * @param {number} bass - Bass energy (0-1)
     * @param {number} vocal - Vocal presence (0-1)
     * @returns {string} Groove preset name
     */
    _detectGroovePreset(bass, vocal) {
        // Scale thresholds by intensity (lower intensity = harder to reach energetic)
        const intensityScale = 0.5 + this.intensity * 0.5; // 0.5-1.0

        // Check for energetic (high bass = drop/chorus)
        if (bass > ENERGY_THRESHOLDS.energetic.bass * intensityScale) {
            return 'groove2';
        }

        // Check for flowing (high vocals, moderate bass = melodic section)
        if (vocal > ENERGY_THRESHOLDS.flowing.vocal * intensityScale &&
            bass < ENERGY_THRESHOLDS.flowing.bass * 1.5) {
            return 'groove3';
        }

        // Default to subtle
        return 'groove1';
    }

    /**
     * Switch to a new groove preset with quantized transition
     * @private
     * @param {string} newGroove - New groove preset name
     */
    _switchGroove(newGroove) {
        if (!this.rhythmAdapter || !GROOVE_PRESETS[newGroove]) return;

        // Use existing setGroove API with 2-bar quantized transition
        this.rhythmAdapter.setGroove(newGroove, {
            quantize: true,
            bars: this.config.grooveSwitchBars
        });

        this.currentGroove = newGroove;
    }

    // ═══════════════════════════════════════════════════════════════════════════════════
    // GESTURE TRIGGERING
    // ═══════════════════════════════════════════════════════════════════════════════════

    /**
     * Decide when and what gestures to trigger
     * @private
     * @param {Object} audio - Current audio data
     */
    _triggerGestures(audio) {
        if (!this.mascot) {
            console.log('[DanceChoreographer] _triggerGestures: No mascot reference!');
            return;
        }

        // Only trigger gestures when rhythm is actually playing
        // This prevents premature gesture firing before music starts
        const isPlaying = this.rhythmAdapter?.isPlaying?.() ?? false;
        if (!isPlaying) {
            // Reset lastGestureBar when not playing so we can fire immediately when rhythm starts
            this._lastGestureBar = -1;
            return;
        }

        const now = performance.now();

        // Check minimum interval
        if (now - this.lastGestureTime < this.config.minGestureIntervalMs) {
            return;
        }

        // Calculate gesture frequency based on intensity
        const gestureFrequency = this.config.intensityAffectsFrequency
            ? Math.max(1, Math.round(this.config.gestureFrequencyBars / (0.5 + this.intensity)))
            : this.config.gestureFrequencyBars;

        // Check if it's time for a gesture (bar-aligned)
        if (this.barCount % gestureFrequency !== 0) {
            // Only log occasionally to avoid spam
            if (this.barCount > 0 && this.barCount % 8 === 0 && this._lastLoggedBar !== this.barCount) {
                console.log(`[DanceChoreographer] Waiting... barCount=${this.barCount}, freq=${gestureFrequency}, mod=${this.barCount % gestureFrequency}`);
                this._lastLoggedBar = this.barCount;
            }
            return;
        }
        if (this._lastGestureBar === this.barCount) return;

        // Decide what type of gesture based on current groove and energy
        const gestureType = this._selectGestureType(audio);
        const gesture = this._selectGesture(gestureType, audio);

        if (gesture) {
            console.log(`[DanceChoreographer] Triggering gesture: ${Array.isArray(gesture) ? gesture.join('+') : gesture} at bar ${this.barCount}`);
            this._executeGesture(gesture);
            this._lastGestureBar = this.barCount;
            this.lastGestureTime = now;
        }
    }

    /**
     * Select gesture type based on current state
     * @private
     * @param {Object} audio - Current audio data
     * @returns {string} Gesture type: 'punctuation', 'movement', 'dynamics', 'climactic'
     */
    _selectGestureType(audio) {
        // Very high energy (drop, climax) = rare climactic gestures (absolute motion)
        // Only use these sparingly - they interrupt the groove
        if (this.currentGroove === 'groove2' && this.intensity > 0.85 && audio.bass > 0.7) {
            // 30% chance of climactic gesture at very high energy
            if (Math.random() < 0.3) {
                return 'climactic';
            }
        }

        // Section changes or builds = dynamics (swell, flare)
        if (audio.flux > 0.6) {
            return 'dynamics';
        }

        // High energy with groove = movement accents (swagger, dip)
        if (this.currentGroove === 'groove2' && this.intensity > 0.6) {
            return 'movement';
        }

        // Default = punctuation (pop, punch) - the bread and butter of dancing
        return 'punctuation';
    }

    /**
     * Select gesture(s) based on energy level
     * Single gestures are the norm; combos are rare and reserved for high energy moments
     * @private
     * @param {string} type - Gesture type (unused, kept for API compatibility)
     * @param {Object} audio - Current audio data
     * @returns {string|string[]} Single gesture name or array of gesture names
     */
    _selectGesture(type, audio) {
        // Determine energy level
        let level = 'subtle';
        if (this.intensity > 0.7 || this.currentGroove === 'groove2') {
            level = 'energetic';
        } else if (this.intensity > 0.4) {
            level = 'moderate';
        }

        const pool = GESTURE_POOLS[level];
        const comboProbability = this.config.comboProbability[level] || 0;

        // Check if we should use a combo (rare)
        if (pool.combo.length > 0 && Math.random() < comboProbability) {
            return pool.combo[Math.floor(Math.random() * pool.combo.length)];
        }

        // Default: single gesture (the norm)
        return pool.single[Math.floor(Math.random() * pool.single.length)];
    }

    /**
     * Execute a gesture or combo of gestures
     * @private
     * @param {string|string[]} gesture - Single gesture name or array of gesture names
     */
    _executeGesture(gesture) {
        if (!this.mascot || !gesture) return;

        // Handle combo (array of gestures)
        if (Array.isArray(gesture)) {
            // Execute each gesture in the combo with slight stagger
            gesture.forEach((g, i) => {
                // Small delay between combo gestures (50ms stagger)
                setTimeout(() => {
                    this._executeSingleGesture(g);
                }, i * 50);
            });
            return;
        }

        // Single gesture
        this._executeSingleGesture(gesture);
    }

    /**
     * Execute a single gesture (internal)
     * @private
     * @param {string} gesture - Gesture name
     */
    _executeSingleGesture(gesture) {
        if (!this.mascot || !gesture) return;

        // Check if it's a glow gesture (requires safety check)
        if (GLOW_GESTURES.includes(gesture)) {
            if (!this._canTriggerGlow()) {
                return; // Skip glow gesture if on cooldown
            }
            this.lastGlowTime = performance.now();
            if (gesture === 'flash') {
                this.lastFlashBar = this.barCount;
            }
        }

        // Calculate amplitude based on intensity
        const amplitudeScale = this.config.intensityAffectsAmplitude
            ? 0.5 + this.intensity * 0.5
            : 1.0;

        // Trigger the gesture via mascot API
        if (typeof this.mascot.gesture === 'function') {
            this.mascot.gesture(gesture, { scale: amplitudeScale });
        }
    }

    /**
     * Check if glow effects can be triggered (safety check)
     * @private
     * @returns {boolean} True if glow is allowed
     */
    _canTriggerGlow() {
        if (!this.config.glowEnabled) return false;

        const now = performance.now();

        // Check cooldown
        if (now - this.lastGlowTime < this.config.glowCooldownMs) {
            return false;
        }

        // For flash specifically, check bar distance
        if (this.barCount - this.lastFlashBar < GLOW_SAFETY.minBarsBetweenFlash) {
            return false;
        }

        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════════════════
    // GEOMETRY MORPHING
    // ═══════════════════════════════════════════════════════════════════════════════════

    /**
     * Consider triggering a geometry morph on significant energy changes
     * Morphs are rare and intentional - like the mascot "deciding" to transform
     * @private
     * @param {Object} audio - Current audio data
     */
    _considerMorph(audio) {
        if (!this.config.morphEnabled || !this.mascot) return;

        // Check cooldown (long cooldown between morphs)
        const barsSinceLastMorph = this.barCount - this._lastMorphBar;
        if (barsSinceLastMorph < this.config.morphCooldownBars) return;

        // Get current energy levels
        const avgBass = this._getSmoothedEnergy(this._bassHistory);
        this._getSmoothedEnergy(this._vocalHistory);

        // Morph triggers:
        // 1. Groove change (section change) - most natural trigger
        // 2. Very high energy moment (drop) with low probability
        // 3. Energy "reset" - going from high back to low (breakdown)

        let shouldMorph = false;
        let morphReason = '';

        // Track previous groove for section change detection
        if (this._previousGroove === undefined) {
            this._previousGroove = this.currentGroove;
        }

        // Trigger 1: Section change (groove switched)
        if (this.currentGroove !== this._previousGroove) {
            // 40% chance on groove change
            if (Math.random() < 0.4) {
                shouldMorph = true;
                morphReason = 'section_change';
            }
            this._previousGroove = this.currentGroove;
        }

        // Trigger 2: High energy drop (very rare)
        if (!shouldMorph && this.currentGroove === 'groove2' && avgBass > 0.7) {
            // 5% chance during high energy (checked every frame, so still rare)
            // Only check once per bar to avoid spam
            if (this._lastMorphCheckBar !== this.barCount) {
                if (Math.random() < 0.05) {
                    shouldMorph = true;
                    morphReason = 'energy_peak';
                }
                this._lastMorphCheckBar = this.barCount;
            }
        }

        // Trigger 3: Time-based fallback (ensures morphs happen even without groove changes)
        // After dancing without a morph, transform to keep things interesting
        // At 120 BPM: 16 bars = ~32 seconds, so we morph roughly every 30-45 seconds
        if (!shouldMorph && barsSinceLastMorph >= 16) {
            // 25% chance per bar after 16 bars without morphing
            // This guarantees a morph within ~20 bars on average
            if (this._lastMorphCheckBar !== this.barCount) {
                if (Math.random() < 0.25) {
                    shouldMorph = true;
                    morphReason = 'time_variety';
                }
                this._lastMorphCheckBar = this.barCount;
            }
        }

        // Trigger 4: First morph comes early (introduce variety quickly)
        // If we haven't morphed yet and we're past bar 8, 15% chance per bar
        if (!shouldMorph && this._lastMorphBar < 0 && this.barCount >= 8) {
            if (this._lastMorphCheckBar !== this.barCount) {
                if (Math.random() < 0.15) {
                    shouldMorph = true;
                    morphReason = 'intro_variety';
                }
                this._lastMorphCheckBar = this.barCount;
            }
        }

        if (shouldMorph) {
            this._triggerMorph(morphReason);
        }
    }

    /**
     * Trigger a geometry morph to a new shape/variant
     * After morphReturnBars, will morph back to base geometry
     * @private
     * @param {string} reason - Why the morph was triggered (for logging)
     */
    _triggerMorph(reason) {
        if (!this.mascot) return;

        // Clear any pending return morph
        if (this._morphReturnTimeout) {
            clearTimeout(this._morphReturnTimeout);
            this._morphReturnTimeout = null;
        }

        // Check if two targets are the same (geometry + variant)
        const targetsEqual = (a, b) => {
            if (a.geometry !== b.geometry) return false;
            if (!a.variant && !b.variant) return true;
            if (!a.variant || !b.variant) return false;
            return a.variant.type === b.variant.type && a.variant.value === b.variant.value;
        };

        // Select a different target than current (excluding base so we have somewhere to return to)
        const candidates = MORPH_TARGETS.filter(t =>
            !targetsEqual(t, this._currentTarget) && !targetsEqual(t, this._baseTarget)
        );

        // If no options (only base left), pick any non-current
        const finalCandidates = candidates.length > 0
            ? candidates
            : MORPH_TARGETS.filter(t => !targetsEqual(t, this._currentTarget));

        if (finalCandidates.length === 0) return;

        const newTarget = finalCandidates[Math.floor(Math.random() * finalCandidates.length)];
        const targetLabel = this._getTargetLabel(newTarget);
        const currentLabel = this._getTargetLabel(this._currentTarget);

        console.log(`[DanceChoreographer] 🎭 Morphing: ${currentLabel} → ${targetLabel} (reason: ${reason}) at bar ${this.barCount}`);

        // Apply the morph target
        this._applyMorphTarget(newTarget);

        this._currentTarget = newTarget;
        this._lastMorphBar = this.barCount;

        // Schedule return to base geometry
        const bpm = this.rhythmAdapter?.getBPM?.() || 120;
        const barDurationMs = (60 / bpm) * 4 * 1000; // 4 beats per bar
        const returnDelayMs = this.config.morphReturnBars * barDurationMs;

        this._morphReturnTimeout = setTimeout(() => {
            this._returnToBaseGeometry();
        }, returnDelayMs);
    }

    /**
     * Return to base geometry after morph duration expires
     * @private
     */
    _returnToBaseGeometry() {
        if (!this.mascot) return;

        this._morphReturnTimeout = null;

        // Check if two targets are the same
        const targetsEqual = (a, b) => {
            if (a.geometry !== b.geometry) return false;
            if (!a.variant && !b.variant) return true;
            if (!a.variant || !b.variant) return false;
            return a.variant.type === b.variant.type && a.variant.value === b.variant.value;
        };

        // Only return if we're not already at base
        if (targetsEqual(this._currentTarget, this._baseTarget)) return;

        const currentLabel = this._getTargetLabel(this._currentTarget);
        const baseLabel = this._getTargetLabel(this._baseTarget);

        console.log(`[DanceChoreographer] 🔄 Returning: ${currentLabel} → ${baseLabel} at bar ${this.barCount}`);

        // Apply the base target
        this._applyMorphTarget(this._baseTarget);

        this._currentTarget = { ...this._baseTarget };
        // Don't update _lastMorphBar here - the cooldown is for outgoing morphs only
    }

    /**
     * Apply a morph target (geometry + variant)
     * @private
     * @param {Object} target - Target with geometry and optional variant
     */
    _applyMorphTarget(target) {
        const core3D = this.mascot?.core3D;
        if (!core3D) return;

        // Check if we need to change geometry
        const currentGeometry = core3D.geometryType;
        const needsGeometryChange = currentGeometry !== target.geometry;

        if (needsGeometryChange) {
            // Trigger geometry morph
            if (typeof this.mascot.morphTo === 'function') {
                this.mascot.morphTo(target.geometry);
            } else if (typeof this.mascot.setGeometry === 'function') {
                this.mascot.setGeometry(target.geometry);
            }

            // Apply variant after morph completes (morph duration is ~1000ms)
            // Wait 1200ms to ensure material is ready
            if (target.variant) {
                setTimeout(() => {
                    // Verify geometry actually changed before applying variant
                    if (core3D.geometryType === target.geometry) {
                        this._applyVariant(target.geometry, target.variant);
                    }
                }, 1200);
            }
        } else {
            // Same geometry - just apply/clear variant immediately
            if (target.variant) {
                this._applyVariant(target.geometry, target.variant);
            } else {
                this._clearVariant(target.geometry);
            }
        }
    }

    /**
     * Apply a variant effect (eclipse, phase, etc.)
     * @private
     * @param {string} geometry - Geometry type
     * @param {Object} variant - Variant config { type, value }
     */
    _applyVariant(geometry, variant) {
        const core3D = this.mascot?.core3D;
        if (!core3D) return;

        // Safety check: only apply variant if we're on the correct geometry
        if (core3D.geometryType !== geometry) {
            console.warn(`[DanceChoreographer] Skipping variant - expected ${geometry}, got ${core3D.geometryType}`);
            return;
        }

        if (geometry === 'moon') {
            // Verify moon material is ready
            if (!core3D.customMaterial?.uniforms?.shadowOffset) {
                console.warn('[DanceChoreographer] Moon material not ready for phase/eclipse');
                return;
            }

            if (variant.type === 'eclipse') {
                // Set moon to full first (required for eclipse)
                setMoonPhase(core3D.customMaterial, 'full');
                // Apply eclipse
                if (typeof core3D.setMoonEclipse === 'function') {
                    core3D.setMoonEclipse(variant.value);
                }
            } else if (variant.type === 'phase') {
                // Clear any eclipse first
                if (typeof core3D.setMoonEclipse === 'function') {
                    core3D.setMoonEclipse('off');
                }
                // Apply phase using the Moon.js utility
                setMoonPhase(core3D.customMaterial, variant.value);
            }
        } else if (geometry === 'sun') {
            if (variant.type === 'eclipse') {
                if (typeof core3D.setSunShadow === 'function') {
                    core3D.setSunShadow(variant.value);
                }
            }
        }
    }

    /**
     * Clear variant effects for a geometry
     * Only clears if we're currently on that geometry
     * @private
     * @param {string} geometry - Geometry type
     */
    _clearVariant(geometry) {
        const core3D = this.mascot?.core3D;
        if (!core3D) return;

        // Only clear if we're on the correct geometry
        if (core3D.geometryType !== geometry) return;

        if (geometry === 'moon') {
            if (typeof core3D.setMoonEclipse === 'function') {
                core3D.setMoonEclipse('off');
            }
            // Reset to full moon
            if (core3D.customMaterial?.uniforms?.shadowOffset) {
                setMoonPhase(core3D.customMaterial, 'full');
            }
        } else if (geometry === 'sun') {
            if (typeof core3D.setSunShadow === 'function') {
                core3D.setSunShadow('off');
            }
        }
    }

    /**
     * Get a human-readable label for a morph target
     * @private
     * @param {Object} target - Target with geometry and optional variant
     * @returns {string} Label like "moon:blood" or "crystal"
     */
    _getTargetLabel(target) {
        if (!target.variant) return target.geometry;
        return `${target.geometry}:${target.variant.value}`;
    }

    // ═══════════════════════════════════════════════════════════════════════════════════
    // EMOTION SWITCHING
    // ═══════════════════════════════════════════════════════════════════════════════════

    /**
     * Consider triggering an emotion change based on audio energy
     * Emotions change more frequently than morphs, adding life to the dance
     * @private
     * @param {Object} audio - Current audio data
     */
    _considerEmotion(audio) {
        if (!this.config.emotionEnabled || !this.mascot) return;

        // Only consider emotion changes when rhythm is actually playing
        const isPlaying = this.rhythmAdapter?.isPlaying?.() ?? false;
        if (!isPlaying) return;

        // Check cooldown
        const barsSinceLastEmotion = this.barCount - this._lastEmotionBar;
        if (barsSinceLastEmotion < this.config.emotionCooldownBars) return;

        // Get current energy levels
        const avgBass = this._getSmoothedEnergy(this._bassHistory);
        const avgVocal = this._getSmoothedEnergy(this._vocalHistory);
        const combinedEnergy = (avgBass + avgVocal) / 2;

        // Emotion change triggers (more frequent than morphs):
        // 1. Groove change (section change) - guaranteed emotion shift
        // 2. Energy level changes - adapt mood to music
        // 3. Time-based variety - keep the mascot "alive"

        let shouldChangeEmotion = false;
        let emotionReason = '';

        // Track groove for section detection
        if (this._prevGrooveForEmotion === undefined) {
            this._prevGrooveForEmotion = this.currentGroove;
        }

        // Trigger 1: Section change (groove switched) - high probability
        if (this.currentGroove !== this._prevGrooveForEmotion) {
            // 60% chance on groove change (emotions are more fluid than morphs)
            if (Math.random() < 0.6) {
                shouldChangeEmotion = true;
                emotionReason = 'section_change';
            }
            this._prevGrooveForEmotion = this.currentGroove;
        }

        // Trigger 2: High energy peak (drops, chorus)
        if (!shouldChangeEmotion && this.currentGroove === 'groove2' && combinedEnergy > 0.6) {
            // 15% chance per bar during high energy
            if (this._lastEmotionCheckBar !== this.barCount) {
                if (Math.random() < 0.15) {
                    shouldChangeEmotion = true;
                    emotionReason = 'energy_peak';
                }
                this._lastEmotionCheckBar = this.barCount;
            }
        }

        // Trigger 3: Low energy (breakdowns) - shift to calmer emotions
        if (!shouldChangeEmotion && this.currentGroove === 'groove1' && combinedEnergy < 0.25) {
            // 10% chance per bar during quiet sections
            if (this._lastEmotionCheckBar !== this.barCount) {
                if (Math.random() < 0.10) {
                    shouldChangeEmotion = true;
                    emotionReason = 'energy_low';
                }
                this._lastEmotionCheckBar = this.barCount;
            }
        }

        // Trigger 4: Time-based variety (every ~12-16 bars without change)
        if (!shouldChangeEmotion && barsSinceLastEmotion >= 12) {
            // 20% chance per bar after cooldown
            if (this._lastEmotionCheckBar !== this.barCount) {
                if (Math.random() < 0.20) {
                    shouldChangeEmotion = true;
                    emotionReason = 'time_variety';
                }
                this._lastEmotionCheckBar = this.barCount;
            }
        }

        if (shouldChangeEmotion) {
            this._triggerEmotion(emotionReason, combinedEnergy);
        }
    }

    /**
     * Trigger an emotion change
     * Selects an appropriate emotion based on energy level
     * @private
     * @param {string} reason - Why the emotion was triggered
     * @param {number} energy - Current combined energy level (0-1)
     */
    _triggerEmotion(reason, energy) {
        if (!this.mascot) return;

        // Clear any pending return
        if (this._emotionReturnTimeout) {
            clearTimeout(this._emotionReturnTimeout);
            this._emotionReturnTimeout = null;
        }

        // Select emotion based on energy level
        let emotionPool;

        if (this.config.emotionMatchEnergy) {
            // Check for dramatic emotion chance on high energy moments
            if (energy > 0.65 && Math.random() < this.config.dramaticEmotionProbability) {
                emotionPool = DANCE_EMOTIONS.dramatic;
            } else if (energy > 0.55) {
                emotionPool = DANCE_EMOTIONS.high;
            } else if (energy > 0.3) {
                emotionPool = DANCE_EMOTIONS.medium;
            } else {
                emotionPool = DANCE_EMOTIONS.low;
            }
        } else {
            // Random from all emotions
            emotionPool = ALL_DANCE_EMOTIONS;
        }

        // Filter out current emotion
        const candidates = emotionPool.filter(e => e !== this._currentEmotion);
        if (candidates.length === 0) return;

        const newEmotion = candidates[Math.floor(Math.random() * candidates.length)];

        console.log(`[DanceChoreographer] 😊 Emotion: ${this._currentEmotion} → ${newEmotion} (reason: ${reason}, energy: ${energy.toFixed(2)}) at bar ${this.barCount}`);

        // Apply emotion via mascot
        if (typeof this.mascot.setEmotion === 'function') {
            this.mascot.setEmotion(newEmotion);
        } else if (this.mascot.core3D && typeof this.mascot.core3D.setEmotion === 'function') {
            this.mascot.core3D.setEmotion(newEmotion);
        }

        this._currentEmotion = newEmotion;
        this._lastEmotionBar = this.barCount;

        // Schedule return to base emotion
        const bpm = this.rhythmAdapter?.getBPM?.() || 120;
        const barDurationMs = (60 / bpm) * 4 * 1000;
        const returnDelayMs = this.config.emotionReturnBars * barDurationMs;

        this._emotionReturnTimeout = setTimeout(() => {
            this._returnToBaseEmotion();
        }, returnDelayMs);
    }

    /**
     * Return to base emotion after emotion duration expires
     * @private
     */
    _returnToBaseEmotion() {
        if (!this.mascot) return;

        this._emotionReturnTimeout = null;

        // Only return if we're not already at base
        if (this._currentEmotion === this._baseEmotion) return;

        console.log(`[DanceChoreographer] 🔄 Emotion return: ${this._currentEmotion} → ${this._baseEmotion} at bar ${this.barCount}`);

        // Apply base emotion via mascot
        if (typeof this.mascot.setEmotion === 'function') {
            this.mascot.setEmotion(this._baseEmotion);
        } else if (this.mascot.core3D && typeof this.mascot.core3D.setEmotion === 'function') {
            this.mascot.core3D.setEmotion(this._baseEmotion);
        }

        this._currentEmotion = this._baseEmotion;
        // Don't update _lastEmotionBar - cooldown is for outgoing changes only
    }

    /**
     * Set the base emotion (the "home" to return to after changes)
     * @param {string} emotion - Emotion name (e.g., 'neutral', 'joy')
     */
    setBaseEmotion(emotion) {
        this._baseEmotion = emotion;
        this._currentEmotion = emotion;
    }

    /**
     * Sync emotion state from mascot
     * Call this after external setEmotion() calls to keep choreographer in sync
     */
    syncEmotionFromMascot() {
        if (this.mascot?.core3D?.emotion) {
            this._currentEmotion = this.mascot.core3D.emotion;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════════════
    // DEBUG & STATUS
    // ═══════════════════════════════════════════════════════════════════════════════════

    /**
     * Get choreographer status for debugging
     * @returns {Object} Status object
     */
    getStatus() {
        return {
            enabled: this.enabled,
            intensity: this.intensity,
            currentGroove: this.currentGroove,
            currentTarget: this._getTargetLabel(this._currentTarget),
            baseTarget: this._getTargetLabel(this._baseTarget),
            currentEmotion: this._currentEmotion,
            baseEmotion: this._baseEmotion,
            barCount: this.barCount,
            avgBass: this._getSmoothedEnergy(this._bassHistory).toFixed(3),
            avgVocal: this._getSmoothedEnergy(this._vocalHistory).toFixed(3),
            lastGestureAgo: Math.round((performance.now() - this.lastGestureTime) / 1000) + 's',
            lastGlowAgo: Math.round((performance.now() - this.lastGlowTime) / 1000) + 's',
            lastMorphBar: this._lastMorphBar,
            barsSinceLastMorph: this.barCount - this._lastMorphBar,
            lastEmotionBar: this._lastEmotionBar,
            barsSinceLastEmotion: this.barCount - this._lastEmotionBar,
            canGlow: this._canTriggerGlow()
        };
    }

    /**
     * Set the base geometry target (the "home" to return to after morphs)
     * Also sets current target to base
     * @param {string} geometry - Geometry name (e.g., 'crystal', 'moon', 'sun')
     * @param {Object} [variant] - Optional variant { type, value }
     */
    setBaseGeometry(geometry, variant = null) {
        this._baseTarget = { geometry, variant };
        this._currentTarget = { geometry, variant };
    }

    /**
     * Sync geometry state from mascot
     * Call this after external morphTo() calls to keep choreographer in sync
     */
    syncGeometryFromMascot() {
        if (this.mascot?.core3D?.geometryType) {
            const geometry = this.mascot.core3D.geometryType;
            this._currentTarget = { geometry, variant: null };
        }
    }

    /**
     * Reset state
     */
    reset() {
        this.enabled = false;
        this.currentGroove = 'groove1';
        this.barCount = 0;
        this.lastBarProgress = 0;
        this.lastGestureTime = 0;
        this.lastGlowTime = 0;
        this.lastFlashBar = -4;
        this._bassHistory = [];
        this._vocalHistory = [];
        this._gesturesThisBar = 0;
        this._lastGestureBar = -1;
        // Morph state - sync from mascot if available, else default to 'crystal'
        this._lastMorphBar = -16;
        const mascotGeometry = this.mascot?.core3D?.geometryType || 'crystal';
        this._currentTarget = { geometry: mascotGeometry, variant: null };
        this._baseTarget = { geometry: mascotGeometry, variant: null };
        this._previousGroove = undefined;
        this._lastMorphCheckBar = -1;
        // Clear morph return timer
        if (this._morphReturnTimeout) {
            clearTimeout(this._morphReturnTimeout);
            this._morphReturnTimeout = null;
        }
        // Emotion state - sync from mascot if available, else default to 'neutral'
        this._lastEmotionBar = -12;
        const mascotEmotion = this.mascot?.core3D?.emotion || 'neutral';
        this._currentEmotion = mascotEmotion;
        this._baseEmotion = mascotEmotion;
        this._prevGrooveForEmotion = undefined;
        this._lastEmotionCheckBar = -1;
        // Clear emotion return timer
        if (this._emotionReturnTimeout) {
            clearTimeout(this._emotionReturnTimeout);
            this._emotionReturnTimeout = null;
        }
    }

    /**
     * Cleanup resources
     */
    destroy() {
        // Clear timers first
        if (this._morphReturnTimeout) {
            clearTimeout(this._morphReturnTimeout);
            this._morphReturnTimeout = null;
        }
        if (this._emotionReturnTimeout) {
            clearTimeout(this._emotionReturnTimeout);
            this._emotionReturnTimeout = null;
        }
        this.reset();
        this.rhythmAdapter = null;
        this.mascot = null;
        this.audioDeformer = null;
    }
}

/**
 * Procedural Sphere Geometry
 *
 * Generates UV sphere using latitude/longitude parameterization
 */

function createSphere(segments = 32, rings = 32) {
    const vertices = [];
    const normals = [];
    const indices = [];

    // Generate vertices
    for (let ring = 0; ring <= rings; ring++) {
        const v = ring / rings; // 0 to 1
        const phi = v * Math.PI; // 0 to π (latitude)

        for (let segment = 0; segment <= segments; segment++) {
            const u = segment / segments; // 0 to 1
            const theta = u * Math.PI * 2; // 0 to 2π (longitude)

            // Spherical to Cartesian coordinates
            const x = Math.cos(theta) * Math.sin(phi);
            const y = Math.cos(phi);
            const z = Math.sin(theta) * Math.sin(phi);

            vertices.push(x, y, z);

            // For sphere, normal = position (unit sphere)
            normals.push(x, y, z);
        }
    }

    // Generate indices (triangles)
    for (let ring = 0; ring < rings; ring++) {
        for (let segment = 0; segment < segments; segment++) {
            const a = ring * (segments + 1) + segment;
            const b = a + segments + 1;
            const c = a + 1;
            const d = b + 1;

            // Two triangles per quad
            indices.push(a, b, c);
            indices.push(c, b, d);
        }
    }

    return {
        vertices: new Float32Array(vertices),
        normals: new Float32Array(normals),
        indices: new Uint16Array(indices)
    };
}

/**
 * Procedural Crystal Geometry
 *
 * Hexagonal crystal with pointed top and bottom
 * Perfect for magical/mystical aesthetic
 */

function createCrystal(segments = 6) {
    const vertices = [];
    const normals = [];
    const indices = [];

    const height = 1.5;
    const radius = 0.7;
    const midHeight = 0;

    // Vertices
    const vertexMap = new Map();
    let vertexIndex = 0;

    // Helper to add unique vertex
    function addVertex(x, y, z, nx, ny, nz) {
        const key = `${x},${y},${z}`;
        if (!vertexMap.has(key)) {
            vertices.push(x, y, z);
            normals.push(nx, ny, nz);
            vertexMap.set(key, vertexIndex++);
        }
        return vertexMap.get(key);
    }

    // Top point
    const topIndex = addVertex(0, height, 0, 0, 1, 0);

    // Middle ring (hexagon)
    const midIndices = [];
    for (let i = 0; i < segments; i++) {
        const angle = (i / segments) * Math.PI * 2;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;

        // Calculate face normal (pointing outward)
        const nx = Math.cos(angle);
        const nz = Math.sin(angle);

        const idx = addVertex(x, midHeight, z, nx, 0, nz);
        midIndices.push(idx);
    }

    // Bottom point
    const bottomIndex = addVertex(0, -height, 0, 0, -1, 0);

    // Create triangles

    // Top pyramid (top point to mid ring)
    for (let i = 0; i < segments; i++) {
        const next = (i + 1) % segments;
        indices.push(
            topIndex,
            midIndices[i],
            midIndices[next]
        );
    }

    // Bottom pyramid (mid ring to bottom point)
    for (let i = 0; i < segments; i++) {
        const next = (i + 1) % segments;
        indices.push(
            midIndices[i],
            bottomIndex,
            midIndices[next]
        );
    }

    return {
        vertices: new Float32Array(vertices),
        normals: new Float32Array(normals),
        indices: new Uint16Array(indices)
    };
}

/**
 * Procedural Diamond Geometry
 *
 * Brilliant-cut diamond shape (stretched octahedron)
 * Classic faceted gem appearance
 */

function createDiamond() {
    const vertices = [];
    const normals = [];
    const indices = [];

    // Diamond proportions (brilliant cut inspired)
    const topHeight = 1.2;    // Crown height
    const bottomHeight = -0.8; // Pavilion depth
    // const tableSize = 0.4;     // Top facet size
    const girdleSize = 0.8;    // Widest point

    // Key vertices
    const topPoint = [0, topHeight, 0];
    const bottomPoint = [0, bottomHeight, 0];

    // Girdle (widest part - 8 points for more facets)
    const girdlePoints = [];
    const segments = 8;

    for (let i = 0; i < segments; i++) {
        const angle = (i / segments) * Math.PI * 2;
        girdlePoints.push([
            Math.cos(angle) * girdleSize,
            0,
            Math.sin(angle) * girdleSize
        ]);
    }

    // Helper to add triangle
    function addTriangle(p1, p2, p3) {
        // Calculate normal
        const v1 = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
        const v2 = [p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2]];

        // Cross product
        const nx = v1[1] * v2[2] - v1[2] * v2[1];
        const ny = v1[2] * v2[0] - v1[0] * v2[2];
        const nz = v1[0] * v2[1] - v1[1] * v2[0];

        // Normalize
        const len = Math.sqrt(nx*nx + ny*ny + nz*nz);
        const normal = [nx/len, ny/len, nz/len];

        // Add vertices with normal
        const baseIdx = vertices.length / 3;

        vertices.push(...p1);
        normals.push(...normal);

        vertices.push(...p2);
        normals.push(...normal);

        vertices.push(...p3);
        normals.push(...normal);

        indices.push(baseIdx, baseIdx + 1, baseIdx + 2);
    }

    // Crown facets (top pyramid)
    for (let i = 0; i < segments; i++) {
        const next = (i + 1) % segments;
        addTriangle(topPoint, girdlePoints[i], girdlePoints[next]);
    }

    // Pavilion facets (bottom pyramid)
    for (let i = 0; i < segments; i++) {
        const next = (i + 1) % segments;
        addTriangle(girdlePoints[i], bottomPoint, girdlePoints[next]);
    }

    return {
        vertices: new Float32Array(vertices),
        normals: new Float32Array(normals),
        indices: new Uint16Array(indices)
    };
}

/**
 * Procedural 3D Geometries
 *
 * Built-in geometry library - no loading required!
 * Each geometry is generated procedurally from mathematical functions.
 */


/**
 * Core geometry registry (LEGACY - NOT USED)
 *
 * This registry uses the old custom WebGL format with raw TypedArrays.
 * It has been superseded by THREE_GEOMETRIES in ThreeGeometries.js which uses Three.js BufferGeometry.
 *
 * MEMORY LEAK NOTE: This registry can be safely removed in a future cleanup as it is not referenced
 * anywhere in the codebase. The THREE_GEOMETRIES registry is used instead.
 *
 * These are available immediately without loading
 */
const CORE_GEOMETRIES = {
    // Basic shapes
    sphere: createSphere(32, 32),     // Smooth sphere

    // Crystalline shapes
    crystal: createCrystal(6),         // Hexagonal crystal
    diamond: createDiamond(),          // Brilliant cut diamond

    // Platonic solids (TODO: Phase 2)
    // cube: createCube(),
    // octahedron: createOctahedron(),
    // icosahedron: createIcosahedron()
};

/**
 * Dispose of all core geometries
 * Call this when shutting down the 3D system to free GPU memory
 */
function disposeCoreGeometries() {
    Object.values(CORE_GEOMETRIES).forEach(geometry => {
        if (geometry && geometry.vertices) {
            // Our custom geometry format doesn't need disposal (just TypedArrays)
            // But we null the references to help GC
            geometry.vertices = null;
            geometry.normals = null;
            geometry.indices = null;
        }
    });
}

/**
 * ═══════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE 3D
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Emotive Engine 3D - Experimental WebGL Rendering
 * @author Emotive Engine Team
 * @version 3.2.0
 * @module EmotiveEngine3D
 *
 * EXPERIMENTAL: 3D rendering variant with WebGL core + Canvas2D particles
 *
 * Features:
 * - 3D core geometries (crystal, diamond, sphere, etc.)
 * - Procedural animations (bounce, pulse, rotate)
 * - Same API as 2D version: express(), setEmotion(), morphTo()
 * - WebGL rendering with shader-based glow effects
 * - Canvas2D particle overlay (existing particle system)
 *
 * Usage:
 *   import EmotiveMascot3D from '@joshtol/emotive-engine/3d';
 *
 *   const mascot = new EmotiveMascot3D({
 *       canvasId: 'mascot-canvas',
 *       coreGeometry: 'crystal'  // or 'diamond', 'sphere', etc.
 *   });
 *
 *   await mascot.init(canvas);
 *   mascot.start();
 *
 *   // Same API as 2D version
 *   mascot.setEmotion('joy');
 *   mascot.express('bounce');
 */


/**
 * EmotiveMascot3D - 3D rendering variant
 *
 * Hybrid architecture:
 * - Layer 1 (back): WebGL canvas with 3D core
 * - Layer 2 (front): Canvas2D with particles
 *
 * @class EmotiveMascot3D
 * @example
 * const mascot = new EmotiveMascot3D({
 *     canvasId: 'mascot-canvas',
 *     coreGeometry: 'crystal'
 * });
 * await mascot.init(container);
 * mascot.start();
 * mascot.setEmotion('joy');
 */
class EmotiveMascot3D {
    /**
     * Create a new EmotiveMascot3D instance
     * @param {Object} [config={}] - Configuration options
     * @param {string} [config.canvasId='emotive-canvas'] - Base ID for canvas elements
     * @param {string} [config.coreGeometry='sphere'] - 3D geometry type (sphere, crystal, diamond, moon, sun, etc.)
     * @param {number} [config.targetFPS=60] - Target frames per second
     * @param {boolean} [config.enableParticles=true] - Enable particle effects
     * @param {string} [config.defaultEmotion='neutral'] - Initial emotion state
     * @param {boolean} [config.enablePostProcessing=true] - Enable post-processing effects (bloom, etc.)
     * @param {boolean} [config.enableShadows=false] - Enable shadow rendering
     * @param {boolean} [config.enableControls=true] - Enable camera controls (mouse/touch)
     * @param {boolean} [config.autoRotate=true] - Enable auto-rotation
     * @param {boolean} [config.enableBlinking=true] - Enable blinking animation
     * @param {boolean} [config.enableBreathing=true] - Enable breathing animation
     * @param {number} [config.cameraDistance] - Camera Z distance from origin
     * @param {number} [config.fov=45] - Camera field of view in degrees
     * @param {number} [config.minZoom] - Minimum zoom distance
     * @param {number} [config.maxZoom] - Maximum zoom distance
     * @param {string} [config.materialVariant] - Material variant override
     */
    constructor(config = {}) {
        this.config = {
            canvasId: config.canvasId || 'emotive-canvas',
            coreGeometry: config.coreGeometry || 'sphere',
            targetFPS: config.targetFPS || 60,
            enableParticles: config.enableParticles !== false,
            defaultEmotion: config.defaultEmotion || 'neutral',
            ...config
        };

        // Create dual canvas system
        this.container = null;
        this.webglCanvas = null;
        this.canvas2D = null;

        // Renderers
        this.core3D = null;
        this.particleSystem = null;

        // Dance choreographer (auto dance once BPM is locked)
        this.danceChoreographer = null;

        // State
        this.isRunning = false;
        this._destroyed = false;
        this.animationFrameId = null;
        this.lastFrameTime = 0;
        this.gestureTimeouts = []; // Track setTimeout IDs for cleanup

        // Event system (reuse from 2D engine)
        this.eventManager = new EventManager();

        // Add emit/on/off methods to EventManager (DOM event manager doesn't have these)
        if (!this.eventManager.emit) {
            this.eventManager._listeners = {};
            this.eventManager.emit = (event, data) => {
                const listeners = this.eventManager._listeners[event];
                if (listeners) {
                    listeners.forEach(listener => listener(data));
                }
            };
            this.eventManager.on = (event, listener) => {
                if (!this.eventManager._listeners[event]) {
                    this.eventManager._listeners[event] = [];
                }
                this.eventManager._listeners[event].push(listener);
            };
            this.eventManager.off = (event, listener) => {
                const listeners = this.eventManager._listeners[event];
                if (listeners) {
                    const index = listeners.indexOf(listener);
                    if (index > -1) {
                        listeners.splice(index, 1);
                    }
                }
            };
        }

        // Error boundary (no parameters needed)
        this.errorBoundary = new ErrorBoundary();

        // State tracking
        this.emotion = 'neutral';
        this.undertone = null;

        // Intent parser for feel() API
        this._intentParser = new IntentParser();
        this._feelRateLimiter = {
            calls: [],
            windowMs: 1000,
            maxCallsPerSecond: 10
        };
    }

    /**
     * Initialize the 3D engine
     * @param {HTMLElement} container - Container element or canvas
     * @returns {EmotiveMascot3D} This instance for chaining
     * @throws {Error} If initialization fails
     */
    init(container) {
        try {
            // Setup dual canvas layers
            this.setupCanvasLayers(container);

            // Initialize 3D core renderer
            this.core3D = new Core3DManager(this.webglCanvas, {
                geometry: this.config.coreGeometry,
                emotion: this.config.defaultEmotion,
                enableParticles: this.config.enableParticles,
                enablePostProcessing: this.config.enablePostProcessing,
                enableShadows: this.config.enableShadows,
                enableControls: this.config.enableControls,
                autoRotate: this.config.autoRotate,
                enableBlinking: this.config.enableBlinking,
                enableBreathing: this.config.enableBreathing,
                cameraDistance: this.config.cameraDistance,
                fov: this.config.fov,
                minZoom: this.config.minZoom,
                maxZoom: this.config.maxZoom,
                materialVariant: this.config.materialVariant,
                assetBasePath: this.config.assetBasePath
            });

            // Cache 2D canvas context to prevent repeated getContext() calls
            this.ctx2D = this.canvas2D.getContext('2d');

            // Initialize particle system (2D overlay)
            // ONLY create 2D particles if 3D WebGL particles are NOT available
            // 3D demos should use WebGL particles, not 2D canvas overlay
            if (this.config.enableParticles && !this.core3D?.particleOrchestrator) {
                const maxParticles = this.config.maxParticles || 300;
                this.particleSystem = new ParticleSystem(maxParticles, this.errorBoundary);

                // Set canvas dimensions for particle containment
                this.particleSystem.canvasWidth = this.canvas2D.width;
                this.particleSystem.canvasHeight = this.canvas2D.height;
            }

            // Initialize dance choreographer (for auto-dancing when BPM locks)
            this.danceChoreographer = new DanceChoreographer();
            this.danceChoreographer.setRhythmAdapter(this.core3D?.rhythm3DAdapter);
            this.danceChoreographer.setMascot(this);
            // Note: audioDeformer is set later when listenTo() is called

            return this;
        } catch (error) {
            console.error('Failed to initialize 3D engine:', error);
            throw error;
        }
    }

    /**
     * Setup dual canvas architecture
     * WebGL canvas (back) + Canvas2D (front) stacked
     * @private
     * @param {HTMLElement} containerOrCanvas - Container element or canvas element
     */
    setupCanvasLayers(containerOrCanvas) {
        // Create or use container
        if (containerOrCanvas.tagName === 'CANVAS') {
            // User provided single canvas, create container
            const parent = containerOrCanvas.parentElement;
            this.container = document.createElement('div');
            this.container.style.position = 'relative';
            // Use parent's size (styled by CSS) instead of canvas default size
            this.container.style.width = '100%';
            this.container.style.height = '100%';
            parent.replaceChild(this.container, containerOrCanvas);
        } else {
            this.container = containerOrCanvas;
            // Only set position if not already set (don't override fixed/absolute)
            if (!this.container.style.position || this.container.style.position === 'static') {
                this.container.style.position = 'relative';
            }
        }

        // Create Canvas2D for particles (Layer 1 - back)
        this.canvas2D = document.createElement('canvas');
        this.canvas2D.id = `${this.config.canvasId}-particles`;
        this.canvas2D.width = this.container.offsetWidth || 400;
        this.canvas2D.height = this.container.offsetHeight || 400;
        this.canvas2D.style.position = 'absolute';
        this.canvas2D.style.top = '0';
        this.canvas2D.style.left = '0';
        this.canvas2D.style.width = '100%';
        this.canvas2D.style.height = '100%';
        this.canvas2D.style.background = 'transparent';
        this.canvas2D.style.zIndex = '1';
        // Disable pointer events - let WebGL canvas handle all interaction
        this.canvas2D.style.pointerEvents = 'none';
        this.container.appendChild(this.canvas2D);

        // Create WebGL canvas for 3D core (Layer 2 - front)
        // CRITICAL: Canvas is NOT appended to DOM here - it will be appended after first render
        // This prevents any garbage data from being visible during GPU initialization
        this.webglCanvas = document.createElement('canvas');
        this.webglCanvas.id = `${this.config.canvasId}-3d`;
        this.webglCanvas.width = this.canvas2D.width;
        this.webglCanvas.height = this.canvas2D.height;
        this.webglCanvas.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 2;
        `;
        // Only enable pointer events if controls are enabled (for orbit camera)
        // Otherwise, let events pass through to allow page scrolling
        if (this.config.enableControls) {
            this.webglCanvas.style.pointerEvents = 'auto';
            // Prevent browser touch gestures (scroll, zoom) on canvas when controls active
            this.webglCanvas.style.touchAction = 'none';
        } else {
            // Disable all pointer/touch events so scrolling works through the canvas
            this.webglCanvas.style.pointerEvents = 'none';
            this.webglCanvas.style.touchAction = 'auto';
        }
        // NOTE: Canvas is NOT appended here - see animate() for deferred append after first render
        this._canvasAppended = false;
    }

    /**
     * Start animation loop
     * Waits for geometry to be fully loaded before starting render
     * @async
     * @returns {Promise<void>}
     */
    async start() {
        if (this.isRunning) return;

        // Wait for core to be fully initialized (geometry loaded)
        // This prevents Three.js errors from async OBJ loading
        if (this.core3D) {
            await this.core3D.waitUntilReady();
        }

        this.isRunning = true;
        this.lastFrameTime = null; // Will be set on first animate() call
        this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
    }

    /**
     * Stop animation loop
     */
    stop() {
        this.isRunning = false;
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
    }

    /**
     * Main animation loop
     * @private
     * @param {number} currentTime - Current timestamp in milliseconds
     */
    animate(currentTime) {
        // Guard against calls after destroy or stop
        if (!this.isRunning || this._destroyed) {
            return;
        }

        // Initialize lastFrameTime on first frame
        if (this.lastFrameTime === null) {
            this.lastFrameTime = currentTime;
            this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
            return;
        }

        // Calculate deltaTime and cap it to prevent huge jumps when tab is inactive
        // Max 100ms prevents rotation explosions when tabbing back in
        const rawDeltaTime = currentTime - this.lastFrameTime;
        const deltaTime = Math.min(rawDeltaTime, 100); // deltaTime in milliseconds

        this.lastFrameTime = currentTime;

        // Render 3D core - check again as state may have changed
        if (this.core3D && !this._destroyed) {
            this.core3D.render(deltaTime);

            // CRITICAL: Append canvas to DOM after first frame renders
            // Canvas is created but NOT added to DOM during setup to prevent garbage data flash
            // Only after the first successful render do we add it to the document
            if (!this._canvasAppended && this.webglCanvas && this.container) {
                this.container.appendChild(this.webglCanvas);
                this._canvasAppended = true;
            }
        }

        // Update dance choreographer (auto-triggers gestures when BPM is locked)
        if (this.danceChoreographer && !this._destroyed) {
            this.danceChoreographer.update(deltaTime / 1000); // Convert to seconds
        }

        // Render 2D particles (or clear canvas if disabled)
        if (this.canvas2D && this.ctx2D) {
            // Always clear canvas first
            this.ctx2D.clearRect(0, 0, this.canvas2D.width, this.canvas2D.height);

            // Fill with transparent to ensure clearing
            this.ctx2D.fillStyle = 'rgba(0,0,0,0)';
            this.ctx2D.fillRect(0, 0, this.canvas2D.width, this.canvas2D.height);

            if (this.particleSystem) {
                const centerX = this.canvas2D.width / 2;
                const centerY = this.canvas2D.height / 2;

                // Get current emotion and its visual parameters
                const currentEmotion = this.core3D ? this.core3D.emotion : 'neutral';
                const emotionData = getEmotion(currentEmotion);
                const glowColor = this.core3D ? this.rgbToHex(this.core3D.glowColor) : '#FFFFFF';

                // Extract emotion-specific particle parameters
                const particleBehavior = emotionData?.visual?.particleBehavior || 'ambient';
                const particleRate = emotionData?.visual?.particleRate || 15;
                const minParticles = emotionData?.visual?.minParticles || 5;
                const maxParticles = emotionData?.visual?.maxParticles || 30;
                const particleColors = emotionData?.visual?.particleColors || null;

                // Spawn particles - EXACT same as 2D site, no modifications
                this.particleSystem.spawn(
                    particleBehavior,   // Use emotion's particle behavior
                    currentEmotion,     // emotion
                    particleRate,       // Use emotion's spawn rate
                    centerX, centerY,   // position
                    deltaTime,          // deltaTime in milliseconds
                    null,               // count (rate-based)
                    minParticles,       // Use emotion's min particles
                    maxParticles,       // Use emotion's max particles
                    1.0,                // scaleFactor (same as 2D)
                    1.0,                // particleSizeMultiplier
                    particleColors,     // Use emotion's color palette
                    this.undertone      // undertone modifier
                );

                // Apply gesture to particles if active
                let gestureMotion = null;
                let gestureProgress = 0;
                if (this.currentGesture) {
                    const elapsed = currentTime - this.currentGesture.startTime;
                    gestureProgress = Math.min(elapsed / this.currentGesture.duration, 1);
                    gestureMotion = {
                        ...this.currentGesture.config,
                        type: this.currentGesture.name  // Use gesture NAME (e.g., "bounce"), not TYPE
                    };
                }

                // Update particles - EXACT same as 2D site
                this.particleSystem.update(deltaTime, centerX, centerY, gestureMotion, gestureProgress, this.undertone);

                // Render particles with emotion color
                this.particleSystem.render(this.ctx2D, glowColor, null);
            }
        }

        // Continue loop
        this.animationFrameId = requestAnimationFrame(time => this.animate(time));
    }

    /**
     * Set emotional state (same API as 2D version)
     * @param {string} emotion - Emotion name
     * @param {Object|string|null} options - Options object or undertone string
     */
    setEmotion(emotion, options) {
        // Guard against calls after destroy
        if (!this.eventManager || !this.eventManager._listeners) return;

        this.emotion = emotion;

        // Handle options parameter (can be undertone string or options object)
        // If no options provided, keep existing undertone
        if (options !== undefined) {
            if (typeof options === 'string') {
                this.undertone = options;
            } else if (options && typeof options === 'object') {
                this.undertone = options.undertone || null;
            } else if (options === null) {
                // Explicitly clearing undertone
                this.undertone = null;
            }
        }
        // else: options undefined, keep existing this.undertone

        if (this.core3D) {
            this.core3D.setEmotion(emotion, this.undertone);
        }

        // Clear all particles for instant transition
        if (this.particleSystem) {
            this.particleSystem.particles = [];
        }

        this.eventManager.emit('emotion:change', { emotion, undertone: this.undertone });
    }

    /**
     * Update the undertone without resetting emotion
     * @param {string|null} undertone - The undertone to apply
     */
    updateUndertone(undertone) {
        this.undertone = undertone;

        // Re-apply emotion with new undertone
        if (this.core3D && this.emotion) {
            this.core3D.setEmotion(this.emotion, undertone);
        }

        this.eventManager.emit('undertone:change', { undertone });
    }

    /**
     * Set the undertone (alias for updateUndertone)
     * @param {string|null} undertone - The undertone to apply
     */
    setUndertone(undertone) {
        this.updateUndertone(undertone);
    }

    /**
     * Express a gesture (same API as 2D version)
     * @param {string} gestureName - Gesture name
     */
    express(gestureName) {
        // Guard against calls after destroy
        if (!this.eventManager || !this.eventManager._listeners) return;

        // Apply gesture to 3D core
        if (this.core3D) {
            this.core3D.playGesture(gestureName);
        }

        // Apply gesture to particles (same as 2D)
        const gesture = getGesture(gestureName);
        if (gesture) {
            const config = gesture.config || {};
            const duration = config.musicalDuration?.musical
                ? (config.musicalDuration.beats || 2) * 500
                : (config.duration || 800);


            // Track current gesture for particle system
            this.currentGesture = {
                name: gestureName,
                gesture,
                config,
                startTime: performance.now(),
                duration
            };

            // Clear gesture when complete
            const timeoutId = setTimeout(() => {
                if (this.currentGesture && this.currentGesture.name === gestureName) {
                    this.currentGesture = null;
                }
            }, duration);
            this.gestureTimeouts.push(timeoutId);
        }

        this.eventManager.emit('gesture:trigger', { gesture: gestureName });
    }

    /**
     * Trigger a gesture (alias for express, used by DanceChoreographer)
     * @param {string} gestureName - Gesture name
     * @param {Object} options - Options object
     * @param {number} options.scale - Scale multiplier for gesture amplitude
     */
    gesture(gestureName, options = {}) {
        // Scale is applied via the 3D core's gesture system
        // For now, just call express - the scale option can be wired in later
        this.express(gestureName);
    }

    /**
     * Execute a gesture chain combo (same API as 2D version)
     * @param {string|Array} chainName - Chain combo name or array of gestures
     */
    chain(chainName) {
        // Chain definitions from site demo
        const chainDefinitions = {
            'rise': 'breathe > sway+lean+tilt',
            'flow': 'sway > lean+tilt > spin > bounce',
            'burst': 'jump > nod > shake > flash',
            'drift': 'sway+breathe+float+drift',
            'chaos': 'shake+shake > spin+flash > bounce+pulse > twist+sparkle',
            'morph': 'expand > contract > morph+glow > expand+flash',
            'rhythm': 'pulse > pulse+sparkle > pulse+flicker',
            'spiral': 'spin > orbital > twist > orbital+sparkle',
            'routine': 'nod > bounce > spin+sparkle > sway+pulse > nod+flash',
            'radiance': 'sparkle > pulse+flicker > shimmer',
            'twinkle': 'sparkle > flash > pulse+sparkle > shimmer+flicker',
            'stream': 'wave > nod+pulse > sparkle > flash'
        };

        // Get chain definition
        const chainString = typeof chainName === 'string' ? chainDefinitions[chainName] || chainName : chainName.join('>');

        // Parse chain: split by '>' for sequential steps
        const steps = chainString.split('>').map(step =>
            step.trim().split('+').map(g => g.trim()).filter(g => g.length > 0)
        );

        // Execute chain sequence
        this.executeChainSequence(steps);
    }

    /**
     * Execute a sequence of gesture steps with proper timing
     * @param {Array<Array<string>>} steps - Array of steps, each containing simultaneous gestures
     * @private
     */
    executeChainSequence(steps) {
        if (!steps || steps.length === 0) return;

        let currentStep = 0;
        const stepDuration = 800; // Base duration per step (ms)

        const executeStep = () => {
            if (currentStep >= steps.length) return;

            const step = steps[currentStep];

            // Execute all gestures in this step simultaneously
            step.forEach(gestureName => {
                this.express(gestureName);
            });

            currentStep++;
            if (currentStep < steps.length) {
                const timeoutId = setTimeout(executeStep, stepDuration);
                this.gestureTimeouts.push(timeoutId);
            }
        };

        executeStep();
    }

    /**
     * Morph to shape (same API as 2D version)
     * Supports interruption - calling this during an active morph will
     * smoothly transition to the new target without visual glitches.
     *
     * @param {string} shapeName - Shape name
     * @param {Object} options - Optional configuration
     * @param {number} options.duration - Transition duration in ms (default: 800ms)
     * @param {string} options.materialVariant - Material variant to use (e.g., 'multiplexer' for moon blood moon)
     * @param {Function} options.onMaterialSwap - Callback when material is swapped (at morph midpoint)
     */
    morphTo(shapeName, options = {}) {
        if (this.core3D) {
            // Set material variant before morphing (if specified)
            if (options.materialVariant !== undefined) {
                this.core3D.setMaterialVariant(options.materialVariant);
            }

            // Set up one-time material swap callback if specified
            if (options.onMaterialSwap) {
                const existingCallback = this.core3D.onMaterialSwap;
                this.core3D.onMaterialSwap = info => {
                    // Call existing callback first (e.g., SSS preset re-apply)
                    if (existingCallback) {
                        existingCallback(info);
                    }
                    // Then call user-provided callback
                    options.onMaterialSwap(info);
                    // Restore original callback (one-time use)
                    this.core3D.onMaterialSwap = existingCallback;
                };
            }

            const duration = options.duration || 800;
            this.core3D.morphToShape(shapeName, duration);
        }
        this.eventManager.emit('shape:morph', { shape: shapeName });
    }

    /**
     * Express emotions, gestures, and shapes using natural language
     *
     * This is the primary API for LLM integration. Instead of calling
     * setEmotion(), express(), and morphTo() separately, you can describe
     * what you want in plain text.
     *
     * @param {string} intent - Natural language description of desired state
     * @returns {Object} Result with success status, any errors, and parsed intent
     *
     * @example
     * mascot.feel('happy, bouncing')
     * mascot.feel('curious, leaning in')
     * mascot.feel('calm crystal breathing')
     * mascot.feel('yes')  // nods
     * mascot.feel('no')   // shakes head
     */
    feel(intent) {
        // Guard against calls after destroy
        if (!this.eventManager || !this.eventManager._listeners) {
            return { success: false, error: 'Engine destroyed', parsed: null };
        }

        // Rate limiting
        const now = Date.now();
        const limiter = this._feelRateLimiter;

        // Remove calls outside the window
        limiter.calls = limiter.calls.filter(t => now - t < limiter.windowMs);

        // Check rate limit
        if (limiter.calls.length >= limiter.maxCallsPerSecond) {
            console.warn('[feel] Rate limit exceeded. Max 10 calls per second.');
            return {
                success: false,
                error: 'Rate limit exceeded',
                parsed: null
            };
        }

        // Record this call
        limiter.calls.push(now);

        // Parse the intent
        const parsed = this._intentParser.parse(intent);

        // Validate
        const validation = this._intentParser.validate(parsed);
        if (!validation.valid) {
            console.warn('[feel] Invalid intent:', validation.errors);
            return {
                success: false,
                error: validation.errors.join('; '),
                parsed
            };
        }

        // Execute the parsed intent
        try {
            // Set emotion if present
            if (parsed.emotion) {
                const emotionOptions = {};
                if (parsed.undertone && parsed.undertone !== 'clear') {
                    emotionOptions.undertone = parsed.undertone;
                }
                this.setEmotion(parsed.emotion, emotionOptions);
            }

            // Execute gestures
            for (const gesture of parsed.gestures) {
                this.express(gesture);
            }

            // Morph to shape if present
            if (parsed.shape) {
                this.morphTo(parsed.shape);
            }

            return {
                success: true,
                error: null,
                parsed
            };
        } catch (error) {
            console.error('[feel] Execution error:', error);
            return {
                success: false,
                error: error.message,
                parsed
            };
        }
    }

    /**
     * Check if a geometry morph is currently in progress
     * Useful for UI feedback or preventing certain actions during transitions
     * @returns {boolean} True if morphing
     */
    isMorphing() {
        return this.core3D ? this.core3D.isMorphing() : false;
    }

    /**
     * Get current morph state for debugging or UI display
     * @returns {Object} Morph state including progress, current/target geometry, etc.
     */
    getMorphState() {
        return this.core3D ? this.core3D.getMorphState() : null;
    }

    /**
     * Grow in from scale 0 (pop-in animation)
     * Used for initial appearance of mascots
     * @param {number} duration - Duration in milliseconds (default: 500ms)
     */
    growIn(duration = 500) {
        if (this.core3D) {
            this.core3D.growIn(duration);
        }
        this.eventManager.emit('animation:growIn', { duration });
    }

    /**
     * Enable or disable the inner soul/core glow
     * When disabled, the crystal appears as an empty shell without the glowing core
     * @param {boolean} enabled - True to show soul, false to hide
     */
    setCoreGlowEnabled(enabled) {
        if (this.core3D) {
            this.core3D.setCoreGlowEnabled(enabled);
        }
        this.eventManager.emit('coreGlow:toggle', { enabled });
    }

    /**
     * Check if core glow is currently enabled
     * @returns {boolean} True if core glow is enabled
     */
    isCoreGlowEnabled() {
        return this.core3D ? this.core3D.coreGlowEnabled : true;
    }

    /**
     * Enable auto-rotation
     */
    enableAutoRotate() {
        if (this.core3D) {
            // Don't enable rotation for geometries with special rotation rules (moon is tidally locked)
            if (this.core3D.geometryType !== 'moon') {
                // Enable OrbitControls camera rotation
                if (this.core3D.renderer?.controls) {
                    this.core3D.renderer.controls.autoRotate = true;
                    this.core3D.renderer.controls.autoRotateSpeed = this.core3D.options?.autoRotateSpeed ?? 0.5;
                }

                // Enable geometry's internal rotation behavior
                this.core3D.rotationDisabled = false;
                // Re-trigger emotion to restore rotation behavior
                this.setEmotion(this.core3D.emotion, this.undertone);
            }
        }
    }

    /**
     * Disable auto-rotation (stops both camera and emotion-based rotation)
     */
    disableAutoRotate() {
        if (this.core3D?.renderer?.controls) {
            this.core3D.renderer.controls.autoRotate = false;
            this.core3D.renderer.controls.autoRotateSpeed = 0;
        }
        if (this.core3D) {
            this.core3D.rotationDisabled = true;
            this.core3D.rotationBehavior = null;
            // Zero out any accumulated rotation velocity
            if (this.core3D.baseEuler) {
                // Keep current position but stop future rotation
                this.core3D.baseEuler[0] = 0;
                this.core3D.baseEuler[1] = 0;
                this.core3D.baseEuler[2] = 0;
            }
        }
    }

    /**
     * Set camera to a preset position
     * @param {string} preset - Camera preset: 'front', 'side', 'top', 'bottom', 'angle', 'back'
     * @param {number} duration - Animation duration in ms (0 for instant)
     */
    setCameraPreset(preset, duration = 1000) {
        if (this.core3D?.renderer?.setCameraPreset) {
            this.core3D.renderer.setCameraPreset(preset, duration);
        }
    }

    /**
     * Check if auto-rotate is enabled
     * @type {boolean}
     * @readonly
     */
    get autoRotateEnabled() {
        // Check rotationDisabled flag (inverse logic) for accurate state
        // rotationDisabled is the source of truth set by enable/disableAutoRotate
        return this.core3D?.rotationDisabled === false;
    }

    /**
     * Enable particles
     */
    enableParticles() {
        // Enable 3D WebGL particle system rendering
        if (this.core3D?.particleOrchestrator?.renderer) {
            // Enable visibility and force emotion recalculation to spawn particles immediately
            this.core3D.particleVisibility = true;
            this.core3D.particleOrchestrator.renderer.setVisible(true);
            this.core3D.particleOrchestrator.setEmotion(this.core3D.emotion, this.core3D.undertone);

        }

        // Only enable 2D canvas particle system if we don't have 3D particles
        // (3D mode uses WebGL particles, not 2D canvas particles)
        if (!this.core3D?.particleOrchestrator) {
            // Enable 2D canvas particle system (if needed)
            if (!this.particleSystem && this.canvas2D) {
                const maxParticles = this.config.maxParticles || 300;
                this.particleSystem = new ParticleSystem(maxParticles, this.errorBoundary);
                this.particleSystem.canvasWidth = this.canvas2D.width;
                this.particleSystem.canvasHeight = this.canvas2D.height;
            }
            // else: particleSystem already exists, no action needed
        }
    }

    /**
     * Disable particles
     */
    disableParticles() {
        // Disable 3D WebGL particle system rendering
        if (this.core3D?.particleOrchestrator?.renderer) {
            this.core3D.particleVisibility = false;
            this.core3D.particleOrchestrator.renderer.setVisible(false);
            // Clear particles immediately and let update loop handle draw range naturally
            this.core3D.particleOrchestrator.clear();
        }

        // Only disable 2D canvas particle system if we don't have 3D particles
        // (3D mode uses WebGL particles, not 2D canvas particles)
        if (!this.core3D?.particleOrchestrator) {
            // Disable 2D canvas particle system
            if (this.particleSystem) {
                this.particleSystem.destroy();
                this.particleSystem = null;
                // Canvas will be automatically cleared on next animation frame
            }
            // else: no 2D particle system to disable
        }
    }

    /**
     * Check if particles are enabled
     * @type {boolean}
     * @readonly
     */
    get particlesEnabled() {
        // Check 3D particle visibility first (3D mode uses particleOrchestrator)
        if (this.core3D?.particleOrchestrator) {
            return this.core3D.particleVisibility === true;
        }
        // Fall back to 2D particle system check
        return this.particleSystem !== null;
    }

    /**
     * Enable blinking
     */
    enableBlinking() {
        if (this.core3D) {
            this.core3D.blinkingManuallyDisabled = false;
            if (this.core3D.blinkAnimator) {
                this.core3D.blinkAnimator.resume();
            }
        }
    }

    /**
     * Disable blinking
     */
    disableBlinking() {
        if (this.core3D) {
            this.core3D.blinkingManuallyDisabled = true;
            if (this.core3D.blinkAnimator) {
                this.core3D.blinkAnimator.pause();
            }
        }
    }

    /**
     * Check if blinking is enabled
     * @type {boolean}
     * @readonly
     */
    get blinkingEnabled() {
        return this.core3D && this.core3D.blinkAnimator ? this.core3D.blinkAnimator.enabled : false;
    }

    /**
     * Enable breathing
     */
    enableBreathing() {
        if (this.core3D) {
            this.core3D.breathingEnabled = true;
        }
    }

    /**
     * Disable breathing
     */
    disableBreathing() {
        if (this.core3D) {
            this.core3D.breathingEnabled = false;
        }
    }

    /**
     * Check if breathing is enabled
     * @type {boolean}
     * @readonly
     */
    get breathingEnabled() {
        return this.core3D ? this.core3D.breathingEnabled !== false : true;
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // IMPERATIVE BREATHING PHASE API (for meditation)
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Animate mascot scale for a breathing phase over a specified duration.
     * Used by meditation controller for precise breathing exercise timing.
     *
     * Scale targets:
     * - 'inhale': grows to 1.3x normal size
     * - 'exhale': shrinks to 0.85x normal size
     * - 'hold': maintains current scale
     *
     * @param {string} phase - 'inhale' | 'exhale' | 'hold'
     * @param {number} durationSec - Duration in seconds for the animation
     *
     * @example
     * // 4-7-8 breathing pattern
     * mascot.breathePhase('inhale', 4);  // Grow over 4 seconds
     * // ... after 4 seconds
     * mascot.breathePhase('hold', 7);    // Hold for 7 seconds
     * // ... after 7 seconds
     * mascot.breathePhase('exhale', 8);  // Shrink over 8 seconds
     */
    breathePhase(phase, durationSec) {
        if (this.core3D) {
            this.core3D.breathePhase(phase, durationSec);
        }
    }

    /**
     * Stop any active breathing phase animation and reset to neutral scale
     */
    stopBreathingPhase() {
        if (this.core3D) {
            this.core3D.stopBreathingPhase();
        }
    }

    /**
     * Enable wobble/shake effects
     */
    enableWobble() {
        if (this.core3D) {
            this.core3D.setWobbleEnabled(true);
        }
    }

    /**
     * Disable wobble/shake effects
     */
    disableWobble() {
        if (this.core3D) {
            this.core3D.setWobbleEnabled(false);
        }
    }

    /**
     * Check if wobble is enabled
     * @type {boolean}
     * @readonly
     */
    get wobbleEnabled() {
        return this.core3D ? this.core3D.wobbleEnabled !== false : true;
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // RHYTHM SYNC API
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Enable rhythm sync for 3D animations
     * When enabled, gestures and idle animations will sync to the beat
     */
    enableRhythmSync() {
        if (this.core3D) {
            this.core3D.setRhythmEnabled(true);
        }
    }

    /**
     * Disable rhythm sync for 3D animations
     */
    disableRhythmSync() {
        if (this.core3D) {
            this.core3D.setRhythmEnabled(false);
        }
    }

    /**
     * Check if rhythm sync is enabled
     * @type {boolean}
     * @readonly
     */
    get rhythmSyncEnabled() {
        return this.core3D ? this.core3D.rhythmEnabled : false;
    }

    /**
     * Enable ambient groove (subtle idle animation synced to beat)
     */
    enableGroove() {
        if (this.core3D) {
            this.core3D.setGrooveEnabled(true);
        }
    }

    /**
     * Disable ambient groove
     */
    disableGroove() {
        if (this.core3D) {
            this.core3D.setGrooveEnabled(false);
        }
    }

    /**
     * Set beat sync strength for gesture animations
     * @param {number} strength - Sync strength (0-1), higher = more pronounced beat sync
     */
    setBeatSyncStrength(strength) {
        if (this.core3D) {
            this.core3D.setBeatSyncStrength(strength);
        }
    }

    /**
     * Set groove confidence (animation intensity scalar)
     *
     * This controls how pronounced the groove animations are:
     * - 0.15 = Very subtle, tentative feel (like searching for the beat)
     * - 0.5 = Moderate groove
     * - 1.0 = Full groove intensity
     *
     * When BPM detection is active, this is set automatically based on lock stage.
     * Use this method to manually control groove intensity when not using BPM detection,
     * or to override the automatic behavior.
     *
     * @example
     * // Start with tentative groove, then ramp up
     * mascot.setGrooveConfidence(0.2);
     * setTimeout(() => mascot.setGrooveConfidence(1.0), 3000);
     *
     * @param {number} confidence - Groove confidence (0-1, typically 0.15-1.0)
     */
    setGrooveConfidence(confidence) {
        if (this.core3D?.rhythm3DAdapter) {
            this.core3D.rhythm3DAdapter.setGrooveConfidence(confidence);
        }
    }

    /**
     * Get current groove confidence
     * @returns {number} Current groove confidence (0-1)
     */
    getGrooveConfidence() {
        return this.core3D?.rhythm3DAdapter?.grooveConfidence ?? 1.0;
    }

    /**
     * Set groove configuration for idle animations (advanced tuning)
     * @param {Object} config - Groove settings
     * @param {number} config.grooveBounceAmount - Vertical bounce amplitude (default: 0.02)
     * @param {number} config.grooveSwayAmount - Horizontal sway amplitude (default: 0.015)
     * @param {number} config.groovePulseAmount - Scale pulse amplitude (default: 0.03)
     * @param {number} config.grooveRotationAmount - Rotation sway amplitude (default: 0.02)
     */
    setGrooveConfig(config) {
        if (this.core3D) {
            this.core3D.setGrooveConfig(config);
        }
    }

    /**
     * Set the active groove preset for ambient animation
     *
     * Groove presets define the character of the ambient groove:
     * - 'groove1': Subtle, elegant - gentle bounce and sway (default)
     * - 'groove2': Energetic, bouncy - pronounced vertical motion, playful
     * - 'groove3': Smooth, flowing - emphasis on rotation and sway, languid
     *
     * @example
     * // Immediate switch to energetic groove
     * mascot.setGroove('groove2');
     *
     * // Morph to flowing groove over 2 bars
     * mascot.setGroove('groove3', { bars: 2 });
     *
     * // Transition over specific duration
     * mascot.setGroove('groove1', { duration: 3 }); // 3 seconds
     *
     * @param {string} grooveName - Groove preset name ('groove1', 'groove2', 'groove3')
     * @param {Object} [options] - Transition options
     * @param {number} [options.bars] - Transition duration in bars (e.g., 2 = morph over 2 bars)
     * @param {number} [options.duration] - Transition duration in seconds (alternative to bars)
     */
    setGroove(grooveName, options = {}) {
        if (this.core3D) {
            this.core3D.setGroove(grooveName, options);
        }
    }

    /**
     * Get available groove preset names
     * @returns {string[]} Array of groove preset names
     */
    getGroovePresets() {
        if (this.core3D) {
            return this.core3D.getGroovePresets();
        }
        return ['groove1', 'groove2', 'groove3'];
    }

    /**
     * Get current groove preset name
     * @returns {string} Current groove preset name
     */
    getCurrentGroove() {
        if (this.core3D) {
            return this.core3D.getCurrentGroove();
        }
        return 'groove1';
    }

    // ═══════════════════════════════════════════════════════════════════════════════════
    // DANCE CHOREOGRAPHER API
    // ═══════════════════════════════════════════════════════════════════════════════════

    /**
     * Enable automatic dance choreography
     * When enabled, the mascot will automatically trigger gestures based on
     * audio signals once BPM is locked.
     */
    enableDance() {
        if (this.danceChoreographer) {
            this.danceChoreographer.enable();
        }
    }

    /**
     * Disable automatic dance choreography
     */
    disableDance() {
        if (this.danceChoreographer) {
            this.danceChoreographer.disable();
        }
    }

    /**
     * Check if dance choreography is enabled
     * @returns {boolean} True if dance is enabled
     */
    isDanceEnabled() {
        return this.danceChoreographer?.enabled ?? false;
    }

    /**
     * Set dance intensity (affects gesture frequency and amplitude)
     *
     * @example
     * mascot.setDanceIntensity(0.2);  // Subtle, occasional gestures
     * mascot.setDanceIntensity(0.8);  // Energetic, frequent gestures
     *
     * @param {number} intensity - Intensity value 0-1
     */
    setDanceIntensity(intensity) {
        if (this.danceChoreographer) {
            this.danceChoreographer.setIntensity(intensity);
        }
    }

    /**
     * Get current dance intensity
     * @returns {number} Current intensity 0-1
     */
    getDanceIntensity() {
        return this.danceChoreographer?.getIntensity() ?? 0.5;
    }

    /**
     * Get dance choreographer status for debugging
     * @returns {Object} Status object with enabled, intensity, currentGroove, etc.
     */
    getDanceStatus() {
        return this.danceChoreographer?.getStatus() ?? { enabled: false };
    }

    /**
     * Check if rhythm is currently playing
     * @returns {boolean}
     */
    isRhythmPlaying() {
        return this.core3D?.isRhythmPlaying() || false;
    }

    /**
     * Get current BPM from rhythm system
     * @returns {number}
     */
    getRhythmBPM() {
        return this.core3D?.getRhythmBPM() || 120;
    }

    /**
     * Start rhythm playback for 3D animations
     * This MUST be called for rhythm sync to work - it starts the internal rhythm clock.
     * @param {number} bpm - Beats per minute (default: 120)
     * @param {string} pattern - Rhythm pattern: 'straight', 'swing', 'waltz', 'dubstep', etc. (default: 'straight')
     */
    startRhythm(bpm = 120, pattern = 'straight') {
        if (this.core3D) {
            this.core3D.startRhythm(bpm, pattern);
        }
    }

    /**
     * Stop rhythm playback
     */
    stopRhythm() {
        if (this.core3D) {
            this.core3D.stopRhythm();
        }
    }

    /**
     * Set rhythm BPM
     * @param {number} bpm - Beats per minute (20-360)
     */
    setRhythmBPM(bpm) {
        if (this.core3D) {
            this.core3D.setRhythmBPM(bpm);
        }
    }

    /**
     * Set rhythm pattern
     * @param {string} pattern - Pattern name: 'straight', 'swing', 'waltz', 'dubstep', 'breakbeat', etc.
     */
    setRhythmPattern(pattern) {
        if (this.core3D) {
            this.core3D.setRhythmPattern(pattern);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // AUDIO CONNECTION API
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Connect an audio element for audio-reactive animations
     * This starts rhythm sync automatically when audio plays
     * @param {HTMLAudioElement} audioElement - Audio element to connect
     * @returns {Promise<void>}
     */
    async connectAudio(audioElement) {
        if (!audioElement) return;

        this._audioElement = audioElement;

        // Create audio context and analyzer if not exists
        if (!this._audioContext) {
            this._audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        // Resume context if suspended (browser autoplay policy)
        if (this._audioContext.state === 'suspended') {
            await this._audioContext.resume();
        }

        // Create analyzer node
        if (!this._analyzerNode) {
            this._analyzerNode = this._audioContext.createAnalyser();
            this._analyzerNode.fftSize = 256;
            this._analyzerNode.smoothingTimeConstant = 0.8;
        }

        // Try to use fetch + decodeAudioData to bypass CORS tainted audio issue
        // MediaElementSourceNode often returns all zeros due to CORS even with crossOrigin set
        const audioUrl = audioElement.src;
        let usedBufferSource = false;

        // blob: URLs work with fetch in same origin - they're user-uploaded files
        if (audioUrl) {
            try {
                console.log('[Audio] Fetching audio for buffer decode:', audioUrl.substring(0, 60));
                const response = await fetch(audioUrl);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await this._audioContext.decodeAudioData(arrayBuffer);

                // Store the decoded buffer for playback sync
                this._decodedAudioBuffer = audioBuffer;
                this._audioBufferDuration = audioBuffer.duration;
                usedBufferSource = true;
                console.log(`[Audio] SUCCESS: Decoded audio buffer, duration: ${audioBuffer.duration.toFixed(2)}s`);
            } catch (err) {
                console.warn('[Audio] Buffer decode failed, falling back to MediaElementSource:', err.message);
            }
        }

        // Connect audio element to analyzer (for playback through speakers)
        // Note: createMediaElementSource can only be called ONCE per audio element
        if (this._connectedAudioElement === audioElement && this._audioSourceNode) {
            console.log('[Audio] Reusing existing source node for same audio element');
            try {
                this._audioSourceNode.connect(this._analyzerNode);
            } catch (e) {
                // Already connected, ignore
            }
        } else {
            if (this._audioSourceNode) {
                console.log('[Audio] Disconnecting old source node');
                try {
                    this._audioSourceNode.disconnect();
                } catch (e) {
                    // Ignore if already disconnected
                }
            }

            console.log('[Audio] Creating new MediaElementSource for:', audioElement.src.substring(0, 50));
            try {
                this._audioSourceNode = this._audioContext.createMediaElementSource(audioElement);
                this._audioSourceNode.connect(this._analyzerNode);
                this._connectedAudioElement = audioElement;
                console.log('[Audio] MediaElementSource connected, context state:', this._audioContext.state);
            } catch (err) {
                console.error('[Audio] ERROR creating MediaElementSource:', err.message);
            }
        }

        // Only connect analyzer to destination once
        if (!this._analyzerConnected) {
            this._analyzerNode.connect(this._audioContext.destination);
            this._analyzerConnected = true;
        }

        // Start rhythm when audio plays
        const onPlay = () => {
            // Detect BPM or use default
            const bpm = this._detectedBPM || 120;
            this.startRhythm(bpm, 'straight');

            // If we have a decoded buffer, create a buffer source for analysis
            // This runs in parallel with the audio element (muted) purely for FFT data
            if (this._decodedAudioBuffer && !this._analysisSourceNode) {
                this._startBufferAnalysis(audioElement.currentTime);
            }
        };

        const onPause = () => {
            this.stopRhythm();
            this._stopBufferAnalysis();
        };

        const onEnded = () => {
            this.stopRhythm();
            this._stopBufferAnalysis();
        };

        // Sync buffer analysis position when seeking
        const onSeeked = () => {
            if (this._decodedAudioBuffer && this._analysisSourceNode && !audioElement.paused) {
                this._stopBufferAnalysis();
                this._startBufferAnalysis(audioElement.currentTime);
            }
        };

        // Store handlers for cleanup
        this._audioHandlers = { onPlay, onPause, onEnded, onSeeked };

        audioElement.addEventListener('play', onPlay);
        audioElement.addEventListener('pause', onPause);
        audioElement.addEventListener('ended', onEnded);
        audioElement.addEventListener('seeked', onSeeked);

        // If already playing, start rhythm immediately
        if (!audioElement.paused) {
            onPlay();
        }

        // Start buffer analysis BEFORE BPM detection so analyzer exists when interval runs
        // This creates the buffer analyzer that bypasses CORS tainted audio issues
        if (this._decodedAudioBuffer && !this._analysisSourceNode) {
            this._startBufferAnalysis(audioElement.currentTime);
        }

        // Start BPM detection with analyzer validation
        // Will automatically retry/rebuild if analyzer returns zeros
        this._startBPMDetectionWithValidation();
    }

    /**
     * Start BPM detection with analyzer validation and auto-retry
     * If analyzer returns zeros, tears down and rebuilds the audio pipeline
     * @private
     */
    _startBPMDetectionWithValidation() {
        const maxRetries = 3;
        let retryCount = 0;

        const attemptStart = () => {
            retryCount++;
            console.log(`[BPM] Validation attempt ${retryCount}/${maxRetries}`);

            // Start detection
            this._startBPMDetection();

            // Validate after short delay - analyzer either works immediately or not at all
            setTimeout(() => {
                const isWorking = this._validateAnalyzerWorking();

                if (isWorking) {
                    console.log('[BPM] ✓ Analyzer validation PASSED - detection active');
                } else if (retryCount < maxRetries) {
                    console.warn(`[BPM] ✗ Analyzer validation FAILED - rebuilding audio pipeline (attempt ${retryCount + 1})`);

                    // Stop current detection
                    this._stopBPMDetection();

                    // Rebuild buffer analysis pipeline
                    this._rebuildBufferAnalysis();

                    // Retry after rebuild
                    setTimeout(attemptStart, 100);
                } else {
                    console.error('[BPM] ✗ Analyzer validation FAILED after max retries - detection may not work');
                }
            }, 300); // Check after 300ms - enough time to see data if working
        };

        attemptStart();
    }

    /**
     * Check if the buffer analyzer is working (required for BPM detection)
     * @returns {boolean} true if buffer analyzer is producing data
     * @private
     */
    _validateAnalyzerWorking() {
        // Only use buffer analyzer - main analyzer is unreliable due to CORS tainting
        if (!this._bufferAnalyzerNode) {
            console.log('[BPM] Validation: no buffer analyzer (BPM detection unavailable)');
            return false;
        }

        const testArray = new Uint8Array(this._bufferAnalyzerNode.frequencyBinCount);

        // Sample multiple times to catch transient audio
        let maxVal = 0;
        let activeTimeDomainSamples = 0;

        for (let i = 0; i < 10; i++) {
            this._bufferAnalyzerNode.getByteFrequencyData(testArray);
            maxVal = Math.max(maxVal, Math.max(...testArray));

            this._bufferAnalyzerNode.getByteTimeDomainData(testArray);
            const timeMin = Math.min(...testArray);
            const timeMax = Math.max(...testArray);

            // Time domain not centered at 128 means audio is flowing
            if (timeMin < 115 || timeMax > 141) {
                activeTimeDomainSamples++;
            }
        }

        // Check if BPM detector has already received peaks
        if (this._bpmDetector && this._bpmDetector.peakCount > 0) {
            console.log(`[BPM] Validation: peaks already detected (${this._bpmDetector.peakCount} peaks)`);
            return true;
        }

        if (activeTimeDomainSamples > 0) {
            console.log(`[BPM] Validation: time domain active (${activeTimeDomainSamples}/10 samples)`);
            return true;
        }

        if (maxVal > 5) {
            console.log(`[BPM] Validation: frequency data active (max=${maxVal})`);
            return true;
        }

        console.log(`[BPM] Validation: no data (freqMax=${maxVal}, timeDomainActive=${activeTimeDomainSamples})`);
        return false;
    }

    /**
     * Tear down and rebuild the buffer analysis pipeline
     * @private
     */
    _rebuildBufferAnalysis() {
        console.log('[Audio] Rebuilding buffer analysis pipeline...');

        // Stop and disconnect everything
        this._stopBufferAnalysis();

        // Also disconnect the gain node completely
        if (this._analysisGainNode) {
            try {
                this._analysisGainNode.disconnect();
            } catch (_e) {
                // Already disconnected, ignore
            }
            this._analysisGainNode = null;
        }

        // Force recreation of all nodes
        this._bufferAnalyzerNode = null;

        // Restart buffer analysis from current playback position
        if (this._decodedAudioBuffer && this._audioElement) {
            this._startBufferAnalysis(this._audioElement.currentTime);
        }
    }

    /**
     * Start a buffer source node for FFT analysis (bypasses CORS tainted audio)
     * @private
     */
    _startBufferAnalysis(startTime = 0) {
        if (!this._decodedAudioBuffer || !this._audioContext) return;

        // Create a SEPARATE analyzer node for buffer analysis
        // This is necessary because the MediaElementSource taints the main analyzer
        // and getByteFrequencyData() returns zeros for tainted analyzers
        const needsRestart = !this._bufferAnalyzerNode;
        if (!this._bufferAnalyzerNode) {
            this._bufferAnalyzerNode = this._audioContext.createAnalyser();
            // Large FFT to capture more audio per frame (2048 samples = ~46ms at 44.1kHz)
            // This ensures short transients fall within the analysis window
            this._bufferAnalyzerNode.fftSize = 2048;
            // Minimal smoothing - we want to see transients immediately, not averaged out
            // 0.3 was too high for short clicks - they were being smoothed away
            this._bufferAnalyzerNode.smoothingTimeConstant = 0.1;
            console.log('[Audio] Created dedicated buffer analyzer node (fftSize=2048, smoothing=0.1)');
        }

        // Create a new buffer source (they're one-shot, can't be restarted)
        this._analysisSourceNode = this._audioContext.createBufferSource();
        this._analysisSourceNode.buffer = this._decodedAudioBuffer;

        // Debug: verify buffer has actual audio data
        const channelData = this._decodedAudioBuffer.getChannelData(0);
        let maxSample = 0;
        for (let i = 0; i < Math.min(channelData.length, 44100); i++) {
            maxSample = Math.max(maxSample, Math.abs(channelData[i]));
        }
        console.log(`[Audio] Buffer check: channels=${this._decodedAudioBuffer.numberOfChannels} bufferSampleRate=${this._decodedAudioBuffer.sampleRate} contextSampleRate=${this._audioContext.sampleRate} maxSample(first1s)=${maxSample.toFixed(4)}`);

        // Create gain node FIRST (before connecting anything)
        // This ensures the full graph exists before source starts
        if (!this._analysisGainNode) {
            this._analysisGainNode = this._audioContext.createGain();
            // CRITICAL: gain=0 causes Chrome to optimize away the audio path entirely!
            // Use a tiny non-zero value that's effectively inaudible (-60dB = 0.001)
            this._analysisGainNode.gain.value = 0.001;
            this._analysisGainNode.connect(this._audioContext.destination);
            console.log('[Audio] Created analysis gain node (gain=0.001, -60dB)');
        }

        // Connect the FULL chain BEFORE starting the source
        // source -> analyzer -> gain -> destination
        // All connections must exist before start() or Chrome may not process audio
        this._analysisSourceNode.connect(this._bufferAnalyzerNode);
        this._bufferAnalyzerNode.connect(this._analysisGainNode);

        // Now start playback from the current position
        this._analysisSourceNode.start(0, startTime);
        this._analysisStartTime = this._audioContext.currentTime - startTime;

        console.log(`[Audio] Started buffer analysis from ${startTime.toFixed(2)}s contextState=${this._audioContext.state} analyzerConnected=${!!this._bufferAnalyzerNode} sourceBuffer=${!!this._analysisSourceNode.buffer}`);

        // Debug: Check if analyzer can get data after delays
        const debugAnalyzer = () => {
            if (this._bufferAnalyzerNode && this._analysisSourceNode) {
                const testArray = new Uint8Array(this._bufferAnalyzerNode.frequencyBinCount);
                this._bufferAnalyzerNode.getByteFrequencyData(testArray);
                const testMax = Math.max(...testArray);
                const testSum = testArray.reduce((a, b) => a + b, 0);

                // Also check time domain
                const timeArray = new Uint8Array(this._bufferAnalyzerNode.frequencyBinCount);
                this._bufferAnalyzerNode.getByteTimeDomainData(timeArray);
                const timeMax = Math.max(...timeArray);
                const timeMin = Math.min(...timeArray);

                return { testMax, testSum, timeMax, timeMin, binCount: testArray.length };
            }
            return null;
        };

        setTimeout(() => {
            const r = debugAnalyzer();
            if (r) console.log(`[Audio] 100ms check: freqMax=${r.testMax} freqSum=${r.testSum} timeMin=${r.timeMin} timeMax=${r.timeMax}`);
        }, 100);

        setTimeout(() => {
            const r = debugAnalyzer();
            if (r) console.log(`[Audio] 500ms check: freqMax=${r.testMax} freqSum=${r.testSum} timeMin=${r.timeMin} timeMax=${r.timeMax}`);
        }, 500);

        setTimeout(() => {
            const r = debugAnalyzer();
            if (r) console.log(`[Audio] 1000ms check: freqMax=${r.testMax} freqSum=${r.testSum} timeMin=${r.timeMin} timeMax=${r.timeMax}`);
        }, 1000);

        // Restart BPM detection AFTER source is connected and started
        // This ensures the analyzer has audio data when the interval polls it
        if (needsRestart && this._bpmDetectionInterval) {
            console.log('[Audio] Restarting BPM detection to use buffer analyzer');
            this._stopBPMDetection();
            this._startBPMDetection();
        }
    }

    /**
     * Stop the buffer analysis source
     * @private
     */
    _stopBufferAnalysis() {
        console.log('[Audio] Stopping buffer analysis');

        if (this._analysisSourceNode) {
            try {
                this._analysisSourceNode.stop();
                this._analysisSourceNode.disconnect();
            } catch (e) {
                // Already stopped
            }
            this._analysisSourceNode = null;
        }

        // Disconnect buffer analyzer to prevent old analyzers staying connected
        // when track switches (multiple analyzers feeding into gain node = bad data)
        if (this._bufferAnalyzerNode) {
            try {
                this._bufferAnalyzerNode.disconnect();
                console.log('[Audio] Disconnected buffer analyzer');
            } catch (e) {
                // Already disconnected
            }
            // Null it out to force recreation on next track
            // This ensures completely fresh analyzer state
            this._bufferAnalyzerNode = null;
        }

        // Also disconnect the gain node to break all old connections
        if (this._analysisGainNode) {
            try {
                this._analysisGainNode.disconnect();
                // Reconnect to destination (it's the final node in chain)
                this._analysisGainNode.connect(this._audioContext.destination);
                console.log('[Audio] Reset analysis gain node connections');
            } catch (e) {
                // Ignore
            }
        }
    }

    /**
     * Disconnect audio and stop audio-reactive animations
     */
    disconnectAudio() {
        // Stop rhythm
        this.stopRhythm();

        // Stop buffer analysis
        this._stopBufferAnalysis();

        // Remove event listeners
        if (this._audioElement && this._audioHandlers) {
            this._audioElement.removeEventListener('play', this._audioHandlers.onPlay);
            this._audioElement.removeEventListener('pause', this._audioHandlers.onPause);
            this._audioElement.removeEventListener('ended', this._audioHandlers.onEnded);
            if (this._audioHandlers.onSeeked) {
                this._audioElement.removeEventListener('seeked', this._audioHandlers.onSeeked);
            }
        }

        // Stop BPM detection
        this._stopBPMDetection();

        // Disconnect audio source node
        if (this._audioSourceNode) {
            try {
                this._audioSourceNode.disconnect();
            } catch (e) {
                // Ignore
            }
        }

        // Clean up audio nodes (but keep context for reuse)
        this._audioElement = null;
        this._audioHandlers = null;
        this._connectedAudioElement = null;
        this._audioSourceNode = null;
        this._decodedAudioBuffer = null;
        this._bufferAnalyzerNode = null;
    }

    /**
     * Start agent-based BPM detection for accurate tempo lock
     * @private
     */
    _startBPMDetection() {
        // Always reset detector when starting (handles track changes)
        if (!this._bpmDetector) {
            this._bpmDetector = new AgentBPMDetector();
        }
        this._bpmDetector.reset();
        this._detectedBPM = 0;

        // Initialize groove confidence to tentative (0.15) at detection start
        // This ensures animations start subtle and ramp up as BPM is found
        if (this.core3D?.rhythm3DAdapter) {
            this.core3D.rhythm3DAdapter.setGrooveConfidence(0.15);
        }

        // Always stop existing interval to reset closure state (lastPeakTime, fluxHistory, etc.)
        // This ensures fresh detection state when switching tracks without page refresh
        if (this._bpmDetectionInterval) {
            clearInterval(this._bpmDetectionInterval);
            this._bpmDetectionInterval = null;
        }

        // Create dataArray lazily based on the actual analyzer being used
        let dataArray = null;
        let lastPeakTime = 0;
        let prevEnergy = 0;
        let prevTimeDomainAmplitude = 0; // Track previous amplitude for spike detection
        const fluxHistory = [];
        const fluxHistorySize = 20;

        let _onsetDebugCount = 0;
        let _intervalRunCount = 0;
        console.log('[BPM] Starting detection interval, bufferAnalyzer:', !!this._bufferAnalyzerNode, 'audioElement:', !!this._audioElement);
        this._bpmDetectionInterval = setInterval(() => {
            _intervalRunCount++;
            // Debug: log why we're skipping (first few times only)
            if (_intervalRunCount <= 3) {
                console.log(`[BPM-Interval] #${_intervalRunCount} bufferAnalyzer:${!!this._bufferAnalyzerNode} audioElement:${!!this._audioElement} paused:${this._audioElement?.paused}`);
            }
            if (!this._audioElement || this._audioElement.paused) return;

            // Only use buffer analyzer - main analyzer is unreliable due to CORS tainting
            // Buffer analyzer uses fetch+decodeAudioData which bypasses CORS restrictions
            if (!this._bufferAnalyzerNode) {
                // No buffer analyzer = no BPM detection (fetch failed or CORS blocked)
                if (_intervalRunCount === 10) {
                    console.warn('[BPM] No buffer analyzer available - BPM detection disabled for this audio source');
                }
                return;
            }

            // Create/recreate dataArray if needed
            const bufferLength = this._bufferAnalyzerNode.frequencyBinCount;
            if (!dataArray || dataArray.length !== bufferLength) {
                dataArray = new Uint8Array(bufferLength);
                console.log('[BPM] Created dataArray with bufferLength:', bufferLength);
            }

            this._bufferAnalyzerNode.getByteFrequencyData(dataArray);

            // Calculate low frequency energy (bass) - first 16 bins
            let lowFreqEnergy = 0;
            for (let i = 0; i < 16; i++) {
                lowFreqEnergy += dataArray[i];
            }
            lowFreqEnergy /= 16;

            // Calculate TOTAL energy across all bins for broadband detection
            let totalEnergy = 0;
            for (let i = 0; i < bufferLength; i++) {
                totalEnergy += dataArray[i];
            }
            totalEnergy /= bufferLength;

            // Also get time-domain data for transient detection
            // Time domain is better for catching sharp clicks/pops that may not show in FFT
            const timeDomainArray = new Uint8Array(bufferLength);
            this._bufferAnalyzerNode.getByteTimeDomainData(timeDomainArray);

            // Calculate peak-to-peak amplitude in time domain (deviation from 128 center)
            let timeDomainMax = 0;
            let timeDomainMin = 255;
            for (let i = 0; i < bufferLength; i++) {
                timeDomainMax = Math.max(timeDomainMax, timeDomainArray[i]);
                timeDomainMin = Math.min(timeDomainMin, timeDomainArray[i]);
            }
            const timeDomainAmplitude = timeDomainMax - timeDomainMin;

            // Calculate amplitude CHANGE (spike detection for real music)
            // This detects transients even in continuous audio
            const amplitudeChange = timeDomainAmplitude - prevTimeDomainAmplitude;
            prevTimeDomainAmplitude = timeDomainAmplitude;

            // Spectral flux: positive change in energy (onset detection)
            // Use ONLY bass energy for music - bass notes typically fall on beats
            // while higher frequency notes are often subdivisions/arpeggios
            // 100% bass weighting filters out melodic fingerpicking patterns
            const flux = Math.max(0, lowFreqEnergy - prevEnergy);
            prevEnergy = lowFreqEnergy; // Track bass energy for next frame

            // Track flux history for adaptive threshold
            fluxHistory.push(flux);
            if (fluxHistory.length > fluxHistorySize) {
                fluxHistory.shift();
            }

            // Calculate adaptive threshold based on recent flux
            // With fftSize=2048, we have more frequency bins, so flux values are smaller per-bin
            // Lower multiplier (1.1) and minimum (2) to catch quieter onsets
            const avgFlux = fluxHistory.reduce((a, b) => a + b, 0) / fluxHistory.length;
            const threshold = avgFlux * 1.1 + 2;

            // Debug: log energy readings periodically
            _onsetDebugCount++;
            const shouldLogPeriodically = _onsetDebugCount % 100 === 0; // Every second (100*10ms)
            if (_onsetDebugCount <= 10 || shouldLogPeriodically) {
                const maxBin = Math.max(...dataArray);
                console.log(`[BPM-Onset] #${_onsetDebugCount} total=${totalEnergy.toFixed(1)} max=${maxBin} flux=${flux.toFixed(1)} thresh=${threshold.toFixed(1)} tdAmp=${timeDomainAmplitude} ampChg=${amplitudeChange}`);
            }

            const now = performance.now();
            const timeSinceLastPeak = now - lastPeakTime;

            // Detect onset using spectral flux (energy change) - works for all audio
            const fluxOnset = flux > threshold;

            // Time-domain onset detection:
            // For DISCRETE sounds (clicks/silence): absolute amplitude works
            // For CONTINUOUS audio (music): need amplitude SPIKE detection
            // Use amplitude change > 30 as spike threshold for real music
            // But also allow absolute amplitude > 40 for discrete clicks (when coming from silence)
            const isDiscreteClick = timeDomainAmplitude > 40 && prevTimeDomainAmplitude < 10; // Coming from silence
            const isAmplitudeSpike = amplitudeChange > 30; // Sudden increase in continuous audio
            const timeDomainOnset = (isDiscreteClick || isAmplitudeSpike) && totalEnergy > 1;

            // Minimum gap between peaks:
            // - 350ms allows up to 171 BPM (covers most music including fast EDM)
            // - Music above 171 BPM will detect at half tempo (e.g., 180 BPM → 90 BPM)
            // - Fingerpicking halving is handled via half-BPM vote ratio in AgentBPMDetector
            // - 280ms was too aggressive - caused noisy intervals that broke pattern detection
            const isOnset = (fluxOnset || timeDomainOnset) && timeSinceLastPeak > 350;

            if (isOnset) {
                // Feed peak to the agent detector
                // Use higher strength if time-domain detected (sharp transient)
                const peakStrength = timeDomainOnset
                    ? Math.min(1, timeDomainAmplitude / 100)
                    : Math.min(1, flux / 50);

                // Debug: log every detected onset with method
                let method = 'FLUX';
                if (fluxOnset && timeDomainOnset) method = 'BOTH';
                else if (timeDomainOnset && isDiscreteClick) method = 'CLICK';
                else if (timeDomainOnset && isAmplitudeSpike) method = 'SPIKE';
                else if (timeDomainOnset) method = 'TD';
                console.log(`[BPM-Onset] PEAK! method=${method} gap=${timeSinceLastPeak.toFixed(0)}ms flux=${flux.toFixed(1)} ampChg=${amplitudeChange} strength=${peakStrength.toFixed(2)}`);

                this._bpmDetector.processPeak(peakStrength, now);

                // Get detection status
                const status = this._bpmDetector.getStatus();

                // Update detected BPM
                if (status.bpm > 0) {
                    this._detectedBPM = status.bpm;
                    this._bpmConfidence = status.confidence;
                    this._bpmLocked = status.locked;

                    // Only update rhythm engine when we have confidence
                    if (status.locked && this.isRhythmPlaying()) {
                        this.setRhythmBPM(status.bpm);
                    }

                    // Pass grooveConfidence to rhythm adapter for animation amplitude scaling
                    // This creates the "tentative → locked" animation behavior
                    if (this.core3D?.rhythm3DAdapter && status.grooveConfidence !== undefined) {
                        this.core3D.rhythm3DAdapter.setGrooveConfidence(status.grooveConfidence);
                    }
                }

                lastPeakTime = now;
            }
        }, 10); // Check every 10ms - needed to catch short transients like clicks
    }

    /**
     * Stop BPM detection
     * @private
     */
    _stopBPMDetection() {
        if (this._bpmDetectionInterval) {
            clearInterval(this._bpmDetectionInterval);
            this._bpmDetectionInterval = null;
        }
        // Reset detection state but keep detector for reuse
        this._bpmLocked = false;
        this._bpmConfidence = 0;
    }

    /**
     * Get BPM detection status
     * @returns {Object} Detection status object
     * @returns {number} returns.bpm - Current detected BPM (60-180)
     * @returns {number} returns.confidence - Detection confidence (0-1)
     * @returns {boolean} returns.locked - Whether BPM is locked (Stage 1+)
     * @returns {number} returns.lockStage - Lock stage (0=detecting, 1=initial, 2=refining, 3=final)
     * @returns {string} returns.correctionType - 'none', 'halved', or 'doubled'
     * @returns {boolean} returns.finalized - True when fully locked and memory cleaned
     * @returns {number} returns.grooveConfidence - Animation intensity scalar (0.15-1.0)
     * @returns {number} returns.agentCount - Number of BPM candidates in histogram
     * @returns {number} returns.peakCount - Total peaks detected
     * @returns {Array} returns.topAgents - Top 5 BPM candidates with scores
     * @returns {number} returns.intervalCount - Number of intervals in buffer
     */
    getBPMStatus() {
        if (!this._bpmDetector) {
            return {
                bpm: this._detectedBPM || 120,
                subdivision: 1,
                confidence: 0,
                locked: false,
                lockStage: 0,
                correctionType: 'none',
                finalized: false,
                grooveConfidence: 1.0,  // Default to full when no detection active
                agentCount: 0,
                peakCount: 0,
                histogramSize: 0,
                topAgents: [],
                intervalCount: 0
            };
        }
        return this._bpmDetector.getStatus();
    }

    /**
     * Get BPM debug log for clipboard copy
     * @returns {string} Formatted debug log
     */
    getBPMDebugLog() {
        if (!this._bpmDetector || !this._bpmDetector.getDebugLog) {
            return 'No BPM detector active or debug log unavailable.';
        }
        return this._bpmDetector.getDebugLog();
    }

    /**
     * Reset BPM detection to start fresh
     * @param {number} [seedBPM] - Optional initial BPM guess
     */
    resetBPMDetection(seedBPM = null) {
        if (this._bpmDetector) {
            this._bpmDetector.reset(seedBPM);
        }
        this._bpmLocked = false;
        this._bpmConfidence = 0;
        this._detectedBPM = seedBPM || 120;
    }

    /**
     * Helper: Convert RGB array to hex color
     */
    rgbToHex(rgb) {
        const r = Math.round(rgb[0] * 255);
        const g = Math.round(rgb[1] * 255);
        const b = Math.round(rgb[2] * 255);
        return `#${[r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? `0${hex}` : hex;
        }).join('')}`;
    }

    /**
     * Set position offset of the mascot (moves the container)
     * Compatible with 2D mascot's positioning API for scroll-based movement
     * @param {number} x - X offset from base position (pixels)
     * @param {number} y - Y offset from base position (pixels)
     * @param {number} z - Z offset (unused for container positioning)
     */
    setPosition(x, y, z = 0) {
        if (!this.container) return;

        // Store position for reference
        this.position = { x, y, z };

        // Use transform only to avoid conflicting with CSS position properties
        // The container is positioned with CSS (top: 50%, left: X%, transform: translateY(-50%))
        // We combine the base centering transform with our offset
        const isMobile = window.innerWidth < 768;

        if (isMobile) {
            // Mobile: container is centered (top: 50%, left: 50%, transform: translate(-50%, -50%))
            // Apply offset from center using transform only
            this.container.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
        } else {
            // Desktop: container is at left: 12%, top: 50%, transform: translateY(-50%)
            // Use translate for both x and y offset to keep base position intact
            this.container.style.transform = `translate(${x}px, calc(-50% + ${y}px))`;
        }
    }

    /**
     * Get current position
     * @returns {{x: number, y: number, z: number}}
     */
    getPosition() {
        return this.position || { x: 0, y: 0, z: 0 };
    }

    /**
     * Animate to a target position smoothly
     * @param {number} x - Target X offset
     * @param {number} y - Target Y offset
     * @param {number} z - Target Z offset (unused for container positioning)
     * @param {number} duration - Animation duration in milliseconds
     * @param {string} easing - Easing function name (currently only 'easeOutCubic' supported)
     */
    animateToPosition(x, y, z = 0, duration = 1000, easing = 'easeOutCubic') {
        if (!this.container) return;

        const startPos = this.getPosition();
        const startTime = performance.now();

        // Easing function
        const easeOutCubic = t => 1 - Math.pow(1 - t, 3);

        const animate = currentTime => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeOutCubic(progress);

            const currentX = startPos.x + (x - startPos.x) * easedProgress;
            const currentY = startPos.y + (y - startPos.y) * easedProgress;
            const currentZ = startPos.z + (z - startPos.z) * easedProgress;

            this.setPosition(currentX, currentY, currentZ);

            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        };

        requestAnimationFrame(animate);
    }

    /**
     * Set particle containment bounds and scale
     * For 3D, this primarily affects the particle system containment
     * @param {Object|null} bounds - Bounds object {width, height} in pixels, null to disable
     * @param {number} scale - Scale factor for mascot (affects particle spawn radius)
     */
    setContainment(bounds, scale = 1) {
        // Store containment settings
        this._containmentBounds = bounds;
        this._containmentScale = scale;

        // Apply scale to particle system spawn radius
        if (this.particleSystem && scale !== 1) {
            // The particle system uses spawnRadius for particle positioning
            // Adjust based on scale factor
            const baseRadius = this.config.particleSpawnRadius || 150;
            this.particleSystem.setSpawnRadius(baseRadius * scale);
        }

        return this;
    }

    /**
     * Attach mascot to a DOM element with automatic position tracking
     * @param {HTMLElement|string} elementOrSelector - Element or CSS selector
     * @param {Object} options - Attachment options
     * @param {number} options.offsetX - X offset from element center (default: 0)
     * @param {number} options.offsetY - Y offset from element center (default: 0)
     * @param {boolean} options.animate - Animate to position (default: true)
     * @param {number} options.duration - Animation duration in ms (default: 1000)
     * @param {number} options.scale - Scale factor for mascot (default: 1)
     * @param {boolean} options.containParticles - Whether to contain particles within element bounds (default: true)
     * @returns {EmotiveMascot3D} This instance for chaining
     */
    attachToElement(elementOrSelector, options = {}) {
        // Get the target element
        const element = typeof elementOrSelector === 'string'
            ? document.querySelector(elementOrSelector)
            : elementOrSelector;

        if (!element) {
            console.error(`[EmotiveMascot3D] Element not found: ${elementOrSelector}`);
            return this;
        }

        // Store element tracking info
        this._attachedElement = element;
        this._attachOptions = {
            offsetX: options.offsetX || 0,
            offsetY: options.offsetY || 0,
            animate: options.animate !== false,
            duration: options.duration || 1000,
            scale: options.scale || 1,
            containParticles: options.containParticles !== false
        };
        this._hasAttachedBefore = this._hasAttachedBefore || false;

        // Set containment bounds and scale if requested
        const rect = element.getBoundingClientRect();
        if (this._attachOptions.containParticles) {
            this.setContainment({ width: rect.width, height: rect.height }, this._attachOptions.scale);
        } else if (this._attachOptions.scale !== 1) {
            this.setContainment(null, this._attachOptions.scale);
        }

        // Position mascot at element
        this._updateAttachedPosition();

        // Set up automatic tracking on scroll and resize
        this._setupElementTracking();

        return this;
    }

    /**
     * Update mascot position to match attached element
     * @private
     */
    _updateAttachedPosition() {
        if (!this._attachedElement || !this.container) return;

        const rect = this._attachedElement.getBoundingClientRect();
        const isMobile = window.innerWidth < 768;

        // Get element center in viewport coordinates
        const elementCenterX = rect.left + rect.width / 2;
        const elementCenterY = rect.top + rect.height / 2;

        // Calculate the container's base position (where it would be with no offset)
        // This depends on the CSS positioning set by MascotRenderer
        let containerBaseCenterX, containerBaseCenterY;

        if (isMobile) {
            // Mobile: container CSS is top: 18%, left: 50%, transform: translate(-50%, -50%)
            // So the container center is at (50% of viewport width, 18% of viewport height)
            containerBaseCenterX = window.innerWidth / 2;
            containerBaseCenterY = window.innerHeight * 0.18;
        } else {
            // Desktop: container CSS is left: calc(max(20px, (50vw - 500px) / 2 - 375px)), top: 50%
            // The left position places the container center at roughly the left third
            // Container width is 750px, so center is at left + 375px
            const containerWidth = 750;
            const leftPos = Math.max(20, (window.innerWidth / 2 - 500) / 2 - 375);
            containerBaseCenterX = leftPos + containerWidth / 2;
            containerBaseCenterY = window.innerHeight / 2;
        }

        // Calculate offset needed to move from container's base position to element center
        const offsetX = elementCenterX - containerBaseCenterX + this._attachOptions.offsetX;
        const offsetY = elementCenterY - containerBaseCenterY + this._attachOptions.offsetY;

        // Use animation on first attach, instant updates on scroll/resize
        const isFirstAttach = !this._hasAttachedBefore;
        this._hasAttachedBefore = true;

        if (isFirstAttach && this._attachOptions.animate) {
            this.animateToPosition(offsetX, offsetY, 0, this._attachOptions.duration);
        } else {
            this.setPosition(offsetX, offsetY, 0);
        }
    }

    /**
     * Set up scroll and resize event listeners for element tracking
     * @private
     */
    _setupElementTracking() {
        if (this._elementTrackingHandlers) return; // Already set up

        this._elementTrackingHandlers = {
            scroll: () => this._updateAttachedPosition(),
            resize: () => this._updateAttachedPosition()
        };

        window.addEventListener('scroll', this._elementTrackingHandlers.scroll, { passive: true });
        window.addEventListener('resize', this._elementTrackingHandlers.resize);
    }

    /**
     * Check if mascot is attached to an element
     * @returns {boolean} True if attached to an element
     */
    isAttachedToElement() {
        return !!this._attachedElement;
    }

    /**
     * Detach mascot from tracked element and cleanup
     * @returns {EmotiveMascot3D} This instance for chaining
     */
    detachFromElement() {
        this._attachedElement = null;
        this._hasAttachedBefore = false;

        // Remove event listeners
        if (this._elementTrackingHandlers) {
            window.removeEventListener('scroll', this._elementTrackingHandlers.scroll);
            window.removeEventListener('resize', this._elementTrackingHandlers.resize);
            this._elementTrackingHandlers = null;
        }

        // Clear containment and reset scale
        this.setContainment(null, 1);

        // Reset to neutral state (but do NOT change geometry - let caller decide)
        this.setEmotion('neutral');

        return this;
    }

    /**
     * Apply an SSS (Subsurface Scattering) preset to the crystal material
     * Available presets: quartz, emerald, ruby, sapphire, amethyst, topaz, citrine, diamond
     * @param {string} presetName - Name of the SSS preset to apply
     * @returns {boolean} True if preset was applied successfully
     */
    setSSSPreset(presetName) {
        // Store preset name so it can be re-applied after geometry morph (material swap)
        this._currentSSSPreset = presetName;

        // Set up material swap callback if not already done
        if (this.core3D && !this._materialSwapCallbackSet) {
            this._materialSwapCallbackSet = true;
            this.core3D.onMaterialSwap = info => {
                // Re-apply SSS preset after material is swapped during morph
                if (this._currentSSSPreset) {
                    // Small delay to ensure material uniforms are fully initialized
                    setTimeout(() => {
                        applySSSPreset(this, this._currentSSSPreset);
                    }, 50);
                }
            };
        }

        const success = applySSSPreset(this, presetName);
        if (success) {
            this.eventManager.emit('sss:presetChanged', { preset: presetName });
        }
        return success;
    }

    /**
     * Change the geometry type (alias for morphTo for API consistency)
     * @param {string} geometryName - Name of geometry: crystal, moon, sun, heart, rough, sphere, star
     * @param {Object} options - Optional configuration
     * @param {number} options.duration - Transition duration in ms (default: 800ms)
     */
    setGeometry(geometryName, options = {}) {
        this.morphTo(geometryName, options);
    }

    /**
     * Start a solar eclipse animation
     * @param {Object} options - Eclipse options
     * @param {string} options.type - Eclipse type: 'annular' or 'total' (default: 'total')
     * @param {number} options.duration - Duration in ms (default: 10000)
     */
    startSolarEclipse(options = {}) {
        if (this.core3D && typeof this.core3D.startSolarEclipse === 'function') {
            this.core3D.startSolarEclipse(options);
        } else {
            // Fallback: morph to sun and emit event
            this.morphTo('sun');
            this.eventManager.emit('eclipse:solar:start', { type: options.type || 'total' });
        }
    }

    /**
     * Start a lunar eclipse animation (blood moon)
     * @param {Object} options - Eclipse options
     * @param {string} options.type - Eclipse type: 'total' (blood moon), 'partial', 'penumbral'
     * @param {number} options.duration - Duration in ms (default: 10000)
     */
    startLunarEclipse(options = {}) {
        if (this.core3D && typeof this.core3D.startLunarEclipse === 'function') {
            this.core3D.startLunarEclipse(options);
        } else {
            // Fallback: morph to moon and emit event
            this.morphTo('moon');
            this.eventManager.emit('eclipse:lunar:start', { type: options.type || 'total' });
        }
    }

    /**
     * Stop any active eclipse animation
     */
    stopEclipse() {
        if (this.core3D && typeof this.core3D.stopEclipse === 'function') {
            this.core3D.stopEclipse();
        }
        if (this.eventManager) {
            this.eventManager.emit('eclipse:stop');
        }
    }

    /**
     * Cleanup
     */
    destroy() {
        // Set destroyed flag first to stop any pending animation frames
        this._destroyed = true;
        this.stop();

        // Clean up audio connection
        this.disconnectAudio();
        if (this._audioContext) {
            this._audioContext.close();
            this._audioContext = null;
        }
        this._analyzerNode = null;
        this._audioSourceNode = null;

        // Clean up element attachment tracking
        if (this._elementTrackingHandlers) {
            window.removeEventListener('scroll', this._elementTrackingHandlers.scroll);
            window.removeEventListener('resize', this._elementTrackingHandlers.resize);
            this._elementTrackingHandlers = null;
        }
        this._attachedElement = null;

        // Clear all pending gesture timeouts
        this.gestureTimeouts.forEach(id => clearTimeout(id));
        this.gestureTimeouts = [];

        // Clear all event listeners to prevent memory leaks
        if (this.eventManager && this.eventManager._listeners) {
            Object.keys(this.eventManager._listeners).forEach(key => {
                this.eventManager._listeners[key] = [];
            });
            this.eventManager._listeners = null;
        }

        if (this.core3D) {
            this.core3D.destroy();
        }
        if (this.particleSystem) {
            this.particleSystem.destroy();
        }
        if (this.danceChoreographer) {
            this.danceChoreographer.destroy();
            this.danceChoreographer = null;
        }

        // Remove canvas elements from DOM
        if (this.webglCanvas && this.webglCanvas.parentNode) {
            this.webglCanvas.parentNode.removeChild(this.webglCanvas);
        }
        if (this.canvas2D && this.canvas2D.parentNode) {
            this.canvas2D.parentNode.removeChild(this.canvas2D);
        }

        // Null out DOM element references to prevent memory leaks
        this.container = null;
        this.webglCanvas = null;
        this.canvas2D = null;
        this.ctx2D = null;

        // Null out config object
        this.config = null;

        // Null out ErrorBoundary
        this.errorBoundary = null;

        // Null out current gesture reference
        this.currentGesture = null;
    }
}

/**
 * A loader for the RGBE HDR texture format.
 *
 * ```js
 * const loader = new HDRLoader();
 * const envMap = await loader.loadAsync( 'textures/equirectangular/blouberg_sunrise_2_1k.hdr' );
 * envMap.mapping = THREE.EquirectangularReflectionMapping;
 *
 * scene.environment = envMap;
 * ```
 *
 * @augments DataTextureLoader
 * @three_import import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 */
class HDRLoader extends DataTextureLoader {

	/**
     * Constructs a new RGBE/HDR loader.
     *
     * @param {LoadingManager} [manager] - The loading manager.
     */
	constructor( manager ) {

		super( manager );

		/**
         * The texture type.
         *
         * @type {(HalfFloatType|FloatType)}
         * @default HalfFloatType
         */
		this.type = HalfFloatType;

	}

	/**
     * Parses the given RGBE texture data.
     *
     * @param {ArrayBuffer} buffer - The raw texture data.
     * @return {DataTextureLoader~TexData} An object representing the parsed texture data.
     */
	parse( buffer ) {

		// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html

		const
			/* default error routine.  change this to change error handling */
			rgbe_read_error = 1,
			rgbe_write_error = 2,
			rgbe_format_error = 3,
			rgbe_memory_error = 4,
			rgbe_error = function ( rgbe_error_code, msg ) {

				switch ( rgbe_error_code ) {

					case rgbe_read_error: throw new Error( 'THREE.HDRLoader: Read Error: ' + ( msg || '' ) );
					case rgbe_write_error: throw new Error( 'THREE.HDRLoader: Write Error: ' + ( msg || '' ) );
					case rgbe_format_error: throw new Error( 'THREE.HDRLoader: Bad File Format: ' + ( msg || '' ) );
					default:
					case rgbe_memory_error: throw new Error( 'THREE.HDRLoader: Memory Error: ' + ( msg || '' ) );

				}

			},

			/* offsets to red, green, and blue components in a data (float) pixel */
			//RGBE_DATA_RED = 0,
			//RGBE_DATA_GREEN = 1,
			//RGBE_DATA_BLUE = 2,

			/* number of floats per pixel, use 4 since stored in rgba image format */
			//RGBE_DATA_SIZE = 4,

			/* flags indicating which fields in an rgbe_header_info are valid */
			RGBE_VALID_PROGRAMTYPE = 1,
			RGBE_VALID_FORMAT = 2,
			RGBE_VALID_DIMENSIONS = 4,

			NEWLINE = '\n',

			fgets = function ( buffer, lineLimit, consume ) {

				const chunkSize = 128;

				lineLimit = ! lineLimit ? 1024 : lineLimit;
				let p = buffer.pos,
					i = -1, len = 0, s = '',
					chunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				while ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {

					s += chunk; len += chunk.length;
					p += chunkSize;
					chunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				}

				if ( -1 < i ) {

					/*for (i=l-1; i>=0; i--) {
                        byteCode = m.charCodeAt(i);
                        if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
                        else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
                        if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
                    }*/
					buffer.pos += len + i + 1;
					return s + chunk.slice( 0, i );

				}

				return false;

			},

			/* minimal header reading.  modify if you want to parse more information */
			RGBE_ReadHeader = function ( buffer ) {


				// regexes to parse header info fields
				const magic_token_re = /^#\?(\S+)/,
					gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
					exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
					format_re = /^\s*FORMAT=(\S+)\s*$/,
					dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,

					// RGBE format header struct
					header = {

						valid: 0, /* indicate which fields are valid */

						string: '', /* the actual header string */

						comments: '', /* comments found in header */

						programtype: 'RGBE', /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */

						format: '', /* RGBE format, default 32-bit_rle_rgbe */

						gamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */

						exposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */

						width: 0, height: 0 /* image dimensions, width/height */

					};

				let line, match;

				if ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {

					rgbe_error( rgbe_read_error, 'no header found' );

				}

				/* if you want to require the magic token then uncomment the next line */
				if ( ! ( match = line.match( magic_token_re ) ) ) {

					rgbe_error( rgbe_format_error, 'bad initial token' );

				}

				header.valid |= RGBE_VALID_PROGRAMTYPE;
				header.programtype = match[ 1 ];
				header.string += line + '\n';

				while ( true ) {

					line = fgets( buffer );
					if ( false === line ) break;
					header.string += line + '\n';

					if ( '#' === line.charAt( 0 ) ) {

						header.comments += line + '\n';
						continue; // comment line

					}

					if ( match = line.match( gamma_re ) ) {

						header.gamma = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( exposure_re ) ) {

						header.exposure = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( format_re ) ) {

						header.valid |= RGBE_VALID_FORMAT;
						header.format = match[ 1 ];//'32-bit_rle_rgbe';

					}

					if ( match = line.match( dimensions_re ) ) {

						header.valid |= RGBE_VALID_DIMENSIONS;
						header.height = parseInt( match[ 1 ], 10 );
						header.width = parseInt( match[ 2 ], 10 );

					}

					if ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;

				}

				if ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {

					rgbe_error( rgbe_format_error, 'missing format specifier' );

				}

				if ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {

					rgbe_error( rgbe_format_error, 'missing image size specifier' );

				}

				return header;

			},

			RGBE_ReadPixels_RLE = function ( buffer, w, h ) {

				const scanline_width = w;

				if (
				// run length encoding is not allowed so read flat
					( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||
                    // this file is not run length encoded
                    ( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )
				) {

					// return the flat buffer
					return new Uint8Array( buffer );

				}

				if ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {

					rgbe_error( rgbe_format_error, 'wrong scanline width' );

				}

				const data_rgba = new Uint8Array( 4 * w * h );

				if ( ! data_rgba.length ) {

					rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );

				}

				let offset = 0, pos = 0;

				const ptr_end = 4 * scanline_width;
				const rgbeStart = new Uint8Array( 4 );
				const scanline_buffer = new Uint8Array( ptr_end );
				let num_scanlines = h;

				// read in each successive scanline
				while ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {

					if ( pos + 4 > buffer.byteLength ) {

						rgbe_error( rgbe_read_error );

					}

					rgbeStart[ 0 ] = buffer[ pos ++ ];
					rgbeStart[ 1 ] = buffer[ pos ++ ];
					rgbeStart[ 2 ] = buffer[ pos ++ ];
					rgbeStart[ 3 ] = buffer[ pos ++ ];

					if ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {

						rgbe_error( rgbe_format_error, 'bad rgbe scanline format' );

					}

					// read each of the four channels for the scanline into the buffer
					// first red, then green, then blue, then exponent
					let ptr = 0, count;

					while ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {

						count = buffer[ pos ++ ];
						const isEncodedRun = count > 128;
						if ( isEncodedRun ) count -= 128;

						if ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {

							rgbe_error( rgbe_format_error, 'bad scanline data' );

						}

						if ( isEncodedRun ) {

							// a (encoded) run of the same value
							const byteValue = buffer[ pos ++ ];
							for ( let i = 0; i < count; i ++ ) {

								scanline_buffer[ ptr ++ ] = byteValue;

							}
							//ptr += count;

						} else {

							// a literal-run
							scanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );
							ptr += count; pos += count;

						}

					}


					// now convert data from buffer into rgba
					// first red, then green, then blue, then exponent (alpha)
					const l = scanline_width; //scanline_buffer.byteLength;
					for ( let i = 0; i < l; i ++ ) {

						let off = 0;
						data_rgba[ offset ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 1 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 2 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 3 ] = scanline_buffer[ i + off ];
						offset += 4;

					}

					num_scanlines --;

				}

				return data_rgba;

			};

		const RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			destArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;
			destArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;
			destArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;
			destArray[ destOffset + 3 ] = 1;

		};

		const RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			// clamping to 65504, the maximum representable value in float16
			destArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );
			destArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );
			destArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );
			destArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );

		};

		const byteArray = new Uint8Array( buffer );
		byteArray.pos = 0;
		const rgbe_header_info = RGBE_ReadHeader( byteArray );

		const w = rgbe_header_info.width,
			h = rgbe_header_info.height,
			image_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );


		let data, type;
		let numElements;

		switch ( this.type ) {

			case FloatType:

				numElements = image_rgba_data.length / 4;
				const floatArray = new Float32Array( numElements * 4 );

				for ( let j = 0; j < numElements; j ++ ) {

					RGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );

				}

				data = floatArray;
				type = FloatType;
				break;

			case HalfFloatType:

				numElements = image_rgba_data.length / 4;
				const halfArray = new Uint16Array( numElements * 4 );

				for ( let j = 0; j < numElements; j ++ ) {

					RGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );

				}

				data = halfArray;
				type = HalfFloatType;
				break;

			default:

				throw new Error( 'THREE.HDRLoader: Unsupported type: ' + this.type );

		}

		return {
			width: w, height: h,
			data: data,
			header: rgbe_header_info.string,
			gamma: rgbe_header_info.gamma,
			exposure: rgbe_header_info.exposure,
			type: type
		};

	}

	/**
     * Sets the texture type.
     *
     * @param {(HalfFloatType|FloatType)} value - The texture type to set.
     * @return {HDRLoader} A reference to this loader.
     */
	setDataType( value ) {

		this.type = value;
		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		function onLoadCallback( texture, texData ) {

			switch ( texture.type ) {

				case FloatType:
				case HalfFloatType:

					texture.colorSpace = LinearSRGBColorSpace;
					texture.minFilter = LinearFilter;
					texture.magFilter = LinearFilter;
					texture.generateMipmaps = false;
					texture.flipY = true;

					break;

			}

			if ( onLoad ) onLoad( texture, texData );

		}

		return super.load( url, onLoadCallback, onProgress, onError );

	}

}

var HDRLoader$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	HDRLoader: HDRLoader
});

export { CORE_GEOMETRIES, Core3DManager, CrystalSoul, EmotiveMascot3D, GROOVE_PRESETS, GeometryCache, MOON_PHASES, Rhythm3DAdapter, SSSPresets, animateMoonPhase, applySSSPreset, blendModeNames, createCrystal, createDiamond, createMoon, createMoonCrescentMaterial, createMoonFallbackMaterial, createMoonMaterial$1 as createMoonMaterial, createSphere, createSunGeometry, createSunMaterial, EmotiveMascot3D as default, disposeCoreGeometries, disposeMoon, disposeSun, getBlendModeIndex, getBlendModeName, getMoonPhaseNames, getPhaseFromProgress, getPreset as getSSSPreset, getPresetNames as getSSSPresetNames, rhythm3DAdapter, setMoonPhase, updateCrescentShadow, updateMoonGlow, updateSunMaterial };
//# sourceMappingURL=emotive-mascot-3d.js.map
